=== Project Directory Structure ===
Root: C:\Users\viktor.jonsson\OneDrive - CellMax Technologies AB\Documents\Repositories\svenviktorjonsson\platonic-play
Relevant files and folders (excluding specified patterns):

.
├── constants.js
├── index.html
├── package.json
├── readme.md
├── renderer.js
├── script.js
├── style.css
├── utils.js
├── vite.config.js


=== File Contents ===

=== constants.js ===
// constants.js

export const DARK_THEME = {
    activeCenterGlow: '#00ffff',
    uiIconDisabled: '#ff0000',
    helperLine: 'rgba(200, 200, 200, 0.6)',
    coordSysX: '#ff0000',
    coordSysY: '#00ff00',
    coordSysOrigin: '#0000ff',
    checkerboardColor1: '#808080',
    checkerboardColor2: '#c0c0c0',
    background: '#1a1a1a',
    htmlBody: '#1e1e1e',
    grid: [136, 136, 136],
    axis: 'rgba(255, 255, 255, 1)',
    axisTickLabel: [255, 255, 255],
    defaultStroke: 'white',
    vertex: '#ffffff',
    edge: '#BFC5D0',
    face: '#808080',
    frozenReference: 'rgba(240, 240, 130, 0.95)',
    feedbackDefault: [230, 230, 230],
    feedbackSnapped: 'rgba(240, 240, 130, 0.95)',
    geometryInfoText: 'rgba(255, 255, 255, 0.95)',
    geometryInfoTextSnapped: 'rgba(240, 240, 130, 0.95)',
    mouseCoords: 'rgba(255, 255, 255, 0.7)',
    uiIcon: 'white',
    uiIconDefault: '#9CA3AF',
    uiIconSelected: '#F9FAFB',
    uiTextSelected: '#E0F2FE',
    uiTextDefault: '#D1D5DB',
    uiDefault: 'rgba(255, 255, 255, 0.8)',
    selectionGlow: '#4da6ff',
    activeCenterGlow: '#00ffff',
    helperLine: 'rgba(200, 200, 200, 0.6)'
};

export const LIGHT_THEME = {
    background: '#e5e5e5',
    htmlBody: '#e1e1e1',
    grid: [119, 119, 119],
    axis: 'rgba(0, 0, 0, 1)',
    axisTickLabel: [0, 0, 0],
    defaultStroke: 'black',
    vertex: '#000000',
    edge: '#403A2F',
    face: '#7F7F7F',
    frozenReference: 'rgba(217, 119, 6, 0.95)',
    feedbackDefault: [25, 25, 25],
    feedbackSnapped: 'rgba(217, 119, 6, 0.95)',
    geometryInfoText: 'rgba(0, 0, 0, 0.95)',
    geometryInfoTextSnapped: 'rgba(217, 119, 6, 0.95)',
    mouseCoords: 'rgba(0, 0, 0, 0.7)',
    uiIcon: 'black',
    uiIconDefault: '#635C50',
    uiIconSelected: '#060504',
    uiTextSelected: '#1F0D01',
    uiTextDefault: '#2E2A24',
    uiDefault: 'rgba(0, 0, 0, 0.8)',
    selectionGlow: '#0059B3', // High-contrast blue
    activeCenterGlow: '#008080', // High-contrast teal
    helperLine: 'rgba(55, 55, 55, 0.6)',
    coordSysX: '#ff0000',
    coordSysY: '#008000', // Darker green for light bg
    coordSysOrigin: '#0000ff',
    checkerboardColor1: '#ffffff',
    checkerboardColor2: '#cccccc',
    uiIconDisabled: '#cc0000'
};

export const CONTEXT_MENU_INSET = 5;
export const COORD_SYSTEM_EDGE_FRACTION_LABEL_OFFSET = 25;
export const FRACTION_LABEL_FONT_SIZE = 20;
export const INSCRIBED_CIRCLE_ITERATIONS = 20;
export const INSCRIBED_CIRCLE_STEP_FACTOR = 0.1;
export const ALT_SNAP_FRACTIONS = [1 / 4, 1 / 3, 1 / 2, 2 / 3, 3 / 4];

// --- GEOMETRY & DRAWING ---
export const TRANSFORM_ICON_SIZE = 30;
export const UI_FACE_ICON_FILL_COLOR = '#808080';
export const VERTEX_RADIUS = 5;
export const CENTER_POINT_VISUAL_RADIUS = TRANSFORM_ICON_SIZE / 2;
export const VERTEX_SELECT_RADIUS = 10;
export const LINE_WIDTH = 2;
export const GRID_LINEWIDTH = 1;
export const DASH_PATTERN = [6, 6];
export const DASH_PATTERN_SMALL = [3, 3];
export const SELECTED_INDICATOR_OFFSET = 3;
export const DEGREES_IN_CIRCLE = 360;
export const DEGREES_IN_HALF_CIRCLE = 180;
export const DEGREES_IN_QUADRANT = 90;
export const RADIANS_IN_CIRCLE = 2 * Math.PI;
export const MIN_ALPHA_FOR_DRAWING = 0.01;
export const TRIANGULAR_GRID_Y_STEP_FACTOR = Math.sqrt(3) / 2;
export const POLAR_TO_LINE_TRANSITION_RADIUS_FACTOR = 400;
export const ORIGIN_TICK_ANGLE_RAD = Math.PI / 3;
export const AXIS_MAJOR_TICK_SCALE_FACTOR = 1.5;
export const AXIS_ARROW_ANGLE_RAD = Math.PI / 6;
export const MAJOR_TICK_LINE_WIDTH = 1.5;
export const HELPER_LINE_DASH_PATTERN = [2, 3];
export const REF_LINE_DASH_PATTERN = [1, 3];

// --- INTERACTION ---
export const COORD_SYSTEM_CENTER_SNAP_THRESHOLD = 0.01;
export const COORD_SYSTEM_ELEMENT_SELECT_RADIUS = 8;
export const COORD_SYSTEM_AXIS_SELECT_THRESHOLD = 5;
export const COORD_SYSTEM_AXIS_SNAP_THRESHOLD_RAD = Math.PI / 24;
export const COORD_SYSTEM_AXIS_SCALE_SNAP_THRESHOLD_PIXELS = 15;
export const TRANSFORM_SCALE_SNAP_PRIORITY_THRESHOLD = 0.1;
export const EDGE_ID_DELIMITER = '_EDGE_';
export const DOUBLE_CLICK_MS = 300;
export const DRAG_THRESHOLD = 3;
export const EDGE_CLICK_THRESHOLD = 7;
export const MIN_SCALE_VALUE = 1e-15;
export const MAX_SCALE_VALUE = 1e13;
export const ZOOM_FACTOR = 1.15;
export const KEYBOARD_ZOOM_FACTOR = 1.15;
export const ANGLE_SNAP_THRESHOLD_RAD = Math.PI / 48;
export const SCALE_SNAP_THRESHOLD = 0.05
export const ON_SEGMENT_STRICT_T_MIN = 1e-5;
export const ON_SEGMENT_STRICT_T_MAX = 1 - 1e-5;
export const MIN_TRANSFORM_ACTION_THRESHOLD = 0.001;
export const BISECTOR_LINE_EXTENSION_FACTOR = 100000;
export const GRID_SNAP_THRESHOLD_FACTOR = 0.8;

// --- AXES & TICKS ---
export const POLAR_REF_TICK_ALPHA_THRESHOLD = 0.01;
export const POLAR_REF_TICK_LABEL_ALPHA_FACTOR = 0.95;
export const POLAR_REF_LABEL_MARGIN = 100;
export const POLAR_REF_LINE_WIDTH = 1.5;
export const POLAR_GRID_SPOKE_WIDTH_FACTOR = 0.5;
export const AXIS_LINE_WIDTH = 1.5;
export const AXIS_TICK_SIZE = 4;
export const AXIS_TICK_LABEL_ALPHA = 0.9;
export const AXIS_NAME_FONT_SIZE = 24;
export const AXIS_TICK_FONT_SIZE = 10;
export const AXIS_LABEL_OFFSET = 8;
export const AXIS_LABEL_PADDING = 20;
export const AXIS_ARROW_SIZE = 12;
export const INITIAL_POLAR_REL_RADIUS = 0.309;
export const X_AXIS_LABEL_DISTANCE = 5;
export const X_AXIS_LABEL_ARROW_DIST = 20;
export const Y_AXIS_LABEL_DISTANCE = 10;
export const Y_AXIS_LABEL_ARROW_DIST = 5;
export const POLAR_THETA_LABEL_DISTANCE = 20;
export const POLAR_THETA_LABEL_ARROW_DIST = 12;
export const ANGLE_PRECISION_FACTOR = 1e6;
export const BOUNDARY_ANGLE_PRECISION = 7;
export const LABEL_ID_PRECISION_FACTOR = 1e15;
export const ORIGIN_LABEL_TEXT = '\\phantom{-}0';
export const POLAR_AXIS_RADIUS_BUFFER_FACTOR = 1.1;
export const TICK_LABEL_SIGFIG_THRESH_1 = 80;
export const TICK_LABEL_SIGFIG_THRESH_2 = 40;
export const TICK_LABEL_SIGFIG_THRESH_3 = 20;
export const FINE_TICK_ANGLE_THRESHOLD_DEG = 5;
export const IMAGINARY_UNIT_SYMBOL = 'i';
export const POLAR_RADIUS_SYMBOL = 'r';
export const COMPLEX_REAL_LABEL = '\\mathrm{Re}';
export const COMPLEX_IMAGINARY_LABEL = '\\mathrm{Im}';

// --- DEFAULTS ---
export const DEFAULT_CALIBRATION_VIEW_SCALE = 80.0;
export const DEFAULT_REFERENCE_DISTANCE = 1.0;
export const DEFAULT_REFERENCE_ANGLE_RAD = Math.PI / 2;
export const DEFAULT_POLAR_ANGLE_DIFF = 30;

// --- UI & TOOLBAR ---
export const UI_ICON_DISABLED_FILL = '#808080';
export const UI_COLOR_TARGET_UNASSIGNED = 'rgba(128, 128, 128, 1)';
export const FACE_COORD_SYSTEM_ORIGIN_RADIUS = 4;
export const FACE_GLOW_ALPHA = 0.25;
export const UI_BUTTON_PADDING = 10;
export const UI_TOOLBAR_WIDTH = 56;
export const UI_SWATCH_SIZE = 35;
export const UI_PADDING = 10;
export const MENU_BUTTON_WIDTH = 36;
export const MENU_BUTTON_HEIGHT = 30;
export const TOOL_BUTTON_HEIGHT = 40;
export const TOOLBAR_SECTION_GAP = 20;
export const UI_ICON_BASE_SIZE = 32;
export const UI_ICON_LINE_WIDTH = 2;
export const UI_ICON_LINE_WIDTH_SMALL = 1.5;
export const UI_ICON_DASH_PATTERN = [2, 4];
export const UI_ICON_VERTEX_RADIUS = 1.5;
export const UI_ICON_LABEL_FONT_SIZE = 10;
export const UI_MENU_ICON_LINE_WIDTH = 3;
export const TRANSFORM_ICON_PADDING = 15;
export const TRANSFORM_ICON_Y_OFFSET = 5;
export const UI_TRANSFORM_TOOL_LABEL_FONT_SIZE = 24;
export const UI_TRANSFORM_TOOL_LABEL_TEXT = 'T';
export const UI_SYMMETRY_TOOL_LABEL_FONT_SIZE = 24;
export const UI_SYMMETRY_TOOL_LABEL_TEXT = 'S';
export const DISPLAY_ICON_SIZE = 35;
export const DISPLAY_ICON_PADDING = 15;
export const UI_DISPLAY_ICON_BAR_WIDTH_PADDING = 12;
export const UI_DISPLAY_ICON_Y_OFFSET = 10;
export const UI_DISPLAY_ICON_Y_SPACING = 10;
export const UI_DISPLAY_ICON_KNOB_RADIUS = 3;
export const UI_SWATCH_SELECTED_BORDER_WIDTH = 3;
export const UI_BUTTON_BORDER_WIDTH = 2;
export const UI_BUTTON_ICON_PADDING = 7;
export const UI_GHOST_ICON_SIZE = 30;
export const COLOR_PALETTE_Y_OFFSET = 5;
export const COLOR_WHEEL_FADE_START_RADIUS_FACTOR = 0.75;
export const DEFAULT_RECENT_COLORS = ['#ffffff', '#BFC5D0', '#808080', '#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff','rgba(0, 0, 0, 0)']

// --- FEEDBACK LABELS & TEXT ---
export const TRANSFORM_INDICATOR_PRECISION = 4;
export const TRANSFORM_INDICATOR_SCALE_SNAP_TOLERANCE = 0.001;
export const FEEDBACK_LABEL_FONT_SIZE = 12;
export const FEEDBACK_ARC_RADIUS_SCREEN = 30;
export const FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN = 18;
export const FEEDBACK_LINE_VISUAL_WIDTH = 1;
export const REF_TEXT_SCREEN_PIXEL_THRESHOLD = 1.5;
export const REF_TEXT_KATEX_FONT_SIZE = 11;
export const REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN = 18;
export const UI_ANGLE_LABEL_OFFSET = 60;
export const REF_CIRCLE_MIN_DISPLAY_RADIUS = 20;
export const REF_CIRCLE_MIN_TICK_SPACING = 8;
export const REF_CIRCLE_THETA_LABEL_OFFSET = 30;
export const TRANSFORM_ANGLE_LABEL_OFFSET = 20;
export const TRANSFORM_SCALE_LABEL_OFFSET = 18;
export const SCIENTIFIC_NOTATION_UPPER_BOUND = 1000000;
export const SCIENTIFIC_NOTATION_LOWER_BOUND = 0.000001;
export const ZERO_TOLERANCE = 0.00001;
export const FRACTION_FORMAT_TOLERANCE = 0.015;
export const FRACTION_FORMAT_MAX_DENOMINATOR = 32;
export const FRACTION_FORMAT_MAX_DENOMINATOR_TRANSFORM = 10;
export const COORD_PRECISION_FACTOR = 0.999;
export const MAX_COORD_DECIMAL_PLACES = 16;
export const MAX_ANGLE_DECIMAL_PLACES = 12;
export const MOUSE_COORD_FONT_SIZE = 14;
export const KATEX_MINUS_PHANTOM = '\\hphantom{-}';
export const PI_SYMBOL_KATEX = '\\pi';
export const DELTA_SYMBOL_KATEX = '\\delta';
export const DELTA_EQUALS_KATEX = '\\delta = ';
export const THETA_EQUALS_KATEX = '\\theta = ';
export const SELECTION_GLOW_BLUR_RADIUS = 15;
export const SELECTION_GLOW_ALPHA = 0.8;
export const SELECTION_GLOW_RADIUS_OFFSET = 3;
export const SELECTION_GLOW_LINE_WIDTH = 2;
export const EDGE_SELECTION_GLOW_WIDTH_OFFSET = 4;
export const MAX_VERTICES_FOR_ANGLES = 1;
export const MAX_EDGES_FOR_LABELS = 3;
export const MAX_FACES_FOR_COORDS = 1;

// --- GRID CALCULATIONS ---
export const GRID_TARGET_SPACING = 140;
export const GRID_ALPHA_TRANSITION_START = 0.4;
export const GRID_ALPHA_TRANSITION_END = 0.9;
export const GRID_ALPHA_CLAMP_THRESHOLD = 0.05;
export const GRID_POLAR_CIRCLE_MIN_SPACING = 10;
export const GRID_POLAR_SPOKE_MIN_SPACING = 10;
export const GRID_POLAR_SPOKE_MIN_RADIUS = 50;
export const GRID_POINT_RADIUS = 1.5;
export const ANGULAR_GRID_PREDEFINED_LEVELS = [15, 5, 1];
export const ANGULAR_GRID_TARGET_SPACING = 80;
export const ANGULAR_GRID_FADE_IN_THRESHOLD = 0.01;

// --- SNAPPING PARAMETERS ---
export const GEOMETRY_CALCULATION_EPSILON = 1e-9;
export const FLOATING_POINT_PRECISION_LIMIT = 1e-15;
export const VERTICAL_LINE_COS_THRESHOLD = 0.1;
export const SNAP_STICKINESS_RADIUS_SCREEN = 30;
export const LINE_TO_SNAP_RADIUS_SCREEN = 10;
export const VERTEX_ON_LINE_SNAP_RADIUS_SCREEN = 15;
export const DRAG_SNAP_GEOMETRIC_DISTANCE_FACTORS = [0.5, 1, 1.5, 2, 3, 4, 5];
export const DRAW_SNAP_CANDIDATE_COUNT_PER_SIDE = 2;
export const DRAW_SNAP_DISTANCE_FACTOR_STEP = 0.5;
export const DRAW_SNAP_DISTANCE_FACTOR_LIMIT = 50;
export const GHOST_SNAP_RADIUS_SCREEN = 30;
export const MAX_HISTORY_SIZE = 50;

// --- SNAP GENERATION PARAMETERS ---
export const MAX_FRACTION_DENOMINATOR_FOR_ANGLE_SNAPS = 6;
export const MAX_BASE_ANGLE_MULTIPLIER_FOR_SNAPS = 2;
export const MAX_INITIAL_METER_SNAP_MULTIPLIER = 10;
export const MAX_SNAP_DENOMINATOR = 6;
export const MAX_SNAP_INTEGER = 10;

export const MERGE_RADIUS_SCREEN = VERTEX_RADIUS*2;

export const NINETY_DEG_ANGLE_SNAP_FRACTIONS = (() => {
    const uniqueFractions = new Set();
    const denominators = [1, 2, 3, 4, 5, 6];
    for (const q of denominators) {
        for (let p = 1; p <= q * 4; p++) {
            uniqueFractions.add(p / q);
        }
    }
    return Array.from(uniqueFractions).sort((a, b) => a - b);
})();


function generateSnapFactors(maxDenominator, maxInteger) {
    const fractionsSet = new Set();
    fractionsSet.add(0);
    for (let q = 1; q <= maxDenominator; q++) {
        for (let p = 1; p <= q * maxInteger; p++) {
            fractionsSet.add(p / q);
        }
    }
    return Array.from(fractionsSet).sort((a, b) => a - b);
}

export const SNAP_FACTORS = generateSnapFactors(MAX_SNAP_DENOMINATOR, MAX_SNAP_INTEGER);

// --- ENUMS & LITERALS ---
export const VERTEX_TYPE_REGULAR = 'regular';
export const TRANSFORMATION_TYPE_ROTATION = ' transformation_rotation';
export const TRANSFORMATION_TYPE_SCALE = ' transformation_scale';
export const TRANSFORMATION_TYPE_ROTATE_SCALE = 'transformation_rotate_scale';
export const TRANSFORMATION_TYPE_DIRECTIONAL_SCALE = 'transformation_directional_scale';
export const COORDS_DISPLAY_MODE_NONE = 'none';
export const COORDS_DISPLAY_MODE_REGULAR = 'regular';
export const COORDS_DISPLAY_MODE_COMPLEX = 'complex';
export const COORDS_DISPLAY_MODE_POLAR = 'polar';
export const GRID_DISPLAY_MODE_NONE = 'none';
export const GRID_DISPLAY_MODE_LINES = 'lines';
export const GRID_DISPLAY_MODE_POINTS = 'points';
export const GRID_DISPLAY_MODE_TRIANGULAR = 'triangular';
export const GRID_DISPLAY_MODE_POLAR = 'polar';
export const ANGLE_DISPLAY_MODE_DEGREES = 'degrees';
export const ANGLE_DISPLAY_MODE_RADIANS = 'radians';
export const ANGLE_DISPLAY_MODE_NONE = 'none';
export const DISTANCE_DISPLAY_MODE_ON = 'on';
export const DISTANCE_DISPLAY_MODE_NONE = 'none';
export const KEY_SPACE = ' ';
export const KEY_ESCAPE = 'Escape';
export const KEY_DELETE = 'Delete';
export const KEY_BACKSPACE = 'Backspace';
export const KEY_REPEAT = 'r';
export const KEY_ZOOM_IN = '=';
export const KEY_ZOOM_IN_PLUS = '+';
export const KEY_ZOOM_OUT = '-';
export const KEY_COPY = 'c';
export const KEY_PASTE = 'v';
export const KEY_CUT = 'x';
export const KEY_UNDO = 'z';
export const KEY_REDO = 'y';
export const KEY_SELECT_ALL = 'a';
export const COLOR_TARGET_VERTEX = 'vertex';
export const COLOR_TARGET_EDGE = 'edge';
export const COLOR_TARGET_FACE = 'face';


=== index.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Platonic Play</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <link rel="stylesheet" href="./style.css">
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <div class="canvas-wrapper-relative">
                <canvas id="drawingCanvas"></canvas>
                <div id="html-overlay"></div>
            </div>
        </div>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script type="module" src="./script.js"></script>
    
    <div id="context-menu" class="context-menu"></div>
</body>
</html>

=== package.json ===
{
  "name": "platonic-play",
  "version": "1.0.0",
  "description": "",
  "main": "script.js",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "vite": "^7.0.6"
  },
  "dependencies": {
    "colormap-selector": "github:svenviktorjonsson/colormap-selector"
  }
}


=== readme.md ===


=== renderer.js ===
import * as U from './utils.js';
import * as C from './constants.js';

const patternCache = new Map();

export function calculateGridIntervals(viewTransformScale) {
    const effectiveDataInterval = C.GRID_TARGET_SPACING / viewTransformScale;

    let lowerPowerOf10 = Math.pow(10, Math.floor(Math.log10(effectiveDataInterval)));
    let higherPowerOf10 = Math.pow(10, Math.ceil(Math.log10(effectiveDataInterval)));

    if (Math.abs(lowerPowerOf10 - higherPowerOf10) < C.GEOMETRY_CALCULATION_EPSILON || lowerPowerOf10 === 0) {
        higherPowerOf10 = lowerPowerOf10 === 0 ? 0.001 : lowerPowerOf10 * 10;
        if (lowerPowerOf10 === 0) lowerPowerOf10 = 0.0001;
    }

    const grid1Interval = lowerPowerOf10;
    const grid2Interval = higherPowerOf10;

    let logInterpFactor = 0;
    if (grid2Interval > grid1Interval && grid1Interval > 0) {
        logInterpFactor = (Math.log10(effectiveDataInterval) - Math.log10(grid1Interval)) / (Math.log10(grid2Interval) - Math.log10(grid1Interval));
    }

    let interpValue = (logInterpFactor - C.GRID_ALPHA_TRANSITION_START) / (C.GRID_ALPHA_TRANSITION_END - C.GRID_ALPHA_TRANSITION_START);
    interpValue = Math.max(0, Math.min(1, interpValue));
    interpValue = interpValue * interpValue * (3 - 2 * interpValue);

    let alpha1 = 1 - interpValue;
    let alpha2 = interpValue;

    if (alpha1 < C.GRID_ALPHA_CLAMP_THRESHOLD) alpha1 = 0; else if (alpha1 > 1 - C.GRID_ALPHA_CLAMP_THRESHOLD) alpha1 = 1;
    if (alpha2 < C.GRID_ALPHA_CLAMP_THRESHOLD) alpha2 = 0; else if (alpha2 > 1 - C.GRID_ALPHA_CLAMP_THRESHOLD) alpha2 = 1;

    const totalAlpha = alpha1 + alpha2;
    if (totalAlpha > 0 && totalAlpha !== 2) {
        alpha1 /= totalAlpha;
        alpha2 /= totalAlpha;
    }

    return { grid1Interval, grid2Interval, alpha1, alpha2 };
}

export function getDynamicAngularIntervals(viewTransform, canvasWidth, canvasHeight, dataToScreen) {
    const originScreen = dataToScreen({ x: 0, y: 0 });
    const screenCenter = { x: canvasWidth / 2, y: canvasHeight / 2 };

    const radiusToCenterScreen = U.distance(originScreen, screenCenter);
    let targetAngleDeg;

    if (radiusToCenterScreen < 1e-6) {
        targetAngleDeg = C.ANGULAR_GRID_TARGET_SPACING;
    } else {
        const targetAngleRad = C.ANGULAR_GRID_TARGET_SPACING / radiusToCenterScreen;
        targetAngleDeg = targetAngleRad * (180 / Math.PI);
    }

    if (isNaN(targetAngleDeg) || targetAngleDeg <= C.GEOMETRY_CALCULATION_EPSILON) {
        targetAngleDeg = C.GEOMETRY_CALCULATION_EPSILON;
    }

    const results = [];
    let allLevels = [...C.ANGULAR_GRID_PREDEFINED_LEVELS];

    let lastGeneratedLevel = allLevels[allLevels.length - 1];
    
    const absoluteMinimum = 1e-15;
    
    while (lastGeneratedLevel > absoluteMinimum) {
        lastGeneratedLevel /= 10;
        if (!allLevels.includes(lastGeneratedLevel)) {
            allLevels.push(lastGeneratedLevel);
        }
    }

    allLevels.sort((a, b) => b - a);

    let primaryLevel = null;
    let secondaryLevel = null;

    for (let i = allLevels.length - 1; i >= 0; i--) {
        const currentLevel = allLevels[i];

        if (targetAngleDeg < currentLevel) {
            primaryLevel = { angle: currentLevel, alpha: 1.0 };
            if (i + 1 < allLevels.length) {
                secondaryLevel = { angle: allLevels[i + 1], alpha: 0 };
            }
            break;
        }
    }

    if (!primaryLevel && allLevels.length > 0) {
        primaryLevel = { angle: allLevels[0], alpha: 1.0 };
        if (allLevels.length > 1) {
            secondaryLevel = { angle: allLevels[1], alpha: 0 };
        }
    } else if (!primaryLevel && allLevels.length === 0) {
        primaryLevel = { angle: C.ANGULAR_GRID_PREDEFINED_LEVELS[0], alpha: 1.0 };
    }

    results.push(primaryLevel);

    if (secondaryLevel) {
        const logPrimary = Math.log10(primaryLevel.angle);
        const logSecondary = Math.log10(secondaryLevel.angle);
        const logTarget = Math.log10(targetAngleDeg);

        let interpValue;
        if (logSecondary === logPrimary) {
            interpValue = 0;
        } else {
            interpValue = (logTarget - logPrimary) / (logSecondary - logPrimary);
        }

        interpValue = Math.max(0, Math.min(1, interpValue));

        const fadeInAlpha = interpValue * interpValue * (3 - 2 * interpValue);

        if (fadeInAlpha > C.ANGULAR_GRID_FADE_IN_THRESHOLD) {
            secondaryLevel.alpha = fadeInAlpha;
            results.push(secondaryLevel);
        }
    }

    const uniqueResults = [];
    const seenAngles = new Set();
    results.sort((a, b) => b.angle - a.angle);

    for (const res of results) {
        if (!seenAngles.has(res.angle)) {
            uniqueResults.push(res);
            seenAngles.add(res.angle);
        }
    }

    if (uniqueResults.length === 0) {
        uniqueResults.push({ angle: C.ANGULAR_GRID_PREDEFINED_LEVELS[0], alpha: 1.0 });
    }

    return uniqueResults;
}

export function drawFaceGlows(ctx, { allFaces, hoveredFaceId, selectedFaceIds, colors, isDragConfirmed, dragPreviewVertices }, dataToScreen, findVertexById, getFaceId) {
    if (!hoveredFaceId && selectedFaceIds.length === 0) return;

    const getLiveVertex = (vertexId) => {
        if (isDragConfirmed && dragPreviewVertices) {
            const previewVertex = dragPreviewVertices.find(p => p && p.id === vertexId);
            if (previewVertex) {
                return previewVertex;
            }
        }
        return findVertexById(vertexId);
    };

    allFaces.forEach(face => {
        const faceId = getFaceId(face);
        const isSelected = selectedFaceIds.includes(faceId);
        const isHovered = faceId === hoveredFaceId;

        // Draw glow only for selected/hovered faces that are not holes themselves.
        if ((isSelected || isHovered) && face.color !== 'transparent') {
            ctx.save();
            ctx.fillStyle = colors.selectionGlow;
            ctx.globalAlpha = C.FACE_GLOW_ALPHA;
            
            ctx.beginPath();

            // 1. Add the outer boundary to the path
            const vertices = face.vertexIds.map(id => getLiveVertex(id)).filter(p => p && p.type === 'regular');
            if (vertices.length < 3) {
                ctx.restore();
                return;
            }
            const screenVertices = vertices.map(v => dataToScreen(v));
            screenVertices.forEach((vertex, index) => {
                if (index === 0) {
                    ctx.moveTo(vertex.x, vertex.y);
                } else {
                    ctx.lineTo(vertex.x, vertex.y);
                }
            });
            ctx.closePath();

            // 2. Add all child boundaries to the path to create holes for the glow
            if (face.childFaceIds && face.childFaceIds.length > 0) {
                face.childFaceIds.forEach(childId => {
                    const childFace = allFaces.find(f => f.id === childId);
                    if (childFace) {
                        const childLiveVertices = childFace.vertexIds.map(id => getLiveVertex(id)).filter(p => p && p.type === 'regular');
                        if (childLiveVertices.length >= 3) {
                            const childScreenVertices = childLiveVertices.map(v => dataToScreen(v));
                            ctx.moveTo(childScreenVertices[0].x, childScreenVertices[0].y);
                            childScreenVertices.slice(1).forEach(vertex => ctx.lineTo(vertex.x, vertex.y));
                            ctx.closePath();
                        }
                    }
                });
            }

            // 3. Fill the complex path using the 'evenodd' rule
            ctx.fill('evenodd');
            
            ctx.restore();
        }
    });
}

function calculateVisibleAngleRange(originScreen, screenRadius, canvasWidth, canvasHeight) {
    // If origin is inside the viewport, we can see the full circle
    if (originScreen.x >= 0 && originScreen.x <= canvasWidth && 
        originScreen.y >= 0 && originScreen.y <= canvasHeight) {
        return { ranges: [[0, 360]], isFullCircle: true };
    }

    const rect = {
        left: 0,
        right: canvasWidth,
        top: 0,
        bottom: canvasHeight
    };

    // If circle doesn't intersect the viewport at all
    if (originScreen.x + screenRadius < rect.left || 
        originScreen.x - screenRadius > rect.right ||
        originScreen.y + screenRadius < rect.top || 
        originScreen.y - screenRadius > rect.bottom) {
        return null;
    }

    const corners = [
        { x: rect.left, y: rect.top },
        { x: rect.right, y: rect.top },
        { x: rect.right, y: rect.bottom },
        { x: rect.left, y: rect.bottom }
    ];

    // If all corners are inside the circle, we see the full circle
    const allCornersInside = corners.every(corner => {
        const distSq = (corner.x - originScreen.x) ** 2 + (corner.y - originScreen.y) ** 2;
        return distSq <= screenRadius ** 2;
    });

    if (allCornersInside) {
        return { ranges: [[0, 360]], isFullCircle: true };
    }

    // Find all intersection points and angles
    const intersectionAngles = [];

    // Check corners that are outside the circle
    corners.forEach(corner => {
        const distSq = (corner.x - originScreen.x) ** 2 + (corner.y - originScreen.y) ** 2;
        if (distSq > screenRadius ** 2) {
            const dx = corner.x - originScreen.x;
            const dy = corner.y - originScreen.y;
            const angle = Math.atan2(-dy, dx);
            const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle;
            intersectionAngles.push(normalizedAngle * 180 / Math.PI);
        }
    });

    // Check intersections with rectangle edges
    const edges = [
        { x1: rect.left, y1: rect.top, x2: rect.right, y2: rect.top },
        { x1: rect.right, y1: rect.top, x2: rect.right, y2: rect.bottom },
        { x1: rect.right, y1: rect.bottom, x2: rect.left, y2: rect.bottom },
        { x1: rect.left, y1: rect.bottom, x2: rect.left, y2: rect.top }
    ];

    edges.forEach(edge => {
        const intersections = U.getLineCircleIntersection(
            {p1: {x: edge.x1, y: edge.y1}, p2: {x: edge.x2, y: edge.y2}},
            {center: {x: originScreen.x, y: originScreen.y}, radius: screenRadius}
        );
        
        intersections.forEach(vertex => {
            const dx = vertex.x - originScreen.x;
            const dy = vertex.y - originScreen.y;
            const angle = Math.atan2(-dy, dx);
            const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle;
            intersectionAngles.push(normalizedAngle * 180 / Math.PI);
        });
    });

    if (intersectionAngles.length === 0) {
        return { ranges: [[0, 360]], isFullCircle: true };
    }

    // Remove duplicates and sort
    const uniqueAngles = [...new Set(intersectionAngles.map(a => Math.round(a * 1e6) / 1e6))].sort((a, b) => a - b);

    if (uniqueAngles.length < 2) {
        return { ranges: [[0, 360]], isFullCircle: true };
    }

    // Find the largest gap between consecutive angles (this is the invisible range)
    let maxGap = 0;
    let maxGapStartAngle = 0;
    let maxGapEndAngle = 0;

    for (let i = 0; i < uniqueAngles.length; i++) {
        const currentAngle = uniqueAngles[i];
        const nextAngle = uniqueAngles[(i + 1) % uniqueAngles.length];
        
        let gap;
        if (i === uniqueAngles.length - 1) {
            // Wrap around gap
            gap = (360 - currentAngle) + nextAngle;
        } else {
            gap = nextAngle - currentAngle;
        }

        if (gap > maxGap) {
            maxGap = gap;
            maxGapStartAngle = currentAngle;
            maxGapEndAngle = nextAngle;
        }
    }

    // The visible range is everything EXCEPT the largest gap
    // So we need to return the complement of the gap
    if (maxGapEndAngle > maxGapStartAngle) {
        // Simple case: gap doesn't wrap around
        return {
            ranges: [[maxGapEndAngle, maxGapStartAngle + 360]],
            isFullCircle: false
        };
    } else {
        // Gap wraps around 0/360
        return {
            ranges: [[maxGapEndAngle, maxGapStartAngle]],
            isFullCircle: false
        };
    }
}

export function clearCanvas(ctx, { canvas, dpr, colors }) {
    const actualCanvasWidth = canvas.width / dpr;
    const actualCanvasHeight = canvas.height / dpr;
    ctx.resetTransform();
    ctx.scale(dpr, dpr);
    ctx.fillStyle = colors.background;
    ctx.fillRect(0, 0, actualCanvasWidth, actualCanvasHeight);
}

export function drawFaces(ctx, { allFaces, facesVisible, isDragConfirmed, dragPreviewVertices, transformIndicatorData, initialDragVertexStates, colors, initialCoordSystemStates }, dataToScreen, findVertexById) {
    if (!facesVisible || !allFaces || !colors || !ctx) return;

    const getLiveVertex = (vertexId) => {
        if (isDragConfirmed && dragPreviewVertices) {
            const previewVertex = dragPreviewVertices.find(p => p && p.id === vertexId);
            if (previewVertex) return previewVertex;
        }
        return findVertexById(vertexId);
    };

    // First pass: Draw top-level faces with their holes
    const topLevelFaces = allFaces.filter(f => !f.parentFaceId);
    topLevelFaces.forEach((face) => {
        if (!face || !face.vertexIds || face.vertexIds.length < 3) return;
        
        const liveVertices = face.vertexIds.map(id => getLiveVertex(id)).filter(p => p && p.type === 'regular');
        if (liveVertices.length < 3) return;

        const screenVertices = liveVertices.map(v => dataToScreen(v));

        let faceToDraw = face;
        if (isDragConfirmed && face.localCoordSystem && face.vertexIds.some(vid => dragPreviewVertices.some(pv => pv.id === vid))) {
            const initialSystem = initialCoordSystemStates.get(face.id);
            const previewSystem = calculatePreviewCoordSystem(face, { initialSystem, dragPreviewVertices, initialDragVertexStates, findVertexById, transformIndicatorData });
            faceToDraw = { ...face, localCoordSystem: previewSystem };
        }
        
        if (screenVertices.every(v => v && typeof v.x === 'number' && typeof v.y === 'number')) {
            drawFace(ctx, screenVertices, faceToDraw, colors, dataToScreen, findVertexById, allFaces, getLiveVertex, true);
        }
    });

    // Second pass: Draw the fills for child faces that are not meant to be holes yet
    const childFaces = allFaces.filter(f => f.parentFaceId && f.color !== 'transparent');
    childFaces.forEach((face) => {
        if (!face || !face.vertexIds || face.vertexIds.length < 3) return;

        const liveVertices = face.vertexIds.map(id => getLiveVertex(id)).filter(p => p && p.type === 'regular');
        if (liveVertices.length < 3) return;

        const screenVertices = liveVertices.map(v => dataToScreen(v));
        
        let faceToDraw = face;
        if (isDragConfirmed && face.localCoordSystem && face.vertexIds.some(vid => dragPreviewVertices.some(pv => pv.id === vid))) {
            const initialSystem = initialCoordSystemStates.get(face.id);
            const previewSystem = calculatePreviewCoordSystem(face, { initialSystem, dragPreviewVertices, initialDragVertexStates, findVertexById, transformIndicatorData });
            faceToDraw = { ...face, localCoordSystem: previewSystem };
        }

        if (screenVertices.every(v => v && typeof v.x === 'number' && typeof v.y === 'number')) {
            drawFace(ctx, screenVertices, faceToDraw, colors, dataToScreen, findVertexById, allFaces, getLiveVertex, false);
        }
    });
}

function calculatePreviewCoordSystem(face, { initialSystem, dragPreviewVertices, initialDragVertexStates, findVertexById, transformIndicatorData }) {
    if (!initialSystem) return face.localCoordSystem;

    const faceVertexIds = new Set(face.vertexIds);
    const draggedVertexIds = new Set(initialDragVertexStates.map(v => v.id));
    const isRigidDrag = [...faceVertexIds].every(id => draggedVertexIds.has(id));

    if (isRigidDrag) {
        const previewSystem = JSON.parse(JSON.stringify(initialSystem));
        if (transformIndicatorData) {
            const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
            const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
            previewSystem.origin = U.applyTransformToVertex(initialSystem.origin, center, rotation, scale, directionalScale, startVector);
            
            if (directionalScale) {
                const p_unit_x_initial = U.localToGlobal({ x: 1, y: 0 }, initialSystem);
                const p_unit_x_final = U.applyTransformToVertex(p_unit_x_initial, center, rotation, scale, directionalScale, startVector);
                previewSystem.scale = U.distance(previewSystem.origin, p_unit_x_final);
            } else {
                previewSystem.angle = U.normalizeAngle(initialSystem.angle + rotation);
                previewSystem.scale = initialSystem.scale * scale;
            }
        } else {
            if (initialDragVertexStates.length > 0 && dragPreviewVertices.length > 0) {
                 const originalDraggedVertex = initialDragVertexStates.find(v => faceVertexIds.has(v.id));
                 const previewDraggedVertex = originalDraggedVertex ? dragPreviewVertices.find(v => v.id === originalDraggedVertex.id) : null;
                 if (previewDraggedVertex) {
                    const deltaX = previewDraggedVertex.x - originalDraggedVertex.x;
                    const deltaY = previewDraggedVertex.y - originalDraggedVertex.y;
                    previewSystem.origin.x += deltaX;
                    previewSystem.origin.y += deltaY;
                 }
            }
        }
        return previewSystem;
    }

    const liveVertices = face.vertexIds
        .map(id => dragPreviewVertices.find(p => p && p.id === id) || findVertexById(id))
        .filter(p => p && p.type === 'regular');

    if (!initialSystem.isCustom) {
        const incircle = U.calculateIncenter(liveVertices);
        if (incircle) {
            const rotation = transformIndicatorData ? transformIndicatorData.rotation : 0;
            return {
                ...initialSystem,
                origin: incircle.center,
                scale: incircle.radius,
                angle: U.normalizeAngle(initialSystem.angle + rotation)
            };
        }
        return initialSystem;
    }

    const previewSystem = JSON.parse(JSON.stringify(initialSystem));

    if (transformIndicatorData) {
        const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
        const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };

        previewSystem.origin = U.applyTransformToVertex(initialSystem.origin, center, rotation, scale, directionalScale, startVector);

        if (directionalScale) {
            const p_unit_x_initial = U.localToGlobal({ x: 1, y: 0 }, initialSystem);
            const p_unit_x_final = U.applyTransformToVertex(p_unit_x_initial, center, rotation, scale, directionalScale, startVector);
            previewSystem.scale = U.distance(previewSystem.origin, p_unit_x_final);
        } else {
            previewSystem.angle = U.normalizeAngle(initialSystem.angle + rotation);
            previewSystem.scale = initialSystem.scale * scale;
        }
    }

    let newOrigin = { ...previewSystem.origin };
    let newAngle = previewSystem.angle;
    let newScale = previewSystem.scale;

    if (previewSystem.attachedToVertex) {
        if (draggedVertexIds.has(previewSystem.attachedToVertex)) {
            const draggedVertex = dragPreviewVertices.find(p => p.id === previewSystem.attachedToVertex);
            if (draggedVertex) newOrigin = { ...draggedVertex };
        }
    } else if (previewSystem.attachedToEdge) {
        if (draggedVertexIds.has(previewSystem.attachedToEdge.v1) || draggedVertexIds.has(previewSystem.attachedToEdge.v2)) {
            const v1 = dragPreviewVertices.find(p => p.id === previewSystem.attachedToEdge.v1) || findVertexById(previewSystem.attachedToEdge.v1);
            const v2 = dragPreviewVertices.find(p => p.id === previewSystem.attachedToEdge.v2) || findVertexById(previewSystem.attachedToEdge.v2);
            if (v1 && v2) {
                newOrigin = {
                    x: v1.x + previewSystem.attachedToEdge.t * (v2.x - v1.x),
                    y: v1.y + previewSystem.attachedToEdge.t * (v2.y - v1.y)
                };
            }
        }
    }

    if (previewSystem.rotationAlignedToEdge) {
        if (draggedVertexIds.has(previewSystem.rotationAlignedToEdge.v1) || draggedVertexIds.has(previewSystem.rotationAlignedToEdge.v2)) {
            const v1 = dragPreviewVertices.find(p => p.id === previewSystem.rotationAlignedToEdge.v1) || findVertexById(previewSystem.rotationAlignedToEdge.v1);
            const v2 = dragPreviewVertices.find(p => p.id === previewSystem.rotationAlignedToEdge.v2) || findVertexById(previewSystem.rotationAlignedToEdge.v2);
            if (v1 && v2) {
                const currentEdgeAngle = Math.atan2(v2.y - v1.y, v2.x - v1.x);
                const { originalAngle, originalSystemAngle } = previewSystem.rotationAlignedToEdge;
                const angleOffset = originalSystemAngle - originalAngle;
                newAngle = U.normalizeAngle(currentEdgeAngle + angleOffset);
            }
        }
    }

    if (previewSystem.scaleAttachedToEdge) {
        if (draggedVertexIds.has(previewSystem.scaleAttachedToEdge.v1) || draggedVertexIds.has(previewSystem.scaleAttachedToEdge.v2)) {
            const v1 = dragPreviewVertices.find(p => p.id === previewSystem.scaleAttachedToEdge.v1) || findVertexById(previewSystem.scaleAttachedToEdge.v1);
            const v2 = dragPreviewVertices.find(p => p.id === previewSystem.scaleAttachedToEdge.v2) || findVertexById(previewSystem.scaleAttachedToEdge.v2);
            if (v1 && v2) {
                newScale = U.distance(v1, v2) * previewSystem.scaleAttachedToEdge.scaleRatio;
            }
        }
    }

    if (liveVertices.length >= 3) {
        previewSystem.origin = U.clampPointToPolygon(newOrigin, liveVertices);
    } else {
        previewSystem.origin = newOrigin;
    }
    previewSystem.angle = newAngle;
    previewSystem.scale = Math.max(0.01, newScale);

    return previewSystem;
}

export function drawCopyPreviews(ctx, params, dataToScreen) {
    const { copyCount, isDragConfirmed, initialDragVertexStates, dragPreviewVertices, transformIndicatorData, allEdges, allFaces, findVertexById, findNeighbors, colors, snappedEdgesInfo, snappedVertexIds } = params;
    if (copyCount < 1 || !isDragConfirmed || !initialDragVertexStates.length) {
        return;
    }

    const verticesToCopy = initialDragVertexStates.filter(p => p.type === 'regular');
    if (verticesToCopy.length === 0) return;

    const vertexIdsToCopy = new Set(verticesToCopy.map(p => p.id));
    const incidentEdges = allEdges.filter(edge =>
        vertexIdsToCopy.has(edge.id1) && vertexIdsToCopy.has(edge.id2)
    );
    const affectedFaces = allFaces.filter(face =>
        face.vertexIds && face.vertexIds.some(vId => vertexIdsToCopy.has(vId))
    );

    ctx.save();
    ctx.globalAlpha = 1.0;

    for (let i = 0; i < copyCount; i++) {
        let previewVerticesForThisCopy;
        const copyIndex = i;

        if (transformIndicatorData) {
            const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
            const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
            
            if (scale === 0 && directionalScale && i > 0) {
                previewVerticesForThisCopy = verticesToCopy.map(p => {
                    const projectedPos = U.applyDirectionalProjection(p, center, startVector);
                    return { ...p, id: `preview_${p.id}_${i}`, ...projectedPos };
                });
            } else {
                const effectiveRotation = rotation * i;
                const effectiveScale = Math.pow(scale, i);
                previewVerticesForThisCopy = verticesToCopy.map(p => {
                    const newPos = U.applyTransformToVertex(p, center, effectiveRotation, effectiveScale, directionalScale, startVector);
                    return { ...p, id: `preview_${p.id}_${i}`, x: newPos.x, y: newPos.y };
                });
            }
        } else {
            const deltaX = dragPreviewVertices[0].x - initialDragVertexStates[0].x;
            const deltaY = dragPreviewVertices[0].y - initialDragVertexStates[0].y;
            const effectiveDeltaX = deltaX * i;
            const effectiveDeltaY = deltaY * i;
            previewVerticesForThisCopy = verticesToCopy.map(p => ({
                ...p, id: `preview_${p.id}_${i}`, x: p.x + effectiveDeltaX, y: p.y + effectiveDeltaY
            }));
        }

        const newIdMapForThisCopy = new Map();
        previewVerticesForThisCopy.forEach((previewVertex, index) => {
            const originalVertex = verticesToCopy[index];
            newIdMapForThisCopy.set(originalVertex.id, previewVertex);
        });

        affectedFaces.forEach(originalFace => {
            const faceVerticesForThisCopy = originalFace.vertexIds.map(originalVertexId => {
                return vertexIdsToCopy.has(originalVertexId)
                    ? newIdMapForThisCopy.get(originalVertexId)
                    : findVertexById(originalVertexId);
            }).filter(v => v && v.type === 'regular');

            if (faceVerticesForThisCopy.length >= 3) {
                const screenVertices = faceVerticesForThisCopy.map(v => dataToScreen(v));
                if (screenVertices.every(v => v && typeof v.x === 'number' && typeof v.y === 'number')) {
                    let faceToDraw = originalFace;
                    drawFace(ctx, screenVertices, faceToDraw, colors, dataToScreen, findVertexById);
                }
            }
        });
        
        ctx.setLineDash([]);
        ctx.lineWidth = C.LINE_WIDTH;

        incidentEdges.forEach(originalEdge => {
            const p1 = newIdMapForThisCopy.get(originalEdge.id1);
            const p2 = newIdMapForThisCopy.get(originalEdge.id2);
            if (p1 && p2) {
                const p1Screen = dataToScreen(p1);
                const p2Screen = dataToScreen(p2);
                ctx.beginPath();
                ctx.moveTo(p1Screen.x, p1Screen.y);
                ctx.lineTo(p2Screen.x, p2Screen.y);
                ctx.strokeStyle = originalEdge.color || colors.edge;
                ctx.stroke();

                const originalEdgeId = U.getEdgeId(originalEdge);
                if (snappedEdgesInfo && snappedEdgesInfo.has(originalEdgeId)) {
                    const copyIndices = snappedEdgesInfo.get(originalEdgeId);
                    if (copyIndices.has(copyIndex)) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(p1Screen.x, p1Screen.y);
                        ctx.lineTo(p2Screen.x, p2Screen.y);
                        ctx.strokeStyle = colors.feedbackSnapped;
                        ctx.globalAlpha = C.SELECTION_GLOW_ALPHA;
                        ctx.lineWidth = C.LINE_WIDTH + C.EDGE_SELECTION_GLOW_WIDTH_OFFSET;
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }
        });

        verticesToCopy.forEach(originalVertex => {
            const correspondingPreviewVertex = newIdMapForThisCopy.get(originalVertex.id);
            if (!correspondingPreviewVertex) return;
            
            const neighbors = findNeighbors(originalVertex.id);
            neighbors.forEach(neighborId => {
                if (!vertexIdsToCopy.has(neighborId)) {
                    const neighborVertex = findVertexById(neighborId);
                    if (neighborVertex && neighborVertex.type === 'regular') {
                        const previewScreen = dataToScreen(correspondingPreviewVertex);
                        const neighborScreen = dataToScreen(neighborVertex);
                        ctx.beginPath();
                        ctx.moveTo(previewScreen.x, previewScreen.y);
                        ctx.lineTo(neighborScreen.x, neighborScreen.y);
                        ctx.strokeStyle = colors.edge;
                        ctx.stroke();
                    }
                }
            });
        });

        previewVerticesForThisCopy.forEach((vertex, index) => {
            const originalVertex = verticesToCopy[index];
            drawVertex(ctx, vertex, { 
                selectedVertexIds: [], 
                selectedCenterIds: [], 
                activeCenterId: null, 
                currentColor: vertex.color, 
                colors, 
                verticesVisible: true,
                isSnapped: snappedVertexIds.has(originalVertex.id) && snappedVertexIds.get(originalVertex.id).has(copyIndex)
            }, dataToScreen, () => {});
        });
    }

    ctx.restore();
}

export function drawDeformingDragPreviewFaces(ctx, params, dataToScreen) {
    const { copyCount, initialDragVertexStates, dragPreviewVertices, allFaces, findVertexById, colors } = params;

    if (initialDragVertexStates.length !== 1) return;

    const originalVertex = initialDragVertexStates[0];
    const deltaX = dragPreviewVertices[0].x - originalVertex.x;
    const deltaY = dragPreviewVertices[0].y - originalVertex.y;
    const affectedFaces = allFaces.filter(face => face.vertexIds.includes(originalVertex.id));

    for (let i = 1; i <= copyCount; i++) {
        const effectiveDeltaX = deltaX * i;
        const effectiveDeltaY = deltaY * i;
        
        const getLiveVertexForCopy = (vertexId) => {
            if (vertexId === originalVertex.id) {
                return { ...originalVertex, x: originalVertex.x + effectiveDeltaX, y: originalVertex.y + effectiveDeltaY };
            }
            return findVertexById(vertexId);
        };

        affectedFaces.forEach(originalFace => {
            const faceVerticesForThisCopy = originalFace.vertexIds.map(getLiveVertexForCopy).filter(Boolean);
            if (faceVerticesForThisCopy.length >= 3) {
                const screenVertices = faceVerticesForThisCopy.map(v => dataToScreen(v));
                drawFace(ctx, screenVertices, originalFace, colors, dataToScreen, findVertexById, allFaces, getLiveVertexForCopy, true);
            }
        });
    }
}

export function drawDeformingDragPreviewEdgesAndVertices(ctx, params, dataToScreen) {
    const { copyCount, initialDragVertexStates, dragPreviewVertices, allEdges, findVertexById, findNeighbors, colors } = params;

    if (initialDragVertexStates.length !== 1) return;

    const originalVertex = initialDragVertexStates[0];
    const deltaX = dragPreviewVertices[0].x - originalVertex.x;
    const deltaY = dragPreviewVertices[0].y - originalVertex.y;

    const incidentEdges = allEdges.filter(edge => edge.id1 === originalVertex.id || edge.id2 === originalVertex.id);

    for (let i = 1; i <= copyCount; i++) {
        const effectiveDeltaX = deltaX * i;
        const effectiveDeltaY = deltaY * i;
        
        const previewVertex = {
            ...originalVertex,
            x: originalVertex.x + effectiveDeltaX,
            y: originalVertex.y + effectiveDeltaY
        };

        const getLiveVertexForCopy = (vertexId) => {
            if (vertexId === originalVertex.id) return previewVertex;
            return findVertexById(vertexId);
        };

        // Draw Edges
        incidentEdges.forEach(originalEdge => {
            const p1 = getLiveVertexForCopy(originalEdge.id1);
            const p2 = getLiveVertexForCopy(originalEdge.id2);
            if (p1 && p2) {
                const p1Screen = dataToScreen(p1);
                const p2Screen = dataToScreen(p2);
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(p1Screen.x, p1Screen.y);
                ctx.lineTo(p2Screen.x, p2Screen.y);
                ctx.strokeStyle = originalEdge.color || colors.edge;
                ctx.lineWidth = C.LINE_WIDTH;
                ctx.stroke();
                ctx.restore();
            }
        });

        // Draw Vertices
        const screenPos = dataToScreen(previewVertex);
        ctx.save();
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, C.VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
        ctx.fillStyle = colors.feedbackSnapped;
        ctx.fill();
        ctx.restore();
    }
}


export function drawDrawingPreview(ctx, { startVertex, snappedData, isShiftPressed, currentColor, nextCreationColor, nextEdgeColor, colors, edgeColormapInfo }, dataToScreen) {
    const startScreen = dataToScreen(startVertex);
    const targetScreen = dataToScreen(snappedData);

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(startScreen.x, startScreen.y);
    ctx.lineTo(targetScreen.x, targetScreen.y);
    ctx.setLineDash(C.DASH_PATTERN);
    
    if (edgeColormapInfo && edgeColormapInfo.colormapItem) {
        const gradient = ctx.createLinearGradient(startScreen.x, startScreen.y, targetScreen.x, targetScreen.y);
        const startColor = U.sampleColormap(edgeColormapInfo.colormapItem, edgeColormapInfo.startT);
        const endColor = U.sampleColormap(edgeColormapInfo.colormapItem, edgeColormapInfo.endT);
        gradient.addColorStop(0, startColor);
        gradient.addColorStop(1, endColor);
        ctx.strokeStyle = gradient;
    } else if (snappedData.snapped) {
        ctx.strokeStyle = colors.feedbackSnapped;
    } else if (isShiftPressed) {
        ctx.strokeStyle = colors.feedbackSnapped;
    } else {
        ctx.strokeStyle = nextEdgeColor;
    }
    
    ctx.lineWidth = C.LINE_WIDTH;
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.beginPath();
    ctx.arc(targetScreen.x, targetScreen.y, C.VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
    
    if (snappedData.snapped) {
        ctx.fillStyle = colors.feedbackSnapped;
    } else {
        ctx.fillStyle = nextCreationColor;
    }
    
    ctx.fill();
    ctx.restore();
}

function generateOptimizedAngleSequence(angleStep, minAngle, maxAngle) {
    const angles = [];
    
    const isWraparound = maxAngle > 360;
    
    if (isWraparound) {
        const actualMaxAngle = maxAngle - 360;
        
        const startAngle1 = Math.floor(minAngle / angleStep) * angleStep;
        for (let angle = startAngle1; angle < 360; angle += angleStep) {
            if (angle >= minAngle) {
                angles.push(angle);
            }
        }
        
        for (let angle = 0; angle <= actualMaxAngle + angleStep; angle += angleStep) {
            if (angle <= actualMaxAngle) {
                angles.push(angle);
            }
        }
    } else {
        const startAngle = Math.floor(minAngle / angleStep) * angleStep;
        for (let angle = startAngle; angle <= maxAngle + angleStep; angle += angleStep) {
            if (angle >= minAngle && angle <= maxAngle && angle >= 0 && angle < 360) {
                angles.push(angle);
            }
        }
    }
    
    return [...new Set(angles)].sort((a, b) => a - b);
}

function isTickVisible(tickEnd, canvasWidth, canvasHeight) {
    return tickEnd.x >= -C.AXIS_LABEL_PADDING && 
           tickEnd.x <= canvasWidth + C.AXIS_LABEL_PADDING && 
           tickEnd.y >= -C.AXIS_LABEL_PADDING && 
           tickEnd.y <= canvasHeight + C.AXIS_LABEL_PADDING;
}

export function drawPolarReferenceCircle(ctx, htmlOverlay, updateHtmlLabel, radius, alpha, { canvas, dpr, viewTransform, angleDisplayMode, colors }, dataToScreen, lastAngularGridState) {
    if (typeof dataToScreen !== 'function' || typeof updateHtmlLabel !== 'function') {
        return;
    }

    const originScreen = dataToScreen({ x: 0, y: 0 });
    const canvasWidthCSS = canvas.width / dpr;
    const canvasHeightCSS = canvas.height / dpr;
    const screenCenter = { x: canvasWidthCSS / 2, y: canvasHeightCSS / 2 };
    const baseRadius = Math.min(canvasWidthCSS, canvasHeightCSS) / 4;
    const panDistance = U.distance(originScreen, screenCenter);
    const screenRadius = baseRadius + panDistance;

    if (screenRadius < C.REF_CIRCLE_MIN_DISPLAY_RADIUS || !isCircleInView(originScreen.x, originScreen.y, screenRadius, canvasWidthCSS, canvasHeightCSS)) {
        return;
    }

    ctx.save();
    ctx.strokeStyle = `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;

    const transitionRadius = Math.min(canvasWidthCSS, canvasHeightCSS) * 400;
    const isLineMode = screenRadius > transitionRadius;

    let visibleAngleRange = null;

    if (isLineMode) {
        const screenRect = { x: 0, y: 0, w: canvasWidthCSS, h: canvasHeightCSS };
        const circle = { x: originScreen.x, y: originScreen.y, r: screenRadius };
        const intersections = getCircleRectIntersections(circle, screenRect);

        if (intersections.length >= 2) {
            let p1 = intersections[0], p2 = intersections[1];
            let maxDistSq = 0;
            for (let i = 0; i < intersections.length; i++) {
                for (let j = i + 1; j < intersections.length; j++) {
                    const dSq = (intersections[i].x - intersections[j].x)**2 + (intersections[i].y - intersections[j].y)**2;
                    if (dSq > maxDistSq) {
                        maxDistSq = dSq;
                        p1 = intersections[i];
                        p2 = intersections[j];
                    }
                }
            }
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            const angle1 = (Math.atan2(originScreen.y - p1.y, p1.x - originScreen.x) * 180 / Math.PI + 360) % 360;
            const angle2 = (Math.atan2(originScreen.y - p2.y, p2.x - originScreen.x) * 180 / Math.PI + 360) % 360;
            visibleAngleRange = { minAngle: Math.min(angle1, angle2), maxAngle: Math.max(angle1, angle2), isFullCircle: false };
            if (Math.abs(angle1 - angle2) > 180) {
                 visibleAngleRange = { minAngle: Math.max(angle1, angle2), maxAngle: Math.min(angle1, angle2) + 360, isFullCircle: false };
            }
        }
    } else {
        ctx.beginPath();
        ctx.arc(originScreen.x, originScreen.y, screenRadius, 0, 2 * Math.PI);
        ctx.stroke();
        visibleAngleRange = calculateVisibleAngleRange(originScreen, screenRadius, canvasWidthCSS, canvasHeightCSS);
    }
    
    ctx.restore();
    
    if (!visibleAngleRange) return;

    const dataRadius = screenRadius / (viewTransform.scale / dpr);
    const drawnAnglesSimple = new Set();
    const drawnAnglesComplex = new Map();

    lastAngularGridState.forEach(level => {
        const tickAlpha = level.alpha;
        if (tickAlpha < C.POLAR_REF_TICK_ALPHA_THRESHOLD) return;

        const screenSeparation = screenRadius * (level.angle * Math.PI / 180);
        
        if (screenSeparation < C.REF_CIRCLE_MIN_TICK_SPACING * 0.5) return;

        const finalColor = `rgba(${colors.feedbackDefault.join(',')}, ${tickAlpha * C.POLAR_REF_TICK_LABEL_ALPHA_FACTOR})`;

        let anglesToProcess;
        if (visibleAngleRange.isFullCircle) {
            anglesToProcess = [];
            for (let deg = 0; deg < 360; deg += level.angle) {
                anglesToProcess.push(deg);
            }
        } else {
            anglesToProcess = [];
            if (visibleAngleRange.ranges && Array.isArray(visibleAngleRange.ranges)) {
                visibleAngleRange.ranges.forEach(range => {
                    const [minAngle, maxAngle] = range;
                    const rangeAngles = generateOptimizedAngleSequence(level.angle, minAngle, maxAngle);
                    anglesToProcess.push(...rangeAngles);
                });
            } else if (visibleAngleRange.minAngle !== undefined && visibleAngleRange.maxAngle !== undefined) {
                anglesToProcess = generateOptimizedAngleSequence(level.angle, visibleAngleRange.minAngle, visibleAngleRange.maxAngle);
            }
            anglesToProcess = [...new Set(anglesToProcess)];
        }

        anglesToProcess.forEach(deg => {
            deg = Math.round(deg * 1e10) / 1e10;
            
            if (angleDisplayMode === 'degrees') {
                if (drawnAnglesSimple.has(deg)) return;
            }
            else if (angleDisplayMode === 'radians') {
                const levelKey = `${deg}-${level.angle}`;
                if (drawnAnglesComplex.has(levelKey)) return;
            }

            const angleRad = deg * Math.PI / 180;
            
            const labelPos = { 
                x: originScreen.x + (screenRadius + C.REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN) * Math.cos(angleRad), 
                y: originScreen.y - (screenRadius + C.REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN) * Math.sin(angleRad) 
            };
            
            const labelMargin = C.POLAR_REF_LABEL_MARGIN;
            const isLabelVisible = labelPos.x > -labelMargin && labelPos.x < canvasWidthCSS + labelMargin && 
                                   labelPos.y > -labelMargin && labelPos.y < canvasHeightCSS + labelMargin;
            
            if (!isLabelVisible) {
                return;
            }
            
            let labelOptions = { textAlign: 'center', textBaseline: 'middle' };
            
            if (angleDisplayMode === 'radians') {
                labelOptions = { textAlign: 'left', textBaseline: 'middle' };
            }

            ctx.save();
            ctx.strokeStyle = finalColor;
            ctx.lineWidth = C.GRID_LINEWIDTH;

            if (deg % 90 === 0 && deg < 360) {
                const vertexOnCircle = { 
                    x: originScreen.x + screenRadius * Math.cos(angleRad), 
                    y: originScreen.y - screenRadius * Math.sin(angleRad) 
                };

                let tickVec;
                const tickLength = C.AXIS_TICK_SIZE * 1.5;
                
                switch (deg) {
                    case 0:
                        tickVec = { x: Math.SQRT1_2, y: -Math.SQRT1_2 };
                        labelOptions = { textAlign: 'left', textBaseline: 'bottom' };
                        break;
                    case 90:
                        tickVec = { x: Math.SQRT1_2, y: -Math.SQRT1_2 };
                        labelOptions = { textAlign: 'left', textBaseline: 'bottom' };
                        break;
                    case 180:
                        tickVec = { x: -Math.SQRT1_2, y: -Math.SQRT1_2 };
                        labelOptions = { textAlign: 'right', textBaseline: 'bottom' };
                        break;
                    case 270:
                        tickVec = { x: Math.SQRT1_2, y: Math.SQRT1_2 };
                        labelOptions = { textAlign: 'left', textBaseline: 'top' };
                        break;
                }
                
                const tickEnd = {
                    x: vertexOnCircle.x + tickVec.x * tickLength,
                    y: vertexOnCircle.y + tickVec.y * tickLength
                };

                ctx.lineWidth = C.POLAR_REF_LINE_WIDTH;
                ctx.beginPath();
                ctx.moveTo(vertexOnCircle.x, vertexOnCircle.y);
                ctx.lineTo(tickEnd.x, tickEnd.y);
                ctx.stroke();
                
                labelPos.x = tickEnd.x;
                labelPos.y = tickEnd.y;

            } else {
                const tickStart = { 
                    x: originScreen.x + (screenRadius - C.VERTEX_RADIUS) * Math.cos(angleRad), 
                    y: originScreen.y - (screenRadius - C.VERTEX_RADIUS) * Math.sin(angleRad) 
                };
                const tickEnd = { 
                    x: originScreen.x + (screenRadius + C.VERTEX_RADIUS) * Math.cos(angleRad), 
                    y: originScreen.y - (screenRadius + C.VERTEX_RADIUS) * Math.sin(angleRad) 
                };
                if (isTickVisible(tickEnd, canvasWidthCSS, canvasHeightCSS)) {
                    ctx.beginPath();
                    ctx.moveTo(tickStart.x, tickStart.y);
                    ctx.lineTo(tickEnd.x, tickEnd.y);
                    ctx.stroke();
                }
            }
            
            ctx.restore();
            
            let angleText = '';
            if (angleDisplayMode === 'degrees') {
                let precision = Math.max(0, (level.angle.toString().split('.')[1] || '').length);
                
                if (level.angle < 1) {
                    precision = Math.max(precision, Math.ceil(-Math.log10(level.angle)) + 1);
                }
                
                const cleanDeg = Math.round(deg * Math.pow(10, precision)) / Math.pow(10, precision);
                const formattedDeg = parseFloat(cleanDeg.toFixed(precision));
                
                const displayValue = Math.round(formattedDeg * 1e10) / 1e10;
                angleText = `${displayValue}^{\\circ}`;
            } else {
                if (deg === 0 && angleDisplayMode === 'radians') {
                    angleText = '0';
                } else if (deg !== 0) {
                    const isFineTick = level.angle <= 5;
                    
                    if (isFineTick) {
                        const radianValue = deg * Math.PI / 180;
                        
                        const levelAnglePrecision = Math.max(0, (level.angle.toString().split('.')[1] || '').length);
                        const radianPrecision = Math.max(3, levelAnglePrecision + 2);
                        
                        let formattedRadian = radianValue.toFixed(radianPrecision);
                        formattedRadian = parseFloat(formattedRadian).toString();
                        
                        if (parseFloat(formattedRadian) !== 0) {
                            angleText = formattedRadian;
                        }
                    } else {
                        const numerator = deg;
                        const denominator = 180;
                        
                        const gcdValue = U.gcd(numerator, denominator);
                        const simplifiedNum = numerator / gcdValue;
                        const simplifiedDen = denominator / gcdValue;
                        
                        if (simplifiedDen === 1) {
                            if (simplifiedNum === 1) angleText = '\\pi';
                            else if (simplifiedNum === -1) angleText = '-\\pi';
                            else angleText = `${simplifiedNum}\\pi`;
                        } else {
                            if (simplifiedNum === 1) angleText = `\\frac{\\pi}{${simplifiedDen}}`;
                            else if (simplifiedNum === -1) angleText = `-\\frac{\\pi}{${simplifiedDen}}`;
                            else if (simplifiedNum < 0) angleText = `-\\frac{${Math.abs(simplifiedNum)}\\pi}{${simplifiedDen}}`;
                            else angleText = `\\frac{${simplifiedNum}\\pi}{${simplifiedDen}}`;
                        }
                    }
                }
            }

            if (angleText) {
                const labelId = angleDisplayMode === 'radians' 
                    ? `circ-label-${deg}-${level.angle}-${dataRadius.toExponential(15)}`
                    : `circ-label-${deg}-${dataRadius.toExponential(15)}`;
                    
                updateHtmlLabel({ 
                    id: labelId, 
                    content: angleText, 
                    x: labelPos.x, 
                    y: labelPos.y, 
                    color: finalColor, 
                    fontSize: C.REF_TEXT_KATEX_FONT_SIZE, 
                    options: labelOptions
                });
                
                if (angleDisplayMode === 'degrees') {
                    drawnAnglesSimple.add(deg);
                } else {
                    const levelKey = `${deg}-${level.angle}`;
                    drawnAnglesComplex.set(levelKey, { 
                        levelAngle: level.angle, 
                        alpha: tickAlpha,
                        labelId: labelId 
                    });
                }
            }
        });
    });

    const arrowColor = colors.feedbackDefault;
    let stickyArrowAngle = -Infinity;
    const zeroDegVertex = { x: originScreen.x + screenRadius, y: originScreen.y };
    if (zeroDegVertex.x > -C.AXIS_LABEL_PADDING && zeroDegVertex.x < canvasWidthCSS + C.AXIS_LABEL_PADDING && zeroDegVertex.y > -C.AXIS_LABEL_PADDING && zeroDegVertex.y < canvasHeightCSS + C.AXIS_LABEL_PADDING) {
        stickyArrowAngle = 0;
    } else {
        const screenRect = { x: 0, y: 0, w: canvasWidthCSS, h: canvasHeightCSS };
        const circle = { x: originScreen.x, y: originScreen.y, r: screenRadius };
        const intersections = getCircleRectIntersections(circle, screenRect);
        
        if (intersections.length > 0) {
            let largestVisibleAngle = -Infinity;
            
            intersections.forEach(p => {
                const angle = Math.atan2(originScreen.y - p.y, p.x - originScreen.x);
                const normalizedAngle = angle >= 0 ? angle : angle + 2 * Math.PI;
                
                const testPoint = { 
                    x: originScreen.x + screenRadius * Math.cos(normalizedAngle), 
                    y: originScreen.y - screenRadius * Math.sin(normalizedAngle) 
                };
                
                const margin = C.AXIS_LABEL_PADDING;
                const isVisible = testPoint.x > -margin && testPoint.x < canvasWidthCSS + margin && 
                                 testPoint.y > -margin && testPoint.y < canvasHeightCSS + margin;
                
                if (isVisible && normalizedAngle > largestVisibleAngle) {
                    largestVisibleAngle = normalizedAngle;
                }
            });
            
            const corners = [{x:0,y:0}, {x:screenRect.w,y:0}, {x:screenRect.w,y:screenRect.h}, {x:0,y:screenRect.h}];
            corners.forEach(c => {
                if (U.distance(c, originScreen) < circle.r) {
                    const angle = Math.atan2(originScreen.y - c.y, c.x - originScreen.x);
                    const normalizedAngle = angle >= 0 ? angle : angle + 2 * Math.PI;
                    
                    const testPoint = { 
                        x: originScreen.x + screenRadius * Math.cos(normalizedAngle), 
                        y: originScreen.y - screenRadius * Math.sin(normalizedAngle) 
                    };
                    
                    const margin = C.AXIS_LABEL_PADDING;
                    const isVisible = testPoint.x > -margin && testPoint.x < canvasWidthCSS + margin && 
                                     testPoint.y > -margin && testPoint.y < canvasHeightCSS + margin;
                    
                    if (isVisible && normalizedAngle > largestVisibleAngle) {
                        largestVisibleAngle = normalizedAngle;
                    }
                }
            });
            
            if (largestVisibleAngle > -Infinity) {
                stickyArrowAngle = largestVisibleAngle;
            }
        }
    }

    if (stickyArrowAngle > -Infinity) {
        const arrowAngle = stickyArrowAngle;
        const tipPos = { x: originScreen.x + screenRadius * Math.cos(arrowAngle), y: originScreen.y - screenRadius * Math.sin(arrowAngle) };
        const tangentVec = { x: -Math.sin(arrowAngle), y: -Math.cos(arrowAngle) };
        const radialVec = { x: Math.cos(arrowAngle), y: -Math.sin(arrowAngle) };
        const p1 = { x: tipPos.x - C.AXIS_ARROW_SIZE * tangentVec.x + (C.AXIS_ARROW_SIZE / 2) * radialVec.x, y: tipPos.y - C.AXIS_ARROW_SIZE * tangentVec.y + (C.AXIS_ARROW_SIZE / 2) * radialVec.y };
        const p2 = { x: tipPos.x - C.AXIS_ARROW_SIZE * tangentVec.x - (C.AXIS_ARROW_SIZE / 2) * radialVec.x, y: tipPos.y - C.AXIS_ARROW_SIZE * tangentVec.y - (C.AXIS_ARROW_SIZE / 2) * radialVec.y };
        ctx.save();
        ctx.fillStyle = `rgba(${arrowColor.join(',')}, 1.0)`;
        ctx.beginPath();
        ctx.moveTo(tipPos.x, tipPos.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        let labelPos;
        if (arrowAngle === 0) {
            labelPos = {
                x: tipPos.x - C.POLAR_THETA_LABEL_DISTANCE,
                y: tipPos.y + C.POLAR_THETA_LABEL_ARROW_DIST + C.AXIS_ARROW_SIZE
            };
        } else {
            const radialVecInward = { x: -Math.cos(arrowAngle), y: Math.sin(arrowAngle) };
            labelPos = {
                x: tipPos.x + radialVecInward.x * (C.POLAR_THETA_LABEL_ARROW_DIST + C.AXIS_ARROW_SIZE) + tangentVec.x * C.POLAR_THETA_LABEL_DISTANCE,
                y: tipPos.y + radialVecInward.y * (C.POLAR_THETA_LABEL_ARROW_DIST + C.AXIS_ARROW_SIZE) + tangentVec.y * C.POLAR_THETA_LABEL_DISTANCE
            };
        }
        updateHtmlLabel({ id: `theta-label-sticky`, content: '\\theta', x: labelPos.x, y: labelPos.y, color: `rgba(${arrowColor.join(',')}, 1.0)`, fontSize: C.AXIS_NAME_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } });
    }
}

function getCircleRectIntersections(circle, rect) {
    const { x: cx, y: cy, r } = circle;
    const { x: rx, y: ry, w: rw, h: rh } = rect;
    const intersections = [];
    
    const circleForUtils = { center: { x: cx, y: cy }, radius: r };
    
    const checkLine = (x1, y1, x2, y2) => {
        const line = { p1: { x: x1, y: y1 }, p2: { x: x2, y: y2 } };
        const points = U.getLineCircleIntersection(line, circleForUtils);
        
        points.forEach(point => {
            const dx = x2 - x1;
            const dy = y2 - y1;
            
            let t;
            if (Math.abs(dx) > Math.abs(dy)) {
                t = (point.x - x1) / dx;
            } else {
                t = (point.y - y1) / dy;
            }
            
            if (t >= 0 && t <= 1) {
                intersections.push({ x: point.x, y: point.y });
            }
        });
    };
    
    checkLine(rx, ry, rx + rw, ry);
    checkLine(rx + rw, ry, rx + rw, ry + rh);
    checkLine(rx + rw, ry + rh, rx, ry + rh);
    checkLine(rx, ry + rh, rx, ry);
    
    return intersections;
}

export function isCircleInView(circleX, circleY, circleRadius, canvasWidth, canvasHeight) {
    if (circleX + circleRadius < 0 ||
        circleX - circleRadius > canvasWidth ||
        circleY + circleRadius < 0 ||
        circleY - circleRadius > canvasHeight) {
        return false;
    }
    return true;
}

function drawZeroTickAndTickLabel(ctx, origin, canvasWidth, canvasHeight, coordsDisplayMode, updateHtmlLabel, colors) {
    const tickColor = `rgba(${colors.axisTickLabel.join(',')}, ${C.AXIS_TICK_LABEL_ALPHA})`;
    const longTickSize = C.AXIS_TICK_SIZE * C.AXIS_MAJOR_TICK_SCALE_FACTOR;
    
    ctx.save();
    ctx.strokeStyle = tickColor;
    ctx.lineWidth = C.MAJOR_TICK_LINE_WIDTH;
    ctx.setLineDash([]);
    
    const yLength = longTickSize;
    const xLength = yLength / Math.tan(C.ORIGIN_TICK_ANGLE_RAD);
    
    const endX = origin.x - xLength;
    const endY = origin.y + yLength;
    
    ctx.beginPath();
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
    ctx.restore();
    
    updateHtmlLabel({
        id: 'tick-label-origin',
        content: C.ORIGIN_LABEL_TEXT,
        x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET,
        y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET,
        color: tickColor,
        fontSize: C.AXIS_TICK_FONT_SIZE,
        options: { textAlign: 'right', textBaseline: 'top' }
    });
}

export function drawAxes(ctx, htmlOverlay, { canvas, dpr, coordsDisplayMode, viewTransform, angleDisplayMode, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState, updateHtmlLabel) {
    ctx.save();
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;
    const origin = dataToScreen({ x: 0, y: 0 });

    const drawAxisWithArrows = (x1, y1, x2, y2) => {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        const angle = Math.atan2(y2 - y1, x2 - x1);
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - C.AXIS_ARROW_SIZE * Math.cos(angle - C.AXIS_ARROW_ANGLE_RAD), y2 - C.AXIS_ARROW_SIZE * Math.sin(angle - C.AXIS_ARROW_ANGLE_RAD));
        ctx.lineTo(x2 - C.AXIS_ARROW_SIZE * Math.cos(angle + C.AXIS_ARROW_ANGLE_RAD), y2 - C.AXIS_ARROW_SIZE * Math.sin(angle + C.AXIS_ARROW_ANGLE_RAD));
        ctx.closePath();
        ctx.fill();
    };

    const drawTicksAndLabels = (interval1, alpha1, interval2, alpha2, isPolar) => {
        const drawnXPositions = new Map();
        const drawnYPositions = new Map();
        
        const addTicksForInterval = (interval, alpha, isCoarser) => {
            if (!interval || alpha < C.MIN_ALPHA_FOR_DRAWING) return;
            const topLeftData = screenToData({ x: 0, y: 0 });
            const bottomRightData = screenToData({ x: canvasWidth, y: canvasHeight });
            const localZeroThreshold = interval * C.GEOMETRY_CALCULATION_EPSILON;
            
            if (isPolar) {
                const maxRadiusData = Math.hypot(Math.max(Math.abs(topLeftData.x), Math.abs(bottomRightData.x)), Math.max(Math.abs(topLeftData.y), Math.abs(bottomRightData.y))) * C.POLAR_AXIS_RADIUS_BUFFER_FACTOR;
                const startMultiplier = 1;
                const endMultiplier = Math.ceil(maxRadiusData / interval);
                
                for (let i = startMultiplier; i <= endMultiplier; i++) {
                    const r_data = i * interval;
                    const existing = drawnXPositions.get(r_data);
                    if (!existing) {
                        drawnXPositions.set(r_data, { alpha, isCoarser });
                    } else if (isCoarser) {
                        drawnXPositions.set(r_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                    } else {
                        if (!existing.isCoarser) {
                            drawnXPositions.set(r_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                        }
                    }
                }
            } else {
                const startMultiplierX = Math.floor(topLeftData.x / interval);
                const endMultiplierX = Math.ceil(bottomRightData.x / interval);
                const startMultiplierY = Math.floor(bottomRightData.y / interval);
                const endMultiplierY = Math.ceil(topLeftData.y / interval);
                
                for (let i = startMultiplierX; i <= endMultiplierX; i++) {
                    const x_data = i * interval;
                    if (Math.abs(x_data) < localZeroThreshold) continue;
                    const existing = drawnXPositions.get(x_data);
                    if (!existing) {
                        drawnXPositions.set(x_data, { alpha, isCoarser });
                    } else if (isCoarser) {
                        drawnXPositions.set(x_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                    } else {
                        if (!existing.isCoarser) {
                            drawnXPositions.set(x_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                        }
                    }
                }
                
                for (let i = startMultiplierY; i <= endMultiplierY; i++) {
                    const y_data = i * interval;
                    if (Math.abs(y_data) < localZeroThreshold) continue;
                    const existing = drawnYPositions.get(y_data);
                    if (!existing) {
                        drawnYPositions.set(y_data, { alpha, isCoarser });
                    } else if (isCoarser) {
                        drawnYPositions.set(y_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                    } else {
                        if (!existing.isCoarser) {
                            drawnYPositions.set(y_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                        }
                    }
                }
            }
        };
        
        const interval1IsCoarser = !interval2 || interval1 >= interval2;
        
        addTicksForInterval(interval1, alpha1, interval1IsCoarser);
        addTicksForInterval(interval2, alpha2, !interval1IsCoarser);

        // Check if scientific notation should be used for ANY visible value
        let useScientific = false;
        const checkScientific = (val) => {
            const absValue = Math.abs(val);
            if (absValue >= C.SCIENTIFIC_NOTATION_UPPER_BOUND || (absValue > 0 && absValue < C.SCIENTIFIC_NOTATION_LOWER_BOUND)) {
                useScientific = true;
            }
        };
        
        // Check all axis tick values
        drawnXPositions.forEach((_, x_data) => checkScientific(x_data));
        drawnYPositions.forEach((_, y_data) => checkScientific(y_data));
        
        // Also check the current viewport bounds to ensure mouse coordinates will be consistent
        const topLeftData = screenToData({ x: 0, y: 0 });
        const bottomRightData = screenToData({ x: canvasWidth, y: canvasHeight });
        checkScientific(topLeftData.x);
        checkScientific(topLeftData.y);
        checkScientific(bottomRightData.x);
        checkScientific(bottomRightData.y);
        
        // Calculate decimal places based on the primary interval
        const primaryInterval = interval1 || interval2 || 1;
        const decimalPlaces = primaryInterval > 0 ? Math.max(0, -Math.floor(Math.log10(primaryInterval))) : 0;
        
        drawnXPositions.forEach((tickInfo, x_data) => {
            const effectiveAlpha = tickInfo.isCoarser ? 1.0 : tickInfo.alpha;
            const tickLabelColor = `rgba(${colors.axisTickLabel.join(',')}, ${C.AXIS_TICK_LABEL_ALPHA * effectiveAlpha})`;
            ctx.strokeStyle = tickLabelColor;
            ctx.lineWidth = C.GRID_LINEWIDTH;
            
            if (isPolar) {
                let labelText;
                if (useScientific) {
                    // Calculate how many decimal places needed in scientific notation coefficient
                    // to distinguish between consecutive tick values
                    const logValue = Math.log10(Math.abs(x_data));
                    const exponent = Math.floor(logValue);
                    const coefficient = x_data / Math.pow(10, exponent);
                    
                    // Determine precision needed based on tick interval
                    const intervalInSameScale = primaryInterval / Math.pow(10, exponent);
                    const decimalPlacesNeeded = Math.max(0, -Math.floor(Math.log10(intervalInSameScale)) + 1);
                    
                    const expStr = Math.abs(x_data).toExponential(decimalPlacesNeeded);
                    const parts = expStr.split('e');
                    let coefficientStr = parts[0];
                    let exp = parseInt(parts[1], 10);
                    const sign = x_data < 0 ? "-" : "";
                    labelText = `${sign}${coefficientStr} \\cdot 10^{${exp}}`;
                } else {
                    labelText = x_data.toFixed(decimalPlaces).replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
                }
                const stableIdPart = x_data.toExponential(15);
                
                const isYAxisOnScreen = origin.y > -C.AXIS_LABEL_PADDING && origin.y < canvasHeight + C.AXIS_LABEL_PADDING;
                const isXAxisOnScreen = origin.x > -C.AXIS_LABEL_PADDING && origin.x < canvasWidth + C.AXIS_LABEL_PADDING;

                const pX = dataToScreen({ x: x_data, y: 0 });
                if (isYAxisOnScreen && pX.x > -C.AXIS_LABEL_PADDING && pX.x < canvasWidth + C.AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(pX.x, origin.y - C.AXIS_TICK_SIZE / 2); 
                    ctx.lineTo(pX.x, origin.y + C.AXIS_TICK_SIZE / 2); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-x-${stableIdPart}`, 
                        content: labelText, 
                        x: pX.x, 
                        y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET, 
                        color: tickLabelColor, 
                        fontSize: C.AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'center', textBaseline: 'top' } 
                    });
                }
                
                const pNegX = dataToScreen({ x: -x_data, y: 0 });
                if (isYAxisOnScreen && pNegX.x > -C.AXIS_LABEL_PADDING && pNegX.x < canvasWidth + C.AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(pNegX.x, origin.y - C.AXIS_TICK_SIZE / 2); 
                    ctx.lineTo(pNegX.x, origin.y + C.AXIS_TICK_SIZE / 2); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-negx-${stableIdPart}`, 
                        content: labelText, 
                        x: pNegX.x, 
                        y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET, 
                        color: tickLabelColor, 
                        fontSize: C.AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'center', textBaseline: 'top' } 
                    });
                }
                
                const pPosY = dataToScreen({ x: 0, y: x_data });
                if (isXAxisOnScreen && pPosY.y > -C.AXIS_LABEL_PADDING && pPosY.y < canvasHeight + C.AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(origin.x - C.AXIS_TICK_SIZE / 2, pPosY.y); 
                    ctx.lineTo(origin.x + C.AXIS_TICK_SIZE / 2, pPosY.y); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-posy-${stableIdPart}`, 
                        content: labelText, 
                        x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET, 
                        y: pPosY.y, 
                        color: tickLabelColor, 
                        fontSize: C.AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'right', textBaseline: 'middle' } 
                    });
                }
                
                const pNegY = dataToScreen({ x: 0, y: -x_data });
                if (isXAxisOnScreen && pNegY.y > -C.AXIS_LABEL_PADDING && pNegY.y < canvasHeight + C.AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(origin.x - C.AXIS_TICK_SIZE / 2, pNegY.y); 
                    ctx.lineTo(origin.x + C.AXIS_TICK_SIZE / 2, pNegY.y); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-negy-${stableIdPart}`, 
                        content: labelText, 
                        x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET, 
                        y: pNegY.y, 
                        color: tickLabelColor, 
                        fontSize: C.AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'right', textBaseline: 'middle' } 
                    });
                }
            } else {
                const screenX = dataToScreen({ x: x_data, y: 0 }).x;
                ctx.beginPath(); 
                ctx.moveTo(screenX, origin.y); 
                ctx.lineTo(screenX, origin.y + C.AXIS_TICK_SIZE); 
                ctx.stroke();
                
                let tickLabel;
                if (useScientific) {
                    // Calculate precision needed for scientific notation
                    const logValue = Math.log10(Math.abs(x_data));
                    const exponent = Math.floor(logValue);
                    
                    // Determine precision needed based on tick interval
                    const intervalInSameScale = primaryInterval / Math.pow(10, exponent);
                    const decimalPlacesNeeded = Math.max(0, -Math.floor(Math.log10(intervalInSameScale)) + 1);
                    
                    const expStr = Math.abs(x_data).toExponential(decimalPlacesNeeded);
                    const parts = expStr.split('e');
                    let coefficientStr = parts[0];
                    // Remove trailing zeros from coefficient
                    coefficientStr = coefficientStr.replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
                    let exp = parseInt(parts[1], 10);
                    const sign = x_data < 0 ? "-" : "";
                    tickLabel = `${sign}${coefficientStr} \\cdot 10^{${exp}}`;
                } else {
                    tickLabel = x_data.toFixed(decimalPlaces).replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
                }
                
                const getStableId = (prefix, num) => `${prefix}-${num.toExponential(15)}`;
                updateHtmlLabel({ 
                    id: getStableId('tick-label-x', x_data), 
                    content: tickLabel, 
                    x: screenX, 
                    y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'center', textBaseline: 'top' } 
                });
            }
        });
        
        if (!isPolar) {
            drawnYPositions.forEach((tickInfo, y_data) => {
                const effectiveAlpha = tickInfo.isCoarser ? 1.0 : tickInfo.alpha;
                const tickLabelColor = `rgba(${colors.axisTickLabel.join(',')}, ${C.AXIS_TICK_LABEL_ALPHA * effectiveAlpha})`;
                ctx.strokeStyle = tickLabelColor;
                ctx.lineWidth = C.GRID_LINEWIDTH;
                
                const screenY = dataToScreen({ x: 0, y: y_data }).y;
                let yLabelContent;
                if (useScientific) {
                    // Calculate precision needed for scientific notation
                    const logValue = Math.log10(Math.abs(y_data));
                    const exponent = Math.floor(logValue);
                    
                    // Determine precision needed based on tick interval
                    const intervalInSameScale = primaryInterval / Math.pow(10, exponent);
                    const decimalPlacesNeeded = Math.max(0, -Math.floor(Math.log10(intervalInSameScale)) + 1);
                    
                    const expStr = Math.abs(y_data).toExponential(decimalPlacesNeeded);
                    const parts = expStr.split('e');
                    let coefficientStr = parts[0];
                    // Remove trailing zeros from coefficient
                    coefficientStr = coefficientStr.replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
                    let exp = parseInt(parts[1], 10);
                    const sign = y_data < 0 ? "-" : "";
                    yLabelContent = `${sign}${coefficientStr} \\cdot 10^{${exp}}`;
                } else {
                    yLabelContent = y_data.toFixed(decimalPlaces).replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
                }
                
                if (coordsDisplayMode === C.COORDS_DISPLAY_MODE_COMPLEX && Math.abs(y_data) > C.GEOMETRY_CALCULATION_EPSILON) {
                    if (yLabelContent === '1') yLabelContent = C.IMAGINARY_UNIT_SYMBOL;
                    else if (yLabelContent === '-1') yLabelContent = `-${C.IMAGINARY_UNIT_SYMBOL}`;
                    else yLabelContent += C.IMAGINARY_UNIT_SYMBOL;
                }
                
                ctx.beginPath(); 
                ctx.moveTo(origin.x, screenY); 
                ctx.lineTo(origin.x - C.AXIS_TICK_SIZE, screenY); 
                ctx.stroke();
                
                const getStableId = (prefix, num) => `${prefix}-${num.toExponential(15)}`;
                updateHtmlLabel({ 
                    id: getStableId('tick-label-y', y_data), 
                    content: yLabelContent, 
                    x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET, 
                    y: screenY, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'right', textBaseline: 'middle' } 
                });
            });
        }
        return { useScientific };
    };

    ctx.lineWidth = C.AXIS_LINE_WIDTH;
    ctx.strokeStyle = colors.axis;
    ctx.fillStyle = colors.axis;

    let formatInfo = { useScientific: false };
    if (coordsDisplayMode === C.COORDS_DISPLAY_MODE_POLAR) {
        const { interval1, interval2, alpha1, alpha2 } = lastGridState;
        
        // Draw polar axis lines with arrows and labels
        drawPolarAxisLines(ctx, htmlOverlay, { canvas, dpr, colors }, dataToScreen, updateHtmlLabel);
        
        // Calculate scientific notation decision for consistency
        let useScientific = false;
        const checkScientific = (val) => {
            const absValue = Math.abs(val);
            if (absValue >= C.SCIENTIFIC_NOTATION_UPPER_BOUND || (absValue > 0 && absValue < C.SCIENTIFIC_NOTATION_LOWER_BOUND)) {
                useScientific = true;
            }
        };
        
        // Check viewport bounds for scientific notation decision
        const topLeftData = screenToData({ x: 0, y: 0 });
        const bottomRightData = screenToData({ x: canvasWidth, y: canvasHeight });
        checkScientific(topLeftData.x);
        checkScientific(topLeftData.y);
        checkScientific(bottomRightData.x);
        checkScientific(bottomRightData.y);
        
        // Draw polar radius ticks and labels
        drawPolarRadiusTicks(ctx, htmlOverlay, { canvas, dpr, colors }, dataToScreen, screenToData, lastGridState, updateHtmlLabel, useScientific);
        
        // Draw polar reference circles (angle ticks)
        drawPolarReferenceCircle(ctx, htmlOverlay, updateHtmlLabel, 0, 0, { canvas, dpr, coordsDisplayMode, viewTransform, angleDisplayMode, colors }, dataToScreen, lastAngularGridState);
        
        formatInfo = { useScientific };
    } else {
        if (origin.y > 0 && origin.y < canvasHeight) drawAxisWithArrows(0, origin.y, canvasWidth, origin.y);
        if (origin.x > 0 && origin.x < canvasWidth) drawAxisWithArrows(origin.x, canvasHeight, origin.x, 0);
        
        let xLabel = 'x';
        let yLabel = 'y';
        if (coordsDisplayMode === C.COORDS_DISPLAY_MODE_COMPLEX) {
            xLabel = C.COMPLEX_REAL_LABEL;
            yLabel = C.COMPLEX_IMAGINARY_LABEL;
        }
        
        updateHtmlLabel({ 
            id: 'axis-label-x', 
            content: xLabel, 
            x: canvasWidth - C.AXIS_ARROW_SIZE - C.X_AXIS_LABEL_ARROW_DIST, 
            y: origin.y - C.X_AXIS_LABEL_DISTANCE, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'center', textBaseline: 'bottom' } 
        });
        
        updateHtmlLabel({ 
            id: 'axis-label-y', 
            content: yLabel, 
            x: origin.x + C.Y_AXIS_LABEL_DISTANCE, 
            y: C.AXIS_ARROW_SIZE + C.Y_AXIS_LABEL_ARROW_DIST, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'left', textBaseline: 'middle' } 
        });
        
        formatInfo = drawTicksAndLabels(lastGridState.interval1, lastGridState.alpha1, lastGridState.interval2, lastGridState.alpha2, false);
    }

    drawZeroTickAndTickLabel(ctx, origin, canvasWidth, canvasHeight, coordsDisplayMode, updateHtmlLabel, colors);

    ctx.restore();
    return formatInfo;
}

export function drawPolarRadiusTicks(ctx, htmlOverlay, { canvas, dpr, colors }, dataToScreen, screenToData, lastGridState, updateHtmlLabel, useScientific) {
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;
    const origin = dataToScreen({ x: 0, y: 0 });
    
    // Check if origin axes are visible on screen
    const isYAxisOnScreen = origin.y > -C.AXIS_LABEL_PADDING && origin.y < canvasHeight + C.AXIS_LABEL_PADDING;
    const isXAxisOnScreen = origin.x > -C.AXIS_LABEL_PADDING && origin.x < canvasWidth + C.AXIS_LABEL_PADDING;
    
    // Early exit if no axes are visible
    if (!isYAxisOnScreen && !isXAxisOnScreen) {
        return;
    }
    
    const { interval1, interval2, alpha1, alpha2 } = lastGridState;
    const drawnRadiusPositions = new Map();
    
    // Calculate decimal places based on the primary interval
    const primaryInterval = interval1 || interval2 || 1;
    const decimalPlaces = primaryInterval > 0 ? Math.max(0, -Math.floor(Math.log10(primaryInterval))) : 0;
    
    const addTicksForInterval = (interval, alpha, isCoarser) => {
        if (!interval || alpha < C.MIN_ALPHA_FOR_DRAWING) return;
        
        // Calculate only the radius range that could be visible on the current axes
        let maxRadius = 0;
        
        if (isYAxisOnScreen) {
            // Check X-axis visibility range
            const leftData = screenToData({ x: 0, y: origin.y });
            const rightData = screenToData({ x: canvasWidth, y: origin.y });
            maxRadius = Math.max(maxRadius, Math.abs(leftData.x), Math.abs(rightData.x));
        }
        
        if (isXAxisOnScreen) {
            // Check Y-axis visibility range  
            const topData = screenToData({ x: origin.x, y: 0 });
            const bottomData = screenToData({ x: origin.x, y: canvasHeight });
            maxRadius = Math.max(maxRadius, Math.abs(topData.y), Math.abs(bottomData.y));
        }
        
        // Add small buffer
        maxRadius *= 1.1;
        
        const startMultiplier = 1;
        const endMultiplier = Math.ceil(maxRadius / interval);
        
        // Limit calculations to prevent performance issues
        const maxCalculations = 1000;
        const actualEndMultiplier = Math.min(endMultiplier, startMultiplier + maxCalculations);
        
        for (let i = startMultiplier; i <= actualEndMultiplier; i++) {
            const r_data = i * interval;
            
            // Check if any tick for this radius will be visible
            let willBeVisible = false;
            
            if (isYAxisOnScreen) {
                const xPos = dataToScreen({ x: r_data, y: 0 }).x;
                const xNegPos = dataToScreen({ x: -r_data, y: 0 }).x;
                if ((xPos >= -C.AXIS_LABEL_PADDING && xPos <= canvasWidth + C.AXIS_LABEL_PADDING) ||
                    (xNegPos >= -C.AXIS_LABEL_PADDING && xNegPos <= canvasWidth + C.AXIS_LABEL_PADDING)) {
                    willBeVisible = true;
                }
            }
            
            if (!willBeVisible && isXAxisOnScreen) {
                const yPos = dataToScreen({ x: 0, y: r_data }).y;
                const yNegPos = dataToScreen({ x: 0, y: -r_data }).y;
                if ((yPos >= -C.AXIS_LABEL_PADDING && yPos <= canvasHeight + C.AXIS_LABEL_PADDING) ||
                    (yNegPos >= -C.AXIS_LABEL_PADDING && yNegPos <= canvasHeight + C.AXIS_LABEL_PADDING)) {
                    willBeVisible = true;
                }
            }
            
            // Only add if it will be visible
            if (willBeVisible) {
                const existing = drawnRadiusPositions.get(r_data);
                if (!existing) {
                    drawnRadiusPositions.set(r_data, { alpha, isCoarser });
                } else if (isCoarser) {
                    drawnRadiusPositions.set(r_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                } else {
                    if (!existing.isCoarser) {
                        drawnRadiusPositions.set(r_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                    }
                }
            }
        }
    };
    
    const interval1IsCoarser = !interval2 || interval1 >= interval2;
    addTicksForInterval(interval1, alpha1, interval1IsCoarser);
    addTicksForInterval(interval2, alpha2, !interval1IsCoarser);
    
    // Draw radius ticks and labels
    drawnRadiusPositions.forEach((tickInfo, r_data) => {
        const effectiveAlpha = tickInfo.isCoarser ? 1.0 : tickInfo.alpha;
        const tickLabelColor = `rgba(${colors.axisTickLabel.join(',')}, ${C.AXIS_TICK_LABEL_ALPHA * effectiveAlpha})`;
        ctx.strokeStyle = tickLabelColor;
        ctx.lineWidth = C.GRID_LINEWIDTH;
        
        // Format the label text
        let labelText;
        if (useScientific) {
            const logValue = Math.log10(Math.abs(r_data));
            const exponent = Math.floor(logValue);
            const intervalInSameScale = primaryInterval / Math.pow(10, exponent);
            const decimalPlacesNeeded = Math.max(0, -Math.floor(Math.log10(intervalInSameScale)) + 1);
            
            const expStr = Math.abs(r_data).toExponential(decimalPlacesNeeded);
            const parts = expStr.split('e');
            let coefficientStr = parts[0];
            coefficientStr = coefficientStr.replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
            let exp = parseInt(parts[1], 10);
            const sign = r_data < 0 ? "-" : "";
            labelText = `${sign}${coefficientStr} \\cdot 10^{${exp}}`;
        } else {
            labelText = r_data.toFixed(decimalPlaces).replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
        }
        
        const stableIdPart = r_data.toExponential(15);

        // Draw ticks on X-axis (only if Y axis is visible)
        if (isYAxisOnScreen) {
            const pX = dataToScreen({ x: r_data, y: 0 });
            if (pX.x > -C.AXIS_LABEL_PADDING && pX.x < canvasWidth + C.AXIS_LABEL_PADDING) {
                ctx.beginPath(); 
                ctx.moveTo(pX.x, origin.y - C.AXIS_TICK_SIZE / 2); 
                ctx.lineTo(pX.x, origin.y + C.AXIS_TICK_SIZE / 2); 
                ctx.stroke();
                updateHtmlLabel({ 
                    id: `polartick-r-x-${stableIdPart}`, 
                    content: labelText, 
                    x: pX.x, 
                    y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'center', textBaseline: 'top' } 
                });
            }
            
            const pNegX = dataToScreen({ x: -r_data, y: 0 });
            if (pNegX.x > -C.AXIS_LABEL_PADDING && pNegX.x < canvasWidth + C.AXIS_LABEL_PADDING) {
                ctx.beginPath(); 
                ctx.moveTo(pNegX.x, origin.y - C.AXIS_TICK_SIZE / 2); 
                ctx.lineTo(pNegX.x, origin.y + C.AXIS_TICK_SIZE / 2); 
                ctx.stroke();
                updateHtmlLabel({ 
                    id: `polartick-r-negx-${stableIdPart}`, 
                    content: labelText, 
                    x: pNegX.x, 
                    y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'center', textBaseline: 'top' } 
                });
            }
        }
        
        // Draw ticks on Y-axis (only if X axis is visible)
        if (isXAxisOnScreen) {
            const pPosY = dataToScreen({ x: 0, y: r_data });
            if (pPosY.y > -C.AXIS_LABEL_PADDING && pPosY.y < canvasHeight + C.AXIS_LABEL_PADDING) {
                ctx.beginPath(); 
                ctx.moveTo(origin.x - C.AXIS_TICK_SIZE / 2, pPosY.y); 
                ctx.lineTo(origin.x + C.AXIS_TICK_SIZE / 2, pPosY.y); 
                ctx.stroke();
                updateHtmlLabel({ 
                    id: `polartick-r-posy-${stableIdPart}`, 
                    content: labelText, 
                    x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET, 
                    y: pPosY.y, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'right', textBaseline: 'middle' } 
                });
            }
            
            const pNegY = dataToScreen({ x: 0, y: -r_data });
            if (pNegY.y > -C.AXIS_LABEL_PADDING && pNegY.y < canvasHeight + C.AXIS_LABEL_PADDING) {
                ctx.beginPath(); 
                ctx.moveTo(origin.x - C.AXIS_TICK_SIZE / 2, pNegY.y); 
                ctx.lineTo(origin.x + C.AXIS_TICK_SIZE / 2, pNegY.y); 
                ctx.stroke();
                updateHtmlLabel({ 
                    id: `polartick-r-negy-${stableIdPart}`, 
                    content: labelText, 
                    x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET, 
                    y: pNegY.y, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'right', textBaseline: 'middle' } 
                });
            }
        }
    });
}

export function drawPolarAxisLines(ctx, htmlOverlay, { canvas, dpr, colors }, dataToScreen, updateHtmlLabel) {
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;
    const origin = dataToScreen({ x: 0, y: 0 });
    
    const drawAxisWithArrows = (x1, y1, x2, y2) => {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        const angle = Math.atan2(y2 - y1, x2 - x1);
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - C.AXIS_ARROW_SIZE * Math.cos(angle - C.AXIS_ARROW_ANGLE_RAD), y2 - C.AXIS_ARROW_SIZE * Math.sin(angle - C.AXIS_ARROW_ANGLE_RAD));
        ctx.lineTo(x2 - C.AXIS_ARROW_SIZE * Math.cos(angle + C.AXIS_ARROW_ANGLE_RAD), y2 - C.AXIS_ARROW_SIZE * Math.sin(angle + C.AXIS_ARROW_ANGLE_RAD));
        ctx.closePath();
        ctx.fill();
    };
    
    ctx.lineWidth = C.GRID_LINEWIDTH;
    
    const posXVisible = canvasWidth > origin.x;
    const negXVisible = 0 < origin.x;
    const posYVisible = 0 < origin.y;
    const negYVisible = canvasHeight > origin.y;
    
    if (posXVisible) {
        drawAxisWithArrows(origin.x, origin.y, canvasWidth, origin.y);
        updateHtmlLabel({ 
            id: 'axis-label-r-posx', 
            content: C.POLAR_RADIUS_SYMBOL, 
            x: canvasWidth - C.AXIS_ARROW_SIZE - C.X_AXIS_LABEL_ARROW_DIST, 
            y: origin.y - C.X_AXIS_LABEL_DISTANCE, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'center', textBaseline: 'bottom' } 
        });
    }
    
    if (negXVisible) {
        drawAxisWithArrows(origin.x, origin.y, 0, origin.y);
        updateHtmlLabel({ 
            id: 'axis-label-r-negx', 
            content: C.POLAR_RADIUS_SYMBOL, 
            x: C.AXIS_ARROW_SIZE + C.X_AXIS_LABEL_ARROW_DIST, 
            y: origin.y - C.X_AXIS_LABEL_DISTANCE, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'center', textBaseline: 'bottom' } 
        });
    }
    
    if (posYVisible) {
        drawAxisWithArrows(origin.x, origin.y, origin.x, 0);
        updateHtmlLabel({ 
            id: 'axis-label-r-posy', 
            content: C.POLAR_RADIUS_SYMBOL, 
            x: origin.x + C.Y_AXIS_LABEL_DISTANCE, 
            y: C.AXIS_ARROW_SIZE + C.Y_AXIS_LABEL_ARROW_DIST, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'left', textBaseline: 'middle' } 
        });
    }
    
    if (negYVisible) {
        drawAxisWithArrows(origin.x, origin.y, origin.x, canvasHeight);
        updateHtmlLabel({ 
            id: 'axis-label-r-negy', 
            content: C.POLAR_RADIUS_SYMBOL, 
            x: origin.x + C.Y_AXIS_LABEL_DISTANCE, 
            y: canvasHeight - C.AXIS_ARROW_SIZE - C.Y_AXIS_LABEL_ARROW_DIST, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'left', textBaseline: 'middle' } 
        });
    }
}

export function drawPolarGrid(ctx, { canvas, dpr, colors, gridAlpha }, origin, maxDataRadius, viewTransform, lastGridState, lastAngularGridState) {
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;
    const transitionRadius = Math.min(canvasWidth, canvasHeight) * C.POLAR_TO_LINE_TRANSITION_RADIUS_FACTOR;

    let minViewRadius, maxViewRadius;
    if (origin.x >= 0 && origin.x <= canvasWidth && origin.y >= 0 && origin.y <= canvasHeight) {
        minViewRadius = 0;
    } else {
        const distances = [
            U.distanceToSegment(origin.x, origin.y, 0, 0, canvasWidth, 0),
            U.distanceToSegment(origin.x, origin.y, canvasWidth, 0, canvasWidth, canvasHeight),
            U.distanceToSegment(origin.x, origin.y, canvasWidth, canvasHeight, 0, canvasHeight),
            U.distanceToSegment(origin.x, origin.y, 0, canvasHeight, 0, 0)
        ];
        minViewRadius = Math.min(...distances);
    }
    
    const corners = [
        { x: 0, y: 0 },
        { x: canvasWidth, y: 0 },
        { x: canvasWidth, y: canvasHeight },
        { x: 0, y: canvasHeight }
    ];
    
    const cornerDistances = corners.map(corner => 
        Math.sqrt((corner.x - origin.x) ** 2 + (corner.y - origin.y) ** 2)
    );
    
    maxViewRadius = Math.max(...cornerDistances);

    const minViewRadiusData = minViewRadius * dpr / viewTransform.scale;
    const maxViewRadiusData = maxViewRadius * dpr / viewTransform.scale;

    const drawPolarCircles = (interval, alpha) => {
        if (!interval || alpha < C.MIN_ALPHA_FOR_DRAWING) return;
        
        const screenSpacing = interval * viewTransform.scale / dpr;
        if (screenSpacing < C.GRID_POLAR_CIRCLE_MIN_SPACING) return;

        ctx.strokeStyle = `rgba(${colors.grid.join(',')}, ${alpha * gridAlpha})`;
        ctx.lineWidth = C.GRID_LINEWIDTH;
        
        const startMultiplier = minViewRadiusData === 0 ? 1 : Math.ceil(minViewRadiusData / interval);
        const endMultiplier = Math.floor(maxViewRadiusData / interval);
        
        for (let i = startMultiplier; i <= endMultiplier; i++) {
            const r = i * interval;
            const screenRadius = r * viewTransform.scale / dpr;
            
            if (screenRadius > transitionRadius) {
                const intersections = [];
                const circle = { center: { x: origin.x, y: origin.y }, radius: screenRadius };
                
                const edges = [
                    { p1: { x: 0, y: 0 }, p2: { x: canvasWidth, y: 0 } },
                    { p1: { x: canvasWidth, y: 0 }, p2: { x: canvasWidth, y: canvasHeight } },
                    { p1: { x: canvasWidth, y: canvasHeight }, p2: { x: 0, y: canvasHeight } },
                    { p1: { x: 0, y: canvasHeight }, p2: { x: 0, y: 0 } }
                ];
                
                edges.forEach(edge => {
                    const edgeIntersections = U.getLineCircleIntersection(edge, circle);
                    edgeIntersections.forEach(point => {
                        if (point.x >= 0 && point.x <= canvasWidth && point.y >= 0 && point.y <= canvasHeight) {
                            intersections.push(point);
                        }
                    });
                });
                
                if (intersections.length >= 2) {
                    let p1 = intersections[0], p2 = intersections[1], maxDistSq = 0;
                    for (let j = 0; j < intersections.length; j++) {
                        for (let k = j + 1; k < intersections.length; k++) {
                            const dSq = (intersections[j].x - intersections[k].x)**2 + (intersections[j].y - intersections[k].y)**2;
                            if (dSq > maxDistSq) {
                                maxDistSq = dSq;
                                p1 = intersections[j];
                                p2 = intersections[k];
                            }
                        }
                    }
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            } else {
                ctx.beginPath();
                ctx.arc(origin.x, origin.y, screenRadius, 0, C.RADIANS_IN_CIRCLE);
                ctx.stroke();
            }
        }
    };

    drawPolarCircles(lastGridState.interval1, lastGridState.alpha1);
    drawPolarCircles(lastGridState.interval2, lastGridState.alpha2);

    if (!lastAngularGridState || !Array.isArray(lastAngularGridState)) {
        return;
    }

    const screenCenter = { x: canvasWidth / 2, y: canvasHeight / 2 };
    const baseRadius = Math.min(canvasWidth, canvasHeight) / 4;
    const panDistance = Math.sqrt((origin.x - screenCenter.x) ** 2 + (origin.y - screenCenter.y) ** 2);
    const spokeReferenceRadius = baseRadius + panDistance;

    if (spokeReferenceRadius < C.REF_CIRCLE_MIN_DISPLAY_RADIUS || !isCircleInView(origin.x, origin.y, spokeReferenceRadius, canvasWidth, canvasHeight)) {
        return;
    }

    const isLineMode = spokeReferenceRadius > transitionRadius;
    let visibleAngleRange = null;

    if (isLineMode) {
        const screenRect = { x: 0, y: 0, w: canvasWidth, h: canvasHeight };
        const circle = { x: origin.x, y: origin.y, r: spokeReferenceRadius };
        const intersections = getCircleRectIntersections(circle, screenRect);

        if (intersections.length >= 2) {
            let p1 = intersections[0], p2 = intersections[1];
            let maxDistSq = 0;
            for (let i = 0; i < intersections.length; i++) {
                for (let j = i + 1; j < intersections.length; j++) {
                    const dSq = (intersections[i].x - intersections[j].x)**2 + (intersections[i].y - intersections[j].y)**2;
                    if (dSq > maxDistSq) {
                        maxDistSq = dSq;
                        p1 = intersections[i];
                        p2 = intersections[j];
                    }
                }
            }
            const angle1 = (Math.atan2(origin.y - p1.y, p1.x - origin.x) * 180 / Math.PI + 360) % 360;
            const angle2 = (Math.atan2(origin.y - p2.y, p2.x - origin.x) * 180 / Math.PI + 360) % 360;
            visibleAngleRange = { minAngle: Math.min(angle1, angle2), maxAngle: Math.max(angle1, angle2), isFullCircle: false };
            if (Math.abs(angle1 - angle2) > 180) {
                visibleAngleRange = { minAngle: Math.max(angle1, angle2), maxAngle: Math.min(angle1, angle2) + 360, isFullCircle: false };
            }
        }
    } else {
        visibleAngleRange = calculateVisibleAngleRange(origin, spokeReferenceRadius, canvasWidth, canvasHeight);
    }
    
    if (!visibleAngleRange) return;

    const drawnAngles = new Set();

    lastAngularGridState.forEach(level => {
        const tickAlpha = level.alpha;
        if (tickAlpha < C.POLAR_REF_TICK_ALPHA_THRESHOLD) return;

        const screenSeparation = spokeReferenceRadius * (level.angle * Math.PI / 180);
        if (screenSeparation < C.REF_CIRCLE_MIN_TICK_SPACING * 0.5) return;

        ctx.strokeStyle = `rgba(${colors.grid.join(',')}, ${tickAlpha * gridAlpha})`;
        ctx.lineWidth = C.GRID_LINEWIDTH * C.POLAR_GRID_SPOKE_WIDTH_FACTOR;

        let anglesToProcess;
        if (visibleAngleRange.isFullCircle) {
            anglesToProcess = [];
            for (let deg = 0; deg < 360; deg += level.angle) {
                anglesToProcess.push(deg);
            }
        } else {
            anglesToProcess = [];
            if (visibleAngleRange.ranges && Array.isArray(visibleAngleRange.ranges)) {
                visibleAngleRange.ranges.forEach(range => {
                    let [minAngle, maxAngle] = range;
                    
                    if (isLineMode) {
                        const corners = [
                            { x: 0, y: 0 },
                            { x: canvasWidth, y: 0 },
                            { x: canvasWidth, y: canvasHeight },
                            { x: 0, y: canvasHeight }
                        ];
                        
                        const cornerAngles = corners.map(corner => {
                            return (Math.atan2(origin.y - corner.y, corner.x - origin.x) * 180 / Math.PI + 360) % 360;
                        });
                        
                        const allAngles = [...cornerAngles, minAngle, maxAngle].sort((a, b) => a - b);
                        const extendedMinAngle = Math.min(...allAngles) - level.angle * 2;
                        const extendedMaxAngle = Math.max(...allAngles) + level.angle * 2;
                        
                        minAngle = extendedMinAngle;
                        maxAngle = extendedMaxAngle;
                    }
                    
                    const rangeAngles = generateOptimizedAngleSequence(level.angle, minAngle, maxAngle);
                    anglesToProcess.push(...rangeAngles);
                });
            } else if (visibleAngleRange.minAngle !== undefined && visibleAngleRange.maxAngle !== undefined) {
                let minAngle = visibleAngleRange.minAngle;
                let maxAngle = visibleAngleRange.maxAngle;
                
                if (isLineMode) {
                    const corners = [
                        { x: 0, y: 0 },
                        { x: canvasWidth, y: 0 },
                        { x: canvasWidth, y: canvasHeight },
                        { x: 0, y: canvasHeight }
                    ];
                    
                    const cornerAngles = corners.map(corner => {
                        return (Math.atan2(origin.y - corner.y, corner.x - origin.x) * 180 / Math.PI + 360) % 360;
                    });
                    
                    const allAngles = [...cornerAngles, minAngle, maxAngle].sort((a, b) => a - b);
                    const extendedMinAngle = Math.min(...allAngles) - level.angle * 2;
                    const extendedMaxAngle = Math.max(...allAngles) + level.angle * 2;
                    
                    minAngle = extendedMinAngle;
                    maxAngle = extendedMaxAngle;
                }
                
                anglesToProcess = generateOptimizedAngleSequence(level.angle, minAngle, maxAngle);
            }
            anglesToProcess = [...new Set(anglesToProcess)];
        }

        anglesToProcess.forEach(deg => {
            deg = Math.round(deg * 1e10) / 1e10;
            if (drawnAngles.has(deg)) return;

            const angleRad = deg * Math.PI / 180;
            
            const tickStart = {
                x: origin.x + (minViewRadiusData * viewTransform.scale / dpr) * Math.cos(angleRad),
                y: origin.y - (minViewRadiusData * viewTransform.scale / dpr) * Math.sin(angleRad)
            };
            const tickEnd = {
                x: origin.x + (maxViewRadiusData * viewTransform.scale / dpr) * Math.cos(angleRad),
                y: origin.y - (maxViewRadiusData * viewTransform.scale / dpr) * Math.sin(angleRad)
            };

            ctx.beginPath();
            ctx.moveTo(tickStart.x, tickStart.y);
            ctx.lineTo(tickEnd.x, tickEnd.y);
            ctx.stroke();
            
            drawnAngles.add(deg);
        });
    });
}

export function drawGrid(ctx, { gridDisplayMode, canvas, dpr, viewTransform, gridAlpha, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState) {
    
    if (gridDisplayMode === C.GRID_DISPLAY_MODE_NONE) return;

    ctx.save();

    const origin = dataToScreen({ x: 0, y: 0 });
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;

    if (gridDisplayMode === C.GRID_DISPLAY_MODE_POLAR) {
        const topLeftData = screenToData({ x: 0, y: 0 });
        const bottomRightData = screenToData({ x: canvasWidth, y: canvasHeight });
        const maxDataRadius = Math.hypot(Math.max(Math.abs(topLeftData.x), Math.abs(bottomRightData.x)), Math.max(Math.abs(topLeftData.y), Math.abs(bottomRightData.y)));

        // Call the new unified polar grid drawing function
        drawPolarGrid(ctx, { canvas, dpr, colors, gridAlpha }, origin, maxDataRadius, viewTransform, lastGridState, lastAngularGridState);

    } else {
        // Rectangular grid modes (lines, points, triangular)
        const drawGridElements = (interval, alpha) => {
            if (!interval || alpha < C.MIN_ALPHA_FOR_DRAWING) return;
            const gridElementColor = `rgba(${colors.grid.join(',')}, ${alpha * gridAlpha})`;

            const start = screenToData({ x: 0, y: canvasHeight });
            const end = screenToData({ x: canvasWidth, y: 0 });
            
            const startMultiplierX = Math.floor(start.x / interval);
            const endMultiplierX = Math.ceil(end.x / interval);
            const startMultiplierY = Math.floor(start.y / interval);
            const endMultiplierY = Math.ceil(end.y / interval);

            if (gridDisplayMode === C.GRID_DISPLAY_MODE_LINES) {
                ctx.strokeStyle = gridElementColor;
                ctx.lineWidth = C.GRID_LINEWIDTH;
                for (let i = startMultiplierX; i <= endMultiplierX; i++) {
                    const x = i * interval;
                    const screenX = dataToScreen({ x: x, y: 0 }).x;
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, canvasHeight);
                    ctx.stroke();
                }
                for (let i = startMultiplierY; i <= endMultiplierY; i++) {
                    const y = i * interval;
                    const screenY = dataToScreen({ x: 0, y: y }).y;
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(canvasWidth, screenY);
                    ctx.stroke();
                }
            } else if (gridDisplayMode === C.GRID_DISPLAY_MODE_POINTS) {
                ctx.fillStyle = gridElementColor;
                const vertexRadius = C.GRID_POINT_RADIUS * dpr;
                for (let i = startMultiplierX; i <= endMultiplierX; i++) {
                    const x = i * interval;
                    for (let j = startMultiplierY; j <= endMultiplierY; j++) {
                        const y = j * interval;
                        const screenPos = dataToScreen({ x: x, y: y });
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, vertexRadius, 0, C.RADIANS_IN_CIRCLE);
                        ctx.fill();
                    }
                }
            } else if (gridDisplayMode === C.GRID_DISPLAY_MODE_TRIANGULAR) {
                ctx.fillStyle = gridElementColor;
                const vertexRadius = C.GRID_POINT_RADIUS * dpr;
                const y_step = interval * C.TRIANGULAR_GRID_Y_STEP_FACTOR;
                
                const startMultiplierY_tri = Math.floor(start.y / y_step);
                const endMultiplierY_tri = Math.ceil(end.y / y_step);
                
                for (let j = startMultiplierY_tri; j <= endMultiplierY_tri; j++) {
                    const y = j * y_step;
                    const rowIndex = j;
                    const x_offset = (rowIndex % 2 !== 0) ? interval / 2 : 0;
                    for (let i = startMultiplierX; i <= endMultiplierX; i++) {
                        const x = i * interval;
                        const finalX = x + x_offset;
                        const screenPos = dataToScreen({ x: finalX, y: y });
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, vertexRadius, 0, C.RADIANS_IN_CIRCLE);
                        ctx.fill();
                    }
                }
            }
        };
        
        drawGridElements(lastGridState.interval1, lastGridState.alpha1);
        drawGridElements(lastGridState.interval2, lastGridState.alpha2);
    }
    
    ctx.restore();
}

export function drawAngleArc(ctx, centerScreen, dataStartAngleRad, dataEndAngleRad, radius, color, isDashed = false) {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = C.GRID_LINEWIDTH;
    ctx.setLineDash(isDashed ? C.DASH_PATTERN_SMALL : []);
    const canvasStartAngle = -dataStartAngleRad;
    const canvasEndAngle = -dataEndAngleRad;
    let signedAngleDiffData = U.normalizeAngleToPi(dataEndAngleRad - dataStartAngleRad);
    ctx.beginPath();
    ctx.arc(centerScreen.x, centerScreen.y, radius, canvasStartAngle, canvasEndAngle, signedAngleDiffData > 0);
    ctx.stroke();
    ctx.restore();
}

export function drawVertex(ctx, vertex, { selectedVertexIds, selectedCenterIds, activeCenterId, colors, verticesVisible = true, isHovered = false, isSnapped = false }, dataToScreen, updateHtmlLabel) {
    let isSelected;
    if (vertex.type === C.VERTEX_TYPE_REGULAR) {
        isSelected = selectedVertexIds.includes(vertex.id);
        
        if (!verticesVisible && !isSelected && !isHovered && !isSnapped) {
            return;
        }
    } else {
        isSelected = selectedCenterIds.includes(vertex.id);
    }

    const screenPos = dataToScreen(vertex);

    switch (vertex.type) {
        case C.VERTEX_TYPE_REGULAR:
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, C.VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            ctx.fillStyle = isSnapped ? colors.feedbackSnapped : (vertex.color || colors.vertex);
            ctx.fill();
            break;
        case C.TRANSFORMATION_TYPE_ROTATION:
        case C.TRANSFORMATION_TYPE_SCALE:
        case C.TRANSFORMATION_TYPE_ROTATE_SCALE:
        case C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE:
            const onCanvasIconSize = C.CENTER_POINT_VISUAL_RADIUS * 2;
            const icon = {
                type: vertex.type,
                x: screenPos.x - onCanvasIconSize / 2,
                y: screenPos.y - onCanvasIconSize / 2,
                width: onCanvasIconSize,
                height: onCanvasIconSize
            };
            drawUITransformationSymbols(ctx, icon, colors);
            break;
    }

    const shouldGlow = isSelected || isHovered || isSnapped;
    if (shouldGlow) {
        ctx.save();
        
        let glowColor = colors.selectionGlow;
        if (isSnapped) {
            glowColor = colors.feedbackSnapped;
        } else if (vertex.id === activeCenterId) {
            glowColor = colors.activeCenterGlow;
        }

        ctx.shadowColor = glowColor;
        ctx.shadowBlur = C.SELECTION_GLOW_BLUR_RADIUS;
        ctx.globalAlpha = C.SELECTION_GLOW_ALPHA;

        ctx.beginPath();
        let glowRadius;
        if (vertex.type === C.VERTEX_TYPE_REGULAR) {
            glowRadius = C.VERTEX_RADIUS + C.SELECTION_GLOW_RADIUS_OFFSET;
        } else {
            glowRadius = C.CENTER_POINT_VISUAL_RADIUS + C.SELECTION_GLOW_RADIUS_OFFSET;
        }
        ctx.arc(screenPos.x, screenPos.y, glowRadius, 0, C.RADIANS_IN_CIRCLE);
        ctx.strokeStyle = glowColor;
        ctx.lineWidth = C.SELECTION_GLOW_LINE_WIDTH;
        ctx.stroke();

        ctx.restore();
    }
}

function drawFractionalSnapLabels(ctx, { info, colors, idPrefix, startVertexScreen }, dataToScreen, findVertexById, updateHtmlLabel) {
    if (!info || !info.edge) return;

    const { edge, fraction, snapPoint } = info;
    const p1 = findVertexById(edge.id1);
    const p2 = findVertexById(edge.id2);
    if (!p1 || !p2) return;

    const p1Screen = dataToScreen(p1);
    const p2Screen = dataToScreen(p2);
    const snapPointScreen = dataToScreen(snapPoint);
    const color = colors.feedbackSnapped;

    const perpVec = U.normalize({ x: -(p2Screen.y - p1Screen.y), y: p2Screen.x - p1Screen.x });
    
    let offsetMultiplier = 1;
    if (startVertexScreen) { // This logic is specific to draw mode to place the label on the correct side
        const side = (p2Screen.x - p1Screen.x) * (startVertexScreen.y - p1Screen.y) - (p2Screen.y - p1Screen.y) * (startVertexScreen.x - p1Screen.x);
        offsetMultiplier = side > 0 ? -1 : 1;
    }

    const offset = C.COORD_SYSTEM_EDGE_FRACTION_LABEL_OFFSET;

    const mid1 = { x: (p1Screen.x + snapPointScreen.x) / 2, y: (p1Screen.y + snapPointScreen.y) / 2 };
    const labelPos1 = { x: mid1.x + offsetMultiplier * perpVec.x * offset, y: mid1.y + offsetMultiplier * perpVec.y * offset };
    const text1 = U.formatFraction(fraction, 0.001, 8);

    updateHtmlLabel({
        id: `${idPrefix}-1`,
        content: text1,
        x: labelPos1.x,
        y: labelPos1.y,
        color: color,
        fontSize: C.FRACTION_LABEL_FONT_SIZE,
        options: { textAlign: 'center', textBaseline: 'middle' }
    });

    const mid2 = { x: (snapPointScreen.x + p2Screen.x) / 2, y: (snapPointScreen.y + p2Screen.y) / 2 };
    const labelPos2 = { x: mid2.x + offsetMultiplier * perpVec.x * offset, y: mid2.y + offsetMultiplier * perpVec.y * offset };
    const text2 = U.formatFraction(1 - fraction, 0.001, 8);

    updateHtmlLabel({
        id: `${idPrefix}-2`,
        content: text2,
        x: labelPos2.x,
        y: labelPos2.y,
        color: color,
        fontSize: C.FRACTION_LABEL_FONT_SIZE,
        options: { textAlign: 'center', textBaseline: 'middle' }
    });
}



export function drawAltHoverIndicator(ctx, { altHoverInfo, colors }, dataToScreen, findVertexById, updateHtmlLabel) {
    if (!altHoverInfo) return;

    const { point, element, shiftKey, fraction } = altHoverInfo;
    const screenPos = dataToScreen(point);

    const fillColor = shiftKey ? colors.feedbackSnapped : colors.vertex;
    const glowColor = shiftKey ? colors.feedbackSnapped : colors.vertex;

    // Draw the glow
    ctx.save();
    ctx.shadowColor = glowColor;
    ctx.shadowBlur = C.SELECTION_GLOW_BLUR_RADIUS;
    ctx.globalAlpha = C.SELECTION_GLOW_ALPHA;
    ctx.beginPath();
    const glowRadius = C.VERTEX_RADIUS + C.SELECTION_GLOW_RADIUS_OFFSET;
    ctx.arc(screenPos.x, screenPos.y, glowRadius, 0, C.RADIANS_IN_CIRCLE);
    ctx.strokeStyle = glowColor;
    ctx.lineWidth = C.SELECTION_GLOW_LINE_WIDTH;
    ctx.stroke();
    ctx.restore();

    // Draw the main point
    ctx.save();
    ctx.beginPath();
    ctx.arc(screenPos.x, screenPos.y, C.VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.restore();

    if (element.type === 'edge' && shiftKey) {
        drawAltHoverSnapLabels(ctx, { info: { edge: element.edge, fraction, snapPoint: point }, colors }, dataToScreen, findVertexById, updateHtmlLabel);
    }
}

export function drawAllEdges(ctx, { allEdges, selectedEdgeIds, isDragConfirmed, dragPreviewVertices, colors, edgesVisible, snappedEdgeIds }, dataToScreen, findVertexById, getEdgeId) {
    ctx.lineWidth = C.LINE_WIDTH;
    allEdges.forEach(edge => {
        const p1_orig = findVertexById(edge.id1);
        const p2_orig = findVertexById(edge.id2);
        if (!p1_orig || !p2_orig || p1_orig.type !== C.VERTEX_TYPE_REGULAR || p2_orig.type !== C.VERTEX_TYPE_REGULAR) return;

        const edgeId = getEdgeId(edge);
        const isSelected = selectedEdgeIds.includes(edgeId);
        const isSnapped = snappedEdgeIds && snappedEdgeIds.has(edgeId) && (snappedEdgeIds.get(edgeId).has(undefined) || snappedEdgeIds.get(edgeId).has(0));

        if (!edgesVisible && !isSelected && !isSnapped) return;

        let p1_render = { ...p1_orig };
        let p2_render = { ...p2_orig };
        let shouldBeDashed = false;

        if (isDragConfirmed && dragPreviewVertices.length > 0) {
            const p1Preview = dragPreviewVertices.find(dp => dp.id === p1_orig.id);
            const p2Preview = dragPreviewVertices.find(dp => dp.id === p2_orig.id);
            
            const p1BeingDragged = !!p1Preview;
            const p2BeingDragged = !!p2Preview;
            shouldBeDashed = p1BeingDragged !== p2BeingDragged;
            
            if (p1Preview) { p1_render.x = p1Preview.x; p1_render.y = p1Preview.y; }
            if (p2Preview) { p2_render.x = p2Preview.x; p2_render.y = p2Preview.y; }
        }

        const p1Screen = dataToScreen(p1_render);
        const p2Screen = dataToScreen(p2_render);

        ctx.beginPath();
        ctx.moveTo(p1Screen.x, p1Screen.y);
        ctx.lineTo(p2Screen.x, p2Screen.y);

        if (edge.colormapItem) {
            const gradient = ctx.createLinearGradient(p1Screen.x, p1Screen.y, p2Screen.x, p2Screen.y);
            const startColor = U.sampleColormap(edge.colormapItem, edge.gradientStart);
            const endColor = U.sampleColormap(edge.colormapItem, edge.gradientEnd);
            gradient.addColorStop(0, startColor);
            gradient.addColorStop(1, endColor);
            ctx.strokeStyle = gradient;
        } else {
            ctx.strokeStyle = edge.color || colors.defaultStroke;
        }

        ctx.setLineDash(shouldBeDashed ? C.DASH_PATTERN : []);
        ctx.lineWidth = C.LINE_WIDTH;
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw selection/snap highlights
        if (isSelected || isSnapped) {
            ctx.beginPath();
            ctx.moveTo(p1Screen.x, p1Screen.y);
            ctx.lineTo(p2Screen.x, p2Screen.y);
            ctx.strokeStyle = isSnapped ? colors.feedbackSnapped : colors.selectionGlow;
            ctx.globalAlpha = C.SELECTION_GLOW_ALPHA;
            ctx.lineWidth = C.LINE_WIDTH + C.EDGE_SELECTION_GLOW_WIDTH_OFFSET;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }
    });
    ctx.setLineDash([]);
    ctx.strokeStyle = colors.defaultStroke;
}

function drawAltHoverSnapLabels(ctx, { info, colors }, dataToScreen, findVertexById, updateHtmlLabel) {
    drawFractionalSnapLabels(ctx, { info, colors, idPrefix: 'alt-snap-label' }, dataToScreen, findVertexById, updateHtmlLabel);
}

export function drawDrawingSnapLabels(ctx, { info, colors }, dataToScreen, findVertexById, updateHtmlLabel) {
    if (!info || !info.startVertex) return;
    const startVertexScreen = dataToScreen(info.startVertex);
    drawFractionalSnapLabels(ctx, { info, colors, idPrefix: 'snap-label', startVertexScreen }, dataToScreen, findVertexById, updateHtmlLabel);
}

function drawRotationIndicator(ctx, { transformIndicatorData, colors, currentShiftPressed }, dataToScreen) {
    const { center, startPos, currentPos, rotation, isSnapping, snapType } = transformIndicatorData;
    const color = isSnapping ? colors.feedbackSnapped : `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;
    const centerScreen = dataToScreen(center);
    const startScreen = dataToScreen(startPos);
    const currentScreen = dataToScreen(currentPos); // The "cursor"

    ctx.save();
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
    ctx.strokeStyle = color;

    // Helper 1: Dashed line from center to the original handle position.
    ctx.setLineDash(C.DASH_PATTERN);
    ctx.beginPath();
    ctx.moveTo(centerScreen.x, centerScreen.y);
    ctx.lineTo(startScreen.x, startScreen.y);
    ctx.stroke();

    const shouldDrawProjectionHelper = !currentShiftPressed || (currentShiftPressed && snapType === 'projection');
    if (shouldDrawProjectionHelper) {
        // This is the "target" point, the end of the pure rotation arc.
        const rotatedHandlePos = U.applyTransformToVertex(startPos, center, rotation, 1.0);
        const rotatedHandleScreen = dataToScreen(rotatedHandlePos);


        ctx.beginPath();
        ctx.moveTo(rotatedHandleScreen.x, rotatedHandleScreen.y);
        ctx.lineTo(currentScreen.x, currentScreen.y);
        ctx.stroke();
    }
    
    // Path: The solid arc representing the pure rotation.
    if (Math.abs(rotation) > C.MIN_TRANSFORM_ACTION_THRESHOLD) {
        ctx.setLineDash([]);
        const arcRadius = U.distance(centerScreen, startScreen);
        const startAngleScreen = Math.atan2(startScreen.y - centerScreen.y, startScreen.x - centerScreen.x);
        const screenRotation = -rotation;
        const anticlockwise = rotation > 0;
        ctx.beginPath();
        ctx.arc(centerScreen.x, centerScreen.y, arcRadius, startAngleScreen, startAngleScreen + screenRotation, anticlockwise);
        ctx.stroke();
    }
    ctx.restore();
}

function drawScaleIndicator(ctx, { transformIndicatorData, colors, currentShiftPressed }, dataToScreen) {
    const { center, startPos, scale, isSnapping, snapType, currentPos } = transformIndicatorData;
    const color = isSnapping ? colors.feedbackSnapped : `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;
    const centerScreen = dataToScreen(center);
    const startScreen = dataToScreen(startPos);
    const currentScreen = dataToScreen(currentPos);

    ctx.save();
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
    ctx.strokeStyle = color;

    ctx.setLineDash(C.DASH_PATTERN);
    ctx.beginPath();
    ctx.moveTo(centerScreen.x, centerScreen.y);
    ctx.lineTo(startScreen.x, startScreen.y);
    ctx.stroke();

    const shouldDrawProjectionHelper = !currentShiftPressed;
    if (shouldDrawProjectionHelper) {
        const arcRadius = U.distance(centerScreen, currentScreen);
        const handleAngle = Math.atan2(startScreen.y - centerScreen.y, startScreen.x - centerScreen.x);
        const cursorAngle = Math.atan2(currentScreen.y - centerScreen.y, currentScreen.x - centerScreen.x);

        // --- THIS IS THE FIX ---
        // Calculate the shortest angular distance to determine the correct direction.
        let angularDifference = cursorAngle - handleAngle;
        if (angularDifference > Math.PI) {
            angularDifference -= 2 * Math.PI;
        } else if (angularDifference < -Math.PI) {
            angularDifference += 2 * Math.PI;
        }

        // Reverse the logic: draw CCW only if the shortest angle is negative.
        const anticlockwise = angularDifference < 0;

        ctx.beginPath();
        ctx.arc(centerScreen.x, centerScreen.y, arcRadius, handleAngle, cursorAngle, anticlockwise);
        ctx.stroke();
        // --- END OF FIX ---
    }

    // Path: Solid line for scaling (always visible)
    const scaledStartPos = { x: center.x + (startPos.x - center.x) * scale, y: center.y + (startPos.y - center.y) * scale };
    const scaledStartScreen = dataToScreen(scaledStartPos);
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(startScreen.x, startScreen.y);
    ctx.lineTo(scaledStartScreen.x, scaledStartScreen.y);
    ctx.stroke();
    
    ctx.restore();
}

function drawDirectionalScaleIndicator(ctx, { transformIndicatorData, colors, currentShiftPressed }, dataToScreen) {
    const { center, startPos, currentPos, scale, startVector, isSnapping, snapType, projectionSource } = transformIndicatorData;
    const color = isSnapping ? colors.feedbackSnapped : `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;
    const centerScreen = dataToScreen(center);
    const startScreen = dataToScreen(startPos);
    const currentScreen = dataToScreen(currentPos);

    ctx.save();
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
    ctx.strokeStyle = color;

    // Helper: Dashed line from center to start (always visible)
    ctx.setLineDash(C.DASH_PATTERN);
    ctx.beginPath();
    ctx.moveTo(centerScreen.x, centerScreen.y);
    ctx.lineTo(startScreen.x, startScreen.y);
    ctx.stroke();

    const scaledStartPos = U.applyTransformToVertex(startPos, center, 0, scale, true, startVector);
    const scaledStartScreen = dataToScreen(scaledStartPos);
    
    // Helper: Dashed cursor projection line (conditionally visible)
    const shouldDrawProjectionHelper = !currentShiftPressed || (currentShiftPressed && snapType === 'projection');
    if (shouldDrawProjectionHelper) {
        ctx.setLineDash(C.DASH_PATTERN);
        ctx.beginPath();
        ctx.moveTo(currentScreen.x, currentScreen.y);
        ctx.lineTo(scaledStartScreen.x, scaledStartScreen.y);
        ctx.stroke();
    }
    
    // Path: Solid scaling line (always visible)
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(startScreen.x, startScreen.y);
    ctx.lineTo(scaledStartScreen.x, scaledStartScreen.y);
    ctx.stroke();
    
    // Helper: Perpendicular line for explicit projection snapping
    if (isSnapping && snapType === 'projection' && projectionSource) {
        const sourceScreen = dataToScreen(projectionSource);
        const axisP1 = center;
        const axisP2 = { x: center.x + startVector.x, y: center.y + startVector.y };
        const projectedSourcePoint = U.getClosestPointOnLine(projectionSource, axisP1, axisP2);
        const projectedSourceScreen = dataToScreen(projectedSourcePoint);
        
        ctx.setLineDash(C.DASH_PATTERN);
        ctx.beginPath();
        ctx.moveTo(sourceScreen.x, sourceScreen.y);
        ctx.lineTo(projectedSourceScreen.x, projectedSourceScreen.y);
        ctx.stroke();
    }
    ctx.restore();
}

function drawRotateScaleIndicator(ctx, { transformIndicatorData, colors }, dataToScreen) {
    const { center, startPos, rotation, scale, isSnapping } = transformIndicatorData;
    const color = isSnapping ? colors.feedbackSnapped : `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;
    const centerScreen = dataToScreen(center);
    const startScreen = dataToScreen(startPos);
    
    ctx.save();
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
    ctx.strokeStyle = color;
    
    // Helper: Dashed line from center to start (always visible)
    ctx.setLineDash(C.DASH_PATTERN);
    ctx.beginPath();
    ctx.moveTo(centerScreen.x, centerScreen.y);
    ctx.lineTo(startScreen.x, startScreen.y);
    ctx.stroke();

    const scaledStartPos = { x: center.x + (startPos.x - center.x) * scale, y: center.y + (startPos.y - center.y) * scale };
    const scaledStartScreen = dataToScreen(scaledStartPos);

    // Path (Scaling): Solid line (always visible)
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(startScreen.x, startScreen.y);
    ctx.lineTo(scaledStartScreen.x, scaledStartScreen.y);
    ctx.stroke();

    // Path (Rotation): Solid arc (always visible)
    if (Math.abs(rotation) > C.MIN_TRANSFORM_ACTION_THRESHOLD) {
        const arcRadius = U.distance(centerScreen, scaledStartScreen);
        const startAngleScreen = Math.atan2(startScreen.y - centerScreen.y, startScreen.x - centerScreen.x);
        const screenRotation = -rotation;
        const anticlockwise = rotation > 0;
        
        ctx.beginPath();
        ctx.arc(centerScreen.x, centerScreen.y, arcRadius, startAngleScreen, startAngleScreen + screenRotation, anticlockwise);
        ctx.stroke();
    }
    ctx.restore();
}

export function drawTransformIndicators(ctx, htmlOverlay, { transformIndicatorData, colors, coordSystemTransformIndicatorData, currentShiftPressed }, dataToScreen, updateHtmlLabel) {
    if (transformIndicatorData) {
        const { isSnapping, snapType, transformType } = transformIndicatorData;

        ctx.save();
        ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;

        switch (transformType) {
            case C.TRANSFORMATION_TYPE_ROTATE_SCALE:
                drawRotateScaleIndicator(ctx, { transformIndicatorData, colors, currentShiftPressed }, dataToScreen);
                break;
            case C.TRANSFORMATION_TYPE_ROTATION:
                drawRotationIndicator(ctx, { transformIndicatorData, colors, currentShiftPressed }, dataToScreen);
                break;
            case C.TRANSFORMATION_TYPE_SCALE:
                drawScaleIndicator(ctx, { transformIndicatorData, colors, currentShiftPressed }, dataToScreen);
                break;
            case C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE:
                drawDirectionalScaleIndicator(ctx, { transformIndicatorData, colors, currentShiftPressed }, dataToScreen);
                break;
        }
        
        if (isSnapping && snapType === 'projection' && currentShiftPressed) {
            drawProjectionSnapIndicator(ctx, { transformIndicatorData, colors }, dataToScreen);
        }
        
        ctx.restore();

        drawTransformLabels(htmlOverlay, { transformIndicatorData, colors }, dataToScreen, updateHtmlLabel);
    }

    if (coordSystemTransformIndicatorData) {
        drawCoordSystemTransformIndicator(htmlOverlay, { coordSystemTransformIndicatorData, colors }, dataToScreen, updateHtmlLabel);
    }
}

function drawProjectionSnapIndicator(ctx, { transformIndicatorData, colors }, dataToScreen) {
    const { transformType, projectionSource, projectionCenter, projectionPoint, currentPos } = transformIndicatorData;

    if (transformType === C.TRANSFORMATION_TYPE_ROTATE_SCALE) {
        return;
    }

    ctx.setLineDash(C.DASH_PATTERN);
    ctx.strokeStyle = colors.feedbackSnapped;

    if (transformType === C.TRANSFORMATION_TYPE_ROTATION && projectionPoint) {
        const currentScreen = dataToScreen(currentPos);
        const projectionScreen = dataToScreen(projectionPoint);
        const sourceScreen = dataToScreen(projectionSource);
        
        ctx.beginPath();
        ctx.moveTo(sourceScreen.x, sourceScreen.y);
        ctx.lineTo(projectionScreen.x, projectionScreen.y);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(currentScreen.x, currentScreen.y);
        ctx.lineTo(projectionScreen.x, projectionScreen.y);
        ctx.stroke();
    } else if (transformType === C.TRANSFORMATION_TYPE_SCALE && projectionCenter) {
        const projectionCenterScreen = dataToScreen(projectionCenter);
        const projectionSourceScreen = dataToScreen(projectionSource);
        const currentScreen = dataToScreen(currentPos);
        
        const radius = U.distance(projectionCenterScreen, projectionSourceScreen);
        let startAngle = Math.atan2(projectionSourceScreen.y - projectionCenterScreen.y, projectionSourceScreen.x - projectionCenterScreen.x);
        let endAngle = Math.atan2(currentScreen.y - projectionCenterScreen.y, currentScreen.x - projectionCenterScreen.x);
        
        const twoPi = 2 * Math.PI;
        startAngle = (startAngle + twoPi) % twoPi;
        endAngle = (endAngle + twoPi) % twoPi;
        const clockwiseDistance = (endAngle - startAngle + twoPi) % twoPi;
        const counterClockwiseDistance = (startAngle - endAngle + twoPi) % twoPi;
        const anticlockwise = counterClockwiseDistance < clockwiseDistance;
        
        ctx.beginPath();
        ctx.arc(projectionCenterScreen.x, projectionCenterScreen.y, radius, startAngle, endAngle, anticlockwise);
        ctx.stroke();
    }
}

function drawTransformLabels(htmlOverlay, { transformIndicatorData, colors }, dataToScreen, updateHtmlLabel) {
    const { center, startPos, rotation, scale, isSnapping, snapType, snappedScaleValue, transformType } = transformIndicatorData;
    const centerScreen = dataToScreen(center);
    const startScreen = dataToScreen(startPos);
    const color = isSnapping ? colors.feedbackSnapped : `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;

    if ((transformType === C.TRANSFORMATION_TYPE_SCALE || transformType === C.TRANSFORMATION_TYPE_ROTATE_SCALE || transformType === C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE)) {
        let scaleText;
        const effectiveScale = snappedScaleValue !== null ? snappedScaleValue : scale;
        
        const isHighPrecisionSnap = (snapType === 'projection') || (snapType === 'merge' && transformType === C.TRANSFORMATION_TYPE_ROTATE_SCALE);

        if (isHighPrecisionSnap) {
            scaleText = `\\times ${parseFloat(effectiveScale.toFixed(C.TRANSFORM_INDICATOR_PRECISION)).toString()}`;
        } else if (isSnapping && snappedScaleValue !== null) {
            scaleText = `\\times ${U.formatFraction(snappedScaleValue, C.FRACTION_FORMAT_TOLERANCE, C.FRACTION_FORMAT_MAX_DENOMINATOR_TRANSFORM)}`;
        } else {
            scaleText = `\\times ${parseFloat(effectiveScale.toFixed(C.TRANSFORM_INDICATOR_PRECISION)).toString()}`;
        }
        const midX = (centerScreen.x + startScreen.x) / 2;
        const midY = (centerScreen.y + startScreen.y) / 2;
        const lineAngle = Math.atan2(startScreen.y - centerScreen.y, startScreen.x - centerScreen.x);
        const textPerpAngle = lineAngle - Math.PI / 2;
        const scaleTextX = midX + Math.cos(textPerpAngle) * C.TRANSFORM_SCALE_LABEL_OFFSET;
        const scaleTextY = midY + Math.sin(textPerpAngle) * C.TRANSFORM_SCALE_LABEL_OFFSET;
        let rotationDeg = lineAngle * (180 / Math.PI);
        if (rotationDeg > 90 || rotationDeg < -90) rotationDeg += 180;
        updateHtmlLabel({ id: 'transform-scale-indicator', content: scaleText, x: scaleTextX, y: scaleTextY, color: color, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'bottom', rotation: rotationDeg } });
    } else {
        updateHtmlLabel({ id: 'transform-scale-indicator', content: '', x: 0, y: 0, color: color, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: {} });
    }

    if ((transformType === C.TRANSFORMATION_TYPE_ROTATION || transformType === C.TRANSFORMATION_TYPE_ROTATE_SCALE) && Math.abs(rotation) > C.MIN_TRANSFORM_ACTION_THRESHOLD) {
        const angleDeg = rotation * (180 / Math.PI);
        const angleText = `${parseFloat(angleDeg.toFixed(C.TRANSFORM_INDICATOR_PRECISION)).toString()}^{\\circ}`;
        const startVecScreen = { x: startScreen.x - centerScreen.x, y: startScreen.y - centerScreen.y };
        const bisectorAngle = Math.atan2(startVecScreen.y, startVecScreen.x) + (-rotation) / 2;
        const arcRadius = Math.hypot(startVecScreen.x, startVecScreen.y);
        const labelRadius = arcRadius + C.TRANSFORM_ANGLE_LABEL_OFFSET;
        const angleTextX = centerScreen.x + labelRadius * Math.cos(bisectorAngle);
        const angleTextY = centerScreen.y + labelRadius * Math.sin(bisectorAngle);
        let rotationDeg = bisectorAngle * (180 / Math.PI);
        if (rotationDeg > 90 || rotationDeg < -90) rotationDeg += 180;
        updateHtmlLabel({ id: 'transform-angle-indicator', content: angleText, x: angleTextX, y: angleTextY, color: color, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { rotation: rotationDeg } });
    } else {
        updateHtmlLabel({ id: 'transform-angle-indicator', content: '', x: 0, y: 0, color: color, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: {} });
    }
}

function drawCoordSystemTransformIndicator(htmlOverlay, { coordSystemTransformIndicatorData, colors }, dataToScreen, updateHtmlLabel) {
    const { edgeFraction, orthogonalDistanceFraction, v1, v2, snapPosition } = coordSystemTransformIndicatorData;
    let labelText = '';
    let labelPos = { x: 0, y: 0 };
    if (orthogonalDistanceFraction !== undefined) {
        labelText = U.formatFraction(orthogonalDistanceFraction, 0.001, 8);
        const originScreen = dataToScreen(snapPosition.origin);
        const snapScreen = dataToScreen(snapPosition.closest);
        const midX = (originScreen.x + snapScreen.x) / 2;
        const midY = (originScreen.y + snapScreen.y) / 2;
        const angle = Math.atan2(snapScreen.y - originScreen.y, snapScreen.x - originScreen.x);
        labelPos.x = midX + Math.cos(angle + Math.PI/2) * C.COORD_SYSTEM_EDGE_FRACTION_LABEL_OFFSET;
        labelPos.y = midY + Math.sin(angle + Math.PI/2) * C.COORD_SYSTEM_EDGE_FRACTION_LABEL_OFFSET;
    } else if (edgeFraction !== undefined) {
        const v1Screen = dataToScreen(v1);
        const v2Screen = dataToScreen(v2);
        const snapScreen = dataToScreen(snapPosition);
        const edgeAngle = Math.atan2(v2Screen.y - v1Screen.y, v2Screen.x - v1Screen.x);
        const offsetX = Math.cos(edgeAngle + Math.PI/2) * C.COORD_SYSTEM_EDGE_FRACTION_LABEL_OFFSET;
        const offsetY = Math.sin(edgeAngle + Math.PI/2) * C.COORD_SYSTEM_EDGE_FRACTION_LABEL_OFFSET;
        labelPos.x = snapScreen.x + offsetX;
        labelPos.y = snapScreen.y + offsetY;
        labelText = U.formatFraction(edgeFraction, 0.001, 8);
    }
    if (labelText) {
         updateHtmlLabel({ 
            id: 'coord-system-edge-fraction', 
            content: labelText, 
            x: labelPos.x, 
            y: labelPos.y, 
            color: colors.feedbackSnapped, 
            fontSize: C.FRACTION_LABEL_FONT_SIZE, 
            options: { textAlign: 'center', textBaseline: 'middle' } 
        });
    }
}

export function drawReferenceElementsGeometry(ctx, context, dataToScreen, screenToData, { showAngles, showDistances, viewTransform, mousePos, colors }) {
    if ((!showAngles && !showDistances) || !context.frozen_Origin_Data_to_display) return;
    
    const startVertexData = context.frozen_Origin_Data_to_display;
    const mouseDataPos = screenToData(mousePos);
    const previewDistance = U.distance(startVertexData, mouseDataPos);
    
    if (previewDistance < C.GEOMETRY_CALCULATION_EPSILON) return;

    const refElementColor = colors.frozenReference;

    const turnAngleData = context.displayAngleA_valueRad_for_A_equals_label;
    const baseAngleData = context.frozen_A_baseRad_to_display !== null ? context.frozen_A_baseRad_to_display : 0;
    const distanceData = context.frozen_D_du_to_display;

    if (!startVertexData) return;

    const frozenOriginScreen = dataToScreen(startVertexData);
    const absoluteAngleForRefLine = baseAngleData + turnAngleData;

    ctx.save();
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
    ctx.strokeStyle = refElementColor;

    if (showAngles && context.displayAngleA_valueRad_for_A_equals_label !== null && Math.abs(context.displayAngleA_valueRad_for_A_equals_label) > C.GEOMETRY_CALCULATION_EPSILON) {
        const effectiveRadiusForLine = C.FEEDBACK_ARC_RADIUS_SCREEN + ctx.lineWidth / 2;

        const dottedLineEndVertexData = {
            x: startVertexData.x + Math.cos(baseAngleData) * (effectiveRadiusForLine / viewTransform.scale),
            y: startVertexData.y + Math.sin(baseAngleData) * (effectiveRadiusForLine / viewTransform.scale)
        };
        const dottedLineEndVertexScreen = dataToScreen(dottedLineEndVertexData);

        ctx.beginPath();
        ctx.moveTo(frozenOriginScreen.x, frozenOriginScreen.y);
        ctx.lineTo(dottedLineEndVertexScreen.x, dottedLineEndVertexScreen.y);
        ctx.setLineDash(C.REF_LINE_DASH_PATTERN);
        ctx.stroke();

        drawAngleArc(ctx, frozenOriginScreen, baseAngleData, absoluteAngleForRefLine, C.FEEDBACK_ARC_RADIUS_SCREEN, refElementColor, false);
    }
    ctx.restore();
}

export function prepareSnapInfoTexts(ctx, htmlOverlay, startVertexData, targetDataPos, snappedOutput, { showDistances, showAngles, currentShiftPressed, distanceSigFigs, angleSigFigs, angleDisplayMode, viewTransform, frozenReference_D_du, gridDisplayMode, frozenReference_A_rad, colors }, dataToScreen, drawingContext, updateHtmlLabel) {
    if ((!showAngles && !showDistances) || snappedOutput.distance < C.GEOMETRY_CALCULATION_EPSILON) {
        return;
    }

    const startScreen = dataToScreen(startVertexData);
    const { angle: snappedAbsoluteAngleDeg, distance: snappedDistanceData, lengthSnapFactor, angleSnapFactor, angleTurn, gridToGridSquaredSum, gridInterval } = snappedOutput;
    const { offsetAngleRad, isFirstSegmentBeingDrawn } = drawingContext;
    const currentElementColor = currentShiftPressed ? colors.feedbackSnapped : colors.geometryInfoText;
    const currentLineAbsoluteAngle = Math.atan2(targetDataPos.y - startVertexData.y, targetDataPos.x - startVertexData.x);

    if (snappedDistanceData * viewTransform.scale / window.devicePixelRatio < C.VERTEX_RADIUS) {
        return;
    }

    const isAngleFeedbackActive = showAngles && snappedDistanceData > C.GEOMETRY_CALCULATION_EPSILON && Math.abs(angleTurn) > C.GEOMETRY_CALCULATION_EPSILON;

    if (showDistances) {
        let distanceText = '';

        if (currentShiftPressed && !isFirstSegmentBeingDrawn && frozenReference_D_du !== null) {
            const currentExactDistance = snappedDistanceData;

            if (gridToGridSquaredSum !== null && gridInterval) {
                const actualGridDistance = gridInterval * Math.sqrt(gridToGridSquaredSum);
                if (Math.abs(actualGridDistance - frozenReference_D_du) < C.GEOMETRY_CALCULATION_EPSILON) {
                    distanceText = C.DELTA_SYMBOL_KATEX;
                } else {
                    let foundFraction = false;
                    for (const factor of C.SNAP_FACTORS) {
                        if (Math.abs(currentExactDistance / frozenReference_D_du - factor) < C.GEOMETRY_CALCULATION_EPSILON) {
                            distanceText = U.formatSnapFactor(factor, 'D');
                            foundFraction = true;
                            break;
                        }
                    }
                    if (!foundFraction) {
                        const [coeff, radicand] = U.simplifySquareRoot(gridToGridSquaredSum);
                        const finalCoeff = gridInterval * coeff;
                        const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                        distanceText = U.formatSimplifiedRoot(roundedFinalCoeff, radicand);
                    }
                }
            } else if (frozenReference_D_du > C.GEOMETRY_CALCULATION_EPSILON) {
                const ratio = currentExactDistance / frozenReference_D_du;
                let foundFraction = false;
                for (const factor of C.SNAP_FACTORS) {
                    if (Math.abs(ratio - factor) < C.GEOMETRY_CALCULATION_EPSILON) {
                        distanceText = U.formatSnapFactor(factor, 'D');
                        foundFraction = true;
                        break;
                    }
                }
                if (!foundFraction) {
                    distanceText = U.formatNumber(snappedDistanceData, distanceSigFigs);
                }
            } else {
                distanceText = U.formatNumber(snappedDistanceData, distanceSigFigs);
            }
        } else if (currentShiftPressed && isFirstSegmentBeingDrawn && gridDisplayMode !== C.GRID_DISPLAY_MODE_NONE && gridInterval) {
            if (gridToGridSquaredSum !== null && gridInterval) {
                if (gridToGridSquaredSum >= 0) {
                    const [coeff, radicand] = U.simplifySquareRoot(gridToGridSquaredSum);
                    const finalCoeff = gridInterval * coeff;
                    const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                    distanceText = U.formatSimplifiedRoot(roundedFinalCoeff, radicand);
                }
            } else {
                distanceText = U.formatNumber(snappedDistanceData, distanceSigFigs);
            }
        } else {
            distanceText = U.formatNumber(snappedDistanceData, distanceSigFigs);
        }

        if (distanceText) {
            const startScreenPos = dataToScreen(startVertexData);
            const endScreenPos = dataToScreen(targetDataPos);
            const edgeAngleScreen = Math.atan2(endScreenPos.y - startScreenPos.y, endScreenPos.x - startScreenPos.x);
            const midX = (startScreenPos.x + endScreenPos.x) / 2;
            const midY = (startScreenPos.y + endScreenPos.y) / 2;

            let textPerpAngle;

            if (isAngleFeedbackActive) {
                if (angleTurn > C.GEOMETRY_CALCULATION_EPSILON) {
                    textPerpAngle = edgeAngleScreen - Math.PI / 2;
                } else if (angleTurn < -C.GEOMETRY_CALCULATION_EPSILON) {
                    textPerpAngle = edgeAngleScreen + Math.PI / 2;
                } else {
                    textPerpAngle = edgeAngleScreen - Math.PI / 2;
                }
            } else {
                if (Math.abs(Math.sin(edgeAngleScreen)) < C.VERTICAL_LINE_COS_THRESHOLD) {
                    textPerpAngle = edgeAngleScreen - Math.PI / 2;
                } else if (Math.abs(Math.cos(edgeAngleScreen)) < C.VERTICAL_LINE_COS_THRESHOLD) {
                    textPerpAngle = edgeAngleScreen;
                    if (Math.sin(edgeAngleScreen) < 0) {
                        textPerpAngle += Math.PI / 2;
                    } else {
                        textPerpAngle -= Math.PI / 2;
                    }
                } else {
                    textPerpAngle = edgeAngleScreen - Math.PI / 2;
                    if (Math.sin(textPerpAngle) > 0) {
                        textPerpAngle += Math.PI;
                    }
                }
            }
            
            const distanceTextX = midX + Math.cos(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
            const distanceTextY = midY + Math.sin(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
            let rotationDeg = edgeAngleScreen * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
            if (rotationDeg > C.DEGREES_IN_QUADRANT || rotationDeg < -C.DEGREES_IN_QUADRANT) {
                rotationDeg += C.DEGREES_IN_HALF_CIRCLE;
            }
            updateHtmlLabel({ id: 'snap-dist', content: distanceText, x: distanceTextX, y: distanceTextY, color: currentElementColor, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: {  rotation: rotationDeg } }, htmlOverlay);
        }
    }

    if (isAngleFeedbackActive) {
        const baseAngleForArc = isFirstSegmentBeingDrawn ? 0 : offsetAngleRad;

        drawAngleArc(ctx, startScreen, baseAngleForArc, currentLineAbsoluteAngle, C.FEEDBACK_ARC_RADIUS_SCREEN, currentElementColor);

        ctx.save();
        ctx.beginPath();
        const effectiveRadiusForLine = C.FEEDBACK_ARC_RADIUS_SCREEN + ctx.lineWidth / 2;
        const baseLineEndData = {
            x: startVertexData.x + (effectiveRadiusForLine / viewTransform.scale) * Math.cos(baseAngleForArc),
            y: startVertexData.y + (effectiveRadiusForLine / viewTransform.scale) * Math.sin(baseAngleForArc)
        };
        const baseLineEndScreen = dataToScreen(baseLineEndData);
        ctx.moveTo(startScreen.x, startScreen.y);
        ctx.lineTo(baseLineEndScreen.x, baseLineEndScreen.y);
        ctx.strokeStyle = currentElementColor;
        ctx.setLineDash(C.HELPER_LINE_DASH_PATTERN);
        ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
        ctx.stroke();
        ctx.restore();

        let angleText = '';
        const canReferToTheta = !isFirstSegmentBeingDrawn && frozenReference_A_rad !== null && Math.abs(frozenReference_A_rad) > C.GEOMETRY_CALCULATION_EPSILON;

        if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
            if (currentShiftPressed && canReferToTheta) {
                const referenceAngleRad = Math.abs(drawingContext.currentSegmentReferenceA_for_display);
                let potentialFactor = null;

                if (typeof angleSnapFactor === 'number') {
                    potentialFactor = angleSnapFactor;
                } else if (angleTurn !== null) {
                    if (Math.abs(referenceAngleRad) > C.GEOMETRY_CALCULATION_EPSILON) {
                        const calculatedFactor = angleTurn / referenceAngleRad;
                        for (const frac of C.NINETY_DEG_ANGLE_SNAP_FRACTIONS) {
                            if (Math.abs(Math.abs(calculatedFactor) - frac) < C.GEOMETRY_CALCULATION_EPSILON) {
                                potentialFactor = calculatedFactor < 0 ? -frac : frac;
                                break;
                            }
                        }
                    }
                }
                if (potentialFactor !== null && Math.abs(potentialFactor) > C.GEOMETRY_CALCULATION_EPSILON) {
                    angleText = U.formatSnapFactor(potentialFactor, 'A');
                } else {
                    let degrees = angleTurn * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
                    if (Math.abs(degrees) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = `${U.formatNumber(degrees, angleSigFigs)}^{\\circ}`;
                    }
                }
            } else {
                let angleToFormatRad = isFirstSegmentBeingDrawn ? currentLineAbsoluteAngle : angleTurn;
                if (currentShiftPressed && !isFirstSegmentBeingDrawn) {
                    let angleToFormatDeg = angleToFormatRad * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
                    if (Math.abs(angleToFormatDeg) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = `${U.formatNumber(angleToFormatDeg, angleSigFigs)}^{\\circ}`;
                    }
                } else {
                    let angleToFormatDeg = U.normalizeAngleToPi(angleToFormatRad) * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
                    if (Math.abs(angleToFormatDeg) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = `${U.formatNumber(angleToFormatDeg, angleSigFigs)}^{\\circ}`;
                    }
                }
            }
        } else if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_RADIANS) {
            if (currentShiftPressed && canReferToTheta) {
                const referenceAngleRad = Math.abs(drawingContext.currentSegmentReferenceA_for_display);
                let potentialFactor = null;

                if (typeof angleSnapFactor === 'number') {
                    potentialFactor = angleSnapFactor;
                } else if (angleTurn !== null) {
                    if (Math.abs(referenceAngleRad) > C.GEOMETRY_CALCULATION_EPSILON) {
                        const calculatedFactor = angleTurn / referenceAngleRad;
                        for (const frac of C.NINETY_DEG_ANGLE_SNAP_FRACTIONS) {
                            if (Math.abs(Math.abs(calculatedFactor) - frac) < C.GEOMETRY_CALCULATION_EPSILON) {
                                potentialFactor = calculatedFactor < 0 ? -frac : frac;
                                break;
                            }
                        }
                    }
                }
                if (potentialFactor !== null && Math.abs(potentialFactor) > C.GEOMETRY_CALCULATION_EPSILON) {
                    const fracStr = U.formatSnapFactor(potentialFactor, null);
                    angleText = `${fracStr === '0' ? '0' : fracStr + C.PI_SYMBOL_KATEX}`;
                    if (angleText.startsWith(`1${C.PI_SYMBOL_KATEX}`)) angleText = C.PI_SYMBOL_KATEX;
                    if (angleText.startsWith(`-1${C.PI_SYMBOL_KATEX}`)) angleText = `-${C.PI_SYMBOL_KATEX}`;
                    if (angleText === `0${C.PI_SYMBOL_KATEX}`) angleText = "0";
                } else {
                    let radians = angleTurn;
                    if (Math.abs(radians) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = U.formatNumber(radians, angleSigFigs);
                    }
                }
            } else {
                let angleToFormatRad = isFirstSegmentBeingDrawn ? currentLineAbsoluteAngle : angleTurn;
                if (currentShiftPressed && !isFirstSegmentBeingDrawn) {
                    let radians = angleToFormatRad;
                    if (Math.abs(radians) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = U.formatNumber(radians, angleSigFigs);
                    }
                } else {
                    let radians = U.normalizeAngleToPi(angleToFormatRad);
                    if (Math.abs(radians) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = U.formatNumber(radians, angleSigFigs);
                    }
                }
            }
        }

        if (angleText) {
    const canvasStartAngle = -baseAngleForArc;
    const canvasEndAngle = -currentLineAbsoluteAngle;
    const sumCos = Math.cos(canvasStartAngle) + Math.cos(canvasEndAngle);
    const sumSin = Math.sin(canvasStartAngle) + Math.sin(canvasEndAngle);
    const bisectorCanvasAngle = Math.atan2(sumSin, sumCos);
    
    const offset = C.UI_ANGLE_LABEL_OFFSET;
    let rotationDeg = bisectorCanvasAngle * (180 / Math.PI);
    let horizontalShift = offset;

    if (rotationDeg > 90 || rotationDeg < -90) {
        horizontalShift = -offset;
        rotationDeg += 180;
    }

    const rotatedPoint = {
        x: horizontalShift * Math.cos(bisectorCanvasAngle),
        y: horizontalShift * Math.sin(bisectorCanvasAngle)
    };

    const labelScreenPos = {
        x: startScreen.x + rotatedPoint.x,
        y: startScreen.y + rotatedPoint.y
    };

    updateHtmlLabel({ id: 'snap-angle', content: angleText, x: labelScreenPos.x, y: labelScreenPos.y, color: currentElementColor, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { rotation: rotationDeg } }, htmlOverlay);
}
    }
}

export function prepareReferenceElementsTexts(htmlOverlay, context, { showAngles, showDistances, viewTransform, mousePos, frozenReference_D_du, distanceSigFigs, angleSigFigs, angleDisplayMode, colors }, screenToData, dataToScreen, updateHtmlLabel) {
    const dataThreshold = C.REF_TEXT_SCREEN_PIXEL_THRESHOLD / viewTransform.scale;

    let previewDistance = -1;
    if (context.frozen_Origin_Data_to_display) {
        const startVertexData = context.frozen_Origin_Data_to_display;
        const mouseDataPos = screenToData(mousePos);
        previewDistance = U.distance(startVertexData, mouseDataPos);
    }

    if ((!showAngles && !showDistances) || !context.frozen_Origin_Data_to_display || previewDistance < dataThreshold) {
        return;
    }

    const refElementColor = colors.frozenReference;

    const startVertexData = context.frozen_Origin_Data_to_display;
    const turnAngleData = context.displayAngleA_valueRad_for_A_equals_label;
    const baseAngleData = context.frozen_A_baseRad_to_display !== null ? context.frozen_A_baseRad_to_display : 0;
    const distanceData = context.frozen_D_du_to_display;
    const frozenG2GSquaredSum = context.frozen_D_g2g_to_display ? context.frozen_D_g2g_to_display.g2gSquaredSum : null;
    const frozenG2GInterval = context.frozen_D_g2g_to_display ? context.frozen_D_g2g_to_display.interval : null;

    if (!startVertexData) {
        return;
    }

    const absoluteAngleForRefLine = baseAngleData + turnAngleData;
    const endVertexData = {
        x: startVertexData.x + distanceData * Math.cos(absoluteAngleForRefLine),
        y: startVertexData.y + distanceData * Math.sin(absoluteAngleForRefLine)
    };

    const startVertexScreen = dataToScreen(startVertexData);
    const endVertexScreen = dataToScreen(endVertexData);

    if (showDistances && distanceData !== null && distanceData > dataThreshold) {
        let distanceText = '';

        if (frozenG2GSquaredSum !== null && frozenG2GSquaredSum > 0 && frozenG2GInterval) {
            const [coeff, radicand] = U.simplifySquareRoot(frozenG2GSquaredSum);
            const finalCoeff = frozenG2GInterval * coeff;
            const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
            distanceText = `${C.DELTA_EQUALS_KATEX}${U.formatSimplifiedRoot(roundedFinalCoeff, radicand)}`;
        } else {
            const platonicValue = distanceData / C.DEFAULT_REFERENCE_DISTANCE;
            distanceText = `${C.DELTA_EQUALS_KATEX}${U.formatNumber(platonicValue, distanceSigFigs)}`;
        }

        const edgeAngleScreen = Math.atan2(endVertexScreen.y - startVertexScreen.y, endVertexScreen.x - startVertexScreen.x);
        const midX_screen = (startVertexScreen.x + endVertexScreen.x) / 2;
        const midY_screen = (startVertexScreen.y + endVertexScreen.y) / 2;
        
        let rotationDeg = edgeAngleScreen * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
        if (rotationDeg > C.DEGREES_IN_QUADRANT || rotationDeg < -C.DEGREES_IN_QUADRANT) {
            rotationDeg += C.DEGREES_IN_HALF_CIRCLE;
        }
        
        let textPerpAngle;
        if (turnAngleData !== null && Math.abs(turnAngleData) > C.GEOMETRY_CALCULATION_EPSILON) {
            const angleTurnScreen = -turnAngleData;
            if (angleTurnScreen < 0) { // Clockwise angle on screen (CCW in data)
                textPerpAngle = edgeAngleScreen - Math.PI / 2; // Place label on the opposite side
            } else { // Counter-clockwise angle on screen (CW in data)
                textPerpAngle = edgeAngleScreen + Math.PI / 2; // Place label on the opposite side
            }
        } else {
            textPerpAngle = edgeAngleScreen - Math.PI / 2;
            if (Math.sin(textPerpAngle) > 0) {
                textPerpAngle += Math.PI;
            }
        }
        const textDistLabelX_D = midX_screen + Math.cos(textPerpAngle) * C.REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN;
        const textDistLabelY_D = midY_screen + Math.sin(textPerpAngle) * C.REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN;

        updateHtmlLabel({ id: 'ref-dist', content: distanceText, x: textDistLabelX_D, y: textDistLabelY_D, color: refElementColor, fontSize: C.REF_TEXT_KATEX_FONT_SIZE, options: {  rotation: rotationDeg } }, htmlOverlay);
    }

    if (showAngles && turnAngleData !== null && Math.abs(turnAngleData) > C.GEOMETRY_CALCULATION_EPSILON) {
        const startAngleCanvas = -baseAngleData;
        const endAngleCanvas = -(baseAngleData + turnAngleData);

        const sumCos = Math.cos(startAngleCanvas) + Math.cos(endAngleCanvas);
        const sumSin = Math.sin(startAngleCanvas) + Math.sin(endAngleCanvas);
        const bisectorCanvasAngle = Math.atan2(sumSin, sumCos);
        const angleLabelOffsetDistance = C.UI_ANGLE_LABEL_OFFSET;

        const textAngleLabelX_A = startVertexScreen.x + Math.cos(bisectorCanvasAngle) * angleLabelOffsetDistance;
        const textAngleLabelY_A = startVertexScreen.y + Math.sin(bisectorCanvasAngle) * angleLabelOffsetDistance;
        
        let rotationDeg = bisectorCanvasAngle * (180 / Math.PI);
        if (rotationDeg > 90 || rotationDeg < -90) {
            rotationDeg += 180;
        }

        let aKatexText = '';
        if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
            let aValueDeg = turnAngleData * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
            aKatexText = `${C.THETA_EQUALS_KATEX}${U.formatNumber(aValueDeg, angleSigFigs)}^{\\circ}`;
        } else if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_RADIANS) {
            let aValueRad = turnAngleData;
            aKatexText = `${C.THETA_EQUALS_KATEX}${U.formatFraction(aValueRad / Math.PI, C.FRACTION_FORMAT_TOLERANCE, C.FRACTION_FORMAT_MAX_DENOMINATOR)}${C.PI_SYMBOL_KATEX}`;
            if (aKatexText === `${C.THETA_EQUALS_KATEX}1${C.PI_SYMBOL_KATEX}`) aKatexText = C.PI_SYMBOL_KATEX;
            if (aKatexText === `${C.THETA_EQUALS_KATEX}-1${C.PI_SYMBOL_KATEX}`) aKatexText = `-${C.PI_SYMBOL_KATEX}`;
            if (aKatexText === `${C.THETA_EQUALS_KATEX}0${C.PI_SYMBOL_KATEX}`) aKatexText = "0";
        }

        updateHtmlLabel({ id: 'ref-angle', content: aKatexText, x: textAngleLabelX_A, y: textAngleLabelY_A, color: refElementColor, fontSize: C.REF_TEXT_KATEX_FONT_SIZE, options: {  rotation: rotationDeg } }, htmlOverlay);
    }
}

export function updateMouseCoordinates(htmlOverlay, { coordsDisplayMode, isMouseOverCanvas, currentShiftPressed, ghostVertexPosition, gridDisplayMode, lastGridState, angleDisplayMode, canvas, dpr, mousePos, colors, useScientific }, screenToData, updateHtmlLabel) {
    
    if (coordsDisplayMode === C.COORDS_DISPLAY_MODE_NONE || !mousePos || !isMouseOverCanvas) {
        return;
    }

    let displayPos;
    if (currentShiftPressed && ghostVertexPosition) {
        displayPos = ghostVertexPosition;
    } else {
        displayPos = screenToData(mousePos);
    }

    let effectiveGridInterval = 1;
    if (gridDisplayMode !== C.GRID_DISPLAY_MODE_NONE && lastGridState && lastGridState.interval1) {
        effectiveGridInterval = lastGridState.interval1;
    }

    // Mouse coordinates should be 1 decimal place more precise than the finest tick spacing
    let finestInterval = effectiveGridInterval;
    if (lastGridState && lastGridState.interval2 && lastGridState.interval2 < finestInterval) {
        finestInterval = lastGridState.interval2;
    }
    
    // Mouse coordinates precision based on tick interval:
    // - 10000+ → round to nearest 100 (2 fewer sig figs)
    // - 1000 → round to nearest 10 (1 fewer sig fig)  
    // - 100 → round to nearest 1 (0 decimals)
    // - 10 → 1 decimal place
    // - 1 → 2 decimal places
    // - 0.1 → 3 decimal places, etc.
    
    let mouseDecimalPlaces;
    let roundingFactor = 1;
    
    if (finestInterval >= 10000) {
        // Round to nearest 100, show as integers
        roundingFactor = 100;
        mouseDecimalPlaces = 0;
    } else if (finestInterval >= 1000) {
        // Round to nearest 10, show as integers  
        roundingFactor = 10;
        mouseDecimalPlaces = 0;
    } else if (finestInterval >= 100) {
        // Round to nearest 1, show as integers
        roundingFactor = 1;
        mouseDecimalPlaces = 0;
    } else if (finestInterval >= 10) {
        // Show 1 decimal place
        mouseDecimalPlaces = 1;
    } else {
        // For smaller intervals, add 2 more decimal places than tick precision
        const tickDecimalPlaces = Math.max(0, -Math.floor(Math.log10(finestInterval)));
        mouseDecimalPlaces = tickDecimalPlaces + 2;
    }
    
    // Calculate how many significant figures the tick interval has
    const getSignificantFigures = (value) => {
        if (value === 0) return 1;
        // For tick intervals like 100000, 10000, 1000, 100, 10, 1, 0.1, 0.01 etc.
        // These are typically 1 significant figure
        return 1;
    };
    
    const tickSigFigs = getSignificantFigures(finestInterval);
    const mouseSigFigs = tickSigFigs + 2; // Always 2 more sig figs than ticks
    
    // Format coordinates with consistent precision
    const formatCoordinate = (value) => {
        if (useScientific) {
            // For scientific notation, ensure both x and y have same decimal places in coefficient
            // Always use mouseSigFigs - 1 decimal places (since first digit is before decimal)
            const decimalPlacesInCoeff = mouseSigFigs - 1;
            const expStr = Math.abs(value).toExponential(decimalPlacesInCoeff);
            const parts = expStr.split('e');
            let coefficient = parts[0];
            let exponent = parseInt(parts[1], 10);
            const sign = value < 0 ? "-" : "";
            return `${sign}${coefficient} \\cdot 10^{${exponent}}`;
        } else {
            if (roundingFactor > 1) {
                // Only round for large intervals (≥100)
                const roundedValue = Math.round(value / roundingFactor) * roundingFactor;
                return roundedValue.toFixed(mouseDecimalPlaces);
            } else {
                // For smaller intervals, just use fixed decimal places without rounding
                return value.toFixed(mouseDecimalPlaces);
            }
        }
    };

    const angleDecimalPlaces = Math.min(mouseDecimalPlaces, C.MAX_ANGLE_DECIMAL_PLACES);
    
    let textContent = '';

    switch (coordsDisplayMode) {
        case C.COORDS_DISPLAY_MODE_REGULAR: {
            // Both x and y use the same decimal places
            let xText = formatCoordinate(displayPos.x);
            if (displayPos.x >= 0 && !xText.includes('cdot')) xText = `${C.KATEX_MINUS_PHANTOM}${xText}`;
            let yText = formatCoordinate(displayPos.y);
            if (displayPos.y >= 0 && !yText.includes('cdot')) yText = `${C.KATEX_MINUS_PHANTOM}${yText}`;
            textContent = `\\begin{pmatrix*}[r] x \\\\ y \\end{pmatrix*} = \\begin{pmatrix*}[r] ${xText} \\\\ ${yText} \\end{pmatrix*}`;
            break;
        }
        case C.COORDS_DISPLAY_MODE_COMPLEX: {
            // Both real and imaginary parts use the same decimal places
            let rePart = formatCoordinate(displayPos.x);
            if (displayPos.x >= 0 && !rePart.includes('cdot')) rePart = `${C.KATEX_MINUS_PHANTOM}${rePart}`;
            const imAbs = Math.abs(displayPos.y);
            let imPartAbs = formatCoordinate(imAbs);
            const sign = displayPos.y < 0 ? '-' : '+';
            textContent = `z = ${rePart} ${sign} ${imPartAbs}${C.IMAGINARY_UNIT_SYMBOL}`;
            break;
        }
        case C.COORDS_DISPLAY_MODE_POLAR: {
            const rValue = Math.hypot(displayPos.x, displayPos.y);
            const thetaRaw = Math.atan2(displayPos.y, displayPos.x);
            
            let rText = formatCoordinate(rValue);
            if (rValue >= 0 && !rText.includes('cdot')) rText = `${C.KATEX_MINUS_PHANTOM}${rText}`;
            let angleStr;
            if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
                let thetaDeg = U.normalizeAngleDegrees(thetaRaw * 180 / Math.PI);
                angleStr = thetaDeg.toFixed(angleDecimalPlaces);
                if (thetaDeg >= 0) angleStr = `${C.KATEX_MINUS_PHANTOM}${angleStr}`;
                angleStr += `^{\\circ}`;
            } else {
                let thetaRad = U.normalizeAngleToPi(thetaRaw);
                angleStr = thetaRad.toFixed(angleDecimalPlaces);
                if (thetaRad >= 0) angleStr = `${C.KATEX_MINUS_PHANTOM}${angleStr}`;
            }
            textContent = `\\begin{pmatrix*}[r] r \\\\ \\theta \\end{pmatrix*} = \\begin{pmatrix*}[r] ${rText} \\\\ ${angleStr} \\end{pmatrix*}`;
            break;
        }
    }

    const canvasWidth = canvas.width / dpr;
    updateHtmlLabel({ 
        id: 'mouse-coord-text', 
        content: textContent, 
        x: canvasWidth - C.UI_PADDING, 
        y: C.UI_PADDING, 
        color: colors.mouseCoords, 
        fontSize: C.MOUSE_COORD_FONT_SIZE, 
        options: { textAlign: 'right', textBaseline: 'top' } 
    });
}

function drawThemeIcon(ctx, rect, activeThemeName, colors) {
    ctx.save();
    const centerX = rect.x + rect.width / 2;
    const centerY = rect.y + rect.height / 2;
    const radius = rect.width / 2 * 0.6;

    ctx.strokeStyle = colors.uiIcon;
    ctx.fillStyle = colors.uiIcon;
    ctx.lineWidth = 2;

    if (activeThemeName === 'dark') {
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 0.7, 0, 2 * Math.PI);
        ctx.fill();
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * 2 * Math.PI;
            const startX = centerX + Math.cos(angle) * (radius * 0.85);
            const startY = centerY + Math.sin(angle) * (radius * 0.85);
            const endX = centerX + Math.cos(angle) * (radius * 1.1);
            const endY = centerY + Math.sin(angle) * (radius * 1.1);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
    } else {
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(centerX - 5, centerY - 3, radius, 0, 2 * Math.PI);
        ctx.fillStyle = colors.background;
        ctx.fill();
    }
    ctx.restore();
}

export function drawCoordsIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    const x_offset = 1;
    ctx.strokeStyle = colorStrong;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(2 + x_offset, 30); ctx.lineTo(30 + x_offset, 30);
    ctx.moveTo(2 + x_offset, 30); ctx.lineTo(2 + x_offset, 2);
    ctx.stroke();
    ctx.fillStyle = colorStrong;
    const vertex = { x: 16 + x_offset, y: 16 };
    let labelPos = { x: 17 + x_offset, y: 8 };
    let label = '';
    switch (mode) {
        case C.COORDS_DISPLAY_MODE_REGULAR:
            ctx.setLineDash(C.UI_ICON_DASH_PATTERN);
            ctx.beginPath();
            ctx.moveTo(vertex.x, vertex.y); ctx.lineTo(vertex.x, 30);
            ctx.moveTo(vertex.x, vertex.y); ctx.lineTo(2 + x_offset, vertex.y);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            ctx.fill();
            label = '(x,y)';
            break;
        case C.COORDS_DISPLAY_MODE_COMPLEX:
            ctx.setLineDash(C.UI_ICON_DASH_PATTERN);
            ctx.beginPath();
            ctx.moveTo(2 + x_offset, 30); ctx.lineTo(vertex.x, vertex.y);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            ctx.fill();
            label = 'x+iy';
            break;
        case C.COORDS_DISPLAY_MODE_POLAR:
            ctx.setLineDash(C.UI_ICON_DASH_PATTERN);
            ctx.beginPath();
            ctx.moveTo(2 + x_offset, 30); ctx.lineTo(vertex.x, vertex.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(2 + x_offset, 30, 8, -Math.atan2(30 - vertex.y, vertex.x - (2 + x_offset)), 0);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            ctx.fill();
            label = '(r,\\theta)';
            break;
        case C.COORDS_DISPLAY_MODE_NONE:
            break;
    }
    ctx.restore();
    if (label) {
        const labelId = 'icon-label-coords';
        const labelColor = isSelected ? colors.uiTextSelected : colors.uiTextDefault;
        updateHtmlLabel({ id: labelId, content: label, x: center.x + (labelPos.x - 16) * scale, y: center.y + (labelPos.y - 16) * scale, color: labelColor, fontSize: C.UI_ICON_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function drawAngleIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    let sizeIncrease = 0;
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    ctx.strokeStyle = colorStrong;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    const p1 = { x: 28, y: 30 };
    const p2 = { x: 4, y: 30 };
    const p3 = { x: 16, y: 8 };
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.lineTo(p3.x, p3.y);
    ctx.stroke();
    let label = '';
    let labelPos = { x: 20, y: 22 };
    if (mode !== C.ANGLE_DISPLAY_MODE_NONE) {
        ctx.beginPath();
        const angle = Math.atan2(p3.y - p2.y, p3.x - p2.x);
        ctx.arc(p2.x, p2.y, 8, angle, 0);
        ctx.stroke();
        if (mode === C.ANGLE_DISPLAY_MODE_DEGREES) {
            label = '60^\\circ';
        } else if (mode === C.ANGLE_DISPLAY_MODE_RADIANS) {
            label = '\\frac{\\pi}{3}';
            sizeIncrease = 2
        }
    }
    ctx.restore();
    if (label) {
        const labelId = 'icon-label-angles';
        const labelColor = isSelected ? colors.uiTextSelected : colors.uiTextDefault;
        updateHtmlLabel({ id: labelId, content: label, x: center.x + (labelPos.x - 16) * scale, y: center.y + (labelPos.y - 20) * scale, color: labelColor, fontSize: C.UI_ICON_LABEL_FONT_SIZE+sizeIncrease, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function drawDistanceIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    ctx.strokeStyle = colorStrong;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    ctx.beginPath();
    ctx.moveTo(2, 30);
    ctx.lineTo(30, 30);
    ctx.stroke();
    let label = '';
    let labelPos = { x: 16, y: 22 };
    if (mode === C.DISTANCE_DISPLAY_MODE_ON) {
        label = '3.14';
    }
    ctx.restore();
    if (label) {
        const labelId = 'icon-label-distances';
        const labelColor = isSelected ? colors.uiTextSelected : colors.uiTextDefault;
        updateHtmlLabel({ id: labelId, content: label, x: center.x + (labelPos.x - 16) * scale, y: center.y + (labelPos.y - 16) * scale, color: labelColor, fontSize: 12, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function drawGridIcon(ctx, rect, mode, isSelected, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    ctx.strokeStyle = colorStrong;
    ctx.fillStyle = colorStrong;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    switch (mode) {
        case C.GRID_DISPLAY_MODE_LINES:
            ctx.strokeRect(2, 2, 28, 28);
            ctx.beginPath();
            ctx.moveTo(2, 16); ctx.lineTo(30, 16);
            ctx.moveTo(16, 2); ctx.lineTo(16, 30);
            ctx.stroke();
            break;
        case C.GRID_DISPLAY_MODE_POINTS:
            ctx.strokeRect(2, 2, 28, 28);
            ctx.beginPath();
            [8, 16, 24].forEach(x => {
                [8, 16, 24].forEach(y => {
                    ctx.moveTo(x, y);
                    ctx.arc(x, y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
                });
            });
            ctx.fill();
            break;
        case C.GRID_DISPLAY_MODE_TRIANGULAR:
            ctx.strokeRect(2, 2, 28, 28);
            const triRadius = 8;
            const triCenterX = 16;
            const triCenterY = 16;
            ctx.beginPath();
            ctx.arc(triCenterX, triCenterY, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const x = triCenterX + triRadius * Math.cos(angle);
                const y = triCenterY + triRadius * Math.sin(angle);
                ctx.moveTo(x, y);
                ctx.arc(x, y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            }
            ctx.fill();
            break;
        case C.GRID_DISPLAY_MODE_POLAR:
            ctx.beginPath();
            ctx.arc(16, 16, 14, 0, C.RADIANS_IN_CIRCLE);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(16, 16, 7, 0, C.RADIANS_IN_CIRCLE);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(2, 16); ctx.lineTo(30, 16);
            ctx.moveTo(16, 2); ctx.lineTo(16, 30);
            ctx.stroke();
            break;
        case C.GRID_DISPLAY_MODE_NONE:
            ctx.strokeRect(2, 2, 28, 28);
            break;
    }
    ctx.restore();
}

export function drawDisplayIcon(ctx, icon, state, htmlOverlay, updateHtmlLabel) {
    const { coordsDisplayMode, gridDisplayMode, angleDisplayMode, distanceDisplayMode, colors } = state;
    let isSelected = false;
    switch (icon.group) {
        case 'coords':
            isSelected = coordsDisplayMode !== C.COORDS_DISPLAY_MODE_NONE;
            break;
        case 'grid':
            isSelected = gridDisplayMode !== C.GRID_DISPLAY_MODE_NONE;
            break;
        case 'angles':
            isSelected = angleDisplayMode !== C.ANGLE_DISPLAY_MODE_NONE;
            break;
        case 'distances':
            isSelected = distanceDisplayMode === C.DISTANCE_DISPLAY_MODE_ON;
            break;
    }
    const rect = { x: icon.x, y: icon.y, width: icon.width, height: icon.height };
    switch (icon.group) {
        case 'coords':
            drawCoordsIcon(ctx, rect, coordsDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);
            break;
        case 'grid':
            drawGridIcon(ctx, rect, gridDisplayMode, isSelected, colors);
            break;
        case 'angles':
            drawAngleIcon(ctx, rect, angleDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);
            break;
        case 'distances':
            drawDistanceIcon(ctx, rect, distanceDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);
            break;
    }
}

function drawUITransformationSymbols(ctx, icon, colors) {
    const screenPos = { x: icon.x + icon.width / 2, y: icon.y + icon.height / 2 };
    const radius = icon.width / 2;
    ctx.strokeStyle = colors.uiIcon;
    ctx.fillStyle = colors.uiIcon;
    ctx.setLineDash([]);
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    ctx.save();
    ctx.translate(screenPos.x, screenPos.y);

    switch (icon.type) {
        case C.TRANSFORMATION_TYPE_ROTATION: {
            const arcAngle = -Math.PI / 4;
            
            ctx.beginPath();
            ctx.arc(0, 0, radius,  arcAngle,-arcAngle);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(0, 0, radius, Math.PI+arcAngle, Math.PI-arcAngle);
            ctx.stroke();
            
            const arrowSize = radius * 0.25;
            
            const arrow1X = radius * Math.cos(arcAngle);
            const arrow1Y = radius * Math.sin(arcAngle);
            
            ctx.save();
            ctx.translate(arrow1X, arrow1Y);
            ctx.rotate(arcAngle-Math.PI/2);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, -arrowSize * 0.5);
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, arrowSize * 0.5);
            ctx.stroke();
            ctx.restore();
            
            const arrow2X = radius * Math.cos(Math.PI + arcAngle);
            const arrow2Y = radius * Math.sin(Math.PI + arcAngle);
            
            ctx.save();
            ctx.translate(arrow2X, arrow2Y);
            ctx.rotate(arcAngle+Math.PI/2);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, -arrowSize * 0.5);
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, arrowSize * 0.5);
            ctx.stroke();
            ctx.restore();
            break;
        }

        case C.TRANSFORMATION_TYPE_SCALE: {
            const lineLength = radius * 0.8;
            const arrowSize = radius * 0.25;
            
            ctx.beginPath();
            ctx.moveTo(-lineLength, 0);
            ctx.lineTo(lineLength, 0);
            ctx.moveTo(0, -lineLength);
            ctx.lineTo(0, lineLength);
            ctx.stroke();
            
            const arrowPositions = [
                { x: lineLength, y: 0, dirX: 1, dirY: 0 },
                { x: -lineLength, y: 0, dirX: -1, dirY: 0 },
                { x: 0, y: -lineLength, dirX: 0, dirY: -1 },
                { x: 0, y: lineLength, dirX: 0, dirY: 1 }
            ];
            
            arrowPositions.forEach(pos => {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize + pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize - pos.dirX * arrowSize * 0.5);
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize - pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize + pos.dirX * arrowSize * 0.5);
                ctx.stroke();
            });
            break;
        }

        case C.TRANSFORMATION_TYPE_ROTATE_SCALE: {
            // Rotation part
            const arcAngle = -Math.PI / 4;
            
            ctx.beginPath();
            ctx.arc(0, 0, radius,  arcAngle,-arcAngle);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(0, 0, radius, Math.PI+arcAngle, Math.PI-arcAngle);
            ctx.stroke();
            
            let arrowSize = radius * 0.25;
            
            const arrow1X = radius * Math.cos(arcAngle);
            const arrow1Y = radius * Math.sin(arcAngle);
            
            ctx.save();
            ctx.translate(arrow1X, arrow1Y);
            ctx.rotate(arcAngle-Math.PI/2);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, -arrowSize * 0.5);
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, arrowSize * 0.5);
            ctx.stroke();
            ctx.restore();
            
            const arrow2X = radius * Math.cos(Math.PI + arcAngle);
            const arrow2Y = radius * Math.sin(Math.PI + arcAngle);
            
            ctx.save();
            ctx.translate(arrow2X, arrow2Y);
            ctx.rotate(arcAngle+Math.PI/2);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, -arrowSize * 0.5);
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, arrowSize * 0.5);
            ctx.stroke();
            ctx.restore();

            // Scale part
            const lineLength = radius * 0.8;
            arrowSize = radius * 0.25;
            
            ctx.beginPath();
            ctx.moveTo(-lineLength, 0);
            ctx.lineTo(lineLength, 0);
            ctx.moveTo(0, -lineLength);
            ctx.lineTo(0, lineLength);
            ctx.stroke();
            
            const arrowPositions = [
                { x: lineLength, y: 0, dirX: 1, dirY: 0 },
                { x: -lineLength, y: 0, dirX: -1, dirY: 0 },
                { x: 0, y: -lineLength, dirX: 0, dirY: -1 },
                { x: 0, y: lineLength, dirX: 0, dirY: 1 }
            ];
            
            arrowPositions.forEach(pos => {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize + pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize - pos.dirX * arrowSize * 0.5);
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize - pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize + pos.dirX * arrowSize * 0.5);
                ctx.stroke();
            });
            break;
        }

        case C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE: {
            const lineLength = radius * 0.8;
            const arrowSize = radius * 0.25;
            
            ctx.beginPath();
            ctx.moveTo(-lineLength / Math.sqrt(2), -lineLength / Math.sqrt(2));
            ctx.lineTo(lineLength / Math.sqrt(2), lineLength / Math.sqrt(2));
            ctx.moveTo(lineLength / Math.sqrt(2), -lineLength / Math.sqrt(2));
            ctx.lineTo(-lineLength / Math.sqrt(2), lineLength / Math.sqrt(2));
            ctx.stroke();
            
            const arrowPositions = [
                { 
                    x: lineLength / Math.sqrt(2), 
                    y: -lineLength / Math.sqrt(2), 
                    dirX: 1/Math.sqrt(2), 
                    dirY: -1/Math.sqrt(2)
                },
                { 
                    x: -lineLength / Math.sqrt(2), 
                    y: lineLength / Math.sqrt(2), 
                    dirX: -1/Math.sqrt(2), 
                    dirY: 1/Math.sqrt(2)
                }
            ];
            
            arrowPositions.forEach(pos => {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize + pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize - pos.dirX * arrowSize * 0.5);
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize - pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize + pos.dirX * arrowSize * 0.5);
                ctx.stroke();
            });
            break;
        }
    }
    ctx.restore();
}

export function drawVisibilityIcon(ctx, rect, colors) {
    const centerX = rect.x + rect.width / 2;
    const centerY = rect.y + rect.height / 2;
    const eyeWidth = rect.width * 0.6;
    const eyeHeight = rect.height * 0.3;
    
    ctx.save();
    ctx.strokeStyle = colors.uiIcon;
    ctx.fillStyle = colors.uiIcon;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    ctx.lineCap = 'round';
    
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, eyeWidth / 2, eyeHeight / 2, 0, 0, 2 * Math.PI);
    ctx.stroke();
    
    const pupilRadius = eyeHeight * 0.3;
    ctx.beginPath();
    ctx.arc(centerX, centerY, pupilRadius, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.restore();
}

function drawColorPalette(ctx, htmlOverlay, state, updateHtmlLabel) {
    const { canvasUI, colors, allColors, namedColors, colorAssignments, activeColorTargets, verticesVisible, edgesVisible, facesVisible, isDraggingColorTarget, draggedColorTargetInfo, mousePos } = state;

    const checkerboardColor1 = colors.checkerboardColor1;
    const checkerboardColor2 = colors.checkerboardColor2;
    
    function drawCheckerboard(rect) {
        const tileSize = rect.height / 3;
        const numCols = Math.ceil(rect.width / tileSize);
        for (let row = 0; row < 3; row++) {
            for (let col = 0; col < numCols; col++) {
                ctx.fillStyle = (row + col) % 2 === 0 ? checkerboardColor1 : checkerboardColor2;
                const tileX = rect.x + col * tileSize;
                const tileY = rect.y + row * tileSize;
                const tileWidth = Math.min(tileSize, rect.x + rect.width - tileX);
                const tileHeight = Math.min(tileSize, rect.y + rect.height - tileY);
                if (tileWidth > 0 && tileHeight > 0) ctx.fillRect(tileX, tileY, tileWidth, tileHeight);
            }
        }
    }
    
    const randomBtn = canvasUI.randomColorButton;
    if (randomBtn) {
        ctx.fillStyle = '#000000';
        ctx.fillRect(randomBtn.x, randomBtn.y, randomBtn.width, randomBtn.height);
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = C.UI_BUTTON_BORDER_WIDTH;
        ctx.strokeRect(randomBtn.x, randomBtn.y, randomBtn.width, randomBtn.height);
        const centerX = randomBtn.x + randomBtn.width / 2;
        const centerY = randomBtn.y + randomBtn.height / 2;
        const wheelRadius = randomBtn.width * 0.35;
        const segments = 8;
        for (let i = 0; i < segments; i++) {
            const angle1 = (i / segments) * 2 * Math.PI;
            const angle2 = ((i + 1) / segments) * 2 * Math.PI;
            const hue = (i / segments) * 360;
            ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, wheelRadius, angle1, angle2);
            ctx.closePath();
            ctx.fill();
        }
        ctx.fillStyle = colors.background;
        ctx.beginPath();
        ctx.arc(centerX, centerY, wheelRadius * 0.4, 0, 2 * Math.PI);
        ctx.fill();
    }

    const removeBtn = canvasUI.removeColorButton;
    if (removeBtn) {
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = C.UI_BUTTON_BORDER_WIDTH;
        ctx.strokeRect(removeBtn.x, removeBtn.y, removeBtn.width, removeBtn.height);
        ctx.beginPath();
        ctx.moveTo(removeBtn.x + C.UI_BUTTON_ICON_PADDING, removeBtn.y + removeBtn.height / 2);
        ctx.lineTo(removeBtn.x + removeBtn.width - C.UI_BUTTON_ICON_PADDING, removeBtn.y + removeBtn.height / 2);
        ctx.stroke();
    }

    canvasUI.colorSwatches.forEach((swatch) => {
        const colorItem = swatch.item;
        let hasAlpha = false;
        if (colorItem && colorItem.type === 'color') {
            const parsedColor = U.parseColor(colorItem.value);
            if (parsedColor && parsedColor.a < 1.0) hasAlpha = true;
        } else if (colorItem && colorItem.type === 'colormap') {
            if (colorItem.vertices.some(p => p.alpha !== undefined && p.alpha < 1.0)) hasAlpha = true;
        }
        if (hasAlpha) drawCheckerboard(swatch);
        if (colorItem && colorItem.type === 'colormap') {
            const gradient = ctx.createLinearGradient(swatch.x, swatch.y, swatch.x + swatch.width, swatch.y);
            colorItem.vertices.forEach(vertex => {
                let colorValue = vertex.color;
                if (typeof colorValue === 'string') colorValue = namedColors[colorValue] || [0, 0, 0];
                gradient.addColorStop(vertex.pos, `rgba(${colorValue.join(',')},${vertex.alpha || 1.0})`);
            });
            ctx.fillStyle = gradient;
        } else if (colorItem) {
            ctx.fillStyle = colorItem.value;
        }
        ctx.fillRect(swatch.x, swatch.y, swatch.width, swatch.height);
    });

    const addBtn = canvasUI.addColorButton;
    if (addBtn) {
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = C.UI_BUTTON_BORDER_WIDTH;
        ctx.strokeRect(addBtn.x, addBtn.y, addBtn.width, addBtn.height);
        ctx.beginPath();
        ctx.moveTo(addBtn.x + addBtn.width / 2, addBtn.y + C.UI_BUTTON_ICON_PADDING);
        ctx.lineTo(addBtn.x + addBtn.width / 2, addBtn.y + addBtn.height - C.UI_BUTTON_ICON_PADDING);
        ctx.moveTo(addBtn.x + C.UI_BUTTON_ICON_PADDING, addBtn.y + addBtn.height / 2);
        ctx.lineTo(addBtn.x + addBtn.width - C.UI_BUTTON_ICON_PADDING, addBtn.y + addBtn.height / 2);
        ctx.stroke();
    }

    if (canvasUI.colorTargetIcons) {
        const getIconOptions = (target) => {
            let targetColorIndex = colorAssignments[target];
            if (isDraggingColorTarget && draggedColorTargetInfo && draggedColorTargetInfo.target === target && draggedColorTargetInfo.previewColorIndex !== undefined) {
                targetColorIndex = draggedColorTargetInfo.previewColorIndex;
            }

            const colorItem = (targetColorIndex === -1) ? null : allColors[targetColorIndex];

            const options = {};
            if (target === C.COLOR_TARGET_VERTEX) {
                options.vertexState = verticesVisible ? 'filled' : 'disabled';
                if (targetColorIndex === -1) {
                    options.vertexColor = C.UI_COLOR_TARGET_UNASSIGNED;
                } else if (colorItem && colorItem.type === 'color') {
                    options.vertexColor = colorItem.value;
                } else if (colorItem && colorItem.type === 'colormap') {
                    options.vertexColormapItem = colorItem;
                }
            } else if (target === C.COLOR_TARGET_EDGE) {
                options.edgeState = edgesVisible ? 'solid' : 'disabled';
                if (targetColorIndex === -1) {
                    options.edgeColor = C.UI_COLOR_TARGET_UNASSIGNED;
                } else if (colorItem && colorItem.type === 'color') {
                    options.edgeColor = colorItem.value;
                } else if (colorItem && colorItem.type === 'colormap') {
                    options.edgeColormapItem = colorItem;
                }
            } else if (target === C.COLOR_TARGET_FACE) {
                options.faceState = facesVisible ? 'filled' : 'disabled';
                if (targetColorIndex === -1) {
                    options.faceColor = C.UI_COLOR_TARGET_UNASSIGNED;
                } else if (colorItem && colorItem.type === 'color') {
                    options.faceColor = colorItem.value;
                } else if (colorItem && colorItem.type === 'colormap') {
                    options.faceColormapItem = colorItem;
                }
            }
            return options;
        };

        const drawOrder = [C.COLOR_TARGET_FACE, C.COLOR_TARGET_EDGE, C.COLOR_TARGET_VERTEX];
        drawOrder.forEach(targetToDraw => {
            const icon = canvasUI.colorTargetIcons.find(i => i.target === targetToDraw);
            if (icon) {
                const isActive = activeColorTargets.includes(targetToDraw);
                const iconOptions = getIconOptions(targetToDraw);

                if (isDraggingColorTarget && draggedColorTargetInfo && draggedColorTargetInfo.target === C.COLOR_TARGET_FACE && targetToDraw === C.COLOR_TARGET_FACE) {
                    const swatchUnderMouse = canvasUI.colorSwatches.find(swatch =>
                        mousePos.x >= swatch.x && mousePos.x <= swatch.x + swatch.width &&
                        mousePos.y >= swatch.y && mousePos.y <= swatch.y + swatch.height
                    );

                    if (swatchUnderMouse && swatchUnderMouse.item.type === 'colormap') {
                        const t = U.clamp((mousePos.x - swatchUnderMouse.x) / swatchUnderMouse.width, 0, 1);
                        iconOptions.faceColor = U.sampleColormap(swatchUnderMouse.item, t);
                        iconOptions.faceState = 'filled';
                    }
                }

                drawTriangleIcon(ctx, icon, iconOptions, colors, isActive);
            }
        });
    }

    const drawnBoxesForSwatches = new Set();
    activeColorTargets.forEach(target => {
        let targetColorIndex = colorAssignments[target];
        if (isDraggingColorTarget && draggedColorTargetInfo && draggedColorTargetInfo.target === target && draggedColorTargetInfo.previewColorIndex !== undefined) {
            targetColorIndex = draggedColorTargetInfo.previewColorIndex;
        }
        
        if (targetColorIndex === -1 || drawnBoxesForSwatches.has(targetColorIndex)) return;

        const swatch = canvasUI.colorSwatches.find(s => s.index === targetColorIndex);
        if (swatch) {
            const targetsForThisSwatch = Object.keys(colorAssignments).filter(t => {
                let checkIndex = colorAssignments[t];
                if (isDraggingColorTarget && draggedColorTargetInfo && draggedColorTargetInfo.target === t && draggedColorTargetInfo.previewColorIndex !== undefined) {
                    checkIndex = draggedColorTargetInfo.previewColorIndex;
                }
                return checkIndex === swatch.index && activeColorTargets.includes(t);
            });
            const iconsForThisSwatch = canvasUI.colorTargetIcons.filter(icon => targetsForThisSwatch.includes(icon.target));

            if (iconsForThisSwatch.length > 0) {
                const minY = Math.min(...iconsForThisSwatch.map(i => i.y));
                
                ctx.strokeStyle = colors.selectionGlow;
                ctx.lineWidth = C.UI_BUTTON_BORDER_WIDTH;
                const padding = 2;
                const boxX = swatch.x - padding;
                const boxY = minY - padding;
                const boxWidth = swatch.width + (padding * 2);
                const boxHeight = (swatch.y + swatch.height) - boxY + padding;
                
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                drawnBoxesForSwatches.add(targetColorIndex);
            }
        }
    });
}

function drawColorToolbarPreview(ctx, rect, { verticesVisible, edgesVisible, facesVisible, colorAssignments, allColors }, colors) {
    const allDisabled = !verticesVisible && !edgesVisible && !facesVisible;

    const options = {
        vertexState: (verticesVisible || allDisabled) ? 'filled' : 'hidden',
        edgeState: (edgesVisible || allDisabled) ? 'solid' : 'hidden',
        faceState: (facesVisible || allDisabled) ? 'filled' : 'hidden',
        showAllDisabled: allDisabled
    };
    
    const vertexColorIndex = colorAssignments[C.COLOR_TARGET_VERTEX];
    if (vertexColorIndex !== -1) {
        const vertexColorItem = allColors[vertexColorIndex];
        if (vertexColorItem && vertexColorItem.type === 'colormap') {
            options.vertexColormapItem = vertexColorItem;
        } else if (vertexColorItem && vertexColorItem.type === 'color') {
            options.vertexColor = vertexColorItem.value;
        }
    } else {
        options.vertexColor = colors.vertex;
    }
    
    const edgeColorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
    if (edgeColorIndex !== -1) {
        const edgeColorItem = allColors[edgeColorIndex];
        if (edgeColorItem && edgeColorItem.type === 'colormap') {
            options.edgeColormapItem = edgeColorItem;
        } else if (edgeColorItem && edgeColorItem.type === 'color') {
            options.edgeColor = edgeColorItem.value;
        }
    } else {
        options.edgeColor = colors.edge;
    }
    
    const faceColorIndex = colorAssignments[C.COLOR_TARGET_FACE];
    if (faceColorIndex !== -1) {
        const faceColorItem = allColors[faceColorIndex];
        if (faceColorItem && faceColorItem.type === 'color') {
            options.faceColor = faceColorItem.value;
        } else if (faceColorItem && faceColorItem.type === 'colormap') {
            options.faceColormapItem = faceColorItem;
        }
    } else {
        options.faceColor = colors.face;
    }
    
    drawTriangleIcon(ctx, rect, options, colors);
}

function drawTriangleIcon(ctx, rect, options, colors, isActive = false) {
    const { vertexState = 'none', edgeState = 'none', faceState = 'none', faceColor, edgeColor, vertexColor: optionsVertexColor, faceColormapItem, showAllDisabled = false } = options;
    
    ctx.save();
    
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    
    const triangleSize = 26;
    const height = triangleSize * Math.sqrt(3) / 2;
    
    const vertices = [
        { x: 16, y: 16 - height / 1.5 },
        { x: 16 - triangleSize / 2, y: 16 + height / 3 },
        { x: 16 + triangleSize / 2, y: 16 + height / 3 }
    ];

    const facePath = new Path2D();
    facePath.moveTo(vertices[0].x, vertices[0].y);
    facePath.lineTo(vertices[1].x, vertices[1].y);
    facePath.lineTo(vertices[2].x, vertices[2].y);
    facePath.closePath();
    
    if (faceState === 'filled') {
        if (faceColormapItem && faceColormapItem.type === 'colormap') {
            const gradient = ctx.createLinearGradient(vertices[1].x, 0, vertices[2].x, 0);
            faceColormapItem.vertices.forEach(vertex => {
                const colorValue = vertex.color;
                const alpha = vertex.alpha !== undefined ? vertex.alpha : 1.0;
                const colorString = `rgba(${colorValue.join(',')},${alpha})`;
                gradient.addColorStop(vertex.pos, colorString);
            });
            ctx.fillStyle = gradient;
        } else {
            ctx.fillStyle = faceColor || colors.face;
        }
        ctx.fill(facePath);
    } else if (faceState === 'disabled') {
        ctx.fillStyle = C.UI_ICON_DISABLED_FILL;
        ctx.fill(facePath);
    }
    
    if (edgeState === 'solid' || edgeState === 'disabled') {
        ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
        ctx.setLineDash([]);
        
        const edges = [
            [vertices[0], vertices[1]],
            [vertices[1], vertices[2]],
            [vertices[2], vertices[0]]
        ];
        
        edges.forEach((edge, edgeIndex) => {
            const [start, end] = edge;
            if (options.edgeColormapItem && options.edgeColormapItem.type === 'colormap' && edgeState === 'solid') {
                const gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
                const edgeOffset = edges.length > 1 ? edgeIndex / (edges.length - 1) : 0.5;
                const startT = Math.max(0, Math.min(1, edgeOffset));
                const endT = Math.max(0, Math.min(1, edgeOffset + 0.3));
                const startColor = U.sampleColormap(options.edgeColormapItem, startT);
                const endColor = U.sampleColormap(options.edgeColormapItem, endT);
                gradient.addColorStop(0, startColor);
                gradient.addColorStop(1, endColor);
                ctx.strokeStyle = gradient;
            } else if (edgeState === 'disabled') {
                ctx.strokeStyle = '#808080';
            } else {
                ctx.strokeStyle = edgeColor || colors.edge;
            }
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
        });
    }
    
    if (vertexState === 'filled' || vertexState === 'disabled') {
        ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
        vertices.forEach((vertex, index) => {
            let currentVertexColor = optionsVertexColor || colors.vertex;
            if (options.vertexColormapItem && options.vertexColormapItem.type === 'colormap' && vertexState === 'filled') {
                const t = vertices.length > 1 ? index / (vertices.length - 1) : 0.5;
                currentVertexColor = U.sampleColormap(options.vertexColormapItem, t);
            }
            if (vertexState === 'disabled') {
                currentVertexColor = '#808080';
            }
            const vertexPath = new Path2D();
            vertexPath.moveTo(vertex.x + C.UI_ICON_VERTEX_RADIUS * 2, vertex.y);
            vertexPath.arc(vertex.x, vertex.y, C.UI_ICON_VERTEX_RADIUS * 2, 0, 2 * Math.PI);
            ctx.fillStyle = currentVertexColor;
            ctx.setLineDash([]);
            ctx.fill(vertexPath);
        });
    }

    const hasDisabledElements = vertexState === 'disabled' || edgeState === 'disabled' || faceState === 'disabled';
    
    if (showAllDisabled) {
        ctx.strokeStyle = colors.uiIconDisabled;
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(2, 2);
        ctx.lineTo(30, 30);
        ctx.stroke();
    } else if (hasDisabledElements) {
        ctx.strokeStyle = colors.uiIconDisabled;
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(2, 2);
        ctx.lineTo(30, 30);
        ctx.stroke();
    }
    
    ctx.restore();
}

export function drawFace(ctx, screenVertices, face, colors, dataToScreen, findVertexById, allFaces, getLiveVertex, drawHoles) {
    if (!screenVertices || screenVertices.length < 3) return;

    ctx.save();

    // Create the path for the face first.
    ctx.beginPath();
    screenVertices.forEach((vertex, index) => {
        if (index === 0) {
            ctx.moveTo(vertex.x, vertex.y);
        } else {
            ctx.lineTo(vertex.x, vertex.y);
        }
    });
    ctx.closePath();

    // If instructed, add child face boundaries to the path to create holes.
    if (drawHoles && face.childFaceIds && face.childFaceIds.length > 0) {
        face.childFaceIds.forEach(childId => {
            const childFace = allFaces.find(f => f.id === childId);
            if (childFace) {
                const childLiveVertices = childFace.vertexIds.map(id => getLiveVertex(id)).filter(p => p && p.type === 'regular');
                if (childLiveVertices.length >= 3) {
                    const childScreenVertices = childLiveVertices.map(v => dataToScreen(v));
                    ctx.moveTo(childScreenVertices[0].x, childScreenVertices[0].y);
                    childScreenVertices.slice(1).forEach(vertex => {
                        ctx.lineTo(vertex.x, vertex.y);
                    });
                    ctx.closePath();
                }
            }
        });
    }

    if (face && face.colormapItem && face.localCoordSystem) {
        const isCycled = face.colormapItem.isCyclic === true;

        if (isCycled) {
            // --- Logic for REPEATING (Cycled) Colormaps ---
            const cacheKey = JSON.stringify(face.colormapItem.vertices);
            let patternCanvas = patternCache.get(cacheKey);

            if (!patternCanvas) {
                patternCanvas = document.createElement('canvas');
                patternCanvas.width = 256;
                patternCanvas.height = 1;
                const patternCtx = patternCanvas.getContext('2d');
                const grad = patternCtx.createLinearGradient(0, 0, 256, 0);
                
                face.colormapItem.vertices.forEach(vertex => {
                    const colorValue = vertex.color;
                    const alpha = vertex.alpha !== undefined ? vertex.alpha : 1.0;
                    let colorString = `rgba(255,255,255,${alpha})`;
                    if (typeof colorValue === 'string') {
                        colorString = colorValue;
                    } else if (Array.isArray(colorValue)) {
                        colorString = `rgba(${colorValue.join(',')},${alpha})`;
                    }
                    grad.addColorStop(vertex.pos, colorString);
                });
                
                patternCtx.fillStyle = grad;
                patternCtx.fillRect(0, 0, 256, 1);
                patternCache.set(cacheKey, patternCanvas);
            }
            
            const pattern = ctx.createPattern(patternCanvas, 'repeat');
            const origin_s = dataToScreen(face.localCoordSystem.origin);
            const unit_vec_global = U.localToGlobal({x: 1, y: 0}, face.localCoordSystem);
            const unit_vec_s = dataToScreen(unit_vec_global);
            
            const dx = unit_vec_s.x - origin_s.x;
            const dy = unit_vec_s.y - origin_s.y;
            
            const screen_dist = Math.hypot(dx, dy);
            const scale = screen_dist > 0 ? screen_dist / 256 : 0;
            
            const matrix = new DOMMatrix();
            matrix.translateSelf(origin_s.x, origin_s.y);
            matrix.rotateSelf(0, 0, -face.localCoordSystem.angle * 180 / Math.PI);
            matrix.scaleSelf(scale, scale);
            
            pattern.setTransform(matrix);
            
            ctx.fillStyle = pattern;
            ctx.fill(drawHoles ? 'evenodd' : 'nonzero');

        } else {
            // --- Logic for SATURATING (Regular) Colormaps ---
            const localStart = { x: 0, y: 0 };
            const localEnd = { x: 1, y: 0 };
            const globalStart = U.localToGlobal(localStart, face.localCoordSystem);
            const globalEnd = U.localToGlobal(localEnd, face.localCoordSystem);
            const screenStart = dataToScreen(globalStart);
            const screenEnd = dataToScreen(globalEnd);
            
            const gradient = ctx.createLinearGradient(screenStart.x, screenStart.y, screenEnd.x, screenEnd.y);
            face.colormapItem.vertices.forEach(vertex => {
                let colorValue = vertex.color;
                if (typeof colorValue === 'string') {
                    gradient.addColorStop(vertex.pos, colorValue);
                } else {
                    const alpha = vertex.alpha !== undefined ? vertex.alpha : 1.0;
                    gradient.addColorStop(vertex.pos, `rgba(${colorValue.join(',')},${alpha})`);
                }
            });
            ctx.fillStyle = gradient;
            ctx.fill(drawHoles ? 'evenodd' : 'nonzero');
        }
    } else {
        // Default solid color fill
        ctx.fillStyle = face?.color || colors.face;
        ctx.fill(drawHoles ? 'evenodd' : 'nonzero');
    }
    
    ctx.restore();
}

function drawVisibilityPanelIcon(ctx, icon, state, htmlOverlay, updateHtmlLabel, iconColors) {
    const {angleDisplayMode, distanceDisplayMode, colors } = state;
    
    const rect = { x: icon.x, y: icon.y, width: icon.width, height: icon.height };
    switch (icon.group) {
        case 'angles':
            drawAngleIcon(ctx, rect, angleDisplayMode, angleDisplayMode !== C.ANGLE_DISPLAY_MODE_NONE, htmlOverlay, updateHtmlLabel, colors);
            break;
        case 'distances':
            drawDistanceIcon(ctx, rect, distanceDisplayMode, distanceDisplayMode === C.DISTANCE_DISPLAY_MODE_ON, htmlOverlay, updateHtmlLabel, colors);
            break;
    }
}

function drawVisibilityPanel(ctx, htmlOverlay, state, updateHtmlLabel) {
    const { canvasUI, colorAssignments, allColors, colors } = state;

    const getColor = (target) => {
        if (!colorAssignments || !allColors) return colors.uiIcon;
        const colorIndex = colorAssignments[target];
        if (colorIndex === -1) return C.UI_COLOR_TARGET_UNASSIGNED;
        const item = allColors[colorIndex];
        if (!item) return colors.uiIcon;
        if (item.type === 'color') return item.value;
        return colors.uiIcon; 
    };

    const iconColors = {
        vertexColor: getColor(C.COLOR_TARGET_VERTEX),
        edgeColor: getColor(C.COLOR_TARGET_EDGE),
        faceColor: getColor(C.COLOR_TARGET_FACE)
    };

    canvasUI.visibilityIcons.forEach(icon => {
        drawVisibilityPanelIcon(ctx, icon, state, htmlOverlay, updateHtmlLabel, iconColors);
    });
}

function drawMainToolbar(ctx, htmlOverlay, state, updateHtmlLabel) {
   const { canvasUI, colors, activeThemeName, colorAssignments, allColors, verticesVisible, edgesVisible, facesVisible } = state;

   const btn = canvasUI.toolbarButton;
   ctx.strokeStyle = colors.uiDefault;
   ctx.lineWidth = C.UI_MENU_ICON_LINE_WIDTH;
   ctx.beginPath();
   for (let i = 0; i < 3; i++) {
       const lineY = btn.y + 5 + i * 10;
       ctx.moveTo(btn.x + 4, lineY);
       ctx.lineTo(btn.x + btn.width - 4, lineY);
   }
   ctx.stroke();

   const ctb = canvasUI.colorToolButton;
   if (ctb) {
       drawColorToolbarPreview(ctx, ctb, {
           verticesVisible,
           edgesVisible,
           facesVisible,
           colorAssignments,
           allColors
       }, colors);
   }

   const ttb = canvasUI.transformToolButton;
   if (ttb) {
       updateHtmlLabel({ id: 'transform-tool-label', content: C.UI_TRANSFORM_TOOL_LABEL_TEXT, x: ttb.x + ttb.width / 2, y: ttb.y + ttb.height / 2, color: colors.uiIcon, fontSize: C.UI_TRANSFORM_TOOL_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
   }

   const dtb = canvasUI.displayToolButton;
   if (dtb) {
       ctx.strokeStyle = colors.uiDefault;
       ctx.fillStyle = colors.uiDefault;
       ctx.lineWidth = C.UI_ICON_LINE_WIDTH;
       const barWidth = dtb.width - C.UI_DISPLAY_ICON_BAR_WIDTH_PADDING;
       for (let i = 0; i < 3; i++) {
           const y = dtb.y + C.UI_DISPLAY_ICON_Y_OFFSET + i * C.UI_DISPLAY_ICON_Y_SPACING;
           ctx.beginPath();
           ctx.moveTo(dtb.x + 6, y);
           ctx.lineTo(dtb.x + 6 + barWidth, y);
           ctx.stroke();
           ctx.beginPath();
           ctx.arc(dtb.x + 6 + barWidth * (i / 2), y, C.UI_DISPLAY_ICON_KNOB_RADIUS, 0, 2 * Math.PI);
           ctx.fill();
       }
   }

   const vtb = canvasUI.visibilityToolButton;
   if (vtb) {
       drawVisibilityIcon(ctx, vtb, colors);
   }

   const themeBtn = canvasUI.themeToggleButton;
   if (themeBtn) {
       drawThemeIcon(ctx, themeBtn, activeThemeName, colors);
   }
}

function drawTransformPanel(ctx, state) {
    const { canvasUI, colors } = state;
    canvasUI.transformIcons.forEach(icon => {
        drawUITransformationSymbols(ctx, icon, colors);
    });
}

function drawDisplayPanel(ctx, htmlOverlay, state, updateHtmlLabel) {
    const { canvasUI, colors, coordsDisplayMode, gridDisplayMode, angleDisplayMode, distanceDisplayMode, activeThemeName } = state;
    
    canvasUI.displayIcons.forEach(icon => {
        const rect = { x: icon.x, y: icon.y, width: icon.width, height: icon.height };
        switch (icon.group) {
            case 'coords':
                drawCoordsIcon(ctx, rect, coordsDisplayMode, coordsDisplayMode !== C.COORDS_DISPLAY_MODE_NONE, htmlOverlay, updateHtmlLabel, colors);
                break;
            case 'grid':
                drawGridIcon(ctx, rect, gridDisplayMode, gridDisplayMode !== C.GRID_DISPLAY_MODE_NONE, colors);
                break;
            case 'angles':
                drawAngleIcon(ctx, rect, angleDisplayMode, angleDisplayMode !== C.ANGLE_DISPLAY_MODE_NONE, htmlOverlay, updateHtmlLabel, colors);
                break;
            case 'distances':
                drawDistanceIcon(ctx, rect, distanceDisplayMode, distanceDisplayMode === C.DISTANCE_DISPLAY_MODE_ON, htmlOverlay, updateHtmlLabel, colors);
                break;
            case 'theme':
                drawThemeIcon(ctx, rect, activeThemeName, colors);
                break;
        }
    });
}

export function drawCanvasUI(ctx, htmlOverlay, state, updateHtmlLabel) {
    const { dpr, isToolbarExpanded, isColorPaletteExpanded, isTransformPanelExpanded, isDisplayPanelExpanded, isVisibilityPanelExpanded,
        isPlacingTransform, placingTransformType, placingSnapPos, mousePos, colors } = state;

    ctx.save();
    ctx.resetTransform();
    ctx.scale(dpr, dpr);

    if (isToolbarExpanded) {
        drawMainToolbar(ctx, htmlOverlay, state, updateHtmlLabel);
    } else {
        const btn = state.canvasUI.toolbarButton;
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = C.UI_MENU_ICON_LINE_WIDTH;
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
            const lineY = btn.y + 5 + i * 10;
            ctx.moveTo(btn.x + 4, lineY);
            ctx.lineTo(btn.x + btn.width - 4, lineY);
        }
        ctx.stroke();
    }

    if (isColorPaletteExpanded) {
        drawColorPalette(ctx, htmlOverlay, state, updateHtmlLabel);
    }
    if (isTransformPanelExpanded) {
        drawTransformPanel(ctx, state);
    }
    if (isDisplayPanelExpanded) {
        drawDisplayPanel(ctx, htmlOverlay, state, updateHtmlLabel);
    }
    if (isVisibilityPanelExpanded) {
        drawVisibilityPanel(ctx, htmlOverlay, state, updateHtmlLabel);
    }

    if (isPlacingTransform) {
        const finalDrawPos = placingSnapPos || mousePos;
        if (finalDrawPos) {
            const iconHalfSize = C.UI_GHOST_ICON_SIZE / 2;
            const ghostIcon = { type: placingTransformType, x: finalDrawPos.x - iconHalfSize, y: finalDrawPos.y - iconHalfSize, width: C.UI_GHOST_ICON_SIZE, height: C.UI_GHOST_ICON_SIZE };
            drawUITransformationSymbols(ctx, ghostIcon, colors);
        }
    }

    ctx.restore();
}

export function getIconPreviewColor(target, draggedColorTargetInfo, allColors, colors) {
    if (draggedColorTargetInfo && draggedColorTargetInfo.target === target && draggedColorTargetInfo.previewColorIndex !== undefined) {
        const colorIndex = draggedColorTargetInfo.previewColorIndex;
        if (colorIndex === -1) {
            return generateRandomColor();
        }
        const item = allColors[colorIndex];
        if (item?.type === 'color') {
            return item.value;
        } else if (item?.type === 'colormap') {
            return sampleColormap(item, 0.5);
        }
    }
    
    // Fallback to current assignment
    const colorIndex = colorAssignments[target];
    if (colorIndex === -1) {
        return C.UI_COLOR_TARGET_UNASSIGNED;
    }
    const item = allColors[colorIndex];
    if (!item) return colors.uiIcon;
    if (item.type === 'color') return item.value;
    return colors.uiIcon;
}

export function drawSelectedEdgeDistances(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showDistances, distanceSigFigs, colors, lastGridState, currentShiftPressed }, findVertexById, getEdgeId, dataToScreen, updateHtmlLabel, currentVertexStates = null, initialDragVertexStates = null, transformIndicatorData = null) {
    if (!showDistances || selectedEdgeIds.length === 0) return;
    
    selectedEdgeIds.forEach(edgeId => {
        const edge = allEdges.find(e => getEdgeId(e) === edgeId);
        if (edge) {
            let p1 = findVertexById(edge.id1);
            let p2 = findVertexById(edge.id2);
            
            if (currentVertexStates) {
                const p1State = currentVertexStates.find(p => p.id === edge.id1);
                const p2State = currentVertexStates.find(p => p.id === edge.id2);
                if (p1State) p1 = p1State;
                if (p2State) p2 = p2State;
            }
            
            if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
                let distanceText;
                const isTransforming = currentVertexStates && transformIndicatorData;

                if (edge.labelMode === 'exact' && edge.exactValue) {
                    const [coeff, radicand] = U.simplifySquareRoot(edge.exactValue.g2gSquaredSum);
                    let finalCoeff = edge.exactValue.gridInterval * coeff;
                    
                    // Only apply scale during a live transform preview
                    if (isTransforming && transformIndicatorData.transformType !== C.TRANSFORMATION_TYPE_ROTATION) {
                        const scale = transformIndicatorData.snappedScaleValue !== null ? transformIndicatorData.snappedScaleValue : transformIndicatorData.scale;
                        finalCoeff *= scale;
                    }
                    
                    distanceText = U.formatSimplifiedRoot(parseFloat(finalCoeff.toFixed(10)), radicand);
                } else {
                    // For 'decimal' mode or if data is missing, calculate the length
                    distanceText = U.formatNumber(U.distance(p1, p2), distanceSigFigs);
                }
                
                const p1Screen = dataToScreen(p1);
                const p2Screen = dataToScreen(p2);
                const midX = (p1Screen.x + p2Screen.x) / 2;
                const midY = (p1Screen.y + p2Screen.y) / 2;
                const edgeAngleScreen = Math.atan2(p2Screen.y - p1Screen.y, p2Screen.x - p1Screen.x);
                
                let textPerpAngle = edgeAngleScreen - Math.PI / 2;
                if (Math.sin(textPerpAngle) > 0) {
                    textPerpAngle += Math.PI;
                }
                
                const distanceTextX = midX + Math.cos(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                const distanceTextY = midY + Math.sin(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                
                let rotationDeg = edgeAngleScreen * (180 / Math.PI);
                if (rotationDeg > 90 || rotationDeg < -90) {
                    rotationDeg += 180;
                }
                
                updateHtmlLabel({ 
                    id: `selected-edge-dist-${edgeId}`, 
                    content: distanceText, 
                    x: distanceTextX, 
                    y: distanceTextY, 
                    color: `rgba(${colors.feedbackDefault.join(',')}, 1.0)`, 
                    fontSize: C.FEEDBACK_LABEL_FONT_SIZE, 
                    options: {  rotation: rotationDeg } 
                });
            }
        }
    });
}

export function drawSelectionRectangle(ctx, startPos, currentPos, colors) {
    ctx.save();
    ctx.strokeStyle = colors.mouseCoords;
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
    ctx.setLineDash(C.DASH_PATTERN);

    const rX = Math.min(startPos.x, currentPos.x);
    const rY = Math.min(startPos.y, currentPos.y);
    const rW = Math.abs(startPos.x - currentPos.x);
    const rH = Math.abs(startPos.y - currentPos.y);

    ctx.strokeRect(rX, rY, rW, rH);
    ctx.restore();
}

export function drawDragFeedback(ctx, htmlOverlay, targetVertexId, currentVertexStates, { lastGridState, showDistances, showAngles, distanceSigFigs, angleDisplayMode, angleSigFigs, currentShiftPressed, viewTransform, colors }, dataToScreen, findNeighbors, getEdgeId, isSnapping = false, excludedEdgeId = null, updateHtmlLabel = null, selectedVertexIds = [], isDragging = false, initialDragVertexStates = [], activeCenterId = null) {
    const feedbackColor = isSnapping ? colors.feedbackSnapped : `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;

    const liveVertices = new Map(currentVertexStates.map(p => [p.id, { ...p }]));
    const getLiveVertex = (id) => liveVertices.get(id);

    const vertex = getLiveVertex(targetVertexId);
    if (!vertex) return;

    const neighbors = findNeighbors(vertex.id).map(getLiveVertex).filter(Boolean);
    const vertexScreen = dataToScreen(vertex);
    const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

    const isVertexOnGrid = (vertex, interval) => {
        if (!vertex || !interval || interval <= 0) return false;
        const epsilon = interval * 1e-6;
        const isOnGridX = Math.abs(vertex.x / interval - Math.round(vertex.x / interval)) < epsilon;
        const isOnGridY = Math.abs(vertex.y / interval - Math.round(vertex.y / interval)) < epsilon;
        return isOnGridX && isOnGridY;
    };

    const allNeighborsAreDragged = neighbors.every(n => selectedVertexIds.includes(n.id));
    const originalVertexState = initialDragVertexStates.find(p => p.id === targetVertexId);

    if (!activeCenterId && isDragging && currentShiftPressed && allNeighborsAreDragged && originalVertexState && U.distance(originalVertexState, vertex) > C.GEOMETRY_CALCULATION_EPSILON) {
        const p1Screen = dataToScreen(originalVertexState);
        const p2Screen = vertexScreen;
        const dragVectorAngle = Math.atan2(p2Screen.y - p1Screen.y, p2Screen.x - p1Screen.x);
        const dataAngle = Math.atan2(vertex.y - originalVertexState.y, vertex.x - originalVertexState.x);

        if (showDistances) {
            let distText;
            const dragStartedOnGrid = gridInterval && isVertexOnGrid(originalVertexState, gridInterval);
            const dragEndedOnGrid = gridInterval && isVertexOnGrid(vertex, gridInterval);
            if (dragStartedOnGrid && dragEndedOnGrid) {
                const deltaX = vertex.x - originalVertexState.x;
                const deltaY = vertex.y - originalVertexState.y;
                const dx_grid = Math.round(deltaX / gridInterval);
                const dy_grid = Math.round(deltaY / gridInterval);
                const g2gSquaredSumForDisplay = dx_grid * dx_grid + dy_grid * dy_grid;
                if (g2gSquaredSumForDisplay === 0) {
                    distText = '0';
                } else {
                    const [coeff, radicand] = U.simplifySquareRoot(g2gSquaredSumForDisplay);
                    const finalCoeff = gridInterval * coeff;
                    const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                    distText = U.formatSimplifiedRoot(roundedFinalCoeff, radicand);
                }
            } else {
                const highPrecisionSigFigs = distanceSigFigs + 2;
                distText = U.formatNumber(U.distance(originalVertexState, vertex), highPrecisionSigFigs);
            }
            const midX = (p1Screen.x + p2Screen.x) / 2;
            const midY = (p1Screen.y + p2Screen.y) / 2;
            
            let textPerpAngle;
            if (showAngles && Math.abs(dataAngle) > C.GEOMETRY_CALCULATION_EPSILON) {
                const angleTurnScreen = -dataAngle;
                if (angleTurnScreen < 0) {
                    textPerpAngle = dragVectorAngle - Math.PI / 2;
                } else {
                    textPerpAngle = dragVectorAngle + Math.PI / 2;
                }
            } else {
                textPerpAngle = dragVectorAngle - Math.PI / 2;
                if (Math.sin(textPerpAngle) > 0) {
                    textPerpAngle += Math.PI;
                }
            }

            const distanceTextX = midX + Math.cos(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
            const distanceTextY = midY + Math.sin(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
            let rotationDeg = dragVectorAngle * (180 / Math.PI);
            if (rotationDeg > 90 || rotationDeg < -90) {
                rotationDeg += 180;
            }
            updateHtmlLabel({ id: `drag-dist-vector-${vertex.id}`, content: distText, x: distanceTextX, y: distanceTextY, color: feedbackColor, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: {  rotation: rotationDeg } }, htmlOverlay);
        }

        ctx.save();
        ctx.setLineDash([]);
        ctx.strokeStyle = feedbackColor;
        ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
        ctx.beginPath();
        ctx.moveTo(p1Screen.x, p1Screen.y);
        ctx.lineTo(p2Screen.x, p2Screen.y);
        ctx.stroke();
        ctx.restore();
        
        if (showAngles && Math.abs(dragVectorAngle) > C.GEOMETRY_CALCULATION_EPSILON) {
            drawAngleArc(ctx, p1Screen, 0, dataAngle, C.FEEDBACK_ARC_RADIUS_SCREEN, feedbackColor);
            
            let angleText;
            if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
                angleText = `${U.formatNumber(dataAngle * (180 / Math.PI), angleSigFigs)}^{\\circ}`;
            } else {
                angleText = U.formatNumber(dataAngle, angleSigFigs);
            }

            if (angleText) {
                const bisectorAngleRad = -dataAngle / 2.0;
                const offset = C.UI_ANGLE_LABEL_OFFSET;

                const rotatedPoint = {
                    x: offset * Math.cos(bisectorAngleRad),
                    y: offset * Math.sin(bisectorAngleRad)
                };
                const labelScreenPos = {
                    x: p1Screen.x + rotatedPoint.x,
                    y: p1Screen.y + rotatedPoint.y
                };

                let rotationDeg = bisectorAngleRad * (180 / Math.PI);
                if (rotationDeg > 90 || rotationDeg < -90) {
                    rotationDeg += 180;
                }

                updateHtmlLabel({
                    id: `drag-angle-vector-${vertex.id}`,
                    content: angleText,
                    x: labelScreenPos.x,
                    y: labelScreenPos.y,
                    color: feedbackColor,
                    fontSize: C.FEEDBACK_LABEL_FONT_SIZE,
                    options: { rotation: rotationDeg }
                }, htmlOverlay);
            }
        }
    }
    
    if (showDistances) {
        neighbors.forEach(neighbor => {
            const isNeighborSelected = selectedVertexIds.includes(neighbor.id);
            if (!isDragging || !isNeighborSelected) {
                const p1 = vertex;
                const p2 = neighbor;
                const edgeId = getEdgeId({ id1: p1.id, id2: p2.id });
                let distanceText;
                const areBothVerticesOnGrid = gridInterval && isVertexOnGrid(p1, gridInterval) && isVertexOnGrid(p2, gridInterval);

                if (areBothVerticesOnGrid) {
                    const deltaX = p1.x - p2.x;
                    const deltaY = p1.y - p2.y;
                    const dx_grid = Math.round(deltaX / gridInterval);
                    const dy_grid = Math.round(deltaY / gridInterval);
                    const g2gSquaredSumForDisplay = dx_grid * dx_grid + dy_grid * dy_grid;
                    if (g2gSquaredSumForDisplay === 0) {
                        distanceText = '0';
                    } else {
                        const [coeff, radicand] = U.simplifySquareRoot(g2gSquaredSumForDisplay);
                        const finalCoeff = gridInterval * coeff;
                        const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                        distanceText = U.formatSimplifiedRoot(roundedFinalCoeff, radicand);
                    }
                } else {
                    const edgeLength = U.distance(p1, p2);
                    distanceText = U.formatNumber(edgeLength, distanceSigFigs);
                }
                
                const p1Screen = dataToScreen(p1);
                const p2Screen = dataToScreen(p2);
                const midX = (p1Screen.x + p2Screen.x) / 2;
                const midY = (p1Screen.y + p2Screen.y) / 2;
                const edgeAngleScreen = Math.atan2(p2Screen.y - p1Screen.y, p2Screen.x - p1Screen.x);
                
                let textPerpAngle = edgeAngleScreen - Math.PI / 2;
                if (Math.sin(textPerpAngle) > 0) {
                    textPerpAngle += Math.PI;
                }
                
                const distanceTextX = midX + Math.cos(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                const distanceTextY = midY + Math.sin(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                
                let rotationDeg = edgeAngleScreen * (180 / Math.PI);
                if (rotationDeg > 90 || rotationDeg < -90) {
                    rotationDeg += 180;
                }
                
                updateHtmlLabel({ 
                    id: `drag-dist-${edgeId}`, 
                    content: distanceText, 
                    x: distanceTextX, 
                    y: distanceTextY, 
                    color: feedbackColor, 
                    fontSize: C.FEEDBACK_LABEL_FONT_SIZE, 
                    options: {  rotation: rotationDeg } 
                });
            }
        });
    }
    
    if (showAngles && neighbors.length >= 2 && (!isDragging || neighbors.some(n => !selectedVertexIds.includes(n.id)))) {
        const sortedNeighbors = [...neighbors].sort((a, b) => {
            const angleA = Math.atan2(a.y - vertex.y, a.x - vertex.x);
            const angleB = Math.atan2(b.y - vertex.y, b.x - vertex.x);
            return angleA - angleB;
        });

        for (let i = 0; i < sortedNeighbors.length; i++) {
            const p1 = sortedNeighbors[i];
            const p2 = sortedNeighbors[(i + 1) % sortedNeighbors.length];
            
            const p1IsSelected = selectedVertexIds.includes(p1.id);
            const p2IsSelected = selectedVertexIds.includes(p2.id);
            const angleIsChanging = !isDragging || !p1IsSelected || !p2IsSelected;
            
            if (!angleIsChanging) continue;
            
            const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };
            const v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };
            const angle1_data = Math.atan2(v1.y, v1.x);
            const angle2_data = Math.atan2(v2.y, v2.x);
            let angleToDisplayRad = angle2_data - angle1_data;
            if (angleToDisplayRad < 0) {
                angleToDisplayRad += 2 * Math.PI;
            }
            if (angleToDisplayRad < C.GEOMETRY_CALCULATION_EPSILON) continue;
            
            const bisectorAngle = angle1_data + (angleToDisplayRad / 2);
            ctx.save();
            ctx.strokeStyle = feedbackColor;
            ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
            ctx.beginPath();
            ctx.arc(vertexScreen.x, vertexScreen.y, C.FEEDBACK_ARC_RADIUS_SCREEN, -angle1_data, -angle2_data, false);
            ctx.stroke();
            ctx.restore();

            let angleText;
            if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
                angleText = `${U.formatNumber(angleToDisplayRad * (180 / Math.PI), angleSigFigs)}^{\\circ}`;
            } else if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_RADIANS) {
                if (currentShiftPressed) {
                    angleText = U.formatFraction(angleToDisplayRad / Math.PI, 0.015, 32) + "\\pi";
                    if (angleText.startsWith(`1\\pi`)) angleText = "\\pi";
                    if (angleText.startsWith(`-1\\pi`)) angleText = `-\\pi`;
                    if (angleText === `0\\pi`) angleText = "0";
                } else {
                    angleText = U.formatNumber(angleToDisplayRad, angleSigFigs);
                }
            }

            if (angleText) {
                const labelId = `drag-angle-${vertex.id}-${p1.id}-${p2.id}`;
                
                const pointOnBisectorData = {
                    x: vertex.x + Math.cos(bisectorAngle),
                    y: vertex.y + Math.sin(bisectorAngle)
                };
                const pointOnBisectorScreen = dataToScreen(pointOnBisectorData);
                const screenBisectorAngleRad = Math.atan2(pointOnBisectorScreen.y - vertexScreen.y, pointOnBisectorScreen.x - vertexScreen.x);

                const offset = C.UI_ANGLE_LABEL_OFFSET;

                const rotatedPoint = {
                    x: offset * Math.cos(screenBisectorAngleRad),
                    y: offset * Math.sin(screenBisectorAngleRad)
                };
                const labelScreenPos = {
                    x: vertexScreen.x + rotatedPoint.x,
                    y: vertexScreen.y + rotatedPoint.y
                };

                let rotationDeg = screenBisectorAngleRad * (180 / Math.PI);
                if (rotationDeg > 90 || rotationDeg < -90) {
                    rotationDeg += 180;
                }

                updateHtmlLabel({
                    id: labelId,
                    content: angleText,
                    x: labelScreenPos.x,
                    y: labelScreenPos.y,
                    color: feedbackColor,
                    fontSize: C.FEEDBACK_LABEL_FONT_SIZE,
                    options: { rotation: rotationDeg }
                }, htmlOverlay);
            }
        }
    }
}

export function drawSelectedEdgeAngles(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showAngles, angleSigFigs, angleDisplayMode, currentShiftPressed, distanceSigFigs, viewTransform, lastGridState, colors }, findVertexById, getEdgeId, dataToScreen, findNeighbors, updateHtmlLabel) {
    if (!showAngles || selectedEdgeIds.length === 0) return;
    
    selectedEdgeIds.forEach(edgeId => {
        const edge = allEdges.find(e => getEdgeId(e) === edgeId);
        if (edge) {
            const p1 = findVertexById(edge.id1);
            const p2 = findVertexById(edge.id2);
            if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
                const feedbackState = {
                    lastGridState,
                    showDistances: false,
                    showAngles: true,
                    distanceSigFigs,
                    angleDisplayMode,
                    angleSigFigs,
                    currentShiftPressed,
                    viewTransform,
                    colors
                };
                
                drawDragFeedback(ctx, htmlOverlay, p1.id, [p1, p2], feedbackState, dataToScreen, findNeighbors, getEdgeId, false, null, updateHtmlLabel);
                drawDragFeedback(ctx, htmlOverlay, p2.id, [p1, p2], feedbackState, dataToScreen, findNeighbors, getEdgeId, false, null, updateHtmlLabel);
            }
        }
    });
}

export function drawFaceCoordinateSystems(ctx, { allFaces, selectedFaceIds, colors, isDragConfirmed, dragPreviewVertices, initialDragVertexStates, transformIndicatorData, highlightedEdgeForSnap, draggedFaceId, coordSystemSnapAngle, coordSystemSnapType, coordSystemSnapScale, initialCoordSystemStates }, dataToScreen, findVertexById) {
    if (selectedFaceIds.length > C.MAX_FACES_FOR_COORDS) return;

    const facesToDraw = new Set(selectedFaceIds);
    if (facesToDraw.size === 0) return;

    facesToDraw.forEach(faceId => {
        const face = allFaces.find(f => f.id === faceId);
        if (!face || !face.localCoordSystem) return;

        let systemToDraw = face.localCoordSystem;

        if (isDragConfirmed && face.vertexIds.some(vid => dragPreviewVertices.some(pv => pv.id === vid))) {
            const initialSystem = initialCoordSystemStates.get(face.id);
            systemToDraw = calculatePreviewCoordSystem(face, { initialSystem, dragPreviewVertices, initialDragVertexStates, findVertexById, transformIndicatorData });
        }
        
        if (draggedFaceId === faceId && coordSystemSnapAngle !== null) {
            const getLiveVertex = (vertexId) => {
                if (isDragConfirmed && dragPreviewVertices) {
                    const previewVertex = dragPreviewVertices.find(p => p && p.id === vertexId);
                    if (previewVertex) return previewVertex;
                }
                return findVertexById(vertexId);
            };

            const originScreen = dataToScreen(systemToDraw.origin);
            
            if (coordSystemSnapType === 'edge' && highlightedEdgeForSnap !== null) {
                const faceVertices = face.vertexIds.map(id => getLiveVertex(id)).filter(p => p && p.type === 'regular');
                if (highlightedEdgeForSnap < faceVertices.length) {
                    const edgeStart = faceVertices[highlightedEdgeForSnap];
                    const edgeEnd = faceVertices[(highlightedEdgeForSnap + 1) % faceVertices.length];
                    const startScreen = dataToScreen(edgeStart);
                    const endScreen = dataToScreen(edgeEnd);
                    
                    ctx.save();
                    ctx.strokeStyle = colors.feedbackSnapped;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(startScreen.x, startScreen.y);
                    ctx.lineTo(endScreen.x, endScreen.y);
                    ctx.stroke();
                    ctx.restore();
                }
            } else if (coordSystemSnapType === 'cardinal') {
                const lineLength = 100;
                const lineEndX = originScreen.x + Math.cos(-coordSystemSnapAngle) * lineLength;
                const lineEndY = originScreen.y + Math.sin(-coordSystemSnapAngle) * lineLength;
                const lineStartX = originScreen.x - Math.cos(-coordSystemSnapAngle) * lineLength;
                const lineStartY = originScreen.y - Math.sin(-coordSystemSnapAngle) * lineLength;
                
                ctx.save();
                ctx.strokeStyle = colors.feedbackSnapped;
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(lineStartX, lineStartY);
                ctx.lineTo(lineEndX, lineEndY);
                ctx.stroke();
                ctx.restore();
            }
        }

        drawCoordinateSystemCross(ctx, systemToDraw, colors, dataToScreen, coordSystemSnapScale);
    });
}

function drawCoordinateSystemCross(ctx, coordSystem, colors, dataToScreen, coordSystemSnapScale = null) {
    const centerScreen = dataToScreen(coordSystem.origin);

    const xAxisEndGlobal = U.localToGlobal({ x: 1, y: 0 }, coordSystem);
    const yAxisEndGlobal = U.localToGlobal({ x: 0, y: 1 }, coordSystem);
    const xAxisScreenEnd = dataToScreen(xAxisEndGlobal);
    const yAxisScreenEnd = dataToScreen(yAxisEndGlobal);

    ctx.save();
    ctx.lineWidth = C.SELECTION_GLOW_LINE_WIDTH;
    ctx.lineCap = 'round';

    const drawArrow = (p1, p2, lineColor, arrowColor) => {
        // Draw line
        ctx.strokeStyle = lineColor;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();

        // Draw arrowhead
        ctx.fillStyle = arrowColor;
        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
        ctx.beginPath();
        ctx.moveTo(p2.x, p2.y);
        ctx.lineTo(p2.x - C.AXIS_ARROW_SIZE * Math.cos(angle - C.AXIS_ARROW_ANGLE_RAD), p2.y - C.AXIS_ARROW_SIZE * Math.sin(angle - C.AXIS_ARROW_ANGLE_RAD));
        ctx.lineTo(p2.x - C.AXIS_ARROW_SIZE * Math.cos(angle + C.AXIS_ARROW_ANGLE_RAD), p2.y - C.AXIS_ARROW_SIZE * Math.sin(angle + C.AXIS_ARROW_ANGLE_RAD));
        ctx.closePath();
        ctx.fill();
    };

    // Determine arrow colors based on snap state
    const xColor = coordSystemSnapScale !== null ? colors.feedbackSnapped : colors.coordSysX;
    const yColor = coordSystemSnapScale !== null ? colors.feedbackSnapped : colors.coordSysY;

    drawArrow(centerScreen, xAxisScreenEnd, xColor, xColor);
    drawArrow(centerScreen, yAxisScreenEnd, yColor, yColor);

    ctx.fillStyle = colors.coordSysOrigin;
    ctx.beginPath();
    ctx.arc(centerScreen.x, centerScreen.y, C.FACE_COORD_SYSTEM_ORIGIN_RADIUS, 0, 2 * Math.PI);
    ctx.fill();

    ctx.restore();
}


=== script.js ===
import ColormapSelector from './node_modules/colormap-selector/ColormapSelector.js';
import './node_modules/colormap-selector/styles.css';

import * as C from './constants.js';
import * as U from './utils.js';
import * as R from './renderer.js';

const canvas = document.getElementById('drawingCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const htmlOverlay = document.getElementById('html-overlay');
const dpr = window.devicePixelRatio || 1;
const activeHtmlLabels = new Map();
let colorEditor;
const canvasUI = {
    toolbarButton: null,
    mainToolbar: null,
    colorToolButton: null,
    colorSwatches: [],
    addColorButton: null,
    transformToolButton: null,
    transformIcons: [],
    displayToolButton: null,
    displayIcons: [],
    themeToggleButton: null,
    symmetryToolButton: null,
    symmetryIcons: []
};

let contextMenu;
let contextMenuVertexId = null;
let contextMenuEdgeId = null;
let contextMenuFaceId = null;
let componentDrawOrder = [];

let drawingSnapLabelInfo = null;
let initialCoordSystemStateOnDrag = null;
let initialCoordSystemStates = new Map();
let coordSystemTransformIndicatorData = null;
let highlightedEdgeForSnap = null;
let coordSystemSnapAngle = null;
let draggedFaceId = null;
let coordSystemSnapType = null;
let coordSystemSnapScale = null;

let isDraggingColorTarget = false;
let draggedColorTargetInfo = null;

let currentDrawingPath = [];
let frozenReference_A_rad = null;
let frozenReference_A_baseRad = null;
let frozenReference_D_du = null;
let frozenReference_Origin_Data = null;
let isMouseOverCanvas = false;
let placingSnapPos = null;
let isDisplayPanelExpanded = false;
let isVisibilityPanelExpanded = false;
let coordsDisplayMode = 'regular';
let gridDisplayMode = 'lines';
let angleDisplayMode = 'degrees';
let distanceDisplayMode = 'on';
let verticesVisible = true;
let edgesVisible = true;
let facesVisible = true;

let hoveredVertexId = null;
let hoveredEdgeId = null;
let hoveredFaceId = null;
let isEdgeTransformDrag = false;
let isDraggingCenter = false;
let allVertices = [];
let allEdges = [];
let allFaces = [];
let snappedEdgeIds = new Map();
let snappedVertexIds = new Map();
let selectedVertexIds = [];
let selectedEdgeIds = [];
let selectedFaceIds = [];
let activeCenterId = null;
let mousePos = { x: 0, y: 0 };

let frozenReference_D_g2g = null;
let isToolbarExpanded = false;
let isColorPaletteExpanded = false;
let isEditingColor = false;
let editingColorIndex = null;
let isTransformPanelExpanded = false;
let isPlacingTransform = false;
let placingTransformType = null;
let drawingSequence = [];
let currentSequenceIndex = 0;
let showAngles = true;
let showDistances = true;
let altHoverInfo = null;
let angleSigFigs = 4;
let distanceSigFigs = 3;
let gridAlpha = 0.5;
let transformIndicatorData = null;
let isActionInProgress = false;
let isDragConfirmed = false;
let isPanningBackground = false;
let isRectangleSelecting = false;
let currentMouseButton = -1;
let actionStartPos = { x: 0, y: 0 };
let backgroundPanStartOffset = { x: 0, y: 0 };
let initialDragVertexStates = [];
let rectangleSelectStartPos = { x: 0, y: 0 };
let actionContext = null;
let allColors = C.DEFAULT_RECENT_COLORS;
let isDrawingMode = false;
let previewLineStartVertexId = null;
let actionTargetVertex = null;
let dragPreviewVertices = [];
let currentShiftPressed = false;
let clipboard = { vertices: [], edges: [], faces: [], referenceVertex: null };
let clickData = { targetId: null, type: null, count: 0, timestamp: 0 };
let undoStack = [];
let currentAltPressed = false;

function setupUndoStackDebugging() {
    const originalPop = Array.prototype.pop;
    const originalPush = Array.prototype.push;
    const originalShift = Array.prototype.shift;
    const originalSplice = Array.prototype.splice;

    undoStack.pop = function() {
        const result = originalPop.call(this);
        return result;
    };

    undoStack.push = function(...args) {
        const result = originalPush.call(this, ...args);
        return result;
    };

    undoStack.shift = function() {
        const result = originalShift.call(this);
        return result;
    };

    undoStack.splice = function(...args) {
        const result = originalSplice.call(this, ...args);
        return result;
    };
}


let isMouseOverColorEditor = false;
let redoStack = [];
let ghostVertexPosition = null;
let selectedCenterIds = [];
let copyCountInput = '';
let copyCountTimer = null;
let ghostVertices = [];
let currentAccumulatedRotation = 0;
let lastGridState = {
    interval1: null,
    interval2: null,
    alpha1: 0,
    alpha2: 0,
    scale: null
};
let viewTransform = {
    scale: C.DEFAULT_CALIBRATION_VIEW_SCALE,
    offsetX: 0,
    offsetY: 0
};
let lastAngularGridState = {
    angle1: 30,
    angle2: 15,
    alpha1: 1,
    alpha2: 0,
};
let labelsToKeepThisFrame = new Set();
let activeThemeName = 'dark';

let activeColorTargets = [];
let isDraggingColorSwatch = false;
let draggedSwatchInfo = null;

let colorAssignments = {
    [C.COLOR_TARGET_VERTEX]: 0,
    [C.COLOR_TARGET_EDGE]: 1,
    [C.COLOR_TARGET_FACE]: 2,
};

let isDraggingCoordSystem = false;
let draggedCoordSystemElement = null;
let coordSystemSnapTargets = null;

let deletedFaceIds = new Set(); // Track explicitly deleted faces
let draggedSwatchTemporarilyRemoved = false;


function ensureFaceCoordinateSystems() {
    U.updateFaceLocalCoordinateSystems(allFaces, findVertexById);
}

function getColors() {
    const theme = U.getCurrentTheme(activeThemeName, C.DARK_THEME);
    return theme;
}

function getColorForTarget(targetType, index = 0, total = 1) {
    let colorIndex = colorAssignments[targetType];

    // Safeguard: If the index is invalid for any reason, default to the first color.
    if (colorIndex < 0 || colorIndex >= allColors.length) {
        colorIndex = 0;
    }

    const item = allColors[colorIndex];
    if (item?.type === 'color') {
        return item.value;
    } else if (item?.type === 'colormap') {
        const t = total > 1 ? index / (total - 1) : 0.5;
        return U.sampleColormap(item, t);
    }
    
    // Fallback to theme defaults if something is still wrong
    const colors = getColors();
    if (targetType === C.COLOR_TARGET_VERTEX) return colors.vertex;
    if (targetType === C.COLOR_TARGET_EDGE) return colors.edge;
    if (targetType === C.COLOR_TARGET_FACE) return colors.face;
    
    return colors.vertex;
}

function applyColorsToSelection() {

    activeColorTargets.forEach(target => {
        const colorIndex = colorAssignments[target];

        if (target === C.COLOR_TARGET_VERTEX) {
            const colorItem = allColors[colorIndex];
            if (colorItem && colorItem.type === 'colormap') {
                const verticesToColor = selectedVertexIds.map(id => findVertexById(id)).filter(p => p && p.type === 'regular');
                verticesToColor.forEach((vertex, index) => {
                    const t = verticesToColor.length > 1 ? index / (verticesToColor.length - 1) : 0.5;
                    vertex.color = U.sampleColormap(colorItem, t);
                });
            } else {
                selectedVertexIds.forEach(id => {
                    const vertex = findVertexById(id);
                    if (vertex && vertex.type === 'regular') {
                        vertex.color = getColorForTarget(C.COLOR_TARGET_VERTEX);
                    }
                });
            }
        } else if (target === C.COLOR_TARGET_EDGE) {
            const colorItem = allColors[colorIndex];
            if (colorItem && colorItem.type === 'colormap') {
                selectedEdgeIds.forEach((edgeId, index) => {
                    const edge = allEdges.find(e => U.getEdgeId(e) === edgeId);
                    if (edge) {
                        const totalEdges = selectedEdgeIds.length;
                        const startT = totalEdges > 1 ? index / totalEdges : 0;
                        const endT = totalEdges > 1 ? (index + 1) / totalEdges : 1;
                        edge.gradientStart = startT;
                        edge.gradientEnd = endT;
                        edge.colormapItem = colorItem;
                        delete edge.color;
                    }
                });
            } else {
                const color = getColorForTarget(C.COLOR_TARGET_EDGE);
                allEdges.forEach(edge => {
                    if (selectedEdgeIds.includes(U.getEdgeId(edge))) {
                        edge.color = color;
                        delete edge.gradientStart;
                        delete edge.gradientEnd;
                        delete edge.colormapItem;
                    }
                });
            }
        } else if (target === C.COLOR_TARGET_FACE) {
            const colorIndex = colorAssignments[target];
            if (colorIndex === -1) {
                const color = getColorForTarget(C.COLOR_TARGET_FACE);
                allFaces.forEach(face => {
                    if (selectedFaceIds.includes(U.getFaceId(face))) {
                        face.color = color;
                        delete face.colormapItem;
                        delete face.colormapDistribution;
                    }
                });
            } else {
                const colorItem = allColors[colorIndex];
                if (colorItem && colorItem.type === 'colormap') {
                    allFaces.forEach(face => {
                        if (selectedFaceIds.includes(U.getFaceId(face))) {
                            face.colormapItem = colorItem;
                            face.colormapDistribution = 'x'; // Default to x-direction
                            delete face.color;
                        }
                    });
                } else {
                    const color = getColorForTarget(C.COLOR_TARGET_FACE);
                    allFaces.forEach(face => {
                        if (selectedFaceIds.includes(U.getFaceId(face))) {
                            face.color = color;
                            delete face.colormapItem;
                            delete face.colormapDistribution;
                        }
                    });
                }
            }
        }
    });
}

function updateHtmlLabel({ id, content, x, y, color, fontSize, options = {} }) {
    labelsToKeepThisFrame.add(id);
    let el = activeHtmlLabels.get(id);

    if (!el) {
        el = document.createElement('div');
        el.style.position = 'absolute';
        el.style.fontFamily = 'KaTeX_Main, Times New Roman, serif';
        el.style.whiteSpace = 'nowrap';
        htmlOverlay.appendChild(el);
        activeHtmlLabels.set(id, el);
    }

    let translateX = '-50%';
    let translateY = '-50%';
    let transformOrigin = 'center';

    switch (options.textAlign) {
        case 'left': translateX = '0%'; break;
        case 'right': translateX = '-100%'; break;
    }

    switch (options.textBaseline) {
        case 'top': translateY = '0%'; break;
        case 'bottom': translateY = '-100%'; break;
    }

    // Adjust origin for rotations to feel more natural with alignment
    if (options.textAlign === 'left' && options.textBaseline === 'top') transformOrigin = 'top left';
    else if (options.textAlign === 'right' && options.textBaseline === 'top') transformOrigin = 'top right';
    else if (options.textAlign === 'left' && options.textBaseline === 'bottom') transformOrigin = 'bottom left';
    else if (options.textAlign === 'right' && options.textBaseline === 'bottom') transformOrigin = 'bottom right';


    el.style.left = `${x}px`;
    el.style.top = `${y}px`;
    el.style.transformOrigin = transformOrigin;
    el.style.transform = `translate(${translateX}, ${translateY}) rotate(${options.rotation || 0}deg)`;
    
    el.style.color = color;
    el.style.fontSize = `${fontSize}px`;

    if (el.katexContent !== content) {
        if (typeof window.katex !== 'undefined') {
            katex.render(content, el, {
                throwOnError: false,
                displayMode: false
            });
        } else {
            el.textContent = content.replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, "$1/$2").replace(/[\\{}]/g, "");
        }
        el.katexContent = content;
    }
}

function cleanupHtmlLabels() {
    for (const [id, el] of activeHtmlLabels.entries()) {
        if (!labelsToKeepThisFrame.has(id)) {
            el.remove();
            activeHtmlLabels.delete(id);
        }
    }
}

function handleCenterSelection(centerId, shiftKey, ctrlKey) {
    if (ctrlKey) {
        const index = selectedCenterIds.indexOf(centerId);
        if (index > -1) {
            selectedCenterIds.splice(index, 1);
            if (activeCenterId === centerId) {
                activeCenterId = selectedCenterIds.length > 0 ? selectedCenterIds[selectedCenterIds.length - 1] : null;
            }
        } else {
            selectedCenterIds.push(centerId);
            activeCenterId = centerId;
        }
    } else if (shiftKey) {
        if (!selectedCenterIds.includes(centerId)) {
            selectedCenterIds.push(centerId);
            activeCenterId = centerId;
        }
    } else {
        selectedCenterIds = [centerId];
        activeCenterId = centerId;
    }
}

function getBestSnapPosition(mouseDataPos) {
    const candidates = U.getGridSnapCandidates(mouseDataPos, gridDisplayMode, lastGridState.interval1, lastAngularGridState, true);

    allVertices.forEach(p => {
        if (p.type === 'regular') {
            candidates.push({ x: p.x, y: p.y, isGridVertex: false });
        }
    });

    allEdges.forEach(edge => {
        const p1 = findVertexById(edge.id1);
        const p2 = findVertexById(edge.id2);
        if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
            const midvertex = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2, isGridVertex: false };
            candidates.push(midvertex);
        }
    });

    if (candidates.length === 0) {
        return null;
    }

    const distanceSq = (p1, p2) => (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;

    return candidates.reduce((best, current) => {
        const bestDist = distanceSq(mouseDataPos, best);
        const currentDist = distanceSq(mouseDataPos, current);
        return currentDist < bestDist ? current : best;
    });
}

function updateComponentDrawOrder() {
    const allVertexIds = new Set(allVertices.map(v => v.id));
    const visited = new Set();
    const newComponents = [];

    for (const vertexId of allVertexIds) {
        if (!visited.has(vertexId)) {
            const component = findAllVerticesInSubgraph(vertexId);
            const componentSet = new Set(component);
            newComponents.push(componentSet);
            component.forEach(id => visited.add(id));
        }
    }

    const key = (component) => [...component].sort().join(',');

    const newComponentOrder = [];
    const usedNewComponents = new Set();

    componentDrawOrder.forEach(oldComponent => {
        const oldKey = key(oldComponent);
        let foundMatch = false;
        for (let i = 0; i < newComponents.length; i++) {
            if (usedNewComponents.has(i)) continue;
            const newComponent = newComponents[i];
            if (oldKey === key(newComponent)) {
                newComponentOrder.push(newComponent);
                usedNewComponents.add(i);
                foundMatch = true;
                break;
            }
        }
    });

    for (let i = 0; i < newComponents.length; i++) {
        if (!usedNewComponents.has(i)) {
            newComponentOrder.push(newComponents[i]);
        }
    }

    componentDrawOrder = newComponentOrder;
}

function drawComponent(componentVertexIds, colors) {
    const copyCount = parseInt(copyCountInput || '1', 10);
    const isDeformingDrag = isDragConfirmed && currentShiftPressed && initialDragVertexStates.length === 1 && initialDragVertexStates[0].type === 'regular';
    const deformingCopyVertexId = (isDeformingDrag && copyCount > 1) ? initialDragVertexStates[0].id : null;

    let componentFaces = allFaces.filter(f => f.vertexIds.every(id => componentVertexIds.has(id)));
    if (deformingCopyVertexId) {
        componentFaces = componentFaces.filter(f => !f.vertexIds.includes(deformingCopyVertexId));
    }

    R.drawFaces(ctx, {
        allFaces: componentFaces, facesVisible, isDragConfirmed, 
        dragPreviewVertices, transformIndicatorData, initialDragVertexStates, 
        colors, initialCoordSystemStates
    }, dataToScreen, findVertexById);

    let componentEdges = allEdges.filter(e => componentVertexIds.has(e.id1) && componentVertexIds.has(e.id2));
    if (deformingCopyVertexId) {
        componentEdges = componentEdges.filter(e => e.id1 !== deformingCopyVertexId && e.id2 !== deformingCopyVertexId);
    }
    const edgesWithHover = hoveredEdgeId ? [...new Set([...selectedEdgeIds, hoveredEdgeId])] : selectedEdgeIds;
    R.drawAllEdges(ctx, {
        allEdges: componentEdges, selectedEdgeIds: edgesWithHover, isDragConfirmed, 
        dragPreviewVertices: deformingCopyVertexId ? [] : dragPreviewVertices, 
        colors, edgesVisible, snappedEdgeIds
    }, dataToScreen, findVertexById, U.getEdgeId);

    const componentVertices = allVertices.filter(v => componentVertexIds.has(v.id));
    componentVertices.forEach(vertex => {
        if (deformingCopyVertexId && vertex.id === deformingCopyVertexId) {
            return;
        }

        let vertexToDraw = { ...vertex };
        if (isDragConfirmed && dragPreviewVertices.length > 0) {
            const preview = dragPreviewVertices.find(dp => dp.id === vertex.id);
            if (preview) vertexToDraw = { ...preview };
        }

        let isSnapped = false;
        if (snappedVertexIds.has(vertex.id)) {
            const indices = snappedVertexIds.get(vertex.id);
            if (indices.has(undefined) || indices.has(0)) {
                isSnapped = true;
            }
        }

        R.drawVertex(ctx, vertexToDraw, { 
            selectedVertexIds, selectedCenterIds, activeCenterId, colors, 
            verticesVisible, isHovered: hoveredVertexId === vertex.id, isSnapped: isSnapped 
        }, dataToScreen, updateHtmlLabel);
    });
}

function getSnappedPosition(startVertex, mouseScreenPos, shiftPressed, isDragContext = false, overrideContext = null) {
    const mouseDataPos = screenToData(mouseScreenPos);
    const drawingContext = overrideContext || getDrawingContext(startVertex.id);

    if (!shiftPressed) {
        const candidates = [];
        const vertexSelectRadiusData = C.VERTEX_SELECT_RADIUS / viewTransform.scale;
        const edgeClickThresholdData = C.EDGE_CLICK_THRESHOLD / viewTransform.scale;

        for (const p of allVertices) {
            if (p.id !== startVertex.id && p.type === "regular" && U.distance(mouseDataPos, p) < vertexSelectRadiusData) {
                candidates.push({ priority: 1, dist: U.distance(mouseDataPos, p), pos: { x: p.x, y: p.y }, snapType: 'vertex', targetVertex: p });
            }
        }

        for (const edge of allEdges) {
            const p1 = findVertexById(edge.id1);
            const p2 = findVertexById(edge.id2);
            if (p1 && p2 && p1.type === "regular" && p2.type === "regular") {
                const closest = U.getClosestPointOnLineSegment(mouseDataPos, p1, p2);
                if (closest.distance < edgeClickThresholdData && closest.onSegmentStrict) {
                    candidates.push({ priority: 2, dist: closest.distance, pos: { x: closest.x, y: closest.y }, snapType: 'edge', targetEdge: edge });
                }
            }
        }

        if (candidates.length > 0) {
            candidates.sort((a, b) => {
                if (a.priority !== b.priority) return a.priority - b.priority;
                return a.dist - b.dist;
            });
            const bestCandidate = candidates[0];
            const finalAngleRad = Math.atan2(bestCandidate.pos.y - startVertex.y, bestCandidate.pos.x - startVertex.x) || 0;
            return {
                ...bestCandidate.pos,
                angle: finalAngleRad * (180 / Math.PI),
                distance: U.distance(startVertex, bestCandidate.pos),
                snapped: true,
                snapType: bestCandidate.snapType,
                targetEdge: bestCandidate.targetEdge,
                targetVertex: bestCandidate.targetVertex,
                gridSnapped: false,
                lengthSnapFactor: null,
                angleSnapFactor: null,
                angleTurn: U.normalizeAngleToPi(finalAngleRad - drawingContext.offsetAngleRad),
                gridToGridSquaredSum: null,
                gridInterval: null
            };
        }

        const finalAngleRad = Math.atan2(mouseDataPos.y - startVertex.y, mouseDataPos.x - startVertex.x) || 0;
        return {
            x: mouseDataPos.x, y: mouseDataPos.y,
            angle: finalAngleRad * (180 / Math.PI),
            distance: U.distance(startVertex, mouseDataPos),
            snapped: false, gridSnapped: false, lengthSnapFactor: null, angleSnapFactor: null,
            angleTurn: U.normalizeAngleToPi(finalAngleRad - drawingContext.offsetAngleRad),
            gridToGridSquaredSum: null, gridInterval: null
        };
    } else {
        const highPriorityCandidates = [];
        const generalCandidates = [];
        const stickyRadius = C.VERTEX_SELECT_RADIUS / viewTransform.scale;

        allVertices.forEach(p => {
            if (p.id !== startVertex.id && p.type === 'regular') {
                const dist = U.distance(mouseDataPos, p);
                if (dist < stickyRadius) {
                    highPriorityCandidates.push({ pos: p, type: 'vertex', sourceVertex: p, dist: dist });
                }
            }
        });

        allEdges.forEach(edge => {
            const p1 = findVertexById(edge.id1);
            const p2 = findVertexById(edge.id2);
            if (p1 && p2 && p1.type === "regular" && p2.type === "regular") {
                C.ALT_SNAP_FRACTIONS.forEach(t => {
                    if (t > C.ON_SEGMENT_STRICT_T_MIN && t < C.ON_SEGMENT_STRICT_T_MAX) {
                        const fracPoint = { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
                        const dist = U.distance(mouseDataPos, fracPoint);
                        if (dist < stickyRadius) {
                            highPriorityCandidates.push({ pos: fracPoint, type: 'edge_fraction', targetEdge: edge, fraction: t, dist: dist });
                        }
                    }
                });
            }
        });

        let bestSnap = null;

        if (highPriorityCandidates.length > 0) {
            bestSnap = highPriorityCandidates.reduce((best, current) => (current.dist < best.dist ? current : best));
        } else {
            const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
            if (gridDisplayMode !== 'none' && gridInterval) {
                const gridVertices = U.getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true);
                gridVertices.forEach(p => generalCandidates.push({ pos: p, isGridVertexSnap: true, type: 'grid' }));
            }

            const referenceAngleForSnapping = drawingContext.currentSegmentReferenceA_for_display;
            const baseUnitDistance = drawingContext.currentSegmentReferenceD;
            const symmetricalAngleFractions = new Set([0, ...C.NINETY_DEG_ANGLE_SNAP_FRACTIONS.flatMap(f => [f, -f])]);
            const sortedSymmetricalFractions = Array.from(symmetricalAngleFractions).sort((a, b) => a - b);
            const allSnapAngles = sortedSymmetricalFractions.map(f => ({ factor: f, angle: U.normalizeAngleToPi(drawingContext.offsetAngleRad + (f * referenceAngleForSnapping)), turn: U.normalizeAngleToPi(f * referenceAngleForSnapping) }));
            const allSnapDistances = [];
            for (let i = 0; i <= C.DRAW_SNAP_DISTANCE_FACTOR_LIMIT / C.DRAW_SNAP_DISTANCE_FACTOR_STEP; i++) {
                const factor = i * C.DRAW_SNAP_DISTANCE_FACTOR_STEP;
                allSnapDistances.push({ factor: factor, dist: factor * baseUnitDistance });
            }

            if (allSnapAngles.length > 0 && allSnapDistances.length > 0) {
                for (const angleData of allSnapAngles) {
                    for (const distData of allSnapDistances) {
                        const pos = { x: startVertex.x + distData.dist * Math.cos(angleData.angle), y: startVertex.y + distData.dist * Math.sin(angleData.angle) };
                        generalCandidates.push({
                            pos: pos, isGridVertexSnap: false, type: 'geometric',
                            lengthSnapFactor: distData.factor, angleSnapFactor: angleData.factor, angleTurn: angleData.turn
                        });
                    }
                }
            }

            if (generalCandidates.length > 0) {
                bestSnap = generalCandidates.reduce((best, current) => {
                    const currentDist = U.distance(mouseDataPos, current.pos);
                    const bestDist = best ? U.distance(mouseDataPos, best.pos) : Infinity;
                    return currentDist < bestDist ? current : best;
                }, null);
            }
        }

        if (bestSnap) {
            const finalAngle = Math.atan2(bestSnap.pos.y - startVertex.y, bestSnap.pos.x - startVertex.x) || 0;
            const snappedDistanceOutput = parseFloat(U.distance(startVertex, bestSnap.pos).toFixed(10));
            let gridToGridSquaredSum = null;
            let finalGridInterval = null;

            if (bestSnap.isGridVertexSnap && gridDisplayMode !== 'polar') {
                const currentGridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
                const epsilon = currentGridInterval * C.GEOMETRY_CALCULATION_EPSILON;
                const isVertexOnGrid = (vertex, interval) => Math.abs(vertex.x / interval - Math.round(vertex.x / interval)) < epsilon && Math.abs(vertex.y / interval - Math.round(vertex.y / interval)) < epsilon;
                if (isVertexOnGrid(startVertex, currentGridInterval)) {
                    const deltaX = bestSnap.pos.x - startVertex.x;
                    const deltaY = bestSnap.pos.y - startVertex.y;
                    const dx_grid = Math.round(deltaX / currentGridInterval);
                    const dy_grid = Math.round(deltaY / currentGridInterval);
                    gridToGridSquaredSum = dx_grid * dx_grid + dy_grid * dy_grid;
                    finalGridInterval = currentGridInterval;
                }
            }
    
            let finalAngleTurn = bestSnap.angleTurn != null ? bestSnap.angleTurn : U.normalizeAngleToPi(finalAngle - drawingContext.offsetAngleRad);
    
            return {
                x: parseFloat(bestSnap.pos.x.toFixed(10)),
                y: parseFloat(bestSnap.pos.y.toFixed(10)),
                angle: finalAngle * (180 / Math.PI),
                distance: snappedDistanceOutput,
                snapped: true,
                gridSnapped: !!bestSnap.isGridVertexSnap,
                snapType: bestSnap.type,
                lengthSnapFactor: bestSnap.lengthSnapFactor || null,
                angleSnapFactor: bestSnap.angleSnapFactor || null,
                angleTurn: finalAngleTurn,
                gridToGridSquaredSum: gridToGridSquaredSum,
                gridInterval: finalGridInterval,
                targetEdge: bestSnap.targetEdge,
                fraction: bestSnap.fraction,
                targetVertex: bestSnap.sourceVertex,
            };
        }

        const finalAngleRad = Math.atan2(mouseDataPos.y - startVertex.y, mouseDataPos.x - startVertex.x) || 0;
        return {
            x: mouseDataPos.x, y: mouseDataPos.y,
            angle: finalAngleRad * (180 / Math.PI),
            distance: U.distance(startVertex, mouseDataPos),
            snapped: false, gridSnapped: false, lengthSnapFactor: null, angleSnapFactor: null,
            angleTurn: U.normalizeAngleToPi(finalAngleRad - drawingContext.offsetAngleRad),
            gridToGridSquaredSum: null, gridInterval: null
        };
    }
}

function invertColors() {
    allColors = allColors.map(colorItem => {
        if (colorItem.type === 'color') {
            return { ...colorItem, value: U.invertGrayscaleValue(colorItem.value) };
        }
        return colorItem;
    });
}

function initializeCanvasUI() {
    canvasUI.toolbarButton = {
        id: "toolbar-button",
        x: C.UI_BUTTON_PADDING,
        y: C.UI_BUTTON_PADDING,
        width: C.MENU_BUTTON_WIDTH,
        height: C.MENU_BUTTON_HEIGHT,
        type: "menuButton"
    };
}

function buildMainToolbarUI() {
    const canvasHeight = canvas.height / dpr;
    canvasUI.mainToolbar = {
        id: "main-toolbar-bg",
        x: 0,
        y: 0,
        width: C.UI_TOOLBAR_WIDTH,
        height: canvasHeight,
        type: "toolbar"
    };

    // Use a consistent vertical gap to create a regular vertical rhythm for each UI row
    const verticalRowGap = C.UI_BUTTON_PADDING;
    let currentY = canvasUI.toolbarButton.y + canvasUI.toolbarButton.height + C.TOOLBAR_SECTION_GAP;

    canvasUI.colorToolButton = {
        id: "color-tool-button",
        type: "toolButton",
        x: C.UI_BUTTON_PADDING,
        y: currentY,
        width: C.UI_TOOLBAR_WIDTH - (2 * C.UI_BUTTON_PADDING),
        height: C.TOOL_BUTTON_HEIGHT,
    };

    currentY += C.TOOL_BUTTON_HEIGHT + verticalRowGap;

    canvasUI.transformToolButton = {
        id: "transform-tool-button",
        type: "toolButton",
        x: C.UI_BUTTON_PADDING,
        y: currentY,
        width: C.UI_TOOLBAR_WIDTH - (2 * C.UI_BUTTON_PADDING),
        height: C.TOOL_BUTTON_HEIGHT,
    };

    currentY += C.TOOL_BUTTON_HEIGHT + verticalRowGap;

    canvasUI.visibilityToolButton = {
        id: "visibility-tool-button",
        type: "toolButton",
        x: C.UI_BUTTON_PADDING,
        y: currentY,
        width: C.UI_TOOLBAR_WIDTH - (2 * C.UI_BUTTON_PADDING),
        height: C.TOOL_BUTTON_HEIGHT,
    };
}

function buildColorPaletteUI() {
    canvasUI.colorSwatches = [];
    canvasUI.colorTargetIcons = [];

    // --- Standard Grid Parameters ---
    const standardHorizontalSpacing = C.TRANSFORM_ICON_SIZE + C.TRANSFORM_ICON_PADDING;
    const panelStartX = C.UI_TOOLBAR_WIDTH + C.UI_BUTTON_PADDING;
    const buttonCenterY = canvasUI.colorToolButton.y + (C.TOOL_BUTTON_HEIGHT / 2);
    const itemSize = C.UI_SWATCH_SIZE;
    const verticalOffset = -2; // Nudge icons UP to align their visual center with the main button
    const itemY = buttonCenterY - (itemSize / 2) + verticalOffset;
    let currentGridX = panelStartX;

    // --- Layout each item, centering it within the standard grid pitch ---
    canvasUI.removeColorButton = {
        id: "remove-color-button",
        type: "button",
        x: currentGridX + (standardHorizontalSpacing - itemSize) / 2,
        y: itemY,
        width: itemSize,
        height: itemSize,
    };
    currentGridX += standardHorizontalSpacing;

    allColors.forEach((item, index) => {
        canvasUI.colorSwatches.push({
            id: `swatch-${index}`,
            type: "colorSwatch",
            x: currentGridX + (standardHorizontalSpacing - itemSize) / 2,
            y: itemY,
            width: itemSize,
            height: itemSize,
            index: index,
            item: item
        });
        currentGridX += standardHorizontalSpacing;
    });

    canvasUI.addColorButton = {
        id: "add-color-button",
        type: "button",
        x: currentGridX + (standardHorizontalSpacing - itemSize) / 2,
        y: itemY,
        width: itemSize,
        height: itemSize,
    };

    Object.entries(colorAssignments).forEach(([target, colorIndex]) => {
        const targetIconSize = itemSize * 0.75;
        const swatch = canvasUI.colorSwatches.find(s => s.index === colorIndex);
        if (swatch) {
            canvasUI.colorTargetIcons.push({
                id: `target-icon-${target}`,
                type: 'colorTargetIcon',
                target: target,
                x: swatch.x + (swatch.width - targetIconSize) / 2,
                y: swatch.y - targetIconSize - 5,
                width: targetIconSize,
                height: targetIconSize
            });
        }
    });

    const allPaletteElements = [
        ...canvasUI.colorSwatches, canvasUI.removeColorButton, canvasUI.addColorButton, ...canvasUI.colorTargetIcons
    ].filter(Boolean);

    if (allPaletteElements.length > 0) {
        const minY = Math.min(...allPaletteElements.map(el => el.y));
        const maxX = Math.max(...allPaletteElements.map(el => el.x + el.width));
        const maxY = Math.max(...allPaletteElements.map(el => el.y + el.height));
        const padding = 5;
        canvasUI.colorPaletteBounds = {
            x: C.UI_TOOLBAR_WIDTH,
            y: minY - padding,
            width: (maxX - C.UI_TOOLBAR_WIDTH) + padding,
            height: (maxY - minY) + (padding * 2)
        };
    } else {
        canvasUI.colorPaletteBounds = null;
    }
}

function buildDisplayPanelUI() {
    canvasUI.displayIcons = [];
    if (!canvasUI.visibilityToolButton) return;

    // --- Standard Grid Parameters ---
    const standardHorizontalSpacing = C.TRANSFORM_ICON_SIZE + C.TRANSFORM_ICON_PADDING;
    const panelStartX = C.UI_TOOLBAR_WIDTH + C.UI_BUTTON_PADDING;
    const buttonCenterY = canvasUI.visibilityToolButton.y + (C.TOOL_BUTTON_HEIGHT / 2);
    const iconSize = C.DISPLAY_ICON_SIZE;
    const verticalOffset = -2; // Nudge icons UP to align their visual center with the main button
    const iconY = buttonCenterY - (iconSize / 2) + verticalOffset;
    let currentGridX = panelStartX;

    const iconGroups = ['coords', 'grid', 'angles', 'distances', 'theme'];

    iconGroups.forEach((group) => {
        canvasUI.displayIcons.push({
            id: `display-icon-${group}`,
            group: group,
            x: currentGridX + (standardHorizontalSpacing - iconSize) / 2,
            y: iconY,
            width: iconSize,
            height: iconSize
        });
        currentGridX += standardHorizontalSpacing;
    });

    if (canvasUI.displayIcons.length > 0) {
        const firstIcon = canvasUI.displayIcons[0];
        const lastIcon = canvasUI.displayIcons[canvasUI.displayIcons.length - 1];
        const padding = 5;
        canvasUI.displayPanelBounds = {
            x: C.UI_TOOLBAR_WIDTH,
            y: firstIcon.y - padding,
            width: (lastIcon.x + lastIcon.width - C.UI_TOOLBAR_WIDTH) + padding,
            height: firstIcon.height + (padding * 2)
        };
    } else {
        canvasUI.displayPanelBounds = null;
    }
}

function buildTransformPanelUI() {
    canvasUI.transformIcons = [];

    // --- Grid System Parameters ---
    const iconSize = C.TRANSFORM_ICON_SIZE;
    const horizontalSpacing = iconSize + C.TRANSFORM_ICON_PADDING;
    const panelStartX = C.UI_TOOLBAR_WIDTH + C.UI_BUTTON_PADDING;
    const buttonCenterY = canvasUI.transformToolButton.y + (C.TOOL_BUTTON_HEIGHT / 2);
    const iconY = buttonCenterY - (iconSize / 2); // No vertical offset for the baseline row

    const transformTypes = [
        C.TRANSFORMATION_TYPE_ROTATION, C.TRANSFORMATION_TYPE_SCALE, C.TRANSFORMATION_TYPE_ROTATE_SCALE, C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE
    ];

    let currentGridX = panelStartX;

    transformTypes.forEach((type) => {
        canvasUI.transformIcons.push({
            id: `transform-icon-${type}`,
            type: type,
            x: currentGridX + (horizontalSpacing - iconSize) / 2,
            y: iconY,
            width: iconSize,
            height: iconSize
        });
        currentGridX += horizontalSpacing;
    });

    if (canvasUI.transformIcons.length > 0) {
        const firstIcon = canvasUI.transformIcons[0];
        const lastIcon = canvasUI.transformIcons[canvasUI.transformIcons.length - 1];
        const padding = 5;
        canvasUI.transformPanelBounds = {
            x: C.UI_TOOLBAR_WIDTH,
            y: firstIcon.y - padding,
            width: (lastIcon.x + lastIcon.width - C.UI_TOOLBAR_WIDTH) + padding,
            height: firstIcon.height + (padding * 2)
        };
    } else {
        canvasUI.transformPanelBounds = null;
    }
}

function removeColorAtIndex(indexToRemove) {
    if (indexToRemove < 0 || indexToRemove >= allColors.length || allColors.length <= 1) {
        return;
    }

    allColors.splice(indexToRemove, 1);

    Object.keys(colorAssignments).forEach(target => {
        if (colorAssignments[target] > indexToRemove) {
            colorAssignments[target]--;
        } else if (colorAssignments[target] === indexToRemove) {
            colorAssignments[target] = Math.min(indexToRemove, allColors.length - 1);
        }
    });

    buildColorPaletteUI();
}

function drawDebugBounds(ctx) {
    ctx.save();
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; // Bright red for visibility
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);

    const drawBox = (box) => {
        if (box) {
            ctx.strokeRect(box.x, box.y, box.width, box.height);
        }
    };

    // Draw bounds for all active UI areas
    if (isToolbarExpanded && canvasUI.mainToolbar) {
        drawBox(canvasUI.mainToolbar);
    }
    if (isColorPaletteExpanded && canvasUI.colorPaletteBounds) {
        drawBox(canvasUI.colorPaletteBounds);
    }
    if (isTransformPanelExpanded && canvasUI.transformPanelBounds) {
        drawBox(canvasUI.transformPanelBounds);
    }
    if (isDisplayPanelExpanded && canvasUI.displayPanelBounds) {
        drawBox(canvasUI.displayPanelBounds);
    }
    
    // Always draw the hamburger button box for reference
    drawBox(canvasUI.toolbarButton);

    ctx.restore();
}

function addToColors(colorObject) {
    if (!colorObject || !colorObject.type) {
        console.error("Invalid color object passed to addToColors:", colorObject);
        return;
    }

    const isDuplicate = allColors.some(item => {
        if (!item || item.type !== colorObject.type) return false;
        if (item.type === 'colormap') {
            return JSON.stringify(item.vertices) === JSON.stringify(colorObject.vertices);
        }
        return item.value === colorObject.value;
    });

    if (isDuplicate) return;

    allColors.push(colorObject);

    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }
}

function getPrecedingSegment(vertexId, edgesToIgnoreIds = []) {
    const currentVertex = findVertexById(vertexId);
    if (!currentVertex) return null;
    for (let i = allEdges.length - 1; i >= 0; i--) {
        const edge = allEdges[i];
        const edgeIdentifier =  U.getEdgeId(edge);
        if (edgesToIgnoreIds.includes(edgeIdentifier)) continue;
        let otherVertexId = null;
        if (edge.id1 === vertexId) otherVertexId = edge.id2;
        else if (edge.id2 === vertexId) otherVertexId = edge.id1;
        if (otherVertexId) {
            const otherVertex = findVertexById(otherVertexId);
            if (otherVertex) {
                const dx = currentVertex.x - otherVertex.x; const dy = currentVertex.y - otherVertex.y;
                return { p1: otherVertex, p2: currentVertex, angleRad: Math.atan2(dy, dx), length: Math.sqrt(dx * dx + dy * dy), edgeId: edgeIdentifier };
            }
        }
    }
    return null;
}

function saveStateForUndo() {
    const state = getCurrentState();
    
    // Create a simple signature of the current state
    const signature = {
        colorCount: allColors.length,
        firstColor: allColors[0]?.value || 'none',
        vertexCount: allVertices.length
    };
    
    
    undoStack.push(state);
    if (undoStack.length > C.MAX_HISTORY_SIZE) undoStack.shift();
    redoStack = [];
    
}

function isMouseInUIPanel(pos) {
    // Always check the main toolbar button first, as it's always visible
    const btn = canvasUI.toolbarButton;
    if (btn && pos.x >= btn.x && pos.x <= btn.x + btn.width && pos.y >= btn.y && pos.y <= btn.y + btn.height) {
        return true;
    }

    // If the main toolbar is collapsed, no other UI is active
    if (!isToolbarExpanded) {
        return false;
    }

    // --- Step 1: Check for a direct hit inside any visible panel ---
    const activePanels = [];
    if (canvasUI.mainToolbar) activePanels.push(canvasUI.mainToolbar);
    if (isColorPaletteExpanded && canvasUI.colorPaletteBounds) activePanels.push(canvasUI.colorPaletteBounds);
    if (isTransformPanelExpanded && canvasUI.transformPanelBounds) activePanels.push(canvasUI.transformPanelBounds);
    if (isDisplayPanelExpanded && canvasUI.displayPanelBounds) activePanels.push(canvasUI.displayPanelBounds);

    for (const panel of activePanels) {
        if (panel && pos.x >= panel.x && pos.x <= panel.x + panel.width &&
            pos.y >= panel.y && pos.y <= panel.y + panel.height) {
            return true;
        }
    }

    // --- Step 2: Check for hits within the vertical gaps between submenus ---
    const activeSubPanels = [];
    if (isColorPaletteExpanded && canvasUI.colorPaletteBounds) activeSubPanels.push(canvasUI.colorPaletteBounds);
    if (isTransformPanelExpanded && canvasUI.transformPanelBounds) activeSubPanels.push(canvasUI.transformPanelBounds);
    if (isDisplayPanelExpanded && canvasUI.displayPanelBounds) activeSubPanels.push(canvasUI.displayPanelBounds);
    
    // Sort panels by their Y position to check gaps between adjacent rows correctly
    activeSubPanels.sort((a, b) => a.y - b.y);

    for (let i = 0; i < activeSubPanels.length - 1; i++) {
        const panelA = activeSubPanels[i]; // Panel above
        const panelB = activeSubPanels[i + 1]; // Panel below

        const gapY_start = panelA.y + panelA.height;
        const gapY_end = panelB.y;

        // Check if cursor is vertically positioned in the gap between the two panels
        if (pos.y > gapY_start && pos.y < gapY_end) {
            // To keep the area next to shorter panels drawable, the gap's width is limited
            // by the narrower of the two adjacent panels.
            const gapX_start = C.UI_TOOLBAR_WIDTH;
            const panelA_submenuWidth = panelA.x + panelA.width - gapX_start;
            const panelB_submenuWidth = panelB.x + panelB.width - gapX_start;
            const gapWidth = Math.min(panelA_submenuWidth, panelB_submenuWidth);
            const gapX_end = gapX_start + gapWidth;

            // The cursor is in the UI if it's over the main toolbar or the safe gap area
            if (pos.x < C.UI_TOOLBAR_WIDTH || (pos.x >= gapX_start && pos.x <= gapX_end)) {
                return true;
            }
        }
    }
    
    // If we've reached this point, the cursor is over the drawable canvas area
    return false;
}

function restoreState(state) {
    allVertices = JSON.parse(JSON.stringify(state.vertices));
    allEdges = JSON.parse(JSON.stringify(state.edges));
    allFaces = JSON.parse(JSON.stringify(state.faces || []));
    selectedVertexIds = JSON.parse(JSON.stringify(state.selectedVertexIds || []));
    selectedEdgeIds = JSON.parse(JSON.stringify(state.selectedEdgeIds || []));
    selectedFaceIds = JSON.parse(JSON.stringify(state.selectedFaceIds || []));
    selectedCenterIds = JSON.parse(JSON.stringify(state.selectedCenterIds || []));
    activeColorTargets = JSON.parse(JSON.stringify(state.activeColorTargets || []));
    allColors = state.allColors ? JSON.parse(JSON.stringify(state.allColors)) : C.DEFAULT_RECENT_COLORS.map(color => {
        if (typeof color === 'string') {
            return { type: 'color', value: color };
        }
        return color;
    });
    colorAssignments = state.colorAssignments ? JSON.parse(JSON.stringify(state.colorAssignments)) : {
        [C.COLOR_TARGET_VERTEX]: 0,
        [C.COLOR_TARGET_EDGE]: 1,
        [C.COLOR_TARGET_FACE]: 2,
    };
    activeCenterId = state.activeCenterId !== undefined ? state.activeCenterId : null;
    isDrawingMode = state.isDrawingMode !== undefined ? state.isDrawingMode : false;
    previewLineStartVertexId = state.previewLineStartVertexId !== undefined ? state.previewLineStartVertexId : null;
    frozenReference_A_rad = state.frozenReference_A_rad !== undefined ? state.frozenReference_A_rad : null;
    frozenReference_A_baseRad = state.frozenReference_A_baseRad !== undefined ? state.frozenReference_A_baseRad : null;
    frozenReference_D_du = state.frozenReference_D_du !== undefined ? state.frozenReference_D_du : null;
    frozenReference_Origin_Data = state.frozenReference_Origin_Data !== undefined ? state.frozenReference_Origin_Data : null;
    frozenReference_D_g2g = state.frozenReference_D_g2g !== undefined ? state.frozenReference_D_g2g : null;
    deletedFaceIds = state.deletedFaceIds !== undefined ? new Set(state.deletedFaceIds) : new Set();
    isActionInProgress = false; isDragConfirmed = false; isRectangleSelecting = false;
    isPanningBackground = false; dragPreviewVertices = [];
    actionTargetVertex = null; currentMouseButton = -1;
    clickData = { targetId: null, type: null, count: 0, timestamp: 0 };
    canvas.style.cursor = 'crosshair';
    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }
    const restoredState = getCurrentState();
    if (undoStack.length === 0) {
        undoStack.push(restoredState);
    }
    // REMOVE THE LINE BELOW:
    // saveStateForUndo();  <-- REMOVE THIS
}

function getCurrentState() {
    return {
        vertices: JSON.parse(JSON.stringify(allVertices)),
        edges: JSON.parse(JSON.stringify(allEdges)),
        faces: JSON.parse(JSON.stringify(allFaces)),
        selectedVertexIds: JSON.parse(JSON.stringify(selectedVertexIds)),
        selectedEdgeIds: JSON.parse(JSON.stringify(selectedEdgeIds)),
        selectedFaceIds: JSON.parse(JSON.stringify(selectedFaceIds)),
        selectedCenterIds: JSON.parse(JSON.stringify(selectedCenterIds)),
        activeColorTargets: JSON.parse(JSON.stringify(activeColorTargets)),
        colorAssignments: JSON.parse(JSON.stringify(colorAssignments)),
        allColors: JSON.parse(JSON.stringify(allColors)),
        activeCenterId: activeCenterId,
        isDrawingMode: isDrawingMode,
        previewLineStartVertexId: previewLineStartVertexId,
        frozenReference_A_rad, frozenReference_A_baseRad, frozenReference_D_du, frozenReference_Origin_Data,
        frozenReference_D_g2g,
        deletedFaceIds: new Set(deletedFaceIds)
    };
}

function updateFaceHierarchy() {
    // 1. Reset all hierarchy links
    allFaces.forEach(f => {
        f.parentFaceId = null;
        f.childFaceIds = [];
    });

    // 2. Prepare candidate data for efficient lookup
    const faceCandidates = allFaces.map(face => {
        const vertices = face.vertexIds.map(id => findVertexById(id));
        if (vertices.some(v => !v)) {
            return null; // Skip faces with invalid vertices
        }
        return {
            face: face,
            vertices: vertices,
            area: Math.abs(U.shoelaceArea(vertices))
        };
    }).filter(Boolean);

    // 3. Determine the direct (smallest) parent for each face
    faceCandidates.forEach(childCandidate => {
        let bestParent = null;
        let minParentArea = Infinity;

        faceCandidates.forEach(parentCandidate => {
            if (childCandidate.face.id === parentCandidate.face.id) return;
            if (parentCandidate.area <= childCandidate.area) return; // Optimization

            const childGraphVertexIds = childCandidate.face.vertexIds;
            const childGraphVertices = childGraphVertexIds.map(id => findVertexById(id));
            if (childGraphVertices.some(v => !v)) return;

            // Check if all vertices of the child's graph are contained
            const verticesAreContained = U.areVerticesContainedInPolygon(childGraphVertices, parentCandidate.vertices);
            
            if (verticesAreContained) {
                const childGraphVertexIdSet = new Set(childGraphVertexIds);
                const childGraphEdges = allEdges.filter(edge => 
                    childGraphVertexIdSet.has(edge.id1) && childGraphVertexIdSet.has(edge.id2)
                );
                
                const edgesDoIntersect = U.doGraphEdgesIntersectPolygon(childGraphEdges, parentCandidate.vertices, findVertexById);

                if (!edgesDoIntersect && parentCandidate.area < minParentArea) {
                    minParentArea = parentCandidate.area;
                    bestParent = parentCandidate.face;
                }
            }
        });

        if (bestParent) {
            childCandidate.face.parentFaceId = bestParent.id;
        }
    });

    // 4. Populate the childFaceIds arrays based on the determined parent links
    allFaces.forEach(f => {
        if (f.parentFaceId) {
            const parent = allFaces.find(p => p.id === f.parentFaceId);
            if (parent && !parent.childFaceIds.includes(f.id)) {
                parent.childFaceIds.push(f.id);
            }
        }
    });
}

function screenToData(screenPos_css_pixels) {
    const screenX_physical = screenPos_css_pixels.x * dpr;
    const screenY_physical = screenPos_css_pixels.y * dpr;
    const canvasHeight_physical = canvas.height;
    return {
        x: (screenX_physical - viewTransform.offsetX) / viewTransform.scale,
        y: (canvasHeight_physical - screenY_physical - viewTransform.offsetY) / viewTransform.scale
    };
}

function dataToScreen(dataPos) {
    const canvasHeight_physical = canvas.height;
    const screenX_physical = dataPos.x * viewTransform.scale + viewTransform.offsetX;
    const screenY_physical = canvasHeight_physical - (dataPos.y * viewTransform.scale + viewTransform.offsetY);
    return {
        x: screenX_physical / dpr,
        y: screenY_physical / dpr
    };
}

function findVertexById(id) {
    return allVertices.find(p => p.id === id);
}

function findClickedVertex(clickPos) {
    const dataPos = screenToData(clickPos);
    const selectRadiusDataRegular = (C.VERTEX_RADIUS * 2) / viewTransform.scale;
    const selectRadiusDataCenter = (C.CENTER_POINT_VISUAL_RADIUS + C.VERTEX_RADIUS) / viewTransform.scale;

    for (let i = allVertices.length - 1; i >= 0; i--) {
        const vertex = allVertices[i];
        if (vertex.type !== 'regular') {
            if (U.distance(dataPos, vertex) < selectRadiusDataCenter) return vertex;
        }
    }

    for (let i = allVertices.length - 1; i >= 0; i--) {
        const vertex = allVertices[i];
        if (vertex.type === 'regular' && U.distance(dataPos, vertex) < selectRadiusDataRegular) return vertex;
    }
    return null;
}

function findClickedEdge(clickPos) {
    const dataPos = screenToData(clickPos);
    const edgeClickThresholdData = C.EDGE_CLICK_THRESHOLD / viewTransform.scale;

    for (let i = allEdges.length - 1; i >= 0; i--) {
        const edge = allEdges[i];
        const p1 = findVertexById(edge.id1);
        const p2 = findVertexById(edge.id2);
        if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
            const closest = U.getClosestPointOnLineSegment(dataPos, p1, p2);
            if (closest.distance < edgeClickThresholdData && closest.onSegmentStrict) {
                return edge;
            }
        }
    }
    return null;
}

function findClickedFace(clickPos) {
    const dataPos = screenToData(clickPos);
    const potentialFaces = [];

    // Find all visible faces whose outer boundary contains the point
    for (const face of allFaces) {
        if (face.color === 'transparent') continue;

        const vertices = face.vertexIds.map(id => findVertexById(id)).filter(p => p && p.type === 'regular');
        if (vertices.length < 3) continue;

        if (U.isVertexInPolygon(dataPos, vertices)) {
            potentialFaces.push(face);
        }
    }

    if (potentialFaces.length === 0) {
        return null;
    }

    // Find the smallest valid face that contains the point
    let smallestValidFace = null;
    let smallestArea = Infinity;

    for (const potentialFace of potentialFaces) {
        let isInsideHole = false;
        if (potentialFace.childFaceIds && potentialFace.childFaceIds.length > 0) {
            for (const childId of potentialFace.childFaceIds) {
                const childFace = allFaces.find(f => f.id === childId);
                // A hole is a child face that is marked transparent
                if (childFace && childFace.color === 'transparent') {
                    const childVertices = childFace.vertexIds.map(id => findVertexById(id)).filter(Boolean);
                    if (childVertices.length >= 3 && U.isVertexInPolygon(dataPos, childVertices)) {
                        isInsideHole = true;
                        break;
                    }
                }
            }
        }

        if (!isInsideHole) {
            const vertices = potentialFace.vertexIds.map(id => findVertexById(id));
            if (vertices.every(Boolean)) {
                 const faceArea = Math.abs(U.shoelaceArea(vertices));
                if (faceArea < smallestArea) {
                    smallestArea = faceArea;
                    smallestValidFace = potentialFace;
                }
            }
        }
    }

    return smallestValidFace;
}

function findNeighborEdges(vertexId) {
    return allEdges.filter(e => e.id1 === vertexId || e.id2 === vertexId);
}

function findAllVerticesInSubgraph(startVertexId) {
    if (!findVertexById(startVertexId)) return [];
    const visited = new Set(); const queue = [startVertexId]; const subgraphVertexIds = [];
    visited.add(startVertexId);
    while (queue.length > 0) {
        const currentVertexId = queue.shift(); subgraphVertexIds.push(currentVertexId);
        U.findNeighbors(currentVertexId, allEdges).forEach(neighborId => {
            if (!visited.has(neighborId)) { visited.add(neighborId); queue.push(neighborId); }
        });
    }
    return subgraphVertexIds;
}

function handleCut() {
    if (selectedVertexIds.length === 0 && selectedEdgeIds.length === 0 && selectedCenterIds.length === 0) return;

    saveStateForUndo();
    handleCopy();
    deleteSelectedItems();
}

function handleCopy() {
    const verticesToCopyIds = new Set(selectedVertexIds);
    if (activeCenterId) verticesToCopyIds.add(activeCenterId);

    const facesToCopy = [];
    if (selectedFaceIds.length > 0) {
        selectedFaceIds.forEach(faceId => {
            // FIX: Find face by its canonical ID, not an object property
            const face = allFaces.find(f => U.getFaceId(f) === faceId);
            if (face) {
                facesToCopy.push(face);
                face.vertexIds.forEach(id => verticesToCopyIds.add(id));
            }
        });
    }

    selectedEdgeIds.forEach(edgeId => {
        const [id1, id2] = edgeId.split(C.EDGE_ID_DELIMITER);
        verticesToCopyIds.add(id1);
        verticesToCopyIds.add(id2);
    });

    clipboard.vertices = Array.from(verticesToCopyIds).map(id => {
        const p = findVertexById(id);
        return p ? { ...p } : null;
    }).filter(p => p);

    clipboard.edges = [];
    allEdges.forEach(edge => {
        if (verticesToCopyIds.has(edge.id1) && verticesToCopyIds.has(edge.id2)) {
            clipboard.edges.push({ ...edge });
        }
    });

    clipboard.faces = facesToCopy.map(f => JSON.parse(JSON.stringify(f)));
    clipboard.referenceVertex = screenToData(mousePos);
}

function handlePaste() {
    if (clipboard.vertices.length === 0 || !clipboard.referenceVertex) return;
    saveStateForUndo();

    const pastePosData = screenToData(mousePos);
    const deltaX = pastePosData.x - clipboard.referenceVertex.x;
    const deltaY = pastePosData.y - clipboard.referenceVertex.y;
    const oldToNewIdMap = new Map();
    const newPastedRegularVertexIds = [];
    let newPastedActiveCenterId = null;

    performEscapeAction();

    clipboard.vertices.forEach(cbVertex => {
        const newId = U.generateUniqueId();
        const newVertex = { ...cbVertex, id: newId, x: cbVertex.x + deltaX, y: cbVertex.y + deltaY };
        allVertices.push(newVertex);
        oldToNewIdMap.set(cbVertex.id, newId);
        if (newVertex.type === 'regular') {
            newPastedRegularVertexIds.push(newId);
        } else {
            newPastedActiveCenterId = newId;
        }
    });

    clipboard.edges.forEach(cbEdge => {
        const newP1Id = oldToNewIdMap.get(cbEdge.id1);
        const newP2Id = oldToNewIdMap.get(cbEdge.id2);
        if (newP1Id && newP2Id) {
            allEdges.push({ ...cbEdge, id1: newP1Id, id2: newP2Id });
        }
    });

    const newPastedFaceIds = [];
    clipboard.faces.forEach(cbFace => {
        const newVertexIds = cbFace.vertexIds.map(id => oldToNewIdMap.get(id)).filter(Boolean);
        if (newVertexIds.length === cbFace.vertexIds.length) {
            const newFace = {
                ...cbFace,
                id: U.getFaceId({ vertexIds: newVertexIds }),
                vertexIds: newVertexIds,
            };

            if (newFace.localCoordSystem) {
                // Translate the origin
                newFace.localCoordSystem.origin.x += deltaX;
                newFace.localCoordSystem.origin.y += deltaY;

                // Remap vertex/edge IDs within the coordinate system's constraints
                if (newFace.localCoordSystem.attachedToVertex) {
                    newFace.localCoordSystem.attachedToVertex = oldToNewIdMap.get(newFace.localCoordSystem.attachedToVertex);
                }
                if (newFace.localCoordSystem.attachedToEdge) {
                    newFace.localCoordSystem.attachedToEdge.v1 = oldToNewIdMap.get(newFace.localCoordSystem.attachedToEdge.v1);
                    newFace.localCoordSystem.attachedToEdge.v2 = oldToNewIdMap.get(newFace.localCoordSystem.attachedToEdge.v2);
                }
                if (newFace.localCoordSystem.rotationAlignedToEdge) {
                    newFace.localCoordSystem.rotationAlignedToEdge.v1 = oldToNewIdMap.get(newFace.localCoordSystem.rotationAlignedToEdge.v1);
                    newFace.localCoordSystem.rotationAlignedToEdge.v2 = oldToNewIdMap.get(newFace.localCoordSystem.rotationAlignedToEdge.v2);
                }
                if (newFace.localCoordSystem.scaleAttachedToEdge) {
                    newFace.localCoordSystem.scaleAttachedToEdge.v1 = oldToNewIdMap.get(newFace.localCoordSystem.scaleAttachedToEdge.v1);
                    newFace.localCoordSystem.scaleAttachedToEdge.v2 = oldToNewIdMap.get(newFace.localCoordSystem.scaleAttachedToEdge.v2);
                }
            }
            newFace.parentFaceId = null;
            newFace.childFaceIds = [];
            allFaces.push(newFace);
            newPastedFaceIds.push(newFace.id);
        }
    });
    ensureFaceCoordinateSystems();

    // Select the newly pasted geometry
    selectedVertexIds = newPastedRegularVertexIds;
    selectedEdgeIds = clipboard.edges.map(e => U.getEdgeId({ id1: oldToNewIdMap.get(e.id1), id2: oldToNewIdMap.get(e.id2) }));
    selectedFaceIds = newPastedFaceIds;
    activeCenterId = newPastedActiveCenterId;

    updateComponentDrawOrder()
}

function deleteSelectedItems() {
    const vertexIdsToDelete = new Set(selectedVertexIds);
    const centerIdsToDelete = new Set(selectedCenterIds);
    const edgeIdsToDelete = new Set(selectedEdgeIds);
    const faceIdsToExplicitlyDelete = new Set(selectedFaceIds);

    if (vertexIdsToDelete.size === 0 && centerIdsToDelete.size === 0 && edgeIdsToDelete.size === 0 && faceIdsToExplicitlyDelete.size === 0) {
        return;
    }
    saveStateForUndo();

    if (faceIdsToExplicitlyDelete.size > 0) {
        const facesToRemoveCompletely = new Set();
        
        allFaces.forEach(face => {
            const faceId = face.id || U.getFaceId(face);
            if (faceIdsToExplicitlyDelete.has(faceId)) {
                deletedFaceIds.add(faceId);
                if (face.childFaceIds && face.childFaceIds.length > 0) {
                    face.childFaceIds.forEach(childId => {
                        const childFace = allFaces.find(f => f.id === childId);
                        if (childFace) {
                            childFace.parentFaceId = null;
                        }
                    });
                }

                if (face.parentFaceId) {
                    face.color = 'transparent';
                } else {
                    facesToRemoveCompletely.add(faceId);
                }
            }
        });

        if (facesToRemoveCompletely.size > 0) {
            allFaces = allFaces.filter(face => !facesToRemoveCompletely.has(face.id || U.getFaceId(face)));
        }
    }

    const edgesBefore = [...allEdges];

    if (edgeIdsToDelete.size > 0) {
        allEdges = allEdges.filter(edge => !edgeIdsToDelete.has(U.getEdgeId(edge)));
    }
    if (vertexIdsToDelete.size > 0) {
        const edgesBefore = JSON.parse(JSON.stringify(allEdges));
        const newEdgesToAdd = [];
        const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        
        const remainingToDelete = new Set(vertexIdsToDelete);

        while (remainingToDelete.size > 0) {
            const startId = remainingToDelete.values().next().value;
            const component = new Set();
            const queue = [startId];
            
            while (queue.length > 0) {
                const currentId = queue.shift();
                if (remainingToDelete.has(currentId)) {
                    component.add(currentId);
                    remainingToDelete.delete(currentId);
                    const neighbors = U.findNeighbors(currentId, allEdges);
                    neighbors.forEach(neighborId => {
                        if (remainingToDelete.has(neighborId)) {
                            queue.push(neighborId);
                        }
                    });
                }
            }

            const boundaryEdges = allEdges.filter(e => 
                (component.has(e.id1) && !component.has(e.id2)) ||
                (component.has(e.id2) && !component.has(e.id1))
            );
            const outermostNeighbors = new Set();
            boundaryEdges.forEach(e => {
                if (!component.has(e.id1)) outermostNeighbors.add(e.id1);
                if (!component.has(e.id2)) outermostNeighbors.add(e.id2);
            });

            const neighborsToConnect = Array.from(outermostNeighbors);
            if (neighborsToConnect.length === 2) {
                const [id1, id2] = neighborsToConnect;
                const v1 = findVertexById(id1);
                const v2 = findVertexById(id2);
                const edgeExists = allEdges.some(e => (e.id1 === id1 && e.id2 === id2) || (e.id1 === id2 && e.id2 === id1));
                if (v1 && v2 && !edgeExists) {
                    newEdgesToAdd.push(U.createEdge(v1, v2, gridInterval, getColorForTarget));
                }
            }
        }

        allVertices = allVertices.filter(p => !vertexIdsToDelete.has(p.id));
        allEdges = allEdges.filter(e => !vertexIdsToDelete.has(e.id1) && !vertexIdsToDelete.has(e.id2));

        if (newEdgesToAdd.length > 0) {
            allEdges.push(...newEdgesToAdd);
            updateFaces(edgesBefore, allEdges);
            ensureFaceCoordinateSystems();
        }
    }

    updateFaces(edgesBefore, allEdges);

    if (centerIdsToDelete.size > 0) {
        allVertices = allVertices.filter(p => !centerIdsToDelete.has(p.id));
    }

    performEscapeAction();
    updateComponentDrawOrder()
}

function zoomAt(zoomCenterScreen_css_pixels, scaleFactor) {
    let newScale = viewTransform.scale * scaleFactor;

    if (newScale < C.MIN_SCALE_VALUE) {
        newScale = C.MIN_SCALE_VALUE;
    }
    if (newScale > C.MAX_SCALE_VALUE) {
        newScale = C.MAX_SCALE_VALUE;
    }

    const effectiveScaleFactor = newScale / viewTransform.scale;

    const mouseX_physical = zoomCenterScreen_css_pixels.x * dpr;
    const mouseY_physical = zoomCenterScreen_css_pixels.y * dpr;

    viewTransform.offsetX = mouseX_physical * (1 - effectiveScaleFactor) + viewTransform.offsetX * effectiveScaleFactor;
    viewTransform.offsetY = (canvas.height - mouseY_physical) * (1 - effectiveScaleFactor) + viewTransform.offsetY * effectiveScaleFactor;

    viewTransform.scale = newScale;
}

function getDrawingContext(currentDrawStartVertexId) {
    let offsetAngleRad = 0;
    let currentSegmentReferenceD;
    let currentSegmentReferenceA_for_display = Math.PI / 2;
    let isFirstSegmentBeingDrawn = true;

    const p_current = findVertexById(currentDrawStartVertexId);
    if (!p_current) {
        isFirstSegmentBeingDrawn = true;
        if (gridDisplayMode !== 'none' && lastGridState.interval1) {
            currentSegmentReferenceD = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        } else {
            currentSegmentReferenceD = C.DEFAULT_REFERENCE_DISTANCE;
        }
        if (frozenReference_D_du !== null) {
            currentSegmentReferenceD = frozenReference_D_du;
        }

        return {
            offsetAngleRad,
            currentSegmentReferenceD,
            currentSegmentReferenceA_for_display,
            isFirstSegmentBeingDrawn,
            displayAngleA_valueRad_for_A_equals_label: null,
            displayAngleA_originVertexData_for_A_equals_label: null,
            frozen_A_baseRad_to_display: null,
            frozen_D_du_to_display: null,
            frozen_D_g2g_to_display: null,
            frozen_Origin_Data_to_display: null
        };
    }

    const segment1_prev_to_current = getPrecedingSegment(p_current.id);

    if (segment1_prev_to_current) {
        isFirstSegmentBeingDrawn = false;
        offsetAngleRad = segment1_prev_to_current.angleRad;
        currentSegmentReferenceD = frozenReference_D_du !== null ? frozenReference_D_du : segment1_prev_to_current.length;

        if (frozenReference_A_rad !== null) {
            if (Math.abs(frozenReference_A_rad) < C.GEOMETRY_CALCULATION_EPSILON) {
                currentSegmentReferenceA_for_display = C.DEFAULT_REFERENCE_ANGLE_RAD;
            } else {
                currentSegmentReferenceA_for_display = Math.abs(frozenReference_A_rad);
            }
        } else {
            currentSegmentReferenceA_for_display = C.DEFAULT_REFERENCE_ANGLE_RAD;
        }
    } else {
        isFirstSegmentBeingDrawn = true;
        if (gridDisplayMode !== 'none' && lastGridState.interval1) {
            currentSegmentReferenceD = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        } else {
            currentSegmentReferenceD = C.DEFAULT_REFERENCE_DISTANCE;
        }
        if (frozenReference_D_du !== null) {
            currentSegmentReferenceD = frozenReference_D_du;
        }
        offsetAngleRad = 0;
        currentSegmentReferenceA_for_display = C.DEFAULT_REFERENCE_ANGLE_RAD;
    }

    return {
        offsetAngleRad,
        currentSegmentReferenceD,
        currentSegmentReferenceA_for_display,
        isFirstSegmentBeingDrawn,
        displayAngleA_valueRad_for_A_equals_label: frozenReference_A_rad,
        displayAngleA_originVertexData_for_A_equals_label: frozenReference_Origin_Data,
        frozen_A_baseRad_to_display: frozenReference_A_baseRad,
        frozen_D_du_to_display: frozenReference_D_du,
        frozen_D_g2g_to_display: frozenReference_D_g2g
    };
}

function getCompletedSegmentProperties(startVertex, endVertex, existingEdges) {
    if (!startVertex || !endVertex) return null;

    const angle = Math.atan2(endVertex.y - startVertex.y, endVertex.x - startVertex.x);
    const length = U.distance(startVertex, endVertex);

    let precedingSegmentAngle = 0;
    let isFirstSegmentOfLine = true;

    for (let i = existingEdges.length - 1; i >= 0; i--) {
        const edge = existingEdges[i];
        let otherVertexId = null;
        if (edge.id1 === startVertex.id && findVertexById(edge.id2)?.type === 'regular') otherVertexId = edge.id2;
        else if (edge.id2 === startVertex.id && findVertexById(edge.id1)?.type === 'regular') otherVertexId = edge.id1;

        if (otherVertexId && otherVertexId !== endVertex.id) {
            const prevVertex = findVertexById(otherVertexId);
            if (prevVertex) {
                precedingSegmentAngle = Math.atan2(startVertex.y - prevVertex.y, startVertex.x - prevVertex.x);
                isFirstSegmentOfLine = false;
                break;
            }
        }
    }

    const angleTurn = U.normalizeAngleToPi(angle - precedingSegmentAngle);

    return {
        startVertex,
        endVertex,
        absoluteAngleRad: angle,
        length: length,
        precedingSegmentAbsoluteAngleRad: precedingSegmentAngle,
        turnAngleRad: angleTurn,
        isFirstSegmentOfLine: isFirstSegmentOfLine
    };
}

function getDescendantVertices(faceId, allFaces) {
    const descendantVertices = new Set();
    const queue = [faceId];
    const visitedFaceIds = new Set([faceId]);

    while (queue.length > 0) {
        const currentFaceId = queue.shift();
        const currentFace = allFaces.find(f => f.id === currentFaceId);

        if (currentFace) {
            currentFace.vertexIds.forEach(vId => descendantVertices.add(vId));
            
            if (currentFace.childFaceIds) {
                currentFace.childFaceIds.forEach(childId => {
                    if (!visitedFaceIds.has(childId)) {
                        visitedFaceIds.add(childId);
                        queue.push(childId);
                    }
                });
            }
        }
    }
    return Array.from(descendantVertices);
}

function completeGraphOnSelectedVertices() {
    const regularVertexIds = selectedVertexIds.filter(id => {
        const vertex = findVertexById(id);
        return vertex && vertex.type === 'regular';
    });

    if (regularVertexIds.length < 2) return;

    saveStateForUndo();

    const edgesBefore = JSON.parse(JSON.stringify(allEdges));
    let edgesWereAdded = false;
    const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

    for (let i = 0; i < regularVertexIds.length; i++) {
        for (let j = i + 1; j < regularVertexIds.length; j++) {
            const id1 = regularVertexIds[i];
            const id2 = regularVertexIds[j];

            const edgeExists = allEdges.some(edge =>
                (edge.id1 === id1 && edge.id2 === id2) ||
                (edge.id1 === id2 && edge.id2 === id1)
            );

            if (!edgeExists) {
                const v1 = findVertexById(id1);
                const v2 = findVertexById(id2);
                if (v1 && v2) {
                    const newEdge = U.createEdge(v1, v2, gridInterval, getColorForTarget);
                    allEdges.push(newEdge);
                    edgesWereAdded = true;
                }
            }
        }
    }

    if (edgesWereAdded && facesVisible) {
        updateFaces(edgesBefore, allEdges);
        
        allFaces.forEach(face => {
            if (!face.color) {
                face.color = getColorForTarget(C.COLOR_TARGET_FACE);
            }
        });
        
        ensureFaceCoordinateSystems();
    }
    updateComponentDrawOrder()
}

function applySelectionLogic(vertexIdsToSelect = [], edgeIdsToSelect = [], faceIdsToSelect = [], wantsShift, wantsCtrl, targetIsCenter = false) {
    if (targetIsCenter) {
        handleCenterSelection(vertexIdsToSelect[0], wantsShift, wantsCtrl);
    } else {
        if (wantsShift) {
            selectedVertexIds = [...new Set([...selectedVertexIds, ...vertexIdsToSelect])];
            selectedEdgeIds = [...new Set([...selectedEdgeIds, ...edgeIdsToSelect])];
            selectedFaceIds = [...new Set([...selectedFaceIds, ...faceIdsToSelect])];
        } else if (wantsCtrl) {
            vertexIdsToSelect.forEach(id => {
                const index = selectedVertexIds.indexOf(id);
                if (index > -1) selectedVertexIds.splice(index, 1);
                else selectedVertexIds.push(id);
            });
            edgeIdsToSelect.forEach(id => {
                const index = selectedEdgeIds.indexOf(id);
                if (index > -1) selectedEdgeIds.splice(index, 1);
                else selectedEdgeIds.push(id);
            });
            faceIdsToSelect.forEach(id => {
                const index = selectedFaceIds.indexOf(id);
                if (index > -1) selectedFaceIds.splice(index, 1);
                else selectedFaceIds.push(id);
            });
        } else {
            selectedVertexIds = [...vertexIdsToSelect];
            selectedEdgeIds = [...edgeIdsToSelect];
            selectedFaceIds = [...faceIdsToSelect];
        }
    }
}

function calculateTransformFromMouse(center, mouseData, startReferenceVertex, centerType, currentAccumulatedRotation = 0) {
    const startVector = { x: startReferenceVertex.x - center.x, y: startReferenceVertex.y - center.y };
    const currentVector = { x: mouseData.x - center.x, y: mouseData.y - center.y };
    const startDist = Math.hypot(startVector.x, startVector.y);
    const currentDist = Math.hypot(currentVector.x, currentVector.y);
    const startAngle = Math.atan2(startVector.y, startVector.x);
    const currentAngle = Math.atan2(currentVector.y, currentVector.x);

    let rotation = 0;
    let scale = 1;
    let directionalScale = false;

    if (centerType === C.TRANSFORMATION_TYPE_ROTATION) {
        scale = 1.0;
        rotation = U.calculateRotationAngle(startAngle, currentAngle, currentAccumulatedRotation);
    } else if (centerType === C.TRANSFORMATION_TYPE_SCALE) {
        rotation = 0.0;
        if (startDist > C.GEOMETRY_CALCULATION_EPSILON) {
            scale = currentDist / startDist;
        }
    } else if (centerType === C.TRANSFORMATION_TYPE_ROTATE_SCALE) {
        rotation = U.calculateRotationAngle(startAngle, currentAngle, currentAccumulatedRotation);
        if (startDist > C.GEOMETRY_CALCULATION_EPSILON) {
            scale = currentDist / startDist;
        }
    } else if (centerType === C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE) {
        directionalScale = true;
        rotation = 0;
        if (startDist > C.GEOMETRY_CALCULATION_EPSILON) {
            const startNormalized = { x: startVector.x / startDist, y: startVector.y / startDist };
            const projectedDistance = (currentVector.x * startNormalized.x + currentVector.y * startNormalized.y);
            scale = projectedDistance / startDist;
        }
    }

    return { rotation, scale, directionalScale };
}

function updateFaces(edgesBefore, edgesAfter) {
    if (!facesVisible) {
        allFaces = [];
        deletedFaceIds.clear();
        return;
    }

    const edgesBeforeSet = new Set(edgesBefore.map(e => U.getEdgeId(e)));
    const edgesAfterSet = new Set(edgesAfter.map(e => U.getEdgeId(e)));
    
    const addedEdges = edgesAfter.filter(e => !edgesBeforeSet.has(U.getEdgeId(e)));
    const removedEdges = edgesBefore.filter(e => !edgesAfterSet.has(U.getEdgeId(e)));

    if (addedEdges.length === 0 && removedEdges.length === 0) {
        return;
    }

    const dirtyVertices = new Set();
    addedEdges.forEach(e => { dirtyVertices.add(e.id1); dirtyVertices.add(e.id2); });
    removedEdges.forEach(e => { dirtyVertices.add(e.id1); dirtyVertices.add(e.id2); });
    
    const affectedComponentVertices = new Set();
    const processedStartNodes = new Set();
    for (const startId of dirtyVertices) {
        if (!processedStartNodes.has(startId)) {
            const component = findAllVerticesInSubgraph(startId);
            component.forEach(vId => {
                affectedComponentVertices.add(vId);
                processedStartNodes.add(vId);
            });
        }
    }

    const affectedEdges = allEdges.filter(e => affectedComponentVertices.has(e.id1) && affectedComponentVertices.has(e.id2));
    const oldFacesInComponent = allFaces.filter(face =>
        face.vertexIds.every(vId => affectedComponentVertices.has(vId))
    );

    const correctFacesForComponent = U.detectClosedPolygons(affectedEdges, findVertexById);

    // Remove all old faces within the affected component
    const oldFaceIdsToRemove = new Set(oldFacesInComponent.map(f => f.id));
    allFaces = allFaces.filter(f => !oldFaceIdsToRemove.has(f.id));

    // ============================ START OF NEW FIX ============================
    
    let facesToAdd = correctFacesForComponent;

    // If we detected more than one new face, check for a composite face.
    if (correctFacesForComponent.length > 1) {
        const facesWithAreas = correctFacesForComponent.map(face => {
            const vertices = face.vertexIds.map(id => findVertexById(id));
            // Ensure all vertices for the face are valid before calculating area
            if (vertices.some(v => !v)) return null;
            return { face: face, area: Math.abs(U.shoelaceArea(vertices)) };
        }).filter(Boolean); // Remove any nulls from invalid faces

        if (facesWithAreas.length > 1) {
            // Sort faces by area, largest first
            facesWithAreas.sort((a, b) => b.area - a.area);

            const largestFace = facesWithAreas[0];
            const sumOfOthersArea = facesWithAreas.slice(1).reduce((sum, item) => sum + item.area, 0);

            // If the largest face's area equals the sum of the others, it's a composite face.
            if (Math.abs(largestFace.area - sumOfOthersArea) < C.GEOMETRY_CALCULATION_EPSILON) {
                // In this case, the faces we want to add are all BUT the largest one.
                facesToAdd = facesWithAreas.slice(1).map(item => item.face);
            }
        }
    }
    
    // ============================= END OF NEW FIX =============================

    const addedEdgeIds = new Set(addedEdges.map(e => U.getEdgeId(e)));

    facesToAdd.forEach(newFace => {
        let isFormedByNewEdge = false;
        if (addedEdges.length > 0) {
            for (let i = 0; i < newFace.vertexIds.length; i++) {
                const p1 = newFace.vertexIds[i];
                const p2 = newFace.vertexIds[(i + 1) % newFace.vertexIds.length];
                const faceEdgeId = U.getEdgeId({ id1: p1, id2: p2 });
                if (addedEdgeIds.has(faceEdgeId)) {
                    isFormedByNewEdge = true;
                    break;
                }
            }
        }
        
        if (deletedFaceIds.has(newFace.id)) {
            if (isFormedByNewEdge) {
                deletedFaceIds.delete(newFace.id);
            } else {
                return;
            }
        }
        
        const colorIndex = colorAssignments[C.COLOR_TARGET_FACE];
        if (colorIndex !== -1) {
            const colorItem = allColors[colorIndex];
            if (colorItem && colorItem.type === 'colormap') {
                newFace.colormapItem = colorItem;
                newFace.colormapDistribution = 'x';
                delete newFace.color;
            } else {
                newFace.color = getColorForTarget(C.COLOR_TARGET_FACE);
                delete newFace.colormapItem;
                delete newFace.colormapDistribution;
            }
        } else {
            newFace.color = getColorForTarget(C.COLOR_TARGET_FACE);
            delete newFace.colormapItem;
            delete newFace.colormapDistribution;
        }
        
        newFace.parentFaceId = null;
        newFace.childFaceIds = [];
        allFaces.push(newFace);
    });

    ensureFaceCoordinateSystems();
}

function insertVertexOnEdgeWithFaces(targetEdge, insertionVertex, gridInterval, getColorForTarget) {
    const p1 = findVertexById(targetEdge.id1);
    const p2 = findVertexById(targetEdge.id2);

    if (!p1 || !p2) return null;

    const edgesBefore = [...allEdges];

    const newVertex = {
        id: U.generateUniqueId(),
        x: insertionVertex.x,
        y: insertionVertex.y,
        type: 'regular',
        color: getColorForTarget(C.COLOR_TARGET_VERTEX)
    };

    allVertices.push(newVertex);

    allEdges = allEdges.filter(e => U.getEdgeId(e) !== U.getEdgeId(targetEdge));

    allEdges.push(U.createEdge(p1, newVertex, gridInterval, getColorForTarget));
    allEdges.push(U.createEdge(newVertex, p2, gridInterval, getColorForTarget));

    if (facesVisible) {
        updateFaces(edgesBefore, allEdges);
    }

    return newVertex;
}

export function findBestVertexMergeSnap(sourceVertices, targetVertices, snapRadius) {
    let bestSnap = {
        dist: Infinity,
        correctionVector: null,
        sourceVertex: null,
        targetVertex: null,
    };

    // Check source vertices against all potential targets
    for (const source of sourceVertices) {
        for (const target of targetVertices) {
            // Ensure we are not snapping a vertex to another vertex that originates
            // from the same object in the same transformation step.
            if (source.originalId === target.originalId && source.transformIndex === target.transformIndex) {
                continue;
            }

            const dist = distance(source, target);
            if (dist < bestSnap.dist) {
                bestSnap.dist = dist;
                bestSnap.sourceVertex = source;
                bestSnap.targetVertex = target;
            }
        }
    }

    if (bestSnap.dist < snapRadius) {
        return {
            snapped: true,
            correctionVector: {
                x: bestSnap.targetVertex.x - bestSnap.sourceVertex.x,
                y: bestSnap.targetVertex.y - bestSnap.sourceVertex.y,
            },
            snapType: 'vertex'
        };
    }

    return { snapped: false };
}

function getTranslationSnap(initialDragVertexStates, rawDelta, copyCount, wasSnapped) {
    const snapRadius = C.MERGE_RADIUS_SCREEN / viewTransform.scale;
    const effectiveRadius = wasSnapped ? snapRadius * 1.5 : snapRadius;

    const verticesToDrag = initialDragVertexStates.filter(p => p.type === 'regular');
    if (verticesToDrag.length === 0) {
        return { delta: rawDelta, snapped: false };
    }

    const initialDraggedIds = new Set(initialDragVertexStates.map(p => p.id));
    const originalMovingEdges = allEdges.filter(e => initialDraggedIds.has(e.id1) && initialDraggedIds.has(e.id2));

    const allMovingVerticesRaw = [];
    const allMovingEdgesRaw = [];

    const loopStart = copyCount > 1 ? 1 : 0;
    const loopEnd = copyCount;

    for (let k = loopStart; k < loopEnd; k++) {
        const copyIndex = copyCount > 1 ? k : 1;
        const transformIndex = copyCount > 1 ? k : 0;

        for (const p_orig of verticesToDrag) {
            allMovingVerticesRaw.push({
                x: p_orig.x + rawDelta.x * copyIndex,
                y: p_orig.y + rawDelta.y * copyIndex,
                originalId: p_orig.id,
                transformIndex: transformIndex
            });
        }
    }

    for (const edge of originalMovingEdges) {
        for (let k = loopStart; k < loopEnd; k++) {
            const transformIndex = copyCount > 1 ? k : 0;
            const p1Copy = allMovingVerticesRaw.find(v => v.originalId === edge.id1 && v.transformIndex === transformIndex);
            const p2Copy = allMovingVerticesRaw.find(v => v.originalId === edge.id2 && v.transformIndex === transformIndex);
            if (p1Copy && p2Copy) {
                allMovingEdgesRaw.push({ p1: p1Copy, p2: p2Copy, originalEdge: edge, transformIndex: transformIndex });
            }
        }
    }

    const staticVertices = allVertices
        .filter(p => p.type === 'regular' && !initialDraggedIds.has(p.id))
        .map(p => ({ ...p, originalId: p.id, transformIndex: undefined }));

    const staticEdges = allEdges.filter(e => !initialDraggedIds.has(e.id1) || !initialDraggedIds.has(e.id2))
        .map(edge => ({ p1: findVertexById(edge.id1), p2: findVertexById(edge.id2), originalEdge: edge, transformIndex: undefined }));

    let allTargetVertices = staticVertices;
    let allTargetEdges = staticEdges;

    if (copyCount > 1) {
        const originalSelectionAsTargets = verticesToDrag.map(v => ({...v, originalId: v.id, transformIndex: 0 }));
        allTargetVertices = [...staticVertices, ...originalSelectionAsTargets];
        const originalEdgesAsTargets = originalMovingEdges.map(e=>({p1:findVertexById(e.id1), p2:findVertexById(e.id2), originalEdge: e, transformIndex: 0}));
        allTargetEdges = [...staticEdges, ...originalEdgesAsTargets];
    } else {
        allTargetEdges = allTargetEdges.filter(targetEdge => {
            const edge = targetEdge.originalEdge;
            const p1IsMoving = initialDraggedIds.has(edge.id1);
            const p2IsMoving = initialDraggedIds.has(edge.id2);
            return !(p1IsMoving ^ p2IsMoving); 
        });
    }

    const vvCandidates = U.findAllVertexMerges(allMovingVerticesRaw, allTargetVertices, effectiveRadius);
    const veCandidates = U.findVertexToEdgeSnaps(allMovingVerticesRaw, allTargetEdges, effectiveRadius);

    const inverse_evCandidates = U.findVertexToEdgeSnaps(allTargetVertices, allMovingEdgesRaw, effectiveRadius);
    const evCandidates = inverse_evCandidates.map(candidate => ({
        dist: candidate.dist,
        snap: {
            dist: candidate.dist,
            sourceEdge: candidate.targetEdge,
            targetVertex: candidate.sourceVertex,
            correctionVector: { 
                x: candidate.sourceVertex.x - candidate.snapPoint.x, 
                y: candidate.sourceVertex.y - candidate.snapPoint.y 
            },
            snapType: 'edge-to-vertex'
        },
        type: 'edge-to-vertex'
    }));

    const allCandidates = [
        ...vvCandidates.map(c => ({ dist: c.dist, snap: c, type: 'vertex' })),
        ...veCandidates.map(c => ({ dist: c.dist, snap: c, type: 'vertex-to-edge' })),
        ...evCandidates
    ];

    if (allCandidates.length === 0) {
        return { delta: rawDelta, snapped: false };
    }

    const priorities = { 'vertex': 1, 'vertex-to-edge': 2, 'edge-to-vertex': 2 };
    allCandidates.sort((a, b) => {
        if (priorities[a.type] !== priorities[b.type]) return priorities[a.type] - priorities[b.type];
        return a.dist - b.dist;
    });

    const bestSnap = allCandidates[0];
    let correction = { x: 0, y: 0 };

    if (bestSnap.type === 'vertex') {
        correction = { x: bestSnap.snap.targetVertex.x - bestSnap.snap.sourceVertex.x, y: bestSnap.snap.targetVertex.y - bestSnap.snap.sourceVertex.y };
    } else if (bestSnap.type === 'vertex-to-edge') {
        correction = { x: bestSnap.snap.snapPoint.x - bestSnap.snap.sourceVertex.x, y: bestSnap.snap.snapPoint.y - bestSnap.snap.sourceVertex.y };
    } else if (bestSnap.type === 'edge-to-vertex') {
        correction = bestSnap.snap.correctionVector;
    }

    let finalDelta = rawDelta;

    const sourceIndex = bestSnap.snap.sourceVertex ? bestSnap.snap.sourceVertex.transformIndex : bestSnap.snap.sourceEdge.transformIndex;
    const targetIndex = bestSnap.type === 'vertex-to-edge' 
        ? bestSnap.snap.targetEdge.transformIndex 
        : (bestSnap.snap.targetVertex ? bestSnap.snap.targetVertex.transformIndex : undefined);

    let denominator = 1;
    if (copyCount === 1) {
        denominator = 1;
    } else if (targetIndex === undefined) {
        denominator = sourceIndex;
    } else {
        denominator = sourceIndex - targetIndex;
    }

    if (Math.abs(denominator) > 1e-9) {
        correction.x /= denominator;
        correction.y /= denominator;
    } else {
        correction = { x: 0, y: 0 };
    }

    finalDelta = { x: rawDelta.x + correction.x, y: rawDelta.y + correction.y };

    return {
        delta: finalDelta,
        snapped: true,
        snapType: bestSnap.type,
        snapDetails: bestSnap.snap
    };
}

function getBestRotateScaleSnap(center, initialVertexStates, handleVertex, rawRotation, rawScale) {
    const mouseDataPos = U.applyTransformToVertex(handleVertex, center, rawRotation, rawScale, false, null);
    const startVector = { x: handleVertex.x - center.x, y: handleVertex.y - center.y };
    const snapRadius = C.MERGE_RADIUS_SCREEN / viewTransform.scale;
    const verticesToTransform = initialVertexStates.filter(p => p.type === 'regular');

    // --- 1. Check for an overriding Merge Snap ---
    const mergeSnaps = [];
    if (verticesToTransform.length > 0) {
        const staticVertices = allVertices.filter(p => p.type === 'regular' && !initialVertexStates.some(ip => ip.id === p.id));
        const copyCount = parseInt(copyCountInput || '1', 10) || 1;
        for (let i = 1; i <= copyCount; i++) {
            verticesToTransform.forEach(p_source => {
                staticVertices.forEach(p_target => {
                    const v_source = { x: p_source.x - center.x, y: p_source.y - center.y };
                    const v_target = { x: p_target.x - center.x, y: p_target.y - center.y };
                    const r_source = Math.hypot(v_source.x, v_source.y);
                    const r_target = Math.hypot(v_target.x, v_target.y);
                    if (r_source > C.GEOMETRY_CALCULATION_EPSILON) {
                        const snap_scale = Math.pow(r_target / r_source, 1 / i);
                        let target_angle = Math.atan2(v_target.y, v_target.x) - Math.atan2(v_source.y, v_source.x);
                        const unwrapped_target_angle = target_angle + Math.round((rawRotation * i - target_angle) / (2 * Math.PI)) * (2 * Math.PI);
                        const snap_rotation = unwrapped_target_angle / i;
                        const handleAtSnapPos = U.applyTransformToVertex(handleVertex, center, snap_rotation, snap_scale, false, startVector);
                        const snapDist = U.distance(mouseDataPos, handleAtSnapPos);
                        mergeSnaps.push({ dist: snapDist, rotation: snap_rotation, scale: snap_scale, pos: handleAtSnapPos });
                    }
                });
            });
        }
    }
    
    if (mergeSnaps.length > 0) {
        const bestMergeSnap = mergeSnaps.sort((a, b) => a.dist - b.dist)[0];
        if (bestMergeSnap.dist < snapRadius) {
            return { ...bestMergeSnap, snapped: true, snapType: 'merge', snappedScaleValue: bestMergeSnap.scale };
        }
    }

    // --- 2. If no merge, perform Geometric Snapping on Shift ---
    if (currentShiftPressed) {
        const geometricSnaps = [];
        const polarCandidates = [];
        const cartesianCandidates = [];

        // Gather 4 polar candidates
        const allSnapAngles = C.NINETY_DEG_ANGLE_SNAP_FRACTIONS.flatMap(f => {
            const angle = f * Math.PI / 2;
            return angle === 0 ? [0] : [angle, -angle];
        }).sort((a, b) => Math.abs(U.normalizeAngleToPi(rawRotation - a)) - Math.abs(U.normalizeAngleToPi(rawRotation - b)));
        const allSnapScales = C.SNAP_FACTORS.filter(f => f > 0).sort((a,b) => Math.abs(rawScale - a) - Math.abs(rawScale - b));
        const candidateAngles = allSnapAngles.slice(0, 2);
        const candidateScales = allSnapScales.slice(0, 2);
        candidateAngles.forEach(angle => {
            candidateScales.forEach(scale => {
                const unwrappedAngle = angle + Math.round((rawRotation - angle) / (2 * Math.PI)) * (2 * Math.PI);
                const handleAtSnapPos = U.applyTransformToVertex(handleVertex, center, unwrappedAngle, scale, false, startVector);
                polarCandidates.push({ dist: U.distance(mouseDataPos, handleAtSnapPos), rotation: unwrappedAngle, scale: scale, pos: handleAtSnapPos });
            });
        });

        // Gather 4 Cartesian grid candidates
        const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        if (gridInterval) {
            const gridPoints = U.getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true);
            const startHandleRadius = Math.hypot(startVector.x, startVector.y);
            gridPoints.forEach(point => {
                if (startHandleRadius > C.GEOMETRY_CALCULATION_EPSILON) {
                    const targetVector = { x: point.x - center.x, y: point.y - center.y };
                    const targetScale = Math.hypot(targetVector.x, targetVector.y) / startHandleRadius;
                    const deltaAngle = Math.atan2(targetVector.y, targetVector.x) - Math.atan2(startVector.y, startVector.x);
                    const unwrappedDeltaAngle = deltaAngle + Math.round((rawRotation - deltaAngle) / (2 * Math.PI)) * (2 * Math.PI);
                    cartesianCandidates.push({ dist: U.distance(mouseDataPos, point), rotation: unwrappedDeltaAngle, scale: targetScale, pos: point });
                }
            });
        }
        
        const bestSnap = [...polarCandidates, ...cartesianCandidates].sort((a,b) => a.dist - b.dist)[0];
        return { ...bestSnap, snapped: true, snapType: 'geometric', snappedScaleValue: bestSnap.scale };
    }

    // --- 3. Fallback to unsnapped ---
    return { rotation: rawRotation, scale: rawScale, pos: mouseDataPos, snapped: false };
}

function getBestRotationSnap(center, initialVertexStates, handleVertex, rawRotation, mouseCursorDataPos) {
    const copyCount = parseInt(copyCountInput || '1', 10);
    let allPossibleSnaps = [];
    const handleRadius = Math.hypot(handleVertex.x - center.x, handleVertex.y - center.y);
    const snapRadius = C.MERGE_RADIUS_SCREEN / viewTransform.scale;

    const verticesToTransform = initialVertexStates.filter(p => p.type === 'regular');
    const staticVertices = allVertices.filter(p => p.type === 'regular' && !initialVertexStates.some(ip => ip.id === p.id));
    
    // --- Merge Snaps ---
    const multipliers = Array.from({ length: copyCount }, (_, k) => k + 1);
    multipliers.forEach(k => {
        verticesToTransform.forEach(p_orig => {
            staticVertices.forEach(p_target => {
                const v_orig = { x: p_orig.x - center.x, y: p_orig.y - center.y };
                const v_target = { x: p_target.x - center.x, y: p_target.y - center.y };
                if (Math.abs(Math.hypot(v_orig.x, v_orig.y) - Math.hypot(v_target.x, v_target.y)) < C.GEOMETRY_CALCULATION_EPSILON) {
                    let delta_theta = Math.atan2(v_target.y, v_target.x) - Math.atan2(v_orig.y, v_orig.x);
                    const unwrapped_delta = delta_theta + Math.round((rawRotation * k - delta_theta) / (2 * Math.PI)) * (2 * Math.PI);
                    allPossibleSnaps.push({ rotation: unwrapped_delta / k, priority: Math.abs(U.normalizeAngleToPi((unwrapped_delta / k) - rawRotation)), snapType: 'merge' });
                }
            });
        });
    });

    // --- Geometric and Projection Snaps (Shift key) ---
    if (currentShiftPressed) {
        // ... (rest of the snapping logic is correct) ...
        const allSnapAngles = C.NINETY_DEG_ANGLE_SNAP_FRACTIONS.flatMap(f => {
            const angle = f * Math.PI / 2;
            return angle === 0 ? [0] : [angle, -angle];
        });
        allSnapAngles.forEach(angle => {
            const priority = Math.abs(U.normalizeAngleToPi(rawRotation - angle));
            const unwrappedAngle = angle + Math.round((rawRotation - angle) / (2 * Math.PI)) * (2 * Math.PI);
            allPossibleSnaps.push({ rotation: unwrappedAngle, priority: priority, snapType: 'geometric' });
        });

        const excludedVertexIds = new Set(initialVertexStates.map(v => v.id));
        let projectionCandidates = allVertices.filter(p => p.type === 'regular' && !excludedVertexIds.has(p.id));
        if (lastGridState) {
            const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
            if (gridInterval) {
                projectionCandidates.push(...U.getGridSnapCandidates(mouseCursorDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true));
            }
        }
        
        projectionCandidates.forEach(candidate => {
            const distToCursor = U.distance(mouseCursorDataPos, candidate);
            if (distToCursor < C.VERTEX_SELECT_RADIUS / viewTransform.scale) {
                const dragOriginAngle = Math.atan2(handleVertex.y - center.y, handleVertex.x - center.x);
                const projectionSourceAngle = Math.atan2(candidate.y - center.y, candidate.x - center.x);
                const deltaAngle = U.normalizeAngleToPi(projectionSourceAngle - dragOriginAngle);
                const unwrappedDelta = deltaAngle + Math.round((rawRotation - deltaAngle) / (2*Math.PI)) * (2*Math.PI);
                allPossibleSnaps.push({ 
                    rotation: unwrappedDelta,
                    priority: distToCursor / 1000, 
                    snapType: 'projection',
                    projectionSource: candidate,
                });
            }
        });
    }

    if (allPossibleSnaps.length === 0) {
        // --- FIX #1: REMOVE 'pos' FROM THE RETURN OBJECT ---
        // This allows handleMouseMove to use the raw mouseData.
        return { rotation: rawRotation, snapped: false, snapType: null };
    }

    allPossibleSnaps.sort((a, b) => a.priority - b.priority);
    const bestSnap = allPossibleSnaps[0];
    
    if (bestSnap.snapType === 'merge') {
        const finalPosCheck = U.applyTransformToVertex(handleVertex, center, bestSnap.rotation, 1, false, null);
        if (U.distance(mouseCursorDataPos, finalPosCheck) > snapRadius) {
            // --- FIX #2: REMOVE 'pos' FROM THIS FALLBACK RETURN AS WELL ---
            return { rotation: rawRotation, snapped: false, snapType: null };
        }
    }

    const finalPos = U.applyTransformToVertex(handleVertex, center, bestSnap.rotation, 1, false, null);
    let finalProjectionPoint = null;
    if (bestSnap.snapType === 'projection') {
         finalProjectionPoint = {
              x: center.x + handleRadius * Math.cos(Math.atan2(handleVertex.y-center.y, handleVertex.x-center.x) + bestSnap.rotation),
              y: center.y + handleRadius * Math.sin(Math.atan2(handleVertex.y-center.y, handleVertex.x-center.x) + bestSnap.rotation)
         };
    }
    
    return {
        rotation: bestSnap.rotation,
        pos: finalPos,
        snapped: true,
        snapType: bestSnap.snapType,
        projectionSource: bestSnap.projectionSource || null,
        projectionPoint: finalProjectionPoint
    };
}

function getBestScaleSnap(center, initialVertexStates, handleVertex, rawScale) {
    const mouseCursorDataPos = screenToData(mousePos);
    const snapRadius = C.MERGE_RADIUS_SCREEN / viewTransform.scale;
    const verticesToTransform = initialVertexStates.filter(p => p.type === 'regular');
    
    // --- 1. Check for an overriding Merge Snap ---
    const mergeSnaps = [];
    if (verticesToTransform.length > 0) {
        const staticVertices = allVertices.filter(p => p.type === 'regular' && !initialVertexStates.some(ip => ip.id === p.id));
        const angleThreshold = snapRadius / 100;
        const copyCount = parseInt(copyCountInput || '1', 10);

        for (let i = 1; i <= copyCount; i++) {
            verticesToTransform.forEach(p_orig => {
                staticVertices.forEach(p_static => {
                    const v_orig = { x: p_orig.x - center.x, y: p_orig.y - center.y };
                    const v_static = { x: p_static.x - center.x, y: p_static.y - center.y };
                    const r_orig = Math.hypot(v_orig.x, v_orig.y);
                    const r_static = Math.hypot(v_static.x, v_static.y);
                    if (r_orig > C.GEOMETRY_CALCULATION_EPSILON) {
                        const theta_orig = Math.atan2(v_orig.y, v_orig.x);
                        const theta_static = Math.atan2(v_static.y, v_static.y);
                        if (Math.abs(U.normalizeAngleToPi(theta_orig - theta_static)) < angleThreshold) {
                             const snap_scale = Math.pow(r_static / r_orig, 1 / i);
                             const finalPos = U.applyTransformToVertex(handleVertex, center, 0, snap_scale, false, null);
                             mergeSnaps.push({ scale: snap_scale, dist: U.distance(mouseCursorDataPos, finalPos) });
                        }
                    }
                });
            });
        }
        if (copyCount > 1) { /* Additional copy-to-copy logic could go here if needed */ }
    }
    
    if (mergeSnaps.length > 0) {
        const bestMergeSnap = mergeSnaps.sort((a, b) => a.dist - b.dist)[0];
        if (bestMergeSnap.dist < snapRadius) {
            const finalPos = U.applyTransformToVertex(handleVertex, center, 0, bestMergeSnap.scale, false, null);
            return { ...bestMergeSnap, pos: finalPos, snapped: true, snapType: 'merge' };
        }
    }

    // --- 2. If no merge, perform Geometric/Projection Snapping on Shift ---
    if (currentShiftPressed) {
        let bestFractionalSnap, bestProjectionSnap;

        let closestFactor = 1;
        let minDiff = Infinity;
        C.SNAP_FACTORS.forEach(factor => {
            const diff = Math.abs(rawScale - factor);
            if (diff < minDiff) { minDiff = diff; closestFactor = factor; }
        });
        const fractionalPos = U.applyTransformToVertex(handleVertex, center, 0, closestFactor, false, null);
        bestFractionalSnap = { scale: closestFactor, pos: fractionalPos, dist: U.distance(mouseCursorDataPos, fractionalPos), snapType: 'geometric', snappedScaleValue: closestFactor };

        const excludedVertexIds = new Set(initialVertexStates.map(v => v.id));
        const projectionCandidates = allVertices.filter(p => p.type === 'regular' && !excludedVertexIds.has(p.id));
        if (lastGridState) {
            const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
            if (gridInterval) {
                projectionCandidates.push(...U.getGridSnapCandidates(mouseCursorDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true));
            }
        }
        
        if (projectionCandidates.length > 0) {
            const bestCand = projectionCandidates.reduce((a, b) => (U.distance(mouseCursorDataPos, a) < U.distance(mouseCursorDataPos, b) ? a : b));
            const handleRadius = Math.hypot(handleVertex.x - center.x, handleVertex.y - center.y);
            const snapRadiusProj = U.distance(center, bestCand);
            if (handleRadius > C.GEOMETRY_CALCULATION_EPSILON) {
                const snappedScale = snapRadiusProj / handleRadius;
                const handleAngle = Math.atan2(handleVertex.y - center.y, handleVertex.x - center.x);
                const finalPos = { x: center.x + snapRadiusProj * Math.cos(handleAngle), y: center.y + snapRadiusProj * Math.sin(handleAngle) };
                bestProjectionSnap = { scale: snappedScale, pos: finalPos, dist: U.distance(mouseCursorDataPos, finalPos), snapType: 'projection', snappedScaleValue: snappedScale, projectionSource: bestCand };
            }
        }
        
        if (bestProjectionSnap && U.distance(mouseCursorDataPos, bestProjectionSnap.projectionSource) < snapRadius) {
             return { ...bestProjectionSnap, snapped: true };
        } else {
             return { ...bestFractionalSnap, snapped: true };
        }
    }

    // --- 3. Fallback to unsnapped ---
    // --- FIX: REMOVE 'pos' FROM THIS FALLBACK RETURN ---
    return { scale: rawScale, snapped: false, snapType: null };
}

function getBestDirectionalScaleSnap(center, initialVertexStates, handleVertex, rawScale, startVector, mouseCursorDataPos) {
    let allPossibleSnaps = [];
    const snapRadius = C.MERGE_RADIUS_SCREEN / viewTransform.scale;
    const verticesToTransform = initialVertexStates.filter(p => p.type === 'regular');

    // --- 1. Check for an overriding Merge Snap ---
    // Note: Merge snapping for directional scale is complex and has been omitted for now.

    // --- 2. If no merge, perform Geometric/Projection Snapping on Shift ---
    if (currentShiftPressed) {
        let bestFractionalSnap = null;
        let bestProjectionSnap = null;

        // --- Find Best Fractional Snap (Default Behavior) ---
        let closestFactor = 1;
        let minDiff = Infinity;
        const scaleCandidates = [...C.SNAP_FACTORS, ...C.SNAP_FACTORS.map(f => -f)];
        scaleCandidates.forEach(factor => {
            const diff = Math.abs(rawScale - factor);
            if (diff < minDiff) {
                minDiff = diff;
                closestFactor = factor;
            }
        });
        const fractionalPos = U.applyTransformToVertex(handleVertex, center, 0, closestFactor, true, startVector);
        bestFractionalSnap = { scale: closestFactor, pos: fractionalPos, dist: U.distance(mouseCursorDataPos, fractionalPos), snapType: 'geometric', snappedScaleValue: closestFactor };

        // --- Find Best Projection Target ---
        const excludedVertexIds = new Set(initialVertexStates.map(v => v.id));
        const projectionCandidates = allVertices.filter(p => p.type === 'regular' && !excludedVertexIds.has(p.id));
        if (lastGridState) {
            const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
            if (gridInterval) {
                projectionCandidates.push(...U.getGridSnapCandidates(mouseCursorDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true));
            }
        }
        
        if (projectionCandidates.length > 0) {
            const bestProjectionCandidate = projectionCandidates.reduce((best, current) => (U.distance(mouseCursorDataPos, current) < U.distance(mouseCursorDataPos, best) ? current : best));
            const axisDist = Math.hypot(startVector.x, startVector.y);

            if (axisDist > C.GEOMETRY_CALCULATION_EPSILON) {
                const axisNorm = { x: startVector.x / axisDist, y: startVector.y / axisDist };
                const getParallelDist = (p) => (p.x - center.x) * axisNorm.x + (p.y - center.y) * axisNorm.y;

                const handleParallelDist = getParallelDist(handleVertex);
                if (Math.abs(handleParallelDist) > C.GEOMETRY_CALCULATION_EPSILON) {
                    const candidateParallelDist = getParallelDist(bestProjectionCandidate);
                    const snappedScale = candidateParallelDist / handleParallelDist;
                    const finalPos = U.applyTransformToVertex(handleVertex, center, 0, snappedScale, true, startVector);
                    bestProjectionSnap = { scale: snappedScale, pos: finalPos, dist: U.distance(mouseCursorDataPos, finalPos), snapType: 'projection', snappedScaleValue: snappedScale, projectionSource: bestProjectionCandidate };
                }
            }
        }
        
        // --- Decide The Winner ---
        if (bestProjectionSnap && U.distance(mouseCursorDataPos, bestProjectionSnap.projectionSource) < snapRadius) {
             allPossibleSnaps.push({ ...bestProjectionSnap, priority: 0 });
        } else {
             allPossibleSnaps.push({ ...bestFractionalSnap, priority: 1 });
        }
    }

    if (allPossibleSnaps.length === 0) {
        // --- FIX: REMOVE 'pos' FROM THIS FALLBACK RETURN ---
        return { scale: rawScale, snapped: false, snapType: null };
    }
    
    const bestSnap = allPossibleSnaps.sort((a, b) => a.priority - b.priority)[0];
    return { ...bestSnap, snapped: true };
}

function drawEnvironment(colors) {
    const actualCanvasWidth = canvas.width / dpr;
    const actualCanvasHeight = canvas.height / dpr;

    const { grid1Interval, grid2Interval, alpha1, alpha2 } = R.calculateGridIntervals(viewTransform.scale);
    lastGridState = { interval1: grid1Interval, interval2: grid2Interval, alpha1, alpha2, scale: viewTransform.scale };
    lastAngularGridState = R.getDynamicAngularIntervals(viewTransform, actualCanvasWidth, actualCanvasHeight, dataToScreen);

    R.drawGrid(ctx, { gridDisplayMode, canvas, dpr, viewTransform, gridAlpha, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState);

    let axisFormatInfo = { useScientific: false };
    if (coordsDisplayMode !== C.COORDS_DISPLAY_MODE_NONE) {
        const stateForAxes = { canvas, dpr, coordsDisplayMode, viewTransform, angleDisplayMode, colors };
        axisFormatInfo = R.drawAxes(ctx, htmlOverlay, stateForAxes, dataToScreen, screenToData, lastGridState, lastAngularGridState, updateHtmlLabel);
    }
    return axisFormatInfo;
}

function drawMainGeometry(colors) {
    const copyCount = parseInt(copyCountInput || '1', 10);
    const isDeformingDrag = isDragConfirmed && currentShiftPressed && initialDragVertexStates.length === 1 && initialDragVertexStates[0].type === 'regular';
    const isRigidCopyDrag = copyCount > 1 && isDragConfirmed && !isDeformingDrag;
    const rigidCopyVertexIds = isRigidCopyDrag ? new Set(initialDragVertexStates.map(v => v.id)) : new Set();
    const deformingCopyVertexId = (isDeformingDrag && copyCount > 1) ? initialDragVertexStates[0].id : null;

    componentDrawOrder.forEach(componentVertexIds => {
        if (isRigidCopyDrag && [...componentVertexIds].every(id => rigidCopyVertexIds.has(id))) {
            return;
        }
        drawComponent(componentVertexIds, colors);
    });

    allVertices.forEach(vertex => {
        if (vertex.type !== 'regular') {
            let vertexToDraw = { ...vertex };
            if (isDragConfirmed && dragPreviewVertices.length > 0) {
                const preview = dragPreviewVertices.find(dp => dp.id === vertex.id);
                if (preview) vertexToDraw = { ...preview };
            }
            R.drawVertex(ctx, vertexToDraw, { 
                selectedVertexIds, selectedCenterIds, activeCenterId, colors, 
                verticesVisible, isHovered: hoveredVertexId === vertex.id, isSnapped: false 
            }, dataToScreen, updateHtmlLabel);
        }
    });

    if (deformingCopyVertexId) {
        R.drawDeformingDragPreviewFaces(ctx, { copyCount, initialDragVertexStates, dragPreviewVertices, allFaces, findVertexById, colors }, dataToScreen);
        R.drawDeformingDragPreviewEdgesAndVertices(ctx, { copyCount, initialDragVertexStates, dragPreviewVertices, allEdges, findVertexById, findNeighbors: (id) => U.findNeighbors(id, allEdges), colors }, dataToScreen);
    } else if (isRigidCopyDrag) {
        R.drawCopyPreviews(ctx, { copyCount, isDragConfirmed, initialDragVertexStates, dragPreviewVertices, transformIndicatorData, allEdges, allFaces, findVertexById, findNeighbors: (id) => U.findNeighbors(id, allEdges), colors, snappedEdgesInfo: snappedEdgeIds, snappedVertexIds }, dataToScreen);
    }
}

function drawUIElements(colors, axisFormatInfo) {
    R.updateMouseCoordinates(htmlOverlay, { coordsDisplayMode, isMouseOverCanvas, currentShiftPressed, ghostVertexPosition, gridDisplayMode, lastGridState, angleDisplayMode, canvas, dpr, mousePos, colors, useScientific: axisFormatInfo.useScientific }, screenToData, updateHtmlLabel);
    
    const stateForUI = {
        dpr, canvasUI, isToolbarExpanded, isColorPaletteExpanded, isTransformPanelExpanded, isDisplayPanelExpanded, isVisibilityPanelExpanded,
        isPlacingTransform, placingTransformType, placingSnapPos, mousePos,
        allColors, activeThemeName, colors, verticesVisible, edgesVisible, facesVisible, coordsDisplayMode, gridDisplayMode, angleDisplayMode, distanceDisplayMode,
        namedColors: colorEditor.namedColors, colorAssignments, activeColorTargets,
        isDraggingColorTarget, draggedColorTargetInfo
    };
    R.drawCanvasUI(ctx, htmlOverlay, stateForUI, updateHtmlLabel);
}

function redrawAll() {
    labelsToKeepThisFrame.clear();
    const colors = getColors();
    R.clearCanvas(ctx, { canvas, dpr, colors });

    drawMainGeometry(colors);
    const axisFormatInfo = drawEnvironment(colors);

    R.drawAltHoverIndicator(ctx, { altHoverInfo, colors }, dataToScreen, findVertexById, updateHtmlLabel);
    drawFeedbackAndIndicators(colors);
    drawUIElements(colors, axisFormatInfo);

    cleanupHtmlLabels();
}

function updateDrawingSequenceColors() {
    if (!currentDrawingPath || currentDrawingPath.length < 2) return;
    
    const colorIndex = colorAssignments[C.COLOR_TARGET_VERTEX];
    if (colorIndex === -1) return;
    
    const colorItem = allColors[colorIndex];
    if (!colorItem || colorItem.type !== 'colormap') return;
    
    const totalVertices = currentDrawingPath.length;
    currentDrawingPath.forEach((vertexId, index) => {
        const vertex = findVertexById(vertexId);
        if (vertex && vertex.type === 'regular') {
            const t = totalVertices > 1 ? index / (totalVertices - 1) : 0.5;
            vertex.color = U.sampleColormap(colorItem, t);
        }
    });
}

function updateDrawingSequenceEdgeColors() {
    if (!currentDrawingPath || currentDrawingPath.length < 2) return;
    
    const colorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
    if (colorIndex === -1) return;
    
    const colorItem = allColors[colorIndex];
    if (!colorItem || colorItem.type !== 'colormap') return;
    
    const totalVertices = currentDrawingPath.length;
    const totalEdges = totalVertices - 1;
    
    for (let i = 0; i < totalEdges; i++) {
        const startVertexId = currentDrawingPath[i];
        const endVertexId = currentDrawingPath[i + 1];
        
        const edge = allEdges.find(e => 
            (e.id1 === startVertexId && e.id2 === endVertexId) ||
            (e.id1 === endVertexId && e.id2 === startVertexId)
        );
        
        if (edge) {
            const startT = i / totalEdges;
            const endT = (i + 1) / totalEdges;
            edge.gradientStart = startT;
            edge.gradientEnd = endT;
            edge.colormapItem = colorItem;
            delete edge.colormapOffset;
            delete edge.color;
        }
    }
}

function handleColorPaletteClick(screenPos, shiftKey, ctrlKey) {
    if (!isColorPaletteExpanded) return false;


    const removeBtn = canvasUI.removeColorButton;
    if (removeBtn && screenPos.x >= removeBtn.x && screenPos.x <= removeBtn.x + removeBtn.width &&
        screenPos.y >= removeBtn.y && screenPos.y <= removeBtn.y + removeBtn.height) {
        if (allColors.length > 1 && activeColorTargets.length > 0) {
            const primaryTarget = activeColorTargets[activeColorTargets.length - 1];
            const colorIndexToRemove = colorAssignments[primaryTarget];
            if (colorIndexToRemove >= 0) {
                saveStateForUndo();
                removeColorAtIndex(colorIndexToRemove);
            }
        }
        return true;
    }

    const addBtn = canvasUI.addColorButton;
    if (addBtn && screenPos.x >= addBtn.x && screenPos.x <= addBtn.x + addBtn.width &&
        screenPos.y >= addBtn.y && screenPos.y <= addBtn.y + addBtn.height) {
        isEditingColor = false;
        editingColorIndex = null;
        colorEditor.show();
        return true;
    }

    return false;
}

function performEscapeAction() {
    if (copyCountTimer) clearTimeout(copyCountTimer);
    copyCountInput = '';
    copyCountTimer = null;

    // Add this new section:
    if (isDraggingColorSwatch) {
        // Restore original state since drag was cancelled
        allColors = draggedSwatchInfo.originalAllColors;
        colorAssignments = draggedSwatchInfo.originalAssignments;
        buildColorPaletteUI();
        
        // Remove the state we saved at drag start since no action was completed
        if (undoStack.length > 0) {
            undoStack.pop();
        }
        
        isDraggingColorSwatch = false;
        draggedSwatchInfo = null;
        draggedSwatchTemporarilyRemoved = false;
    }

    if (isDrawingMode) {
        isDrawingMode = false;
        previewLineStartVertexId = null;
        frozenReference_A_rad = null;
        frozenReference_A_baseRad = null;
        frozenReference_D_du = null;
        frozenReference_D_g2g = null;
        frozenReference_Origin_Data = null;
        drawingSequence = [];
        currentSequenceIndex = 0;
        currentDrawingPath = [];
        drawingSnapLabelInfo = null;
        return;
    }

    if (isPlacingTransform) {
        isPlacingTransform = false;
        placingTransformType = null;
        placingSnapPos = null;
    }

    selectedVertexIds = [];
    selectedEdgeIds = [];
    selectedFaceIds = [];
    selectedCenterIds = [];
    activeCenterId = null;
    activeColorTargets = [];
    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }

    coordSystemTransformIndicatorData = null;
    isActionInProgress = false;
    isDragConfirmed = false;
    isRectangleSelecting = false;
    isEdgeTransformDrag = false;
    isDraggingCenter = false;
    isPanningBackground = false;
    dragPreviewVertices = [];
    initialDragVertexStates = [];
    actionTargetVertex = null;
    currentMouseButton = -1;
    clickData = { targetId: null, type: null, count: 0, timestamp: 0 };
    canvas.style.cursor = 'crosshair';
    transformIndicatorData = null;
    ghostVertices = [];
    ghostVertexPosition = null;
    highlightedEdgeForSnap = null;
    coordSystemSnapAngle = null;
    draggedFaceId = null;
    coordSystemSnapType = null;
    coordSystemTransformIndicatorData = null;
    altHoverInfo = null;
}

function handleRepeat() {
    if (!isDrawingMode || !previewLineStartVertexId || drawingSequence.length === 0) {
        return;
    }

    saveStateForUndo();

    const lastVertex = findVertexById(previewLineStartVertexId);
    if (!lastVertex) {
        performEscapeAction();
        return;
    }

    const precedingSegmentOfLastVertex = getPrecedingSegment(lastVertex.id);
    if (!precedingSegmentOfLastVertex) {
        performEscapeAction();
        return;
    }
    const currentAbsoluteDirection = precedingSegmentOfLastVertex.angleRad;

    if (drawingSequence.length === 1) {
        return;
    }

    const repeatPatternLength = drawingSequence.length - 1;
    const patternStepIndex = ((currentSequenceIndex - 1) % repeatPatternLength) + 1;
    const patternStep = drawingSequence[patternStepIndex];

    const lengthToDraw = patternStep.length;
    let turnToApplyForNextSegment;
    if (patternStepIndex === drawingSequence.length - 1) {
        const firstRepeatSegmentIndex = drawingSequence.length > 2 ? 1 : 0;
        turnToApplyForNextSegment = drawingSequence[firstRepeatSegmentIndex].turn;
    } else {
        turnToApplyForNextSegment = patternStep.turn;
    }

    let colorForNewVertex;
    let colorForCurrentVertex;

    if (patternStepIndex === drawingSequence.length - 1) {
        const establishedColors = [drawingSequence[0].endVertexColor, drawingSequence[1].endVertexColor];
        const currentColorIndex = (currentSequenceIndex - 1) % establishedColors.length;
        colorForCurrentVertex = establishedColors[currentColorIndex];
        const newColorIndex = currentSequenceIndex % establishedColors.length;
        colorForNewVertex = establishedColors[newColorIndex];
        lastVertex.color = colorForCurrentVertex;
    } else {
        colorForNewVertex = patternStep.endVertexColor;
    }

    const newSegmentAbsoluteAngle = U.normalizeAngle(currentAbsoluteDirection + turnToApplyForNextSegment);

    const targetX = lastVertex.x + lengthToDraw * Math.cos(newSegmentAbsoluteAngle);
    const targetY = lastVertex.y + lengthToDraw * Math.sin(newSegmentAbsoluteAngle);

    let newVertex = null;
    let merged = false;
    const mergeRadiusData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;

    for (const p of allVertices) {
        if (p.type === 'regular' && U.distance({ x: targetX, y: targetY }, p) < mergeRadiusData) {
            newVertex = p;
            merged = true;
            break;
        }
    }

    if (!merged) {
        newVertex = { id: U.generateUniqueId(), x: targetX, y: targetY, type: 'regular', color: colorForNewVertex };
        allVertices.push(newVertex);
    }

    const edgeExists = allEdges.some(e =>
            (e.id1 === lastVertex.id && e.id2 === newVertex.id) ||
            (e.id2 === lastVertex.id && e.id1 === newVertex.id)
        );
        if (!edgeExists) {
            allEdges.push({ id1: lastVertex.id, id2: newVertex.id, color: getColorForTarget(C.COLOR_TARGET_EDGE) });
        }

        if (facesVisible) {
            allFaces = U.detectClosedPolygons(allEdges, findVertexById);
            ensureFaceCoordinateSystems();
        }

        currentDrawingPath.push(newVertex.id);
        window.currentDrawingPath = currentDrawingPath;

        // Update both vertex and edge colors in the drawing sequence
        updateDrawingSequenceColors();
        updateDrawingSequenceEdgeColors();

    previewLineStartVertexId = newVertex.id;

    currentSequenceIndex++;
    if (currentSequenceIndex >= drawingSequence.length) {
        currentSequenceIndex = 1;
    }

    frozenReference_D_du = null;
    frozenReference_D_g2g = null;
    frozenReference_A_rad = null;
    frozenReference_A_baseRad = null;
    frozenReference_Origin_Data = null;
}

function gameLoop() {
    redrawAll();
    requestAnimationFrame(gameLoop);
}

function handleCoordinateSystemMouseDown(event) {
    if (selectedFaceIds.length === 0) return false;

    const mousePos = U.getMousePosOnCanvas(event, canvas);

    for (const faceId of selectedFaceIds) {
        const face = allFaces.find(f => f.id === faceId);
        if (!face || !face.localCoordSystem) continue;

        const element = U.findCoordinateSystemElement(mousePos, face, dataToScreen);
        if (element) {
            isDraggingCoordSystem = true;
            draggedCoordSystemElement = element;
            draggedFaceId = face.id;
            coordSystemSnapTargets = prepareCoordSystemSnapTargets(face);

            if (element.type === 'center') {
                face.localCoordSystem.isCustom = true;
            }

            event.preventDefault();
            return true;
        }
    }

    return false;
}

function prepareCoordSystemSnapTargets(currentFace) {
    const vertices = [];
    const edgeMidvertices = [];
    const edgeVertexIds = [];
    const faceCenters = [];
    const edgeAngles = [];

    currentFace.vertexIds.forEach(id => {
        const vertex = findVertexById(id);
        if (vertex && vertex.type === 'regular') {
            vertices.push({ ...vertex, id: id });
        }
    });

    for (let i = 0; i < vertices.length; i++) {
        const v1 = vertices[i];
        const v2 = vertices[(i + 1) % vertices.length];
        edgeMidvertices.push({
            x: (v1.x + v2.x) / 2,
            y: (v1.y + v2.y) / 2
        });
        
        edgeVertexIds.push(v1.id, v2.id);
        edgeAngles.push(Math.atan2(v2.y - v1.y, v2.x - v1.x));
    }

    allFaces.forEach(face => {
        if (face.id !== currentFace.id && face.localCoordSystem) {
            faceCenters.push(face.localCoordSystem.origin);
        }
    });

    return { vertices, edgeMidvertices, edgeVertexIds, faceCenters, edgeAngles };
}

function getAlignedEdgeInfo(face, edgeIndex) {
    const v1Id = face.vertexIds[edgeIndex];
    const v2Id = face.vertexIds[(edgeIndex + 1) % face.vertexIds.length];
    const v1 = findVertexById(v1Id);
    const v2 = findVertexById(v2Id);
    
    if (v1 && v2) {
        return {
            v1Id,
            v2Id,
            edgeAngle: Math.atan2(v2.y - v1.y, v2.x - v1.x)
        };
    }
    
    return null;
}

function updateAffectedEdgeProperties(movedVertexIds, transformIndicatorData) {
    if (movedVertexIds.length === 0) return;

    // For rotation or translation, properties are preserved, so we do nothing.
    const isRotation = transformIndicatorData && transformIndicatorData.transformType === C.TRANSFORMATION_TYPE_ROTATION;
    const isTranslation = !transformIndicatorData;
    if (isRotation || isTranslation) {
        return;
    }

    const affectedEdges = new Set();
    movedVertexIds.forEach(vertexId => {
        findNeighborEdges(vertexId).forEach(edge => affectedEdges.add(edge));
    });

    const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

    // For scaling, we recalculate the property for each affected edge.
    affectedEdges.forEach(edge => {
        const v1 = findVertexById(edge.id1);
        const v2 = findVertexById(edge.id2);
        if (!v1 || !v2) return;

        const deltaX = v1.x - v2.x;
        const deltaY = v1.y - v2.y;
        const dx_grid_float = deltaX / gridInterval;
        const dy_grid_float = deltaY / gridInterval;
        const epsilon = 1e-5;

        const isGridVector = gridInterval &&
            Math.abs(dx_grid_float - Math.round(dx_grid_float)) < epsilon &&
            Math.abs(dy_grid_float - Math.round(dy_grid_float)) < epsilon;

        if (isGridVector) {
            edge.labelMode = 'exact';
            const dx_grid = Math.round(dx_grid_float);
            const dy_grid = Math.round(dy_grid_float);
            edge.exactValue = {
                g2gSquaredSum: dx_grid * dx_grid + dy_grid * dy_grid,
                gridInterval: gridInterval
            };
        } else {
            edge.labelMode = 'decimal';
            delete edge.exactValue;
        }
    });
}

function handleAddFaceFromMenu() {
    if (contextMenuFaceId) {
        saveStateForUndo();
        let faceToModify = allFaces.find(f => f.id === contextMenuFaceId);

        if (faceToModify) {
            // Face exists as a hole; restore its color and parentage.
            faceToModify.color = getColorForTarget(C.COLOR_TARGET_FACE);
            updateFaceHierarchy();
        } else {
            // Face does not exist; create and add it.
            const allPossibleFaces = U.detectClosedPolygons(allEdges, findVertexById);
            const faceToAdd = allPossibleFaces.find(f => f.id === contextMenuFaceId);
            if (faceToAdd) {
                faceToAdd.color = getColorForTarget(C.COLOR_TARGET_FACE);
                allFaces.push(faceToAdd);
                updateFaceHierarchy();
                ensureFaceCoordinateSystems();
            }
        }
        contextMenuFaceId = null;
    }
    contextMenu.style.display = 'none';
}

function getDescendantFaces(faceId, allFaces) {
    const descendants = [];
    const startFace = allFaces.find(f => f.id === faceId);
    if (!startFace) return [];

    const queue = [...(startFace.childFaceIds || [])];
    const visited = new Set(startFace.childFaceIds);

    while (queue.length > 0) {
        const currentId = queue.shift();
        const currentFace = allFaces.find(f => f.id === currentId);
        if (currentFace) {
            descendants.push(currentFace);
            if (currentFace.childFaceIds) {
                currentFace.childFaceIds.forEach(childId => {
                    if (!visited.has(childId)) {
                        visited.add(childId);
                        queue.push(childId);
                    }
                });
            }
        }
    }
    return descendants;
}

function applyCoordinateSystemConstraintsOnDragEnd(face, initialSystem, initialDragVertexStates, dragPreviewVertices, findVertexById) {
    // This function now correctly solves constraints based on the final vertex positions (dragPreviewVertices)
    // without incorrectly checking against the initial set of dragged vertices.

    if (!initialSystem.isCustom) {
        const faceVertices = face.vertexIds.map(id => {
            return dragPreviewVertices.find(p => p.id === id) || findVertexById(id);
        }).filter(v => v && v.type === 'regular');
        
        if (faceVertices.length >= 3) {
            const incircle = U.calculateIncenter(faceVertices);
            if (incircle) {
                face.localCoordSystem.origin = incircle.center;
                face.localCoordSystem.scale = incircle.radius;
            }
        }
        return;
    }

    let finalOrigin = { ...initialSystem.origin };
    let finalAngle = initialSystem.angle;
    let finalScale = initialSystem.scale;
    
    if (face.localCoordSystem.attachedToVertex) {
        const finalVertex = dragPreviewVertices.find(p => p.id === face.localCoordSystem.attachedToVertex);
        if (finalVertex) {
            finalOrigin = { x: finalVertex.x, y: finalVertex.y };
        }
    } else if (face.localCoordSystem.attachedToEdge) {
        const finalV1 = dragPreviewVertices.find(p => p.id === face.localCoordSystem.attachedToEdge.v1) || findVertexById(face.localCoordSystem.attachedToEdge.v1);
        const finalV2 = dragPreviewVertices.find(p => p.id === face.localCoordSystem.attachedToEdge.v2) || findVertexById(face.localCoordSystem.attachedToEdge.v2);
        
        if (finalV1 && finalV2) {
            finalOrigin = {
                x: finalV1.x + face.localCoordSystem.attachedToEdge.t * (finalV2.x - finalV1.x),
                y: finalV1.y + face.localCoordSystem.attachedToEdge.t * (finalV2.y - finalV1.y)
            };
        }
    }
    
    if (face.localCoordSystem.rotationAlignedToEdge) {
        const finalV1 = dragPreviewVertices.find(p => p.id === face.localCoordSystem.rotationAlignedToEdge.v1) || findVertexById(face.localCoordSystem.rotationAlignedToEdge.v1);
        const finalV2 = dragPreviewVertices.find(p => p.id === face.localCoordSystem.rotationAlignedToEdge.v2) || findVertexById(face.localCoordSystem.rotationAlignedToEdge.v2);
        
        if (finalV1 && finalV2) {
            const newEdgeAngle = Math.atan2(finalV2.y - finalV1.y, finalV2.x - finalV1.x);
            const originalEdgeAngle = face.localCoordSystem.rotationAlignedToEdge.originalAngle;
            const originalSystemAngle = face.localCoordSystem.rotationAlignedToEdge.originalSystemAngle;
            
            const angleOffset = originalSystemAngle - originalEdgeAngle;
            finalAngle = U.normalizeAngle(newEdgeAngle + angleOffset);
            
            face.localCoordSystem.rotationAlignedToEdge.originalAngle = newEdgeAngle;
            face.localCoordSystem.rotationAlignedToEdge.originalSystemAngle = finalAngle;
        }
    }
    
    if (face.localCoordSystem.scaleAttachedToEdge) {
        const finalV1 = dragPreviewVertices.find(p => p.id === face.localCoordSystem.scaleAttachedToEdge.v1) || findVertexById(face.localCoordSystem.scaleAttachedToEdge.v1);
        const finalV2 = dragPreviewVertices.find(p => p.id === face.localCoordSystem.scaleAttachedToEdge.v2) || findVertexById(face.localCoordSystem.scaleAttachedToEdge.v2);
        
        if (finalV1 && finalV2) {
            const newEdgeLength = U.distance(finalV1, finalV2);
            finalScale = newEdgeLength * face.localCoordSystem.scaleAttachedToEdge.scaleRatio;
            face.localCoordSystem.scaleAttachedToEdge.originalLength = newEdgeLength;
        }
    }
    
    const finalFaceVertices = face.vertexIds.map(id => {
        return dragPreviewVertices.find(p => p.id === id) || findVertexById(id);
    }).filter(v => v && v.type === 'regular');
    
    if (finalFaceVertices.length >= 3) {
        face.localCoordSystem.origin = U.clampPointToPolygon(finalOrigin, finalFaceVertices);
        face.localCoordSystem.angle = finalAngle;
        face.localCoordSystem.scale = Math.max(0.01, finalScale);
        face.localCoordSystem.isCustom = true;
    }
}

function backupFaceCoordinateSystemsBeforeMerge(allFaces, findRoot) {
    const faceCoordSystemBackup = new Map();
    allFaces.forEach(face => {
        const remappedVertexIds = [...new Set(face.vertexIds.map(vId => findRoot(vId)))];
        if (remappedVertexIds.length >= 3) {
            const newFaceId = U.getFaceId({ vertexIds: remappedVertexIds });
            if (face.localCoordSystem && face.localCoordSystem.isCustom) {
                const backup = JSON.parse(JSON.stringify(face.localCoordSystem));

                if (backup.attachedToVertex) {
                    backup.attachedToVertex = findRoot(backup.attachedToVertex);
                }
                if (backup.attachedToEdge) {
                    backup.attachedToEdge.v1 = findRoot(backup.attachedToEdge.v1);
                    backup.attachedToEdge.v2 = findRoot(backup.attachedToEdge.v2);
                }
                if (backup.rotationAlignedToEdge) {
                    backup.rotationAlignedToEdge.v1 = findRoot(backup.rotationAlignedToEdge.v1);
                    backup.rotationAlignedToEdge.v2 = findRoot(backup.rotationAlignedToEdge.v2);
                }
                if (backup.scaleAttachedToEdge) {
                    backup.scaleAttachedToEdge.v1 = findRoot(backup.scaleAttachedToEdge.v1);
                    backup.scaleAttachedToEdge.v2 = findRoot(backup.scaleAttachedToEdge.v2);
                }

                faceCoordSystemBackup.set(newFaceId, backup);
            }
        }
    });
    return faceCoordSystemBackup;
}

function showContextMenu(event) {
    contextMenu.innerHTML = '';
    contextMenu.style.display = 'none';
    mousePos = U.getMousePosOnCanvas(event, canvas);

    // --- Selection Logic on Right-Click ---
    const clickedVertex = findClickedVertex(mousePos);
    const clickedEdge = !clickedVertex ? findClickedEdge(mousePos) : null;
    const clickedFace = !clickedVertex && !clickedEdge ? findClickedFace(mousePos) : null;
    const clickedItem = clickedVertex || clickedEdge || clickedFace;

    if (clickedItem) {
        let wasSelected = false;
        if (clickedVertex) wasSelected = selectedVertexIds.includes(clickedVertex.id);
        else if (clickedEdge) wasSelected = selectedEdgeIds.includes(U.getEdgeId(clickedEdge));
        else if (clickedFace) wasSelected = selectedFaceIds.includes(U.getFaceId(clickedFace));

        if (!wasSelected) {
            selectedVertexIds = [];
            selectedEdgeIds = [];
            selectedFaceIds = [];
            selectedCenterIds = [];
            if (clickedVertex) selectedVertexIds = [clickedVertex.id];
            else if (clickedEdge) selectedEdgeIds = [U.getEdgeId(clickedEdge)];
            else if (clickedFace) selectedFaceIds = [U.getFaceId(clickedFace)];
        }
    } else {
        performEscapeAction();
    }
    // --- End of Selection Logic ---

    const dataPos = screenToData(mousePos);
    let menuItems = [];
    contextMenuFaceId = null;
    contextMenuEdgeId = null;
    contextMenuVertexId = null;

    const selectionTypeCount =
        (selectedVertexIds.length > 0 ? 1 : 0) +
        (selectedEdgeIds.length > 0 ? 1 : 0) +
        (selectedFaceIds.length > 0 ? 1 : 0);

    // Re-check clicked item after selection has been finalized
    const finalClickedVertex = findClickedVertex(mousePos);
    const finalClickedEdge = !finalClickedVertex ? findClickedEdge(mousePos) : null;

    if (finalClickedVertex && finalClickedVertex.type === 'regular') {
        contextMenuVertexId = finalClickedVertex.id;
        const removeText = selectionTypeCount > 1 ? "Remove Geometry" : "Remove Vertex";
        menuItems.push({ text: removeText, handler: handleRemoveVertexFromMenu });
    } else if (finalClickedEdge) {
        contextMenuEdgeId = U.getEdgeId(finalClickedEdge);
        const removeText = selectionTypeCount > 1 ? "Remove Geometry" : "Remove Edge";
        menuItems.push({ text: removeText, handler: handleRemoveEdgeFromMenu });
    } else {
        const finalClickedFace = findClickedFace(mousePos);
        if (finalClickedFace) {
            contextMenuFaceId = U.getFaceId(finalClickedFace);
            const removeText = selectionTypeCount > 1 ? "Remove Geometry" : "Remove Face";
            menuItems.push({ text: removeText, handler: handleRemoveFaceFromMenu });
            if (finalClickedFace.childFaceIds && finalClickedFace.childFaceIds.length > 0) {
                menuItems.push({ text: 'Remove Face and Children', handler: handleRemoveFaceAndChildrenFromMenu });
            }
        } else {
            const allPossibleFaces = U.detectClosedPolygons(allEdges, findVertexById);
            let smallestPotentialFace = null;
            let smallestArea = Infinity;
            allPossibleFaces.forEach(loop => {
                const vertices = loop.vertexIds.map(id => findVertexById(id));
                if (vertices.every(Boolean) && U.isVertexInPolygon(dataPos, vertices)) {
                    const area = Math.abs(U.shoelaceArea(vertices));
                    if (area < smallestArea) {
                        smallestArea = area;
                        smallestPotentialFace = loop;
                    }
                }
            });
            if (smallestPotentialFace) {
                contextMenuFaceId = smallestPotentialFace.id || U.getFaceId(smallestPotentialFace);
                menuItems.push({ text: 'Add Face', handler: handleAddFaceFromMenu });
            }
        }
    }

    if (menuItems.length > 0) {
        const ul = document.createElement('ul');
        menuItems.forEach(itemData => {
            const li = document.createElement('li');
            li.textContent = itemData.text;
            li.addEventListener('click', itemData.handler);
            ul.appendChild(li);
        });
        contextMenu.appendChild(ul);
        contextMenu.style.left = `${event.clientX - C.CONTEXT_MENU_INSET}px`;
        contextMenu.style.top = `${event.clientY - C.CONTEXT_MENU_INSET}px`;
        contextMenu.style.display = 'block';
    }
}

function handleDisplayPanelClick(screenPos) {
    if (isDisplayPanelExpanded) {
        for (const icon of canvasUI.displayIcons) {
            if (screenPos.x >= icon.x && screenPos.x <= icon.x + icon.width &&
                screenPos.y >= icon.y && screenPos.y <= icon.y + icon.height) {
                switch (icon.group) {
                    case 'coords':
                        const coordsModes = [C.COORDS_DISPLAY_MODE_NONE, C.COORDS_DISPLAY_MODE_REGULAR, C.COORDS_DISPLAY_MODE_COMPLEX, C.COORDS_DISPLAY_MODE_POLAR];
                        coordsDisplayMode = coordsModes[(coordsModes.indexOf(coordsDisplayMode) + 1) % coordsModes.length];
                        break;
                    case 'grid':
                        const gridModes = [C.GRID_DISPLAY_MODE_LINES, C.GRID_DISPLAY_MODE_POINTS, C.GRID_DISPLAY_MODE_TRIANGULAR, C.GRID_DISPLAY_MODE_POLAR, C.GRID_DISPLAY_MODE_NONE];
                        gridDisplayMode = gridModes[(gridModes.indexOf(gridDisplayMode) + 1) % gridModes.length];
                        break;
                    case 'angles':
                        const angleModes = [C.ANGLE_DISPLAY_MODE_DEGREES, C.ANGLE_DISPLAY_MODE_RADIANS, C.ANGLE_DISPLAY_MODE_NONE];
                        angleDisplayMode = angleModes[(angleModes.indexOf(angleDisplayMode) + 1) % angleModes.length];
                        showAngles = angleDisplayMode !== C.ANGLE_DISPLAY_MODE_NONE;
                        break;
                    case 'distances':
                        const distModes = [C.DISTANCE_DISPLAY_MODE_ON, C.DISTANCE_DISPLAY_MODE_NONE];
                        distanceDisplayMode = distModes[(distModes.indexOf(distanceDisplayMode) + 1) % distModes.length];
                        showDistances = distanceDisplayMode === C.DISTANCE_DISPLAY_MODE_ON;
                        break;
                    case 'theme':
                        handleThemeToggle();
                        break;
                }
                return true;
            }
        }
    }
    return false;
}

function handleCanvasUIClick(screenPos, shiftKey = false, ctrlKey = false) {
    const btn = canvasUI.toolbarButton;
    if (screenPos.x >= btn.x && screenPos.x <= btn.x + btn.width &&
        screenPos.y >= btn.y && screenPos.y <= btn.y + btn.height) {
        isToolbarExpanded = !isToolbarExpanded;
        if (isToolbarExpanded) {
            buildMainToolbarUI();
        } else {
            isColorPaletteExpanded = false;
            isTransformPanelExpanded = false;
            isDisplayPanelExpanded = false;
            isVisibilityPanelExpanded = false;
            activeColorTargets = [];
        }
        return true;
    }

    if (isToolbarExpanded) {
        const ctb = canvasUI.colorToolButton;
        if (ctb && screenPos.x >= ctb.x && screenPos.x <= ctb.x + ctb.width &&
            screenPos.y >= ctb.y && screenPos.y <= ctb.y + ctb.height) {
            handleColorToolButtonClick();
            return true;
        }

        const ttb = canvasUI.transformToolButton;
        if (ttb && screenPos.x >= ttb.x && screenPos.x <= ttb.x + ttb.width &&
            screenPos.y >= ttb.y && screenPos.y <= ttb.y + ttb.height) {
            isTransformPanelExpanded = !isTransformPanelExpanded;
            if (isTransformPanelExpanded) buildTransformPanelUI();
            return true;
        }

        const vtb = canvasUI.visibilityToolButton;
        if (vtb && screenPos.x >= vtb.x && screenPos.x <= vtb.x + vtb.width &&
            screenPos.y >= vtb.y && screenPos.y <= vtb.y + vtb.height) {
            isDisplayPanelExpanded = !isDisplayPanelExpanded;
            if (isDisplayPanelExpanded) buildDisplayPanelUI();
            return true;
        }
    }

    if (isColorPaletteExpanded) {
        if (handleColorPaletteClick(screenPos, shiftKey, ctrlKey)) {
            return true;
        }
    }

    if (isTransformPanelExpanded) {
        for (const icon of canvasUI.transformIcons) {
            if (screenPos.x >= icon.x && screenPos.x <= icon.x + icon.width &&
                screenPos.y >= icon.y && screenPos.y <= icon.y + icon.height) {
                if (isPlacingTransform) {
                    placingTransformType = icon.type;
                } else {
                    isPlacingTransform = true;
                    placingTransformType = icon.type;
                    canvas.style.cursor = 'none';
                }
                return true;
            }
        }
    }

    if (isDisplayPanelExpanded) {
        if (handleDisplayPanelClick(screenPos, shiftKey, ctrlKey)) {
            return true;
        }
    }

    // Fallback check: If the click didn't hit a specific element but is within any UI panel,
    // consume the click to prevent canvas interaction.
    if (isMouseInUIPanel(screenPos)) {
        return true;
    }

    return false;
}

function handleUndo() {
    if (undoStack.length === 0) return;
    
    
    const currentStateForRedo = getCurrentState();
    const currentSignature = {
        colorCount: allColors.length,
        firstColor: allColors[0]?.value || 'none',
        vertexCount: allVertices.length
    };
    
    redoStack.push(currentStateForRedo);
    if (redoStack.length > C.MAX_HISTORY_SIZE) redoStack.shift();
    
    const prevState = undoStack.pop();
    
    restoreState(prevState);
    
    const restoredSignature = {
        colorCount: allColors.length,
        firstColor: allColors[0]?.value || 'none',
        vertexCount: allVertices.length
    };
    updateComponentDrawOrder()
}

function handleRedo() {
    if (redoStack.length === 0) return;
    const currentStateForUndo = getCurrentState();
    undoStack.push(currentStateForUndo);
    if (undoStack.length > C.MAX_HISTORY_SIZE) undoStack.shift();
    const nextState = redoStack.pop();
    restoreState(nextState);
    updateComponentDrawOrder()
}

function handleAltHoverMouseMove(mousePos, shiftKey) {
    const mouseDataPos = screenToData(mousePos);
    const p = findClickedVertex(mousePos);
    const e = !p ? findClickedEdge(mousePos) : null;
    const f = !p && !e ? findClickedFace(mousePos) : null;

    if (p) {
        altHoverInfo = {
            point: { x: p.x, y: p.y },
            element: { type: 'vertex', id: p.id },
            shiftKey: shiftKey
        };
    } else if (e) {
        const p1 = findVertexById(e.id1);
        const p2 = findVertexById(e.id2);
        if (p1 && p2) {
            let finalPoint;
            let finalFraction;
            const closest = U.getClosestPointOnLineSegment(mouseDataPos, p1, p2);

            if (shiftKey) {
                const snapResult = U.getBestFractionalSnap(closest, p1, p2);
                finalPoint = snapResult.point;
                finalFraction = snapResult.fraction;
            } else {
                finalPoint = { x: closest.x, y: closest.y };
                finalFraction = closest.t;
            }

            altHoverInfo = {
                point: finalPoint,
                element: { type: 'edge', edge: e },
                shiftKey: shiftKey,
                fraction: finalFraction
            };
        }
    } else if (f) {
        altHoverInfo = {
            point: mouseDataPos,
            element: { type: 'face', id: U.getFaceId(f) },
            shiftKey: shiftKey
        };
    } else {
        altHoverInfo = null;
    }

    // This is the key part that disables the standard hover effect
    hoveredVertexId = null;
    hoveredEdgeId = null;
    hoveredFaceId = null;
}

function handleThemeToggle() {
    saveStateForUndo();
    activeThemeName = activeThemeName === 'dark' ? 'light' : 'dark';
    invertColors(); // This now only inverts the user-defined swatches
    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }
}

function handleCoordinateSystemMouseMove(event) {
    if (!isDraggingCoordSystem || !draggedCoordSystemElement) return false;

    const mousePos = U.getMousePosOnCanvas(event, canvas);
    const mouseDataPos = screenToData(mousePos);
    const element = draggedCoordSystemElement;
    const face = element.face;
    const coordSystem = face.localCoordSystem;

    const faceVertices = face.vertexIds.map(id => findVertexById(id)).filter(p => p && p.type === 'regular' && p.x !== undefined && p.y !== undefined);

    if (element.type === 'center') {
        let targetPos;
        let snapResult = { snapped: false };
        
        if (event.shiftKey) {
            snapResult = U.getCoordinateSystemCenterSnap(
                mouseDataPos,
                coordSystemSnapTargets,
                gridDisplayMode,
                lastGridState,
                lastAngularGridState
            );
            
            if (snapResult.snapped) {
                targetPos = snapResult.snapPoint;
                
                if (snapResult.snapType === 'edge') {
                    const edgeInfo = snapResult.edgeInfo;
                    const v1 = findVertexById(edgeInfo.v1);
                    const v2 = findVertexById(edgeInfo.v2);
                    
                    if (v1 && v2) {
                        if (initialCoordSystemStateOnDrag && initialCoordSystemStateOnDrag.attachedToEdge) {
                            const fractions = [0, 0.25, 1/3, 0.5, 2/3, 0.75, 1];
                            let bestFraction = 0.5;
                            let minDist = Infinity;
                            
                            fractions.forEach(frac => {
                                const fracPoint = {
                                    x: v1.x + frac * (v2.x - v1.x),
                                    y: v1.y + frac * (v2.y - v1.y)
                                };
                                const dist = U.distance(mouseDataPos, fracPoint);
                                if (dist < minDist) {
                                    minDist = dist;
                                    bestFraction = frac;
                                }
                            });
                            
                            targetPos = {
                                x: v1.x + bestFraction * (v2.x - v1.x),
                                y: v1.y + bestFraction * (v2.y - v1.y)
                            };
                            
                            snapResult.edgeInfo.t = bestFraction;
                            
                            const currentEdgeLength = U.distance(v1, v2);
                            const originalEdgeLength = coordSystem.attachedToEdge ? coordSystem.attachedToEdge.originalLength : currentEdgeLength;
                            const scaleRatio = coordSystem.scale / originalEdgeLength;
                            
                            snapResult.edgeInfo.originalLength = currentEdgeLength;
                            snapResult.edgeInfo.scaleRatio = scaleRatio;
                            
                            coordSystemTransformIndicatorData = {
                                edgeFraction: bestFraction,
                                v1: v1,
                                v2: v2,
                                snapPosition: targetPos
                            };
                        } else {
                            targetPos = snapResult.snapPoint;
                            coordSystemTransformIndicatorData = null;
                        }
                    }
                }
            } else {
                const incenter = U.calculateIncenter(faceVertices);
                targetPos = incenter ? incenter.center : faceVertices[0];
            }
            
            if (element.type === 'center') {
                ghostVertexPosition = targetPos;
            }
        } else {
            targetPos = mouseDataPos;
            ghostVertexPosition = null;
            coordSystemTransformIndicatorData = null;
        }
        
        if (faceVertices.length > 0 && faceVertices.every(v => v && v.x !== undefined && v.y !== undefined)) {
            targetPos = U.clampPointToPolygon(targetPos, faceVertices);
            
            if (ghostVertexPosition) {
                ghostVertexPosition = U.clampPointToPolygon(ghostVertexPosition, faceVertices);
            }
        }
        
        coordSystem.origin.x = targetPos.x;
        coordSystem.origin.y = targetPos.y;
        coordSystem.isCustom = true;
        
        if (snapResult.snapped) {
            coordSystem.attachedToVertex = snapResult.vertexId || null;
            coordSystem.attachedToEdge = snapResult.edgeInfo || null;
        } else {
            coordSystem.attachedToVertex = null;
            coordSystem.attachedToEdge = null;
        }
    } else if (element.type === 'x_axis' || element.type === 'y_axis') {
        const vectorFromOrigin = {
            x: mouseDataPos.x - coordSystem.origin.x,
            y: mouseDataPos.y - coordSystem.origin.y
        };
        
        let newAngle = Math.atan2(vectorFromOrigin.y, vectorFromOrigin.x);
        let newScale = Math.hypot(vectorFromOrigin.x, vectorFromOrigin.y);

        highlightedEdgeForSnap = null;
        coordSystemSnapAngle = null;
        coordSystemSnapType = null;
        ghostVertices = [];
        ghostVertexPosition = null;
        coordSystemTransformIndicatorData = null;
        coordSystemSnapScale = null;
        
        if (event.shiftKey) {
            const angleSnapResult = U.getAxisSnapAngle(mouseDataPos, coordSystem.origin, true, coordSystemSnapTargets);
            
            if (angleSnapResult.snapped) {
                newAngle = angleSnapResult.angle;
                coordSystemSnapAngle = newAngle;
                coordSystemSnapType = angleSnapResult.snapType;
                
                const snappedAxisDirection = { x: Math.cos(newAngle), y: Math.sin(newAngle) };
                const mouseVector = { x: mouseDataPos.x - coordSystem.origin.x, y: mouseDataPos.y - coordSystem.origin.y };
                const effectiveScale = mouseVector.x * snappedAxisDirection.x + mouseVector.y * snappedAxisDirection.y;

                if (angleSnapResult.snapType === 'vertex_direction') {
                    const targetVertex = findVertexById(angleSnapResult.targetVertexId);
                    if (targetVertex) {
                        newScale = U.distance(coordSystem.origin, targetVertex);
                        coordSystemSnapScale = newScale;
                    }
                } else if (angleSnapResult.edgeIndex !== null) {
                    highlightedEdgeForSnap = angleSnapResult.edgeIndex;
                    const edgeInfo = getAlignedEdgeInfo(face, angleSnapResult.edgeIndex);
                    const isPerpendicular = Math.abs(U.normalizeAngleToPi(newAngle - edgeInfo.edgeAngle)) > Math.PI / 4 && Math.abs(U.normalizeAngleToPi(newAngle - edgeInfo.edgeAngle)) < 3 * Math.PI / 4;

                    if (element.type === 'x_axis' && isPerpendicular) {
                        const v1 = findVertexById(edgeInfo.v1Id);
                        const v2 = findVertexById(edgeInfo.v2Id);
                        if (v1 && v2) {
                            const closestOnEdge = U.getClosestPointOnLine(coordSystem.origin, v1, v2);
                            const referenceOrthogonalDistance = closestOnEdge.distance;

                            const fractions = [0.25, 1/3, 0.5, 2/3, 0.75, 1.0];
                            let bestSnap = { scale: effectiveScale, dist: Infinity, fraction: null };

                            fractions.forEach(frac => {
                                const targetDist = referenceOrthogonalDistance * frac;
                                const diff = Math.abs(effectiveScale - targetDist);
                                if (diff < bestSnap.dist) {
                                    bestSnap = { scale: targetDist, dist: diff, fraction: frac };
                                }
                            });
                            
                            const pixelSnapThreshold = 15 / viewTransform.scale;
                            if (bestSnap.dist < pixelSnapThreshold) {
                                newScale = bestSnap.scale;
                                coordSystemSnapScale = newScale;
                                coordSystemTransformIndicatorData = {
                                    orthogonalDistanceFraction: bestSnap.fraction,
                                    v1: v1,
                                    v2: v2,
                                    snapPosition: { origin: coordSystem.origin, closest: closestOnEdge }
                                };
                            } else {
                                newScale = effectiveScale > 0 ? effectiveScale : 0;
                                coordSystemSnapScale = newScale;
                            }
                        }
                    } else {
                        const scaleSnapResult = U.getAxisScaleSnap(
                            coordSystem.origin, 
                            element.type === 'y_axis' ? newAngle - Math.PI / 2 : newAngle, 
                            { alignedEdgeInfo: edgeInfo }, 
                            face, 
                            findVertexById,
                            effectiveScale,
                            viewTransform,
                            element.type
                        );
                        
                        if (scaleSnapResult.snapped) {
                            newScale = scaleSnapResult.scale;
                            coordSystemSnapScale = newScale;
                            
                            if (scaleSnapResult.edgeFraction !== null) {
                                const arrowHeadPosition = {
                                    x: coordSystem.origin.x + newScale * Math.cos(element.type === 'y_axis' ? newAngle : newAngle),
                                    y: coordSystem.origin.y + newScale * Math.sin(element.type === 'y_axis' ? newAngle : newAngle)
                                };
                                coordSystemTransformIndicatorData = {
                                    edgeFraction: scaleSnapResult.edgeFraction,
                                    v1: findVertexById(edgeInfo.v1Id),
                                    v2: findVertexById(edgeInfo.v2Id),
                                    snapPosition: arrowHeadPosition
                                };
                            }
                        } else {
                             newScale = effectiveScale > 0 ? effectiveScale : 0;
                        }
                    }
                }
            } else {
                newScale = Math.hypot(vectorFromOrigin.x, vectorFromOrigin.y);
            }
        }

        if (element.type === 'y_axis') {
            coordSystem.angle = newAngle - Math.PI / 2;
        } else {
            coordSystem.angle = newAngle;
        }

        if (newScale > 0.01) {
            coordSystem.scale = newScale;
        }

        coordSystem.isCustom = true;
    }

    return true;
}

function handleCoordinateSystemMouseUp() {
    if (isDraggingCoordSystem) {
        const element = draggedCoordSystemElement;
        const face = element.face;
        const coordSystem = face.localCoordSystem;
        
        if (element.type === 'center' && coordSystem) {
            const snapThreshold = 0.01;
            let attachedToVertex = null;
            let attachedToEdge = null;
            
            face.vertexIds.forEach(vertexId => {
                const vertex = findVertexById(vertexId);
                if (vertex && U.distance(coordSystem.origin, vertex) < snapThreshold) {
                    attachedToVertex = vertexId;
                }
            });
            
            if (!attachedToVertex) {
                for (let i = 0; i < face.vertexIds.length; i++) {
                    const v1 = findVertexById(face.vertexIds[i]);
                    const v2 = findVertexById(face.vertexIds[(i + 1) % face.vertexIds.length]);
                    if (v1 && v2) {
                        const closest = U.getClosestPointOnLineSegment(coordSystem.origin, v1, v2);
                        if (closest.distance < snapThreshold && closest.onSegmentStrict) {
                            const currentEdgeLength = U.distance(v1, v2);
                            attachedToEdge = { 
                                v1: v1.id, 
                                v2: v2.id, 
                                t: closest.t,
                                originalAngle: Math.atan2(v2.y - v1.y, v2.x - v1.x),
                                originalLength: currentEdgeLength,
                                scaleRatio: coordSystem.scale / currentEdgeLength
                            };
                            break;
                        }
                    }
                }
            }
            
            coordSystem.attachedToVertex = attachedToVertex;
            coordSystem.attachedToEdge = attachedToEdge;
        }

        if (element.type === 'x_axis' || element.type === 'y_axis') {
            let didSnapRotationToEdge = false;
            let didSnapScaleToEdge = false;

            if (coordSystemSnapType === 'edge' && highlightedEdgeForSnap !== null) {
                const edgeInfo = getAlignedEdgeInfo(face, highlightedEdgeForSnap);
                if (edgeInfo) {
                    if (coordSystemSnapAngle !== null) {
                        coordSystem.rotationAlignedToEdge = {
                            v1: edgeInfo.v1Id,
                            v2: edgeInfo.v2Id,
                            originalAngle: edgeInfo.edgeAngle,
                            originalSystemAngle: coordSystem.angle
                        };
                        didSnapRotationToEdge = true;
                    }

                    if (coordSystemSnapScale !== null) {
                        const v1 = findVertexById(edgeInfo.v1Id);
                        const v2 = findVertexById(edgeInfo.v2Id);
                        if (v1 && v2) {
                            const edgeLength = U.distance(v1, v2);
                            if (edgeLength > C.GEOMETRY_CALCULATION_EPSILON) {
                                coordSystem.scaleAttachedToEdge = {
                                    v1: edgeInfo.v1Id,
                                    v2: edgeInfo.v2Id,
                                    scaleRatio: coordSystem.scale / edgeLength
                                };
                                didSnapScaleToEdge = true;
                            }
                         }
                    }
                }
            }

            if (!didSnapRotationToEdge) {
                coordSystem.rotationAlignedToEdge = null;
            }
            if (!didSnapScaleToEdge) {
                coordSystem.scaleAttachedToEdge = null;
            }
        }
        
        coordSystemSnapScale = null;
        coordSystemTransformIndicatorData = null;
        isDraggingCoordSystem = false;
        draggedCoordSystemElement = null;
        coordSystemSnapTargets = null;
        highlightedEdgeForSnap = null;
        coordSystemSnapAngle = null;
        coordSystemSnapType = null;
        draggedFaceId = null;
        ghostVertexPosition = null;
        ghostVertices = [];
        coordSystemTransformIndicatorData = null;
        return true;
    }
    return false;
}

function handleColorToolButtonClick() {
    isColorPaletteExpanded = !isColorPaletteExpanded;
    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }
}

function handleRemoveFaceAndChildrenFromMenu() {
    if (contextMenuFaceId) {
        saveStateForUndo();
        const face = allFaces.find(f => f.id === contextMenuFaceId);
        if (face) {
            // 1. Get all descendants (children, grandchildren, etc.)
            const descendantFaces = getDescendantFaces(face.id, allFaces);
            const descendantFaceIds = new Set(descendantFaces.map(df => df.id));
            const descendantVertexIds = new Set();
            descendantFaces.forEach(df => {
                df.vertexIds.forEach(vId => descendantVertexIds.add(vId));
            });

            // 2. Remove all descendant vertices
            allVertices = allVertices.filter(v => !descendantVertexIds.has(v.id));

            // 3. Remove all edges connected to the now-deleted descendant vertices
            allEdges = allEdges.filter(e => !descendantVertexIds.has(e.id1) && !descendantVertexIds.has(e.id2));

            // 4. Remove the parent face and all descendant faces from the faces list
            const allFaceIdsToRemove = new Set([face.id, ...descendantFaceIds]);
            allFaces = allFaces.filter(f => !allFaceIdsToRemove.has(f.id));

            // 5. Clear selection to avoid dangling references
            performEscapeAction();
        }
        contextMenuFaceId = null;
    }
    contextMenu.style.display = 'none';
}

function handleRemoveVertexFromMenu() {
    if (contextMenuVertexId) {
        saveStateForUndo();

        // Check if the right-clicked vertex was already part of a selection.
        const wasVertexSelected = selectedVertexIds.includes(contextMenuVertexId);
        
        if (wasVertexSelected) {
            // If it was selected, the "Remove" action applies to the entire existing selection.
            // We don't need to change the selection arrays.
        } else {
            // If it was not selected, the action applies only to this newly right-clicked vertex.
            selectedEdgeIds = [];
            selectedFaceIds = [];
            selectedCenterIds = [];
            selectedVertexIds = [contextMenuVertexId];
        }

        deleteSelectedItems(); // This now operates on the correct selection set.
        contextMenuVertexId = null;
    }
    contextMenu.style.display = 'none';
}

function handleRemoveEdgeFromMenu() {
    if (contextMenuEdgeId) {
        saveStateForUndo();
        
        // Check if the right-clicked edge was already part of the selection.
        const wasEdgeSelected = selectedEdgeIds.includes(contextMenuEdgeId);
        
        if (!wasEdgeSelected) {
            // If it was not selected, clear the old selection.
            selectedVertexIds = [];
            selectedFaceIds = [];
            selectedCenterIds = [];
            selectedEdgeIds = [contextMenuEdgeId];
        }
        // If it was already selected, do nothing to preserve the multi-selection.

        deleteSelectedItems();
        contextMenuEdgeId = null;
    }
    contextMenu.style.display = 'none';
}

function handleRemoveFaceFromMenu() {
    if (contextMenuFaceId) {
        saveStateForUndo();

        // Check if the right-clicked face was already part of the selection.
        const wasFaceSelected = selectedFaceIds.includes(contextMenuFaceId);

        if (!wasFaceSelected) {
            // If it was not selected, clear the old selection.
            selectedVertexIds = [];
            selectedEdgeIds = [];
            selectedCenterIds = [];
            selectedFaceIds = [contextMenuFaceId];
        }
        // If it was already selected, do nothing to preserve the multi-selection.

        deleteSelectedItems();
        contextMenuFaceId = null;
    }
    contextMenu.style.display = 'none';
}

function handleLeftMouseButtonDown(event) {
    const clickedUIElement = U.getClickedUIElement(mousePos, canvasUI, { isToolbarExpanded, isColorPaletteExpanded, isTransformPanelExpanded, isDisplayPanelExpanded, isVisibilityPanelExpanded });
    if (isPlacingTransform && (!clickedUIElement || clickedUIElement.type !== 'transformIcon')) {
        saveStateForUndo();
        const mouseDataPos = screenToData(mousePos);
        const snappedPos = currentShiftPressed ? getBestSnapPosition(mouseDataPos) : mouseDataPos;

        const newCenter = {
            id: U.generateUniqueId(),
            x: snappedPos.x,
            y: snappedPos.y,
            type: placingTransformType
        };
        allVertices.push(newCenter);

        // Make the new center active and selected
        selectedCenterIds = [newCenter.id];
        activeCenterId = newCenter.id;
        // Clear other selections for clarity
        selectedVertexIds = [];
        selectedEdgeIds = [];
        selectedFaceIds = [];

        // Reset ONLY the placement-related state, keeping the new selection
        isPlacingTransform = false;
        placingTransformType = null;
        placingSnapPos = null;
        canvas.style.cursor = 'crosshair';

        event.preventDefault();
        return;
    }
    isActionInProgress = true;
    isDragConfirmed = false;
    isPanningBackground = false;

    if (isColorPaletteExpanded) {
        const iconsUnderMouse = (canvasUI.colorTargetIcons || []).filter(icon =>
            mousePos.x >= icon.x && mousePos.x <= icon.x + icon.width &&
            mousePos.y >= icon.y && mousePos.y <= icon.y + icon.height
        );

        if (iconsUnderMouse.length > 0) {
            const topIcon = iconsUnderMouse[iconsUnderMouse.length - 1];

            const { element, shiftKey, ctrlKey } = { element: topIcon, shiftKey: event.shiftKey, ctrlKey: event.ctrlKey || event.metaKey };
            if (shiftKey) {
                if (!activeColorTargets.includes(element.target)) {
                    activeColorTargets.push(element.target);
                }
            } else if (ctrlKey) {
                if (activeColorTargets.includes(element.target)) {
                    activeColorTargets = activeColorTargets.filter(t => t !== element.target);
                } else {
                    activeColorTargets.push(element.target);
                }
            } else {
                activeColorTargets = [element.target];
            }
            buildColorPaletteUI();

            actionContext = { target: 'ui_icon_click', element: { ...topIcon, type: 'colorTargetIcon' } };
            canvas.style.cursor = 'default';
            return;
        }

        for (const swatch of canvasUI.colorSwatches) {
            if (mousePos.x >= swatch.x && mousePos.x <= swatch.x + swatch.width &&
                mousePos.y >= swatch.y && mousePos.y <= swatch.y + swatch.height) {
                actionContext = { target: 'ui_swatch', element: { ...swatch } };
                canvas.style.cursor = 'default';
                return;
            }
        }
    }

    if (handleCanvasUIClick(mousePos, event.shiftKey, event.ctrlKey || event.metaKey)) {
        actionContext = { target: 'ui' }; // Set a generic context for UI clicks
        canvas.style.cursor = 'default';
        return;
    }

    if (handleCoordinateSystemMouseDown(event)) {
        return;
    }

    if (event.altKey && !isDrawingMode) {
        const clickedVertex = findClickedVertex(mousePos);
        const clickedEdge = !clickedVertex ? findClickedEdge(mousePos) : null;
        const clickedFace = !clickedVertex && !clickedEdge ? findClickedFace(mousePos) : null;

        if (clickedVertex || clickedEdge || clickedFace) {
            saveStateForUndo();
            performEscapeAction();
            
            if (clickedVertex && clickedVertex.type === 'regular') {
                isDrawingMode = true;
                previewLineStartVertexId = clickedVertex.id;
                drawingSequence = [];
                currentSequenceIndex = 0;
                currentDrawingPath = [clickedVertex.id];
                window.currentDrawingPath = currentDrawingPath;
            } else if (clickedEdge) {
                const p1 = findVertexById(clickedEdge.id1);
                const p2 = findVertexById(clickedEdge.id2);
                if (p1 && p2) {
                    const closest = U.getClosestPointOnLineSegment(screenToData(mousePos), p1, p2);
                    const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
                    const newVertex = insertVertexOnEdgeWithFaces(clickedEdge, closest, gridInterval, getColorForTarget);
                    if (newVertex) {
                        isDrawingMode = true;
                        previewLineStartVertexId = newVertex.id;
                        drawingSequence = [];
                        currentSequenceIndex = 0;
                        currentDrawingPath = [newVertex.id];
                        window.currentDrawingPath = currentDrawingPath;
                    }
                }
            } else if (clickedFace) {
                const startCoords = altHoverInfo ? altHoverInfo.point : (ghostVertexPosition ? ghostVertexPosition : screenToData(mousePos));

                let newVertexColor = getColorForTarget(C.COLOR_TARGET_VERTEX);
                const colorIndex = colorAssignments[C.COLOR_TARGET_VERTEX];
                if (colorIndex !== -1) {
                    const colorItem = allColors[colorIndex];
                    if (colorItem && colorItem.type === 'colormap') {
                        newVertexColor = U.sampleColormap(colorItem, 0);
                    }
                }

                const newVertex = { id: U.generateUniqueId(), ...startCoords, type: 'regular', color: newVertexColor };
                allVertices.push(newVertex);
                isDrawingMode = true;
                previewLineStartVertexId = newVertex.id;
                drawingSequence = [];
                currentSequenceIndex = 0;
                currentDrawingPath = [newVertex.id];
                window.currentDrawingPath = currentDrawingPath;
            }

            isActionInProgress = false;
            event.preventDefault();
            return;
        }
    }

    let clickedVertex = findClickedVertex(mousePos);
    let clickedEdge = !clickedVertex ? findClickedEdge(mousePos) : null;
    let clickedFace = !clickedVertex && !clickedEdge ? findClickedFace(mousePos) : null;

    const shiftOrCtrl = event.shiftKey || event.ctrlKey || event.metaKey;
    const clickedItem = clickedVertex || clickedEdge || clickedFace;
    let isClickOnSelection = false;
    if (clickedVertex) isClickOnSelection = selectedVertexIds.includes(clickedVertex.id) || selectedCenterIds.includes(clickedVertex.id);
    else if (clickedEdge) isClickOnSelection = selectedEdgeIds.includes(U.getEdgeId(clickedEdge));
    else if (clickedFace) isClickOnSelection = selectedFaceIds.includes(U.getFaceId(clickedFace));
    
    if (!isDrawingMode && !shiftOrCtrl && clickedItem && !isClickOnSelection) {
        if (clickedVertex) applySelectionLogic([clickedVertex.id], [], [], false, false, clickedVertex.type !== 'regular');
        else if (clickedEdge) applySelectionLogic([], [U.getEdgeId(clickedEdge)], [], false, false);
        else if (clickedFace) applySelectionLogic([], [], [U.getFaceId(clickedFace)], false, false);
    }
    
    let dragHandle = null;
    if (clickedVertex) {
        dragHandle = clickedVertex;
    } else if (clickedEdge) {
        const p1 = findVertexById(clickedEdge.id1);
        const p2 = findVertexById(clickedEdge.id2);
        dragHandle = U.getClosestPointOnLineSegment(screenToData(mousePos), p1, p2);
    } else if (clickedFace) {
        dragHandle = screenToData(mousePos);
    }

    const isTransformDrag = activeCenterId && (selectedVertexIds.length > 0 || selectedEdgeIds.length > 0 || selectedFaceIds.length > 0);

    initialDragVertexStates = [];
    dragPreviewVertices = [];

    actionContext = {
        targetVertex: clickedVertex,
        dragHandle: dragHandle,
        targetEdge: clickedEdge,
        targetFace: clickedFace,
        target: clickedItem || 'canvas',
        shiftKey: event.shiftKey,
        ctrlKey: event.ctrlKey || event.metaKey,
        altKey: event.altKey,
        isTransformDrag
    };

    if (clickedVertex && clickedVertex.type !== 'regular') {
        isDraggingCenter = true;
        handleCenterSelection(clickedVertex.id, event.shiftKey, event.ctrlKey || event.metaKey);
    }
}

function getFinalDragPositions(initialDragVertexStates, allVertices, finalDelta, copyCount) {
    const allFinalVertices = [];
    const verticesToDrag = initialDragVertexStates.filter(p => p.type === 'regular');
    const initialDraggedIds = new Set(verticesToDrag.map(p => p.id));

    allVertices.forEach(v => {
        if (!initialDraggedIds.has(v.id)) {
            allFinalVertices.push({ ...v, originalId: v.id, transformIndex: undefined });
        }
    });

    for (let i = 0; i < copyCount; i++) {
        verticesToDrag.forEach(p_orig => {
            const newPos = {
                x: p_orig.x + finalDelta.x * (i + 1),
                y: p_orig.y + finalDelta.y * (i + 1)
            };
            allFinalVertices.push({
                ...p_orig,
                ...newPos,
                id: i === 0 ? p_orig.id : `${p_orig.id}_copy_${i}`,
                originalId: p_orig.id,
                transformIndex: i
            });
        });
    }
    return allFinalVertices;
}

function handleLeftMouseButtonUp(event) {
    if (isDraggingColorTarget) {
        const icon = canvasUI.colorTargetIcons.find(i => i.target === draggedColorTargetInfo.target);
        if (icon) {
            const dropTargets = canvasUI.colorSwatches;
            const closestTarget = U.findClosestUIElement(mousePos, dropTargets);
            if (closestTarget) {
                const newIndex = closestTarget.index;
                colorAssignments[draggedColorTargetInfo.target] = newIndex;
                applyColorsToSelection();
            }
        }
        isDraggingColorTarget = false;
        draggedColorTargetInfo = null;
        buildColorPaletteUI();
        isActionInProgress = false;
        isDragConfirmed = false;
        actionContext = null;
        return;
    }

    if (isDraggingColorSwatch) {
        const removeBtn = canvasUI.removeColorButton;
        const isOverRemoveButton = removeBtn &&
            mousePos.x >= removeBtn.x && mousePos.x <= removeBtn.x + removeBtn.width &&
            mousePos.y >= removeBtn.y && mousePos.y <= removeBtn.y + removeBtn.height;

        if (isOverRemoveButton && allColors.length > 1) {
            const currentIndex = allColors.indexOf(draggedSwatchInfo.item);
            if (currentIndex !== -1) {
                removeColorAtIndex(currentIndex);
            }
        }

        isDraggingColorSwatch = false;
        draggedSwatchInfo = null;
        draggedSwatchTemporarilyRemoved = false;
        
        buildColorPaletteUI();
        
        isActionInProgress = false;
        isDragConfirmed = false;
        actionContext = null;
        return;
    }

    if (!isDragConfirmed && actionContext && actionContext.target === 'ui_icon_click' && actionContext.element.type === 'colorTargetIcon') {
        const { element } = actionContext;
        const now = Date.now();
        
        const iconId = `icon-${element.target}`;
        if (clickData.targetId === iconId && (now - clickData.timestamp) < C.DOUBLE_CLICK_MS) {
            saveStateForUndo();
            switch (element.target) {
                case C.COLOR_TARGET_VERTEX:
                    verticesVisible = !verticesVisible;
                    break;
                case C.COLOR_TARGET_EDGE:
                    edgesVisible = !edgesVisible;
                    break;
                case C.COLOR_TARGET_FACE:
                    facesVisible = !facesVisible;
                    break;
            }
            buildColorPaletteUI();
            clickData.count = 0;
        } else {
        }
        
        clickData.targetId = iconId;
        clickData.timestamp = now;
        isActionInProgress = false;
        actionContext = null;
        return;
    } else if (!isDragConfirmed && actionContext && actionContext.target === 'ui') {
        clickData.count = 0;
    }

    if (!isDragConfirmed && actionContext && actionContext.target === 'ui_swatch') {
        const { element } = actionContext;
        const now = Date.now();
        
        const swatchId = `swatch-${element.index}`;
        if (clickData.targetId === swatchId && (now - clickData.timestamp) < C.DOUBLE_CLICK_MS) {
            isEditingColor = true;
            editingColorIndex = element.index;
            const colorToEdit = allColors[element.index];
            let initialState;
            if (colorToEdit.type === 'color') {
                const parsedColor = U.parseColor(colorToEdit.value);
                initialState = { type: 'colormap', points: [{ pos: 0.5, alpha: parsedColor.a, color: [parsedColor.r, parsedColor.g, parsedColor.b], order: 1 }] };
            } else if (colorToEdit.type === 'colormap') {
                initialState = { 
                    type: 'colormap', 
                    points: colorToEdit.vertices.map(v => ({ pos: v.pos, alpha: v.alpha !== undefined ? v.alpha : 1.0, color: Array.isArray(v.color) ? [...v.color] : [v.color.r || 0, v.color.g || 0, v.color.b || 0], order: v.order || 1 })),
                    isCyclic: colorToEdit.isCyclic === true
                };
            }
            colorEditor.show(undefined, undefined, initialState);
            clickData.count = 0;
        } else {
            if (activeColorTargets.length > 0) {
                saveStateForUndo();
                activeColorTargets.forEach(target => colorAssignments[target] = element.index);
                applyColorsToSelection();
                buildColorPaletteUI();
            }
        }
        clickData.targetId = swatchId;
        clickData.timestamp = now;
        isActionInProgress = false;
        actionContext = null;
        return;
    }

    if (!isDragConfirmed && isDraggingColorSwatch) {
        const swatchIndex = allColors.indexOf(draggedSwatchInfo.item);
        const swatchId = `swatch-${swatchIndex}`;
        const now = Date.now();
        
        if (clickData.targetId === swatchId && (now - clickData.timestamp) < C.DOUBLE_CLICK_MS) {
            isEditingColor = true;
            editingColorIndex = swatchIndex;
            const colorToEdit = allColors[swatchIndex];
            let initialState;
            if (colorToEdit.type === 'color') {
                const parsedColor = U.parseColor(colorToEdit.value);
                initialState = { type: 'colormap', points: [{ pos: 0.5, alpha: parsedColor.a, color: [parsedColor.r, parsedColor.g, parsedColor.b], order: 1 }] };
            } else if (colorToEdit.type === 'colormap') {
                initialState = { type: 'colormap', points: colorToEdit.vertices.map(v => ({ pos: v.pos, alpha: v.alpha !== undefined ? v.alpha : 1.0, color: Array.isArray(v.color) ? [...v.color] : [v.color.r || 0, v.color.g || 0, v.color.b || 0], order: v.order || 1 })) };
            }
            colorEditor.show(undefined, undefined, initialState);
            clickData.count = 0;
        } else {
            activeColorTargets.forEach(t => colorAssignments[t] = swatchIndex);
            applyColorsToSelection();
            buildColorPaletteUI();
        }
        clickData.targetId = swatchId;
        clickData.timestamp = now;
        
        isDraggingColorSwatch = false;
        draggedSwatchInfo = null;
        saveStateForUndo();
        return;
    }

    if (handleCoordinateSystemMouseUp()) {
        return;
    }

    if (copyCountTimer) clearTimeout(copyCountTimer);
    const copyCount = parseInt(copyCountInput, 10) || 1;
    copyCountInput = '';
    copyCountTimer = null;

    if (!isActionInProgress) return;

    if (!actionContext) {
        isActionInProgress = false;
        return;
    }

    const { shiftKey, ctrlKey, targetVertex, targetEdge, targetFace } = actionContext;

    if (isDragConfirmed) {
        saveStateForUndo();
        let lastCopySelectionIds = null;
        if (copyCount > 1) {
            const verticesToCopy = initialDragVertexStates.filter(p => p.type === 'regular');
            const originalIds = new Set(verticesToCopy.map(p => p.id));
            const edgesToCopy = allEdges.filter(e => originalIds.has(e.id1) && originalIds.has(e.id2));
            const facesToCopy = allFaces.filter(f => f.vertexIds.every(id => originalIds.has(id)));
            
            const allNewVertices = [];
            const allNewEdges = [];
            const allNewFaces = [];
            lastCopySelectionIds = { vertices: [], edges: [], faces: [] };

            for (let i = 1; i < copyCount; i++) {
                const copyMultiplier = i;
                const newIdMapForThisCopy = new Map();
                const currentCopyVertices = [];
                const currentCopyEdges = [];
                const currentCopyFaces = [];

                verticesToCopy.forEach(p => {
                    let newPos;
                    if (transformIndicatorData) {
                        const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
                        const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
                        newPos = U.applyTransformToVertex(p, center, rotation * copyMultiplier, Math.pow(scale, copyMultiplier), directionalScale, startVector);
                    } else {
                        const delta = { x: dragPreviewVertices[0].x - initialDragVertexStates[0].x, y: dragPreviewVertices[0].y - initialDragVertexStates[0].y };
                        newPos = { x: p.x + delta.x * copyMultiplier, y: p.y + delta.y * copyMultiplier };
                    }
                    const newVertex = { ...p, ...newPos, id: U.generateUniqueId() };
                    allNewVertices.push(newVertex);
                    newIdMapForThisCopy.set(p.id, newVertex.id);
                    currentCopyVertices.push(newVertex.id);
                });

                verticesToCopy.forEach(p_orig => {
                    const neighbors = U.findNeighbors(p_orig.id, allEdges);
                    neighbors.forEach(neighborId => {
                        const isNeighborBeingCopied = originalIds.has(neighborId);
                        if (!isNeighborBeingCopied) {
                            const newId1 = newIdMapForThisCopy.get(p_orig.id);
                            if (newId1) {
                                const newEdge = { id1: newId1, id2: neighborId, color: getColorForTarget(C.COLOR_TARGET_EDGE) };
                                allNewEdges.push(newEdge);
                            }
                        }
                    });
                });

                edgesToCopy.forEach(edge => {
                    const newId1 = newIdMapForThisCopy.get(edge.id1);
                    const newId2 = newIdMapForThisCopy.get(edge.id2);
                    if (newId1 && newId2) {
                        const newEdge = { ...edge, id1: newId1, id2: newId2 };
                        allNewEdges.push(newEdge);
                        currentCopyEdges.push(U.getEdgeId(newEdge));
                    }
                });

                facesToCopy.forEach(originalFace => {
                    const initialSystemForCopy = initialCoordSystemStates.get(originalFace.id);
                    const newVertexIds = originalFace.vertexIds.map(id => newIdMapForThisCopy.get(id));
                    if (newVertexIds.every(Boolean)) {
                        const newFace = JSON.parse(JSON.stringify(originalFace));
                        newFace.id = U.getFaceId({ vertexIds: newVertexIds });
                        newFace.vertexIds = newVertexIds;

                        if (newFace.localCoordSystem && initialSystemForCopy) {
                            if (transformIndicatorData) {
                                const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
                                const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
                                newFace.localCoordSystem.origin = U.applyTransformToVertex(initialSystemForCopy.origin, center, rotation * copyMultiplier, Math.pow(scale, copyMultiplier), directionalScale, startVector);
                                newFace.localCoordSystem.angle = U.normalizeAngle(initialSystemForCopy.angle + (rotation * copyMultiplier));
                                if (!directionalScale) newFace.localCoordSystem.scale = initialSystemForCopy.scale * Math.pow(scale, copyMultiplier);
                            } else {
                                const delta = { x: dragPreviewVertices[0].x - initialDragVertexStates[0].x, y: dragPreviewVertices[0].y - initialDragVertexStates[0].y };
                                newFace.localCoordSystem.origin.x = initialSystemForCopy.origin.x + delta.x * copyMultiplier;
                                newFace.localCoordSystem.origin.y = initialSystemForCopy.origin.y + delta.y * copyMultiplier;
                            }
                            
                            if (newFace.localCoordSystem.attachedToVertex) {
                                newFace.localCoordSystem.attachedToVertex = newIdMapForThisCopy.get(newFace.localCoordSystem.attachedToVertex);
                            }
                            if (newFace.localCoordSystem.attachedToEdge) {
                                newFace.localCoordSystem.attachedToEdge.v1 = newIdMapForThisCopy.get(newFace.localCoordSystem.attachedToEdge.v1);
                                newFace.localCoordSystem.attachedToEdge.v2 = newIdMapForThisCopy.get(newFace.localCoordSystem.attachedToEdge.v2);
                            }
                            if (newFace.localCoordSystem.rotationAlignedToEdge) {
                                newFace.localCoordSystem.rotationAlignedToEdge.v1 = newIdMapForThisCopy.get(newFace.localCoordSystem.rotationAlignedToEdge.v1);
                                newFace.localCoordSystem.rotationAlignedToEdge.v2 = newIdMapForThisCopy.get(newFace.localCoordSystem.rotationAlignedToEdge.v2);
                            }
                            if (newFace.localCoordSystem.scaleAttachedToEdge) {
                                newFace.localCoordSystem.scaleAttachedToEdge.v1 = newIdMapForThisCopy.get(newFace.localCoordSystem.scaleAttachedToEdge.v1);
                                newFace.localCoordSystem.scaleAttachedToEdge.v2 = newIdMapForThisCopy.get(newFace.localCoordSystem.scaleAttachedToEdge.v2);
                            }
                            
                            newFace.localCoordSystem.isCustom = true;
                        }
                        allNewFaces.push(newFace);
                        currentCopyFaces.push(newFace.id);
                    }
                });
                
                if (i === copyCount - 1) {
                    lastCopySelectionIds = { vertices: currentCopyVertices, edges: currentCopyEdges, faces: currentCopyFaces };
                }
            }

            allVertices.push(...allNewVertices);
            allEdges.push(...allNewEdges);
            allFaces.push(...allNewFaces);
            
            selectedVertexIds = [];
            selectedEdgeIds = [];
            selectedFaceIds = [];
            selectedCenterIds = [];
            activeCenterId = null;
        } else if (dragPreviewVertices.length > 0) {
            dragPreviewVertices.forEach(dp => {
                const originalVertex = allVertices.find(p => p.id === dp.id);
                if (originalVertex) {
                    originalVertex.x = dp.x;
                    originalVertex.y = dp.y;
                }
            });
            
            const verticesThatMoved = new Set(initialDragVertexStates.map(v => v.id));
            const affectedFaces = new Set();
            allFaces.forEach(face => {
                if (face.vertexIds.some(vId => verticesThatMoved.has(vId))) {
                    affectedFaces.add(face);
                }
            });

            if (affectedFaces.size > 0) {
                affectedFaces.forEach(face => {
                    const initialSystem = initialCoordSystemStates.get(face.id);
                    if (face.localCoordSystem && initialSystem) {
                        const faceVertexIds = new Set(face.vertexIds);
                        const draggedVertexIds = new Set(initialDragVertexStates.map(v => v.id));
                        const isRigidFaceDrag = [...faceVertexIds].every(vId => draggedVertexIds.has(vId));

                        if (isRigidFaceDrag) {
                            if (transformIndicatorData) {
                                const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
                                const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
                                const newOrigin = U.applyTransformToVertex(initialSystem.origin, center, rotation, scale, directionalScale, startVector);
                                face.localCoordSystem.origin = newOrigin;
                                
                                if (directionalScale) {
                                    const p_unit_x_initial = U.localToGlobal({ x: 1, y: 0 }, initialSystem);
                                    const p_unit_x_final = U.applyTransformToVertex(p_unit_x_initial, center, rotation, scale, directionalScale, startVector);
                                    face.localCoordSystem.scale = U.distance(newOrigin, p_unit_x_final);
                                } else {
                                    face.localCoordSystem.angle = U.normalizeAngle(initialSystem.angle + rotation);
                                    face.localCoordSystem.scale = initialSystem.scale * scale;
                                }
                            } else {
                                const delta = {
                                    x: dragPreviewVertices[0].x - initialDragVertexStates[0].x,
                                    y: dragPreviewVertices[0].y - initialDragVertexStates[0].y
                                };
                                face.localCoordSystem.origin.x = initialSystem.origin.x + delta.x;
                                face.localCoordSystem.origin.y = initialSystem.origin.y + delta.y;
                            }
                        } else {
                            applyCoordinateSystemConstraintsOnDragEnd(face, initialSystem, initialDragVertexStates, dragPreviewVertices, findVertexById);
                        }
                    }
                });
            }
        }

        const mergeRadius = C.MERGE_RADIUS_SCREEN / viewTransform.scale;

        const draggedVerticesFinal = [];
        if (copyCount > 1) {
            const lastCopyIds = new Set(lastCopySelectionIds.vertices);
            allVertices.forEach(v => {
                if (lastCopyIds.has(v.id)) {
                    draggedVerticesFinal.push(v);
                }
            });
        } else {
            draggedVerticesFinal.push(...dragPreviewVertices);
        }

        const edgesToSplit = new Map();

        allVertices.forEach(vertex => {
            if (vertex.type !== 'regular') return;

            allEdges.forEach(edge => {
                if (vertex.id === edge.id1 || vertex.id === edge.id2) {
                    return;
                }

                const p1 = findVertexById(edge.id1);
                const p2 = findVertexById(edge.id2);

                if (p1 && p2) {
                    const closest = U.getClosestPointOnLineSegment(vertex, p1, p2);
                    if (closest.distance < mergeRadius && closest.onSegmentStrict) {
                        const edgeId = U.getEdgeId(edge);
                        if (!edgesToSplit.has(edgeId)) {
                            edgesToSplit.set(edgeId, { edge: edge, pointsToInsert: [] });
                        }
                        edgesToSplit.get(edgeId).pointsToInsert.push({ ...vertex, finalPos: {x: closest.x, y: closest.y} });
                    }
                }
            });
        });
        
        if (edgesToSplit.size > 0) {
            const edgesBefore = JSON.parse(JSON.stringify(allEdges));
            const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

            edgesToSplit.forEach(({ edge, pointsToInsert }) => {
                allEdges = allEdges.filter(e => U.getEdgeId(e) !== U.getEdgeId(edge));

                const p1 = findVertexById(edge.id1);
                pointsToInsert.sort((a, b) => U.distance(p1, a.finalPos) - U.distance(p1, b.finalPos));
                
                let lastVertexInChain = p1;
                pointsToInsert.forEach(insertData => {
                    const vertexToUpdate = allVertices.find(v => v.id === insertData.id);
                    if(vertexToUpdate) {
                        vertexToUpdate.x = insertData.finalPos.x;
                        vertexToUpdate.y = insertData.finalPos.y;
                    }

                    allEdges.push(U.createEdge(lastVertexInChain, vertexToUpdate, gridInterval, getColorForTarget));
                    lastVertexInChain = vertexToUpdate;
                });

                const p2 = findVertexById(edge.id2);
                allEdges.push(U.createEdge(lastVertexInChain, p2, gridInterval, getColorForTarget));
            });

            updateFaces(edgesBefore, allEdges);
            ensureFaceCoordinateSystems();
        }

        const parent = new Map();
        allVertices.forEach(p => parent.set(p.id, p.id));
        const isOriginalDragged = new Set(initialDragVertexStates.map(p => p.id));

        const findRoot = (id) => {
            if (!parent.has(id) || parent.get(id) === id) return id;
            const rootId = findRoot(parent.get(id));
            parent.set(id, rootId);
            return rootId;
        };

        for (let i = 0; i < allVertices.length; i++) {
            for (let j = i + 1; j < allVertices.length; j++) {
                const p1 = allVertices[i];
                const p2 = allVertices[j];
                if (p1.type === 'regular' && p2.type === 'regular' && U.distance(p1, p2) < mergeRadius) {
                    const root1 = findRoot(p1.id);
                    const root2 = findRoot(p2.id);
                    if (root1 !== root2) {
                        const p1_is_orig = isOriginalDragged.has(root1);
                        const p2_is_orig = isOriginalDragged.has(root2);
                        if (p2_is_orig && !p1_is_orig) {
                            parent.set(root1, root2);
                        } else {
                            parent.set(root2, root1);
                        }
                    }
                }
            }
        }

        const verticesToDelete = new Set();
        allVertices.forEach(p => {
            const rootId = findRoot(p.id);
            if (p.id !== rootId) verticesToDelete.add(p.id);
        });

        if (verticesToDelete.size > 0) {
            const edgesBeforeMerge = JSON.parse(JSON.stringify(allEdges));
            
            const faceCoordSystemBackup = backupFaceCoordinateSystemsBeforeMerge(allFaces, findRoot);

            allEdges.forEach(edge => {
                edge.id1 = findRoot(edge.id1);
                edge.id2 = findRoot(edge.id2);
            });

            allFaces.forEach(face => {
                const remappedVertexIds = face.vertexIds.map(vId => findRoot(vId));
                const uniqueVertexIds = remappedVertexIds.filter((vId, index, self) => self.indexOf(vId) === index);
                
                if (uniqueVertexIds.length < 3) {
                    face.vertexIds = [];
                } else {
                    face.vertexIds = uniqueVertexIds;
                    face.id = U.getFaceId({ vertexIds: uniqueVertexIds });
                }
            });

            allVertices = allVertices.filter(p => !verticesToDelete.has(p.id));

            allEdges = allEdges.filter((e, index, self) =>
                e.id1 !== e.id2 &&
                index === self.findIndex(t => U.getEdgeId(t) === U.getEdgeId(e))
            );
            allFaces = allFaces.filter(f => f.vertexIds.length >= 3);
            
            selectedVertexIds = Array.from(new Set(selectedVertexIds.map(id => findRoot(id)).filter(id => !verticesToDelete.has(id))));
            selectedEdgeIds = Array.from(new Set(selectedEdgeIds.map(id => {
                const [id1, id2] = id.split(C.EDGE_ID_DELIMITER);
                const root1 = findRoot(id1);
                const root2 = findRoot(id2);
                return root1 === root2 ? null : U.getEdgeId({id1: root1, id2: root2});
            }).filter(Boolean)));
            selectedFaceIds = Array.from(new Set(selectedFaceIds.map(id => {
                const face = allFaces.find(f => f.id === id);
                return face ? face.id : null;
            }).filter(Boolean)));
            
            updateFaces(edgesBeforeMerge, allEdges);
            
            allFaces.forEach(face => {
                const backupSystem = faceCoordSystemBackup.get(face.id);
                if (backupSystem) {
                    face.localCoordSystem = backupSystem;
                    
                    if (face.localCoordSystem.attachedToVertex) {
                        const mergedVertexId = findRoot(face.localCoordSystem.attachedToVertex);
                        face.localCoordSystem.attachedToVertex = mergedVertexId;
                        
                        const mergedVertex = allVertices.find(v => v.id === mergedVertexId);
                        if (mergedVertex) {
                            face.localCoordSystem.origin.x = mergedVertex.x;
                            face.localCoordSystem.origin.y = mergedVertex.y;
                        }
                    }
                    if (face.localCoordSystem.attachedToEdge) {
                        face.localCoordSystem.attachedToEdge.v1 = findRoot(face.localCoordSystem.attachedToEdge.v1);
                        face.localCoordSystem.attachedToEdge.v2 = findRoot(face.localCoordSystem.attachedToEdge.v2);
                        
                        const v1 = allVertices.find(v => v.id === face.localCoordSystem.attachedToEdge.v1);
                        const v2 = allVertices.find(v => v.id === face.localCoordSystem.attachedToEdge.v2);
                        if (v1 && v2) {
                            const t = face.localCoordSystem.attachedToEdge.t;
                            face.localCoordSystem.origin.x = v1.x + t * (v2.x - v1.x);
                            face.localCoordSystem.origin.y = v1.y + t * (v2.y - v1.y);
                        }
                    }
                    if (face.localCoordSystem.rotationAlignedToEdge) {
                        face.localCoordSystem.rotationAlignedToEdge.v1 = findRoot(face.localCoordSystem.rotationAlignedToEdge.v1);
                        face.localCoordSystem.rotationAlignedToEdge.v2 = findRoot(face.localCoordSystem.rotationAlignedToEdge.v2);
                    }
                    if (face.localCoordSystem.scaleAttachedToEdge) {
                        face.localCoordSystem.scaleAttachedToEdge.v1 = findRoot(face.localCoordSystem.scaleAttachedToEdge.v1);
                        face.localCoordSystem.scaleAttachedToEdge.v2 = findRoot(face.localCoordSystem.scaleAttachedToEdge.v2);
                    }
                }
            });
            
            ensureFaceCoordinateSystems();
        }

        const finalMovedVertexIds = new Set();
        if (copyCount > 1 && lastCopySelectionIds) {
            lastCopySelectionIds.vertices.forEach(id => finalMovedVertexIds.add(id));
        } else if (dragPreviewVertices.length > 0) {
            dragPreviewVertices.forEach(p => finalMovedVertexIds.add(p.id));
        }

        if (verticesToDelete.size > 0) {
            selectedVertexIds.forEach(id => finalMovedVertexIds.add(id));
        }

        if (finalMovedVertexIds.size > 0) {
            updateAffectedEdgeProperties(Array.from(finalMovedVertexIds), transformIndicatorData);
        }

        initialCoordSystemStates.clear();
        updateFaceHierarchy();
        updateComponentDrawOrder();
    } else {
        if (actionContext.target === 'ui-icon') {
        } else {
            const startVertex = findVertexById(previewLineStartVertexId);
            if (isDrawingMode && startVertex) {
                saveStateForUndo();
                const edgesBefore = JSON.parse(JSON.stringify(allEdges));
                const snappedData = getSnappedPosition(startVertex, mousePos, shiftKey);
                let newVertex = null;
                const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

                if (snappedData.snapType === 'vertex' && snappedData.targetVertex) {
                    newVertex = snappedData.targetVertex;
                } else if (snappedData.snapType?.startsWith('edge') && snappedData.targetEdge) {
                    newVertex = insertVertexOnEdgeWithFaces(snappedData.targetEdge, { x: snappedData.x, y: snappedData.y }, gridInterval, getColorForTarget);
                } else {
                    let newVertexColor = getColorForTarget(C.COLOR_TARGET_VERTEX);
                    const colorIndex = colorAssignments[C.COLOR_TARGET_VERTEX];
                    if (colorIndex !== -1) {
                        const colorItem = allColors[colorIndex];
                        if (colorItem && colorItem.type === 'colormap') {
                            newVertexColor = U.sampleColormap(colorItem, 0.5);
                        }
                    }

                    newVertex = { id: U.generateUniqueId(), x: snappedData.x, y: snappedData.y, type: 'regular', color: newVertexColor };
                    allVertices.push(newVertex);
                }

                if (newVertex) {
                    const edgeExists = allEdges.some(e => (e.id1 === startVertex.id && e.id2 === newVertex.id) || (e.id2 === startVertex.id && e.id1 === newVertex.id));
                    if (!edgeExists) {
                        const newEdge = U.createEdge(startVertex, newVertex, gridInterval, getColorForTarget);
                        allEdges.push(newEdge);
                        updateFaces(edgesBefore, allEdges);
                        updateFaceHierarchy();

                        allFaces.forEach(face => {
                            if (!face.color) {
                                face.color = getColorForTarget(C.COLOR_TARGET_FACE);
                            }
                        });
                    }
                    
                    const completedSegmentProps = getCompletedSegmentProperties(startVertex, newVertex, allEdges);
                    if (completedSegmentProps) {
                        if (drawingSequence.length > 0) {
                            drawingSequence[drawingSequence.length - 1].turn = completedSegmentProps.turnAngleRad;
                        }
                        drawingSequence.push({ 
                            length: completedSegmentProps.length, 
                            turn: 0, 
                            endVertexColor: newVertex.color 
                        });
                        currentSequenceIndex = drawingSequence.length - 1;

                        frozenReference_Origin_Data = completedSegmentProps.startVertex;
                        frozenReference_D_du = snappedData.gridToGridSquaredSum > 0 && snappedData.gridInterval ?
                            snappedData.gridInterval * Math.sqrt(snappedData.gridToGridSquaredSum) :
                            completedSegmentProps.length;
                        
                        frozenReference_D_g2g = snappedData.gridToGridSquaredSum > 0 ? { 
                            g2gSquaredSum: snappedData.gridToGridSquaredSum, 
                            interval: snappedData.gridInterval 
                        } : null;
                        
                        frozenReference_A_rad = completedSegmentProps.turnAngleRad;
                        frozenReference_A_baseRad = completedSegmentProps.precedingSegmentAbsoluteAngleRad;
                    }
                    
                    currentDrawingPath.push(newVertex.id);
                    window.currentDrawingPath = currentDrawingPath;

                    updateDrawingSequenceColors();
                    updateDrawingSequenceEdgeColors();
                    updateComponentDrawOrder();
                    
                    previewLineStartVertexId = newVertex.id;
                }
                
                if (shiftKey && newVertex && snappedData) {
                    const completedSegmentProps = getCompletedSegmentProperties(startVertex, newVertex, allEdges);
                    if (completedSegmentProps) {
                        frozenReference_Origin_Data = completedSegmentProps.startVertex;
                        frozenReference_D_du = snappedData.gridToGridSquaredSum > 0 && snappedData.gridInterval ?
                            snappedData.gridInterval * Math.sqrt(snappedData.gridToGridSquaredSum) :
                            completedSegmentProps.length;
                        
                        frozenReference_D_g2g = snappedData.gridToGridSquaredSum > 0 ? { 
                            g2gSquaredSum: snappedData.gridToGridSquaredSum, 
                            interval: snappedData.gridInterval 
                        } : null;
                        
                        frozenReference_A_rad = completedSegmentProps.turnAngleRad;
                        frozenReference_A_baseRad = completedSegmentProps.precedingSegmentAbsoluteAngleRad;
                    }
                } 

                clickData.count = 0;
            } else if (actionContext.target === 'canvas') {
                    saveStateForUndo();
                    const startCoords = ghostVertexPosition ? ghostVertexPosition : screenToData(mousePos);
                    
                    let newVertexColor = getColorForTarget(C.COLOR_TARGET_VERTEX);
                    const colorIndex = colorAssignments[C.COLOR_TARGET_VERTEX];
                    if (colorIndex !== -1) {
                        const colorItem = allColors[colorIndex];
                        if (colorItem && colorItem.type === 'colormap') {
                            newVertexColor = U.sampleColormap(colorItem, 0);
                        }
                    }

                    const newVertex = { id: U.generateUniqueId(), ...startCoords, type: 'regular', color: newVertexColor };
                    allVertices.push(newVertex);
                    isDrawingMode = true;
                    previewLineStartVertexId = newVertex.id;
                    drawingSequence = [];
                    currentSequenceIndex = 0;
                    currentDrawingPath = [newVertex.id];
                    window.currentDrawingPath = currentDrawingPath;
                    updateComponentDrawOrder();
                } else {
                    if (actionContext && actionContext.altKey) {
                    } else {
                        const wasCenterClick = actionContext && actionContext.targetVertex && actionContext.targetVertex.type !== 'regular';
                        if (!wasCenterClick && (targetVertex || targetEdge || targetFace)) {
                            saveStateForUndo(); 
                            const targetId = targetFace ? U.getFaceId(targetFace) : (targetEdge ? U.getEdgeId(targetEdge) : targetVertex.id);
                            let targetType;
                            if (targetFace) targetType = 'face';
                            else if (targetVertex && targetVertex.type !== 'regular') targetType = 'center';
                            else if (targetVertex) targetType = 'vertex';
                            else if (targetEdge) targetType = 'edge';

                            if (targetId && clickData.targetId === targetId && (Date.now() - clickData.timestamp) < C.DOUBLE_CLICK_MS) {
                                clickData.count++;
                            } else {
                                clickData.count = 1;
                            }
                            clickData.targetId = targetId;
                            clickData.type = targetType;
                            clickData.timestamp = Date.now();

                            switch (clickData.count) {
                                case 1:
                                    if (clickData.type === 'face') applySelectionLogic([], [], [clickData.targetId], shiftKey, ctrlKey);
                                    else if (clickData.type === 'edge') applySelectionLogic([], [clickData.targetId], [], shiftKey, ctrlKey);
                                    else if (clickData.type === 'vertex') applySelectionLogic([clickData.targetId], [], [], shiftKey, ctrlKey);
                                    else if (clickData.type === 'center') handleCenterSelection(clickData.targetId, shiftKey, ctrlKey);
                                    break;
                                case 2:
                                    if (clickData.type === 'vertex') {
                                        const neighbors = U.findNeighbors(clickData.targetId, allEdges);
                                        applySelectionLogic([clickData.targetId, ...neighbors], [], [], shiftKey, ctrlKey);
                                    } else if (clickData.type === 'edge') {
                                        const edge = allEdges.find(e => U.getEdgeId(e) === clickData.targetId);
                                        if (edge) {
                                            const validNeighborEdges = [...findNeighborEdges(edge.id1), ...findNeighborEdges(edge.id2)];
                                            applySelectionLogic([], Array.from(new Set(validNeighborEdges.map(e => U.getEdgeId(e)))), [], shiftKey, ctrlKey);
                                        }
                                    } else if (clickData.type === 'face') {
                                        const face = allFaces.find(f => U.getFaceId(f) === clickData.targetId);
                                        if (face) {
                                            const adjacentFaceIds = [];
                                            const faceEdges = new Set();
                                            for (let i = 0; i < face.vertexIds.length; i++) {
                                                const id1 = face.vertexIds[i];
                                                const id2 = face.vertexIds[(i + 1) % face.vertexIds.length];
                                                faceEdges.add(U.getEdgeId({ id1, id2 }));
                                            }
                                            allFaces.forEach(otherFace => {
                                                if (U.getFaceId(otherFace) === U.getFaceId(face)) return;
                                                for (let i = 0; i < otherFace.vertexIds.length; i++) {
                                                    const id1 = otherFace.vertexIds[i];
                                                    const id2 = otherFace.vertexIds[(i + 1) % otherFace.vertexIds.length];
                                                    if (faceEdges.has(U.getEdgeId({ id1, id2 }))) {
                                                        adjacentFaceIds.push(U.getFaceId(otherFace));
                                                        break;
                                                    }
                                                }
                                            });
                                            applySelectionLogic([], [], [U.getFaceId(face), ...adjacentFaceIds], shiftKey, ctrlKey);
                                        }
                                    }
                                    break;
                                case 3:
                                    if (clickData.type === 'vertex' || clickData.type === 'edge' || clickData.type === 'face') {
                                        let startNode;
                                        if (clickData.type === 'vertex') startNode = clickData.targetId;
                                        else if (clickData.type === 'edge') startNode = clickData.targetId.split(C.EDGE_ID_DELIMITER)[0];
                                        else if (clickData.type === 'face') {
                                            const face = allFaces.find(f => U.getFaceId(f) === clickData.targetId);
                                            if (face) startNode = face.vertexIds[0];
                                        }
                                        if (startNode) {
                                            const verticesInSubgraph = new Set(findAllVerticesInSubgraph(startNode));
                                            if (clickData.type === 'vertex') applySelectionLogic(Array.from(verticesInSubgraph), [], [], shiftKey, ctrlKey);
                                            else if (clickData.type === 'edge') {
                                                const edgesInSubgraph = allEdges.filter(e => verticesInSubgraph.has(e.id1) && verticesInSubgraph.has(e.id2)).map(e => U.getEdgeId(e));
                                                applySelectionLogic([], edgesInSubgraph, [], shiftKey, ctrlKey);
                                            } else if (clickData.type === 'face') {
                                                const facesInSubgraph = allFaces.filter(f => f.vertexIds.every(vId => verticesInSubgraph.has(vId))).map(f => U.getFaceId(f));
                                                applySelectionLogic([], [], facesInSubgraph, shiftKey, ctrlKey);
                                            }
                                        }
                                    }
                                    clickData.count = 0;
                                    break;
                            }

                            const newActiveTargets = [];
                            if (selectedFaceIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_FACE);
                            if (selectedEdgeIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_EDGE);
                            if (selectedVertexIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_VERTEX);

                            if (newActiveTargets.length > 0) {
                                activeColorTargets = newActiveTargets;
                                if (isColorPaletteExpanded) {
                                    buildColorPaletteUI();
                                }
                            }
                        }
                    }
                }
        } 
    }
}

function handleRightMouseButtonDown(event) {
    isActionInProgress = true;
    isRectangleSelecting = false; 
    rectangleSelectStartPos = actionStartPos;
    actionContext = {
        target: 'canvas',
        shiftKey: event.shiftKey,
        ctrlKey: event.ctrlKey || event.metaKey
    };
}

function handleRightMouseButtonUp(event) {
    if (isDragConfirmed && isRectangleSelecting) {
        const dataP1 = screenToData({ x: Math.min(actionStartPos.x, mousePos.x), y: Math.min(actionStartPos.y, mousePos.y) });
        const dataP2 = screenToData({ x: Math.max(actionStartPos.x, mousePos.x), y: Math.max(actionStartPos.y, mousePos.y) });
        const minX = Math.min(dataP1.x, dataP2.x);
        const maxX = Math.max(dataP1.x, dataP2.x);
        const minY = Math.min(dataP1.y, dataP2.y);
        const maxY = Math.max(dataP1.y, dataP2.y);
        
        const verticesInRect = allVertices.filter(p => p.type === 'regular' && p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY).map(p => p.id);
        const centersInRect = allVertices.filter(p => p.type !== 'regular' && p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY).map(p => p.id);
        const allVerticesInRectIds = new Set(verticesInRect);
        const edgesInRect = allEdges.filter(e => allVerticesInRectIds.has(e.id1) && allVerticesInRectIds.has(e.id2)).map(e => U.getEdgeId(e));
        const facesInRect = allFaces.filter(f => f.vertexIds.every(vId => allVerticesInRectIds.has(vId))).map(f => U.getFaceId(f));

        if (actionContext.shiftKey) {
            // Add to selection
            selectedVertexIds = [...new Set([...selectedVertexIds, ...verticesInRect])];
            selectedEdgeIds = [...new Set([...selectedEdgeIds, ...edgesInRect])];
            selectedFaceIds = [...new Set([...selectedFaceIds, ...facesInRect])];
            selectedCenterIds = [...new Set([...selectedCenterIds, ...centersInRect])];
        } else if (actionContext.ctrlKey) {
            // Toggle selection
            verticesInRect.forEach(id => {
                const index = selectedVertexIds.indexOf(id);
                if (index > -1) selectedVertexIds.splice(index, 1); else selectedVertexIds.push(id);
            });
            edgesInRect.forEach(id => {
                const index = selectedEdgeIds.indexOf(id);
                if (index > -1) selectedEdgeIds.splice(index, 1); else selectedEdgeIds.push(id);
            });
            facesInRect.forEach(id => {
                const index = selectedFaceIds.indexOf(id);
                if (index > -1) selectedFaceIds.splice(index, 1); else selectedFaceIds.push(id);
            });
            centersInRect.forEach(id => {
                const index = selectedCenterIds.indexOf(id);
                if (index > -1) selectedCenterIds.splice(index, 1); else selectedCenterIds.push(id);
            });
        } else {
            // Replace entire selection
            selectedVertexIds = verticesInRect;
            selectedEdgeIds = edgesInRect;
            selectedFaceIds = facesInRect;
            selectedCenterIds = centersInRect;
        }

        const newActiveTargets = [];
        if (selectedFaceIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_FACE);
        if (selectedEdgeIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_EDGE);
        if (selectedVertexIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_VERTEX);

        if (newActiveTargets.length > 0) {
            activeColorTargets = newActiveTargets;
            if (isColorPaletteExpanded) {
                buildColorPaletteUI();
            }
        }
    } else {
        // This is a simple right-click (not a drag), so show the context menu.
        showContextMenu(event);
    }
}

function handleWheelEvent(event){
    event.preventDefault();
    const mouseScreen = U.getMousePosOnCanvas(event, canvas);
    const scaleFactor = event.deltaY > 0 ? 1 / 1.15 : 1.15;
    zoomAt(mouseScreen, scaleFactor)
}

function handleMouseEnter() {
    isMouseOverCanvas = true;
}

function handleMouseLeave() {
    isMouseOverCanvas = false;
    redrawAll();
}

function handleContextMenu(event){
    event.preventDefault()
}

function handleTranslationDrag(rawDelta, mouseData) {
    const copyCount = parseInt(copyCountInput || '1', 10) || 1;
    const wasSnapped = actionContext.finalSnapResult ? actionContext.finalSnapResult.snapped : false;
    
    const snapResult = getTranslationSnap(initialDragVertexStates, rawDelta, copyCount, wasSnapped);
    const finalDelta = snapResult.delta;

    initialDragVertexStates.forEach(originalVertexState => {
        const previewVertexToUpdate = dragPreviewVertices.find(dp => dp && dp.id === originalVertexState.id);
        if (previewVertexToUpdate) {
            previewVertexToUpdate.x = originalVertexState.x + finalDelta.x;
            previewVertexToUpdate.y = originalVertexState.y + finalDelta.y;
        }
    });
    
    handleTranslationDragSnapVisualization(finalDelta, snapResult);

    actionContext.finalSnapResult = snapResult;
}

function drawFeedbackAndIndicators(colors) {
    if (facesVisible && allVertices.length > 0) {
        R.drawFaceGlows(ctx, { allFaces, hoveredFaceId, selectedFaceIds, colors, isDragConfirmed, dragPreviewVertices }, dataToScreen, findVertexById, U.getFaceId);
        if (selectedFaceIds.length > 0) {
            R.drawFaceCoordinateSystems(ctx, { allFaces, selectedFaceIds, colors, isDragConfirmed, dragPreviewVertices, initialDragVertexStates, transformIndicatorData, highlightedEdgeForSnap, draggedFaceId, coordSystemSnapAngle, coordSystemSnapType, coordSystemSnapScale, initialCoordSystemStates }, dataToScreen, findVertexById);
        }
    }

    if (isDrawingMode && currentShiftPressed && (frozenReference_D_du !== null || frozenReference_A_rad !== null) && currentDrawingPath.length >= 1 && frozenReference_Origin_Data) {
        const lastSegmentStart = findVertexById(frozenReference_Origin_Data.id);
        if (lastSegmentStart) {
            const frozenDisplayContext = { frozen_Origin_Data_to_display: lastSegmentStart, displayAngleA_valueRad_for_A_equals_label: frozenReference_A_rad, frozen_A_baseRad_to_display: frozenReference_A_baseRad, frozen_D_du_to_display: frozenReference_D_du, frozen_D_g2g_to_display: frozenReference_D_g2g };
            const stateForRefGeo = { showAngles, showDistances, viewTransform, mousePos, colors };
            R.drawReferenceElementsGeometry(ctx, frozenDisplayContext, dataToScreen, screenToData, stateForRefGeo);
            const stateForRefTexts = { showAngles, showDistances, viewTransform, mousePos, frozenReference_D_du, distanceSigFigs, angleDisplayMode, colors };
            R.prepareReferenceElementsTexts(htmlOverlay, frozenDisplayContext, stateForRefTexts, screenToData, dataToScreen, updateHtmlLabel);
        }
    }

    const stateForFeedback = { lastGridState, showDistances, showAngles, distanceSigFigs, angleDisplayMode, angleSigFigs, currentShiftPressed, viewTransform, colors };

    if (isDragConfirmed) {
        const draggedVertexIds = new Set(initialDragVertexStates.map(v => v.id));
        let isDeformingDrag = false;
        if (initialDragVertexStates.length > 0) {
            const subgraphVertexIds = new Set(findAllVerticesInSubgraph(initialDragVertexStates[0].id));
            isDeformingDrag = !(draggedVertexIds.size === subgraphVertexIds.size &&
                              [...draggedVertexIds].every(id => subgraphVertexIds.has(id)));
        }

        const hybridVertexStates = allVertices.map(p => {
            const draggedVersion = dragPreviewVertices.find(dp => dp.id === p.id);
            return draggedVersion || p;
        });

        if (isDeformingDrag && currentShiftPressed) {
            initialDragVertexStates.forEach(draggedVertex => {
                const hasStaticNeighbors = U.findNeighbors(draggedVertex.id, allEdges).some(neighborId => !draggedVertexIds.has(neighborId));
                if (hasStaticNeighbors) {
                    R.drawDragFeedback(ctx, htmlOverlay, draggedVertex.id, hybridVertexStates, stateForFeedback, dataToScreen, (id) => U.findNeighbors(id, allEdges), U.getEdgeId, currentShiftPressed, null, updateHtmlLabel, selectedVertexIds, true, initialDragVertexStates, activeCenterId);
                }
            });
        } else if (actionContext && (actionContext.targetVertex || actionContext.targetEdge)) {
            const primaryVertexId = actionContext.targetVertex ? actionContext.targetVertex.id : initialDragVertexStates[0]?.id;
            if (primaryVertexId) {
                R.drawDragFeedback(ctx, htmlOverlay, primaryVertexId, hybridVertexStates, stateForFeedback, dataToScreen, (id) => U.findNeighbors(id, allEdges), U.getEdgeId, currentShiftPressed, null, updateHtmlLabel, selectedVertexIds, true, initialDragVertexStates, activeCenterId);
            }
            if (actionContext.targetEdge) {
                R.drawSelectedEdgeDistances(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showDistances, distanceSigFigs, colors, lastGridState, currentShiftPressed }, findVertexById, U.getEdgeId, dataToScreen, updateHtmlLabel, dragPreviewVertices, initialDragVertexStates, transformIndicatorData);
            }
        }
    } else if ((showDistances || showAngles) && !isDrawingMode && !(parseInt(copyCountInput || '1', 10) > 1 && isDragConfirmed) && !isPlacingTransform) {
        if (selectedVertexIds.length > 0 && selectedVertexIds.length <= C.MAX_VERTICES_FOR_ANGLES) {
            selectedVertexIds.forEach(vertexId => {
                R.drawDragFeedback(ctx, htmlOverlay, vertexId, allVertices, { ...stateForFeedback, currentShiftPressed: false }, dataToScreen, (id) => U.findNeighbors(id, allEdges), U.getEdgeId, false, null, updateHtmlLabel, selectedVertexIds, false, [], activeCenterId);
            });
        }
        if (selectedEdgeIds.length > 0 && selectedEdgeIds.length <= C.MAX_EDGES_FOR_LABELS) {
            R.drawSelectedEdgeDistances(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showDistances, distanceSigFigs, colors, lastGridState }, findVertexById, U.getEdgeId, dataToScreen, updateHtmlLabel, dragPreviewVertices, initialDragVertexStates, transformIndicatorData);
            R.drawSelectedEdgeAngles(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showAngles, angleSigFigs, angleDisplayMode, currentShiftPressed, distanceSigFigs, viewTransform, lastGridState, colors }, findVertexById, U.getEdgeId, dataToScreen, (id) => U.findNeighbors(id, allEdges), updateHtmlLabel);
        }
    }

    if (isDrawingMode && previewLineStartVertexId) {
        const startVertex = findVertexById(previewLineStartVertexId);
        if (startVertex) {
            const currentPreviewDrawingContext = getDrawingContext(startVertex.id);
            const snappedData = getSnappedPosition(startVertex, mousePos, currentShiftPressed);
            let nextEdgeColor = getColorForTarget(C.COLOR_TARGET_EDGE);
            let edgeColormapInfo = null;
            const colorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
            if (colorIndex !== -1) {
                const colorItem = allColors[colorIndex];
                if (colorItem && colorItem.type === 'colormap' && currentDrawingPath && currentDrawingPath.length >= 1) {
                    const totalEdges = currentDrawingPath.length; const nextEdgeIndex = currentDrawingPath.length - 1;
                    const startT = totalEdges > 1 ? nextEdgeIndex / (totalEdges - 1) : 0; const endT = totalEdges > 1 ? (nextEdgeIndex + 1) / totalEdges : 1;
                    edgeColormapInfo = { colormapItem: colorItem, startT: startT, endT: endT };
                }
            }
            R.drawDrawingPreview(ctx, { startVertex, snappedData, isShiftPressed: currentShiftPressed, currentColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextCreationColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextEdgeColor, colors, edgeColormapInfo }, dataToScreen);
            const targetDataPos = { x: snappedData.x, y: snappedData.y };
            const stateForSnapInfo = { showDistances, showAngles, currentShiftPressed, distanceSigFigs, angleSigFigs, angleDisplayMode, viewTransform, frozenReference_D_du, gridDisplayMode, frozenReference_A_rad, colors };
            R.prepareSnapInfoTexts(ctx, htmlOverlay, startVertex, targetDataPos, snappedData, stateForSnapInfo, dataToScreen, currentPreviewDrawingContext, updateHtmlLabel);
        }
    }

    if (isRectangleSelecting && isDragConfirmed) {
        R.drawSelectionRectangle(ctx, rectangleSelectStartPos, mousePos, colors);
    }

    R.drawDrawingSnapLabels(ctx, { info: { ...drawingSnapLabelInfo, startVertex: findVertexById(previewLineStartVertexId) }, colors }, dataToScreen, findVertexById, updateHtmlLabel);
    if (transformIndicatorData || coordSystemTransformIndicatorData) {
        R.drawTransformIndicators(ctx, htmlOverlay, { transformIndicatorData, colors, coordSystemTransformIndicatorData, currentShiftPressed }, dataToScreen, updateHtmlLabel);
    }

    if (ghostVertexPosition) {
        const ghostVertex = { ...ghostVertexPosition, id: 'ghost', type: 'regular' };
        const options = {
            selectedVertexIds: [],
            selectedCenterIds: [],
            activeCenterId: null,
            colors: colors,
            isSnapped: true
        };
        R.drawVertex(ctx, ghostVertex, options, dataToScreen, updateHtmlLabel);
    }
}

function handleMultiCopyTranslationSnapVisualization(finalDelta, snapResult) {
    snappedVertexIds.clear();
    snappedEdgeIds.clear();

    if (!snapResult.snapped) return;

    const copyCount = parseInt(copyCountInput || '1', 10) || 1;
    const mergeRadius = C.MERGE_RADIUS_SCREEN / viewTransform.scale;
    const verticesToDrag = initialDragVertexStates.filter(p => p.type === 'regular');
    const initialDraggedIds = new Set(verticesToDrag.map(p => p.id));

    // Create a temporary map of all vertices that are NOT copies, in their final positions
    const finalNonCopyPositions = new Map();
    allVertices.forEach(v => {
        if (!initialDraggedIds.has(v.id)) {
            finalNonCopyPositions.set(v.id, v); // Static vertices
        }
    });
    dragPreviewVertices.forEach(pv => {
        finalNonCopyPositions.set(pv.id, pv); // Dragged vertices (at final position)
    });

    // 1. Build lists of all STATIC and MOVING elements
    const staticVertices = allVertices
        .filter(p => p.type === 'regular' && !initialDraggedIds.has(p.id))
        .map(p => ({ ...p, originalId: p.id, transformIndex: undefined }));

    const allMovingVertices = [];
    for (let i = 0; i < copyCount; i++) {
        verticesToDrag.forEach(p_orig => {
            allMovingVertices.push({
                x: p_orig.x + finalDelta.x * (i + 1),
                y: p_orig.y + finalDelta.y * (i + 1),
                originalId: p_orig.id,
                transformIndex: i
            });
        });
    }
    
    // Edges that are not part of the rigidly moving group (i.e., static or stretching edges)
    const nonMovingFinalEdges = allEdges.map(edge => {
        const isRigidlyMoving = initialDraggedIds.has(edge.id1) && initialDraggedIds.has(edge.id2);
        if (isRigidlyMoving) return null;
        
        return {
            p1: finalNonCopyPositions.get(edge.id1),
            p2: finalNonCopyPositions.get(edge.id2),
            originalEdge: edge,
            transformIndex: undefined
        };
    }).filter(e => e && e.p1 && e.p2);
    
    // Edges that ARE part of the rigidly moving group, for all copies
    const allMovingEdges = [];
    for (let i = 0; i < copyCount; i++) {
        const currentCopyVertices = allMovingVertices.filter(v => v.transformIndex === i);
        const originalMovingEdges = allEdges.filter(e => initialDraggedIds.has(e.id1) && initialDraggedIds.has(e.id2));
        originalMovingEdges.forEach(edge => {
            const p1Copy = currentCopyVertices.find(v => v.originalId === edge.id1);
            const p2Copy = currentCopyVertices.find(v => v.originalId === edge.id2);
            if (p1Copy && p2Copy) {
                allMovingEdges.push({ p1: p1Copy, p2: p2Copy, originalEdge: edge, transformIndex: i });
            }
        });
    }

    // 2. Check for ALL possible snaps

    // V-V snaps (moving vs static AND moving vs other moving)
    const vvSnaps = U.findAllVertexMerges(allMovingVertices, [...staticVertices, ...allMovingVertices], mergeRadius);
    vvSnaps.forEach(({ sourceVertex, targetVertex }) => {
        if (sourceVertex.originalId === targetVertex.originalId && sourceVertex.transformIndex === targetVertex.transformIndex) return;
        if (!snappedVertexIds.has(sourceVertex.originalId)) snappedVertexIds.set(sourceVertex.originalId, new Set());
        snappedVertexIds.get(sourceVertex.originalId).add(sourceVertex.transformIndex);
        
        if (!snappedVertexIds.has(targetVertex.originalId)) snappedVertexIds.set(targetVertex.originalId, new Set());
        snappedVertexIds.get(targetVertex.originalId).add(targetVertex.transformIndex);
    });

    // V-E snaps (moving vertices against ALL other edges)
    const veSnaps = U.findVertexToEdgeSnaps(allMovingVertices, [...nonMovingFinalEdges, ...allMovingEdges], mergeRadius);
    veSnaps.forEach(({ sourceVertex, targetEdge }) => {
         if (sourceVertex) {
            if (!snappedVertexIds.has(sourceVertex.originalId)) snappedVertexIds.set(sourceVertex.originalId, new Set());
            snappedVertexIds.get(sourceVertex.originalId).add(sourceVertex.transformIndex);
        }
        if (targetEdge && targetEdge.originalEdge) {
            const edgeId = U.getEdgeId(targetEdge.originalEdge);
            if (!snappedEdgeIds.has(edgeId)) snappedEdgeIds.set(edgeId, new Set());
            snappedEdgeIds.get(edgeId).add(targetEdge.transformIndex);
        }
    });

    // E-V snaps (moving edges against static vertices)
    const evSnaps = U.findVertexToEdgeSnaps(staticVertices, allMovingEdges, mergeRadius);
     evSnaps.forEach(({ sourceVertex: targetVertex, targetEdge: sourceEdge }) => {
         if (sourceEdge && sourceEdge.originalEdge) {
            const edgeId = U.getEdgeId(sourceEdge.originalEdge);
            if (!snappedEdgeIds.has(edgeId)) snappedEdgeIds.set(edgeId, new Set());
            snappedEdgeIds.get(edgeId).add(sourceEdge.transformIndex);
        }
        if (targetVertex) {
            if (!snappedVertexIds.has(targetVertex.originalId)) snappedVertexIds.set(targetVertex.originalId, new Set());
            snappedVertexIds.get(targetVertex.originalId).add(targetVertex.transformIndex);
        }
    });
}

function handleIdleMouseMove(mousePos) {
    hoveredVertexId = null;
    hoveredEdgeId = null;
    hoveredFaceId = null;

    if (!isActionInProgress) {
        const p = findClickedVertex(mousePos);
        const e = !p ? findClickedEdge(mousePos) : null;
        const f = !p && !e ? findClickedFace(mousePos) : null;
        if (p) hoveredVertexId = p.id;
        else if (e) hoveredEdgeId = U.getEdgeId(e);
        else if (f) hoveredFaceId = f.id;
    }

    if (currentShiftPressed && !isActionInProgress) {
        const mouseDataPos = screenToData(mousePos);
        if (isPlacingTransform) {
            const potentialSnapPos = getBestSnapPosition(mouseDataPos);
            if (potentialSnapPos) {
                placingSnapPos = dataToScreen(potentialSnapPos);
                ghostVertexPosition = potentialSnapPos;
            }
        } else {
            const p = findClickedVertex(mousePos);
            const e = !p ? findClickedEdge(mousePos) : null;
            const f = !p && !e ? findClickedFace(mousePos) : null;
            if (!p && !e && !f) {
                ghostVertexPosition = getBestSnapPosition(mouseDataPos);
            } else {
                ghostVertexPosition = null;
            }
        }
    } else if (!currentShiftPressed) {
        drawingSnapLabelInfo = null;
        ghostVertexPosition = null;
        placingSnapPos = null;
    }
}

function handleDrawingMouseMove(mousePos) {
    if (previewLineStartVertexId) {
        const startVertex = findVertexById(previewLineStartVertexId);
        if (startVertex) {
            if (currentShiftPressed) {
                const snappedData = getSnappedPosition(startVertex, mousePos, currentShiftPressed);
                drawingSnapLabelInfo = (snappedData.snapped && snappedData.snapType === 'edge_fraction')
                    ? { edge: snappedData.targetEdge, fraction: snappedData.fraction, snapPoint: { x: snappedData.x, y: snappedData.y }, mousePos: mousePos }
                    : null;
            } else {
                drawingSnapLabelInfo = null;
            }
        }
    }
    ghostVertexPosition = null;
}

function handleTransformDrag(mouseData, startReferenceVertex, center, centerType) {
    const rawTransform = calculateTransformFromMouse(center, mouseData, startReferenceVertex, centerType, currentAccumulatedRotation);
    let snapResult = {};
    let finalTransform = {};
    if (centerType === C.TRANSFORMATION_TYPE_ROTATION) {
        snapResult = getBestRotationSnap(center, initialDragVertexStates, startReferenceVertex, rawTransform.rotation, mouseData);
        finalTransform = { rotation: snapResult.rotation, scale: 1, directionalScale: false };
        currentAccumulatedRotation = rawTransform.rotation;
    } else if (centerType === C.TRANSFORMATION_TYPE_SCALE) {
        snapResult = getBestScaleSnap(center, initialDragVertexStates, startReferenceVertex, rawTransform.scale);
        finalTransform = { rotation: 0, scale: snapResult.scale || rawTransform.scale, directionalScale: false };
    } else if (centerType === C.TRANSFORMATION_TYPE_ROTATE_SCALE) {
        snapResult = getBestRotateScaleSnap(center, initialDragVertexStates, startReferenceVertex, rawTransform.rotation, rawTransform.scale);
        finalTransform = { rotation: snapResult.rotation, scale: snapResult.scale, directionalScale: false };
        currentAccumulatedRotation = rawTransform.rotation;
    } else if (centerType === C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE) {
        const startVector = { x: startReferenceVertex.x - center.x, y: startReferenceVertex.y - center.y };
        snapResult = getBestDirectionalScaleSnap(center, initialDragVertexStates, startReferenceVertex, rawTransform.scale, startVector, mouseData);
        finalTransform = { rotation: 0, scale: snapResult.scale || rawTransform.scale, directionalScale: true };
    }

    if (snapResult.snapped && snapResult.snapType === 'projection' && snapResult.projectionSource) {
        ghostVertexPosition = snapResult.projectionSource;
    }

    const startVector = { x: startReferenceVertex.x - center.x, y: startReferenceVertex.y - center.y };

    transformIndicatorData = {
        center,
        startPos: startReferenceVertex,
        currentPos: snapResult.pos || mouseData,
        rotation: finalTransform.rotation,
        scale: finalTransform.scale,
        isSnapping: snapResult.snapped || false,
        transformType: centerType,
        directionalScale: finalTransform.directionalScale,
        snappedScaleValue: snapResult.snappedScaleValue || null,
        gridToGridInfo: snapResult.gridToGridInfo || null,
        gridPoint: snapResult.gridPoint || null,
        nearbyVertex: snapResult.nearbyVertex || null,
        projectionPoint: snapResult.projectionPoint || null,
        projectionSource: snapResult.projectionSource || null,
        snapType: snapResult.snapType || null,
        projectionCenter: snapResult.snapType === 'projection' ? center : null,
        projectionHandleInitial: snapResult.projectionHandleInitial || null,
        startVector: startVector
    };
    const startVectorForApply = { x: startReferenceVertex.x - center.x, y: startReferenceVertex.y - center.y };
    dragPreviewVertices = initialDragVertexStates.map(p_initial => {
        const newPos = U.applyTransformToVertex(p_initial, center, finalTransform.rotation, finalTransform.scale, finalTransform.directionalScale, startVectorForApply);
        return { ...p_initial, x: newPos.x, y: newPos.y };
    });

    if (snapResult.snapped && snapResult.snapType === 'merge' && snapResult.mergingVertex && snapResult.mergeTarget) {
        const sourceVertexInitial = initialDragVertexStates.find(p => p.id === snapResult.mergingVertex.id);
        if (sourceVertexInitial) {
            const snappedVertexPreview = dragPreviewVertices.find(p => p.id === sourceVertexInitial.id);
            if (snappedVertexPreview) {
                const correctionVector = { x: snapResult.mergeTarget.x - snappedVertexPreview.x, y: snapResult.mergeTarget.y - snappedVertexPreview.y };
                dragPreviewVertices.forEach(p => { p.x += correctionVector.x; p.y += correctionVector.y; });
                if (transformIndicatorData.currentPos) { transformIndicatorData.currentPos.x += correctionVector.x; transformIndicatorData.currentPos.y += correctionVector.y; }
            }
        }
    }
    const mergeRadiusData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;
    const staticVerticesForMerge = allVertices.filter(p => p.type === 'regular' && !initialDragVertexStates.some(ip => ip.id === p.id));
    dragPreviewVertices.forEach(previewVertex => {
        if (previewVertex.type === 'regular') {
            staticVerticesForMerge.forEach(staticVertex => {
                if (U.distance(previewVertex, staticVertex) < mergeRadiusData) { ghostVertices.push({ x: staticVertex.x, y: staticVertex.y }); }
            });
        }
    });
    for (let i = 0; i < dragPreviewVertices.length; i++) {
        for (let j = i + 1; j < dragPreviewVertices.length; j++) {
            const p1 = dragPreviewVertices[i];
            const p2 = dragPreviewVertices[j];
            if (p1.type === 'regular' && p2.type === 'regular' && U.distance(p1, p2) < mergeRadiusData) {
                ghostVertices.push({ x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 });
            }
        }
    }
}

function handleUIDrag(mousePos) {
    if (isDraggingColorTarget && draggedColorTargetInfo) {
        const icon = canvasUI.colorTargetIcons.find(i => i.target === draggedColorTargetInfo.target);
        if (icon) {
            const dropTargets = [...canvasUI.colorSwatches];
            const closestTarget = U.findClosestUIElement(mousePos, dropTargets);
            if (closestTarget) {
                icon.x = closestTarget.x + (closestTarget.width - icon.width) / 2;
                draggedColorTargetInfo.previewColorIndex = closestTarget.index;
            } else {
                icon.x = mousePos.x - draggedColorTargetInfo.offsetX;
                draggedColorTargetInfo.previewColorIndex = draggedColorTargetInfo.originalColorIndex;
            }
        }
        return true;
    }

    if (isDraggingColorSwatch) {
        const removeBtn = canvasUI.removeColorButton;
        const isOverRemoveButton = removeBtn &&
            mousePos.x >= removeBtn.x && mousePos.x <= removeBtn.x + removeBtn.width &&
            mousePos.y >= removeBtn.y && mousePos.y <= removeBtn.y + removeBtn.height;

        if (isOverRemoveButton && allColors.length > 1 && !draggedSwatchTemporarilyRemoved) {
            draggedSwatchTemporarilyRemoved = true;
            const indexToRemove = allColors.indexOf(draggedSwatchInfo.item);
            if (indexToRemove >= 0) {
                removeColorAtIndex(indexToRemove);
                buildColorPaletteUI();
            }
            return true;
        } else if (!isOverRemoveButton && draggedSwatchTemporarilyRemoved) {
            draggedSwatchTemporarilyRemoved = false;
            allColors.splice(draggedSwatchInfo.originalIndex, 0, draggedSwatchInfo.item);
            Object.keys(colorAssignments).forEach(target => {
                if (colorAssignments[target] >= draggedSwatchInfo.originalIndex) {
                    colorAssignments[target]++;
                }
            });
            Object.keys(draggedSwatchInfo.originalAssignments).forEach(target => {
                if (draggedSwatchInfo.originalAssignments[target] === draggedSwatchInfo.originalIndex) {
                    colorAssignments[target] = draggedSwatchInfo.originalIndex;
                }
            });
            buildColorPaletteUI();
            return true;
        }

        if (draggedSwatchTemporarilyRemoved) return true;

        const fromIndex = allColors.indexOf(draggedSwatchInfo.item);
        let targetIndex = fromIndex;
        for (let i = 0; i < canvasUI.colorSwatches.length; i++) {
            const swatch = canvasUI.colorSwatches[i];
            if (mousePos.x >= swatch.x && mousePos.x <= swatch.x + swatch.width) {
                targetIndex = allColors.indexOf(swatch.item);
                break;
            }
        }
        
        if (targetIndex !== fromIndex) {
            const temp = allColors[fromIndex];
            allColors.splice(fromIndex, 1);
            allColors.splice(targetIndex, 0, temp);
            
            Object.keys(colorAssignments).forEach(target => {
                if (colorAssignments[target] === fromIndex) {
                    colorAssignments[target] = targetIndex;
                } else if (colorAssignments[target] > fromIndex && colorAssignments[target] <= targetIndex) {
                    colorAssignments[target]--;
                } else if (colorAssignments[target] < fromIndex && colorAssignments[target] >= targetIndex) {
                    colorAssignments[target]++;
                }
            });
            buildColorPaletteUI();
        }
        return true;
    }

    return false;
}

function updateHoverStates() {
    // If we are in the middle of a drag, draw, or pan, clear all idle hover effects.
    if (isActionInProgress || isDrawingMode) {
        altHoverInfo = null;
        ghostVertexPosition = null;
        hoveredVertexId = null;
        hoveredEdgeId = null;
        hoveredFaceId = null;
        return;
    }

    // Check if Alt is held down
    if (currentAltPressed) {
        // If so, run the logic for the special Alt indicator
        handleAltHoverMouseMove(mousePos, currentShiftPressed);
    } else {
        // Otherwise, run the logic for normal and Shift-key hovering
        altHoverInfo = null;
        handleIdleMouseMove(mousePos);
    }
}

function handleMouseMove(event) {
    mousePos = U.getMousePosOnCanvas(event, canvas);
    currentShiftPressed = event.shiftKey;
    currentAltPressed = event.altKey;

    if (isMouseInUIPanel(mousePos)) {
        canvas.style.cursor = 'default';
    } else if (isPlacingTransform) {
        canvas.style.cursor = 'none';
    } else if (isPanningBackground || isDragConfirmed) {
        canvas.style.cursor = 'grabbing';
    } else {
        canvas.style.cursor = 'crosshair';
    }

    if (isActionInProgress) {
        if (!isDragConfirmed && U.distance(mousePos, actionStartPos) > C.DRAG_THRESHOLD && !isDrawingMode) {
            isDragConfirmed = true;
            actionTargetVertex = actionContext.dragHandle;
            isEdgeTransformDrag = !!actionContext.isTransformDrag;

            if (actionContext.target === 'ui_icon_click') {
                isDraggingColorTarget = true;
                draggedColorTargetInfo = {
                    target: actionContext.element.target,
                    offsetX: mousePos.x - actionContext.element.x,
                    offsetY: mousePos.y - actionContext.element.y,
                    originalColorIndex: colorAssignments[actionContext.element.target],
                    previewColorIndex: colorAssignments[actionContext.element.target]
                };
                actionContext.target = 'ui_icon_drag';
                activeColorTargets = [actionContext.element.target];
            } else if (actionContext.target === 'ui_swatch') {
                saveStateForUndo();
                isDraggingColorSwatch = true;
                draggedSwatchInfo = {
                    index: actionContext.element.index,
                    item: actionContext.element.item,
                    offsetX: mousePos.x - actionContext.element.x,
                    originalIndex: actionContext.element.index,
                    originalAllColors: JSON.parse(JSON.stringify(allColors)),
                    originalAssignments: JSON.parse(JSON.stringify(colorAssignments))
                };
            } else if (currentMouseButton === 2) {
                isRectangleSelecting = true;
                return;
            } else if (actionContext.target === 'canvas') {
                isPanningBackground = true;
                backgroundPanStartOffset = { x: viewTransform.offsetX, y: viewTransform.offsetY };
                canvas.style.cursor = 'move';
            } else {
                canvas.style.cursor = 'grabbing';
                isDraggingCenter = actionContext.targetVertex && actionContext.targetVertex.type !== 'regular';

                let verticesToDrag;
                if (isDraggingCenter) {
                    verticesToDrag = [actionContext.targetVertex];
                } else {
                    let verticesToDragIds = new Set(selectedVertexIds);
                    selectedEdgeIds.forEach(edgeId => {
                        const [id1, id2] = edgeId.split(C.EDGE_ID_DELIMITER);
                        verticesToDragIds.add(id1);
                        verticesToDragIds.add(id2);
                    });
                    selectedFaceIds.forEach(faceId => {
                        const face = allFaces.find(f => U.getFaceId(f) === faceId);
                        if (face) {
                            const allFamilyVertices = getDescendantVertices(face.id, allFaces);
                            allFamilyVertices.forEach(id => verticesToDragIds.add(id));
                        }
                    });
                    verticesToDrag = Array.from(verticesToDragIds).map(id => findVertexById(id)).filter(p => p && p.type === 'regular');
                }

                if (isDraggingCenter) {
                    if (actionContext.targetVertex.type === C.TRANSFORMATION_TYPE_ROTATION) {
                        const center = actionContext.targetVertex;
                        const startReferenceVertex = screenToData(actionStartPos);
                        const startVector = { x: startReferenceVertex.x - center.x, y: startReferenceVertex.y - center.y };
                        actionContext.initialRotationStartAngle = Math.atan2(startVector.y, startVector.x);
                        currentAccumulatedRotation = 0;
                    }
                }

                if (verticesToDrag.length > 0) {
                    initialDragVertexStates = JSON.parse(JSON.stringify(verticesToDrag));
                    dragPreviewVertices = JSON.parse(JSON.stringify(verticesToDrag));
                    initialCoordSystemStates.clear();
                    const verticesThatMoved = new Set(initialDragVertexStates.map(v => v.id));
                    allFaces.forEach(face => {
                        if (face.vertexIds.some(vId => verticesThatMoved.has(vId))) {
                            if (face.localCoordSystem) {
                                initialCoordSystemStates.set(face.id, JSON.parse(JSON.stringify(face.localCoordSystem)));
                            }
                        }
                    });
                }
            }
        }

        if (isDragConfirmed) {
            if (isPanningBackground) {
                const deltaX_css = mousePos.x - actionStartPos.x;
                const deltaY_css = mousePos.y - actionStartPos.y;
                viewTransform.offsetX = backgroundPanStartOffset.x + (deltaX_css * dpr);
                viewTransform.offsetY = backgroundPanStartOffset.y - (deltaY_css * dpr);
            } else if (!isRectangleSelecting) {
                if (handleUIDrag(mousePos)) return;
                if (handleCoordinateSystemMouseMove(event)) return;
                const isTransformingSelection = activeCenterId && (selectedVertexIds.length > 0 || selectedEdgeIds.length > 0 || selectedFaceIds.length > 0) && !isEdgeTransformDrag;
                if (isTransformingSelection) {
                    const center = findVertexById(activeCenterId);
                    let startReferenceVertex = actionTargetVertex;
                    if (!startReferenceVertex && initialDragVertexStates.length > 0) {
                        startReferenceVertex = initialDragVertexStates.find(p => U.distance(p, center) > 1e-6) || initialDragVertexStates[0];
                    }
                    if (center && startReferenceVertex) {
                        handleTransformDrag(screenToData(mousePos), startReferenceVertex, center, center.type);
                    }
                } else if (dragPreviewVertices.length > 0) {
                    const mouseData = screenToData(mousePos);
                    const startMouseData = screenToData(actionStartPos);
                    const rawDelta = { x: mouseData.x - startMouseData.x, y: mouseData.y - startMouseData.y };
                    handleTranslationDrag(rawDelta, mouseData);
                }
            }
        }
    } else {
        if (isDrawingMode) {
            handleDrawingMouseMove(mousePos);
        } else {
            updateHoverStates();
        }
    }
}

function handleTranslationDragSnapVisualization(finalDelta, snapResult) {
    snappedVertexIds.clear();
    snappedEdgeIds.clear();
    if (!isDragConfirmed) return;

    const copyCount = parseInt(copyCountInput || '1', 10) || 1;
    const allFinalVertices = getFinalDragPositions(initialDragVertexStates, allVertices, finalDelta, copyCount);
    const { vertexMerges, edgeSplits } = calculateFinalMerges(allFinalVertices, allEdges, viewTransform);

    const addSnappedVertex = (vertex) => {
        if (!vertex || vertex.originalId === undefined) return;
        if (!snappedVertexIds.has(vertex.originalId)) {
            snappedVertexIds.set(vertex.originalId, new Set());
        }
        snappedVertexIds.get(vertex.originalId).add(vertex.transformIndex);
    };

    vertexMerges.forEach((rootId, sourceId) => {
        addSnappedVertex(allFinalVertices.find(v => v.id === sourceId));
        addSnappedVertex(allFinalVertices.find(v => v.id === rootId));
    });

    edgeSplits.forEach(({ edge, pointsToInsert }) => {
        const edgeId = U.getEdgeId(edge);
        const originalEdge = allEdges.find(e => U.getEdgeId(e) === edgeId);
        if (originalEdge) {
            const p1 = allFinalVertices.find(v => v.originalId === originalEdge.id1);
             if (!snappedEdgeIds.has(edgeId)) snappedEdgeIds.set(edgeId, new Set());
             snappedEdgeIds.get(edgeId).add(p1 ? p1.transformIndex : undefined);
        }
        pointsToInsert.forEach(addSnappedVertex);
    });
}

function calculateFinalMerges(allFinalVertices, allEdges, viewTransform) {
    const mergeRadius = C.MERGE_RADIUS_SCREEN / viewTransform.scale;
    const vertexMerges = new Map();
    const edgeSplits = new Map();
    const parent = new Map();
    allFinalVertices.forEach(p => parent.set(p.id, p.id));

    const findRoot = (id) => {
        if (!parent.has(id) || parent.get(id) === id) return id;
        const rootId = findRoot(parent.get(id));
        parent.set(id, rootId);
        return rootId;
    };

    for (let i = 0; i < allFinalVertices.length; i++) {
        for (let j = i + 1; j < allFinalVertices.length; j++) {
            const p1 = allFinalVertices[i];
            const p2 = allFinalVertices[j];
            if (p1.type === 'regular' && p2.type === 'regular' && U.distance(p1, p2) < mergeRadius) {
                const root1 = findRoot(p1.id);
                const root2 = findRoot(p2.id);
                if (root1 !== root2) {
                    parent.set(root2, root1);
                }
            }
        }
    }

    allFinalVertices.forEach(p => {
        const rootId = findRoot(p.id);
        if (p.id !== rootId) {
            vertexMerges.set(p.id, rootId);
        }
    });

    const mergedAwayVertexIds = new Set(vertexMerges.keys());
    const finalVertexMap = new Map(allFinalVertices.map(v => [v.id, v]));

    allEdges.forEach(edge => {
        const root1_id = findRoot(edge.id1);
        const root2_id = findRoot(edge.id2);
        if (root1_id === root2_id) return;

        const p1 = finalVertexMap.get(root1_id);
        const p2 = finalVertexMap.get(root2_id);
        if (!p1 || !p2) return;

        allFinalVertices.forEach(vertex => {
            if (vertex.type !== 'regular' || mergedAwayVertexIds.has(vertex.id)) return;
            if (vertex.id === root1_id || vertex.id === root2_id) return;

            const closest = U.getClosestPointOnLineSegment(vertex, p1, p2);
            if (closest.distance < mergeRadius && closest.onSegmentStrict) {
                const edgeId = U.getEdgeId({id1: root1_id, id2: root2_id});
                if (!edgeSplits.has(edgeId)) {
                    edgeSplits.set(edgeId, {edge: {id1: root1_id, id2: root2_id}, pointsToInsert: []});
                }
                edgeSplits.get(edgeId).pointsToInsert.push(vertex);
            }
        });
    });

    return { vertexMerges, edgeSplits };
}

function handleMouseUpDispatcher(event) {
    if (currentMouseButton === 0) {
        handleLeftMouseButtonUp(event);
    } else if (currentMouseButton === 2) {
        handleRightMouseButtonUp(event);
    }

    cleanupAfterDrag();

    if (isMouseInUIPanel(mousePos)) {
        canvas.style.cursor = 'default';
    } else if (!isPlacingTransform) {
        canvas.style.cursor = 'crosshair';
    }
}

function cleanupAfterDrag() {
    if (copyCountTimer) clearTimeout(copyCountTimer);
    copyCountInput = '';
    copyCountTimer = null;

    isActionInProgress = false;
    isDragConfirmed = false;
    isRectangleSelecting = false;
    isEdgeTransformDrag = false;
    isDraggingCenter = false;
    isPanningBackground = false;
    dragPreviewVertices = [];
    initialDragVertexStates = [];
    actionContext = null;
    transformIndicatorData = null;
    ghostVertices = [];
    ghostVertexPosition = null;
    snappedEdgeIds.clear();
    snappedVertexIds.clear();
}

function handleMouseDownDispatcher(event) {
    if (copyCountTimer) clearTimeout(copyCountTimer);
    copyCountInput = '';
    copyCountTimer = null;

    if (contextMenu.style.display === 'block') {
        contextMenu.style.display = 'none';
    }

    const targetElement = event.target;
    if (targetElement && targetElement.closest('.katex')) {
        event.stopPropagation();
        return;
    }

    if ((isDrawingMode || isPlacingTransform) && event.button === 2) {
        performEscapeAction();
        event.preventDefault();
        return;
    }

    mousePos = U.getMousePosOnCanvas(event, canvas);
    actionStartPos = { ...mousePos };
    currentMouseButton = event.button;

    if (currentMouseButton === 0) {
        handleLeftMouseButtonDown(event);
    } else if (currentMouseButton === 2) {
        handleRightMouseButtonDown(event);
    }
}

function handleKeyDown(event) {
    if (event.key === 'Alt' && !event.repeat) {
        event.preventDefault();
        currentAltPressed = true;
        updateHoverStates();
    }

    const isCtrlOrCmd = event.ctrlKey || event.metaKey;

    if (event.key === 'Shift' && !currentShiftPressed) {
        currentShiftPressed = true;
        const mouseDataPos = screenToData(mousePos);
        if (isPlacingTransform) {
            const potentialSnapPos = getBestSnapPosition(mouseDataPos);
            if (potentialSnapPos) {
                placingSnapPos = dataToScreen(potentialSnapPos);
                ghostVertexPosition = potentialSnapPos;
            }
        } else if (isDrawingMode && previewLineStartVertexId) {
            const startVertex = findVertexById(previewLineStartVertexId);
            if (startVertex) {
                const colors = getColors();
                const currentPreviewDrawingContext = getDrawingContext(startVertex.id);
                const snappedData = getSnappedPosition(startVertex, mousePos, currentShiftPressed);
                let nextEdgeColor = getColorForTarget(C.COLOR_TARGET_EDGE);
                let edgeColormapInfo = null;
                const colorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
                if (colorIndex !== -1) {
                    const colorItem = allColors[colorIndex];
                    if (colorItem && colorItem.type === 'colormap' && currentDrawingPath && currentDrawingPath.length >= 1) {
                        const totalEdges = currentDrawingPath.length;
                        const nextEdgeIndex = currentDrawingPath.length - 1;
                        const startT = totalEdges > 1 ? nextEdgeIndex / (totalEdges - 1) : 0;
                        const endT = totalEdges > 1 ? (nextEdgeIndex + 1) / totalEdges : 1;
                        edgeColormapInfo = {
                            colormapItem: colorItem,
                            startT: startT,
                            endT: endT
                        };
                    }
                }
                R.drawDrawingPreview(ctx, { startVertex, snappedData, isShiftPressed: currentShiftPressed, currentColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextCreationColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextEdgeColor, colors, edgeColormapInfo }, dataToScreen);
                const stateForSnapInfo = { showDistances, showAngles, currentShiftPressed, distanceSigFigs, angleSigFigs, angleDisplayMode, viewTransform, frozenReference_D_du, gridDisplayMode, frozenReference_A_rad, colors };
                R.prepareSnapInfoTexts(ctx, htmlOverlay, startVertex, snappedData, snappedData, stateForSnapInfo, dataToScreen, currentPreviewDrawingContext, updateHtmlLabel);
            }
        } else if (!isActionInProgress) {
            if (isDraggingCoordSystem && draggedCoordSystemElement && draggedCoordSystemElement.type === 'center') {
                const potentialSnapPos = getBestSnapPosition(mouseDataPos);
                if (potentialSnapPos) {
                    ghostVertexPosition = potentialSnapPos;
                    const face = draggedCoordSystemElement.face;
                    const coordSystem = face.localCoordSystem;
                    const faceVertices = face.vertexIds.map(id => findVertexById(id)).filter(p => p && p.type === 'regular');
                    const clampedPos = U.clampPointToPolygon(potentialSnapPos, faceVertices);
                    coordSystem.origin.x = clampedPos.x;
                    coordSystem.origin.y = clampedPos.y;
                    coordSystem.isCustom = true;
                }
            } else {
                const p = findClickedVertex(mousePos);
                const e = !p ? findClickedEdge(mousePos) : null;
                const f = !p && !e ? findClickedFace(mousePos) : null;
                if (!p && !e && !f) {
                    ghostVertexPosition = getBestSnapPosition(mouseDataPos);
                } else {
                    ghostVertexPosition = null;
                }
            }
        }
    }

    if (isActionInProgress && currentMouseButton === 0 && (actionContext?.targetVertex || actionContext?.targetEdge || actionContext?.targetFace) && event.key >= '0' && event.key <= '9') {
        if (event.repeat) {
            return;
        }
        event.preventDefault();
        clearTimeout(copyCountTimer);
        if (copyCountTimer === null || copyCountInput.length >= 2) {
            copyCountInput = event.key;
        } else {
            copyCountInput += event.key;
        }
        copyCountTimer = setTimeout(() => {
            copyCountTimer = null;
        }, 500);
        return;
    }
    if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_REPEAT) {
        event.preventDefault();
        if (isDrawingMode && previewLineStartVertexId) {
            handleRepeat();
        }
        return;
    }
    const allowedDuringAction = ['Shift', 'Control', 'Meta', 'Alt', 'Escape', 'Delete', 'Backspace'];
    if (isActionInProgress && !allowedDuringAction.includes(event.key) && !(isCtrlOrCmd && [C.KEY_COPY, C.KEY_CUT, C.KEY_PASTE, C.KEY_UNDO, C.KEY_REDO, C.KEY_SELECT_ALL, C.KEY_ZOOM_OUT, C.KEY_ZOOM_IN, C.KEY_ZOOM_IN_PLUS].includes(event.key.toLowerCase()))) return;
    if (isMouseOverCanvas && isCtrlOrCmd && (event.key === C.KEY_ZOOM_IN || event.key === C.KEY_ZOOM_IN_PLUS)) {
        event.preventDefault();
        const centerScreen = { x: (canvas.width / dpr) / 2, y: (canvas.height / dpr) / 2 };
        zoomAt(centerScreen, C.KEYBOARD_ZOOM_FACTOR);
        return;
    }
    if (isMouseOverCanvas && isCtrlOrCmd && event.key === C.KEY_ZOOM_OUT) {
        event.preventDefault();
        const centerScreen = { x: (canvas.width / dpr) / 2, y: (canvas.height / dpr) / 2 };
        zoomAt(centerScreen, 1 / C.KEYBOARD_ZOOM_FACTOR);
        return;
    }
    if (event.key === C.KEY_SPACE) {
        event.preventDefault();
        completeGraphOnSelectedVertices();
    } else if (event.key === C.KEY_ESCAPE) {
        performEscapeAction();
    } else if (event.key === C.KEY_DELETE || event.key === C.KEY_BACKSPACE) {
        deleteSelectedItems();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_COPY) {
        event.preventDefault();
        handleCopy();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_CUT) {
        event.preventDefault();
        handleCut();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_PASTE) {
        event.preventDefault();
        handlePaste();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_UNDO && !event.shiftKey) {
        event.preventDefault();
        handleUndo();
    } else if (isCtrlOrCmd && (event.key.toLowerCase() === C.KEY_REDO || (event.shiftKey && event.key.toLowerCase() === C.KEY_UNDO))) {
        event.preventDefault();
        handleRedo();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_SELECT_ALL && !isMouseOverColorEditor) {
        event.preventDefault();
        saveStateForUndo();
        selectedVertexIds = allVertices.filter(p => p.type === 'regular').map(p => p.id);
        selectedEdgeIds = allEdges.map(edge => U.getEdgeId(edge));
        selectedFaceIds = allFaces.map(face => face.id);
        selectedCenterIds = allVertices.filter(p => p.type !== 'regular').map(p => p.id);
        activeCenterId = null;
        const newActiveTargets = [];
        if (selectedFaceIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_FACE);
        if (selectedEdgeIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_EDGE);
        if (selectedVertexIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_VERTEX);
        if (newActiveTargets.length > 0) {
            activeColorTargets = newActiveTargets;
            if (isColorPaletteExpanded) {
                buildColorPaletteUI();
            }
        }
    }
}

function handleKeyUp(event) {
    if (event.key === 'Shift') {
        currentShiftPressed = false;
        ghostVertexPosition = null;
        placingSnapPos = null;
        ghostVertices = [];

        if (isDraggingCoordSystem && draggedCoordSystemElement && draggedCoordSystemElement.type === 'center') {
            const mouseDataPos = screenToData(mousePos);
            const face = draggedCoordSystemElement.face;
            const coordSystem = face.localCoordSystem;
            const faceVertices = face.vertexIds.map(id => findVertexById(id)).filter(p => p && p.type === 'regular');
            const clampedPos = U.clampPointToPolygon(mouseDataPos, faceVertices);
            coordSystem.origin.x = clampedPos.x;
            coordSystem.origin.y = clampedPos.y;
            coordSystem.isCustom = true;
        }
    }
    if (event.key === 'Alt') {
        currentAltPressed = false;
        updateHoverStates();
    }
}

function handleResize() {
    const canvasContainer = document.querySelector('.canvas-container');
    const canvasWrapper = document.querySelector('.canvas-wrapper-relative');

    if (!canvasContainer || !canvasWrapper) {
        return;
    }

    const cW = canvasWrapper.offsetWidth;
    const cH = canvasWrapper.offsetHeight;

    canvas.width = cW * dpr;
    canvas.height = cH * dpr;
    canvas.style.width = `${cW}px`;
    canvas.style.height = `${cH}px`;

    if (htmlOverlay) {
        htmlOverlay.style.width = `${cW}px`;
        htmlOverlay.style.height = `${cH}px`;
    }
}

function handleLoad() {
    setupUndoStackDebugging();
    allColors = C.DEFAULT_RECENT_COLORS.map(color => {
        if (typeof color === 'string') {
            return { type: 'color', value: color };
        }
        return color;
    });

    if (typeof window.katex === 'undefined') {
        console.error("KaTeX library failed to load or initialize. Math rendering will be broken.");
    }
    initializeCanvasUI();
    buildMainToolbarUI();
    handleResize();

    colorEditor = new ColormapSelector();
    colorEditor.initialize();
    document.body.appendChild(colorEditor.getElement());

    const colorEditorElement = colorEditor.getElement();
    colorEditorElement.addEventListener('mouseenter', () => {
        isMouseOverColorEditor = true;
    });
    colorEditorElement.addEventListener('mouseleave', () => {
        isMouseOverColorEditor = false;
    });

    colorEditor.getElement().addEventListener('select', (e) => {
        const colormapData = e.detail;
        const newItem = U.convertColorToColormapFormat(colormapData);

        if (!newItem) return;

        if (isEditingColor && editingColorIndex !== null) {
            allColors[editingColorIndex] = newItem;
        } else {
            addToColors(newItem);
            const newColorIndex = allColors.length - 1;
            activeColorTargets.forEach(target => {
                colorAssignments[target] = newColorIndex;
            });
        }

        applyColorsToSelection();

        isEditingColor = false;
        editingColorIndex = null;
        buildColorPaletteUI();
    });

    viewTransform.scale = 70;
    viewTransform.offsetX = canvas.width / 2;
    viewTransform.offsetY = canvas.height / 2;
    coordsDisplayMode = 'regular';

    contextMenu = document.getElementById('context-menu');
    window.addEventListener('click', () => {
        if (contextMenu) {
            contextMenu.style.display = 'none';
        }
    });
    contextMenu.addEventListener('mouseleave', () => {
        contextMenu.style.display = 'none';
    });

    saveStateForUndo();
    gameLoop();
    updateComponentDrawOrder();
}

canvas.addEventListener('wheel', handleWheelEvent, { passive: false });

canvas.addEventListener('mouseenter', handleMouseEnter);

canvas.addEventListener('mouseleave', handleMouseLeave);

window.addEventListener('contextmenu', handleContextMenu);

canvas.addEventListener('mousemove', handleMouseMove);

canvas.addEventListener("mouseup", handleMouseUpDispatcher);

canvas.addEventListener('mousedown', handleMouseDownDispatcher);

window.addEventListener('keyup', handleKeyUp);

window.addEventListener('keydown', handleKeyDown);

window.addEventListener('resize', handleResize);

window.addEventListener('load', handleLoad);

=== style.css ===
:root {
    --container-bg-color: #1e1e1e;
    --default-text-color: #e2e8f0; /* A light default text color */
}

html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background-color: var(--container-bg-color);
    /* Set a default text color for the whole page */
    color: var(--default-text-color);
}

.container {
    /* Scope the specific font only to the app's container */
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
}

.canvas-container {
    flex-grow: 1;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    box-sizing: border-box;
}

.canvas-wrapper-relative {
    position: relative;
    width: 100%;
    height: 100%;
}

/* This rule is now specific to the main drawing canvas */
#drawingCanvas {
    display: block;
    background-color: #1a1a1a;
    cursor: crosshair;
}

#html-overlay {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    width: 100%;
    height: 100%;
}

.context-menu {
    display: none;
    position: absolute;
    background-color: #2a2a2e;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 5px 0;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    z-index: 1000;
}

.context-menu ul {
    list-style: none;
    margin: 0;
    padding: 0;
}

.context-menu ul li {
    padding: 8px 15px;
    cursor: pointer;
}

.context-menu ul li:hover {
    background-color: #4a4a50;
}


=== utils.js ===
import * as C from './constants.js';


export function formatNumber(value, sigFigs, forceScientific = false) {
    if (value === 0) return "0";
    const absValue = Math.abs(value);
    const sign = value < 0 ? "-" : "";
    let formattedString;
    if (forceScientific || absValue >= C.SCIENTIFIC_NOTATION_UPPER_BOUND || (absValue !== 0 && absValue < C.SCIENTIFIC_NOTATION_LOWER_BOUND)) {
        if (value === 0) return "0";
        const expStr = absValue.toExponential(Math.max(0, sigFigs - 1));
        const parts = expStr.split('e');
        let coefficient = parseFloat(parts[0]).toString();
        let exponent = parseInt(parts[1], 10);
        formattedString = `${coefficient} \\cdot 10^{${exponent}}`;
    } else {
        const integerDigits = absValue < 1 ? 0 : Math.floor(Math.log10(absValue)) + 1;
        let decimalPlacesToDisplay;
        if (absValue === 0) {
            decimalPlacesToDisplay = sigFigs - 1;
        } else if (absValue < 1) {
            let k = 0;
            let temp = absValue;
            while (temp < 1 && k < sigFigs + 5) {
                temp *= 10;
                k++;
            }
            decimalPlacesToDisplay = Math.max(0, (k - 1) + sigFigs);
        } else {
            decimalPlacesToDisplay = Math.max(0, sigFigs - integerDigits);
        }
        let fixedStr = absValue.toFixed(decimalPlacesToDisplay);
        let num = parseFloat(fixedStr);
        if (Math.abs(num) === 0 && value !== 0) {
            return "0";
        }
        formattedString = Math.abs(num).toString();
    }
    return sign + formattedString;
}

export function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b);
}

export function getEdgeId(edge) {
    return edge.id1 < edge.id2 
        ? `${edge.id1}${C.EDGE_ID_DELIMITER}${edge.id2}` 
        : `${edge.id2}${C.EDGE_ID_DELIMITER}${edge.id1}`;
}

export function distanceToSegment(px, py, x1, y1, x2, y2) {
    // Compute vector AB = (x2 - x1, y2 - y1)
    const abX = x2 - x1;
    const abY = y2 - y1;
    
    // Compute squared length
    const lSquared = abX * abX + abY * abY;
    
    // If points are the same, distance is to that point
    if (lSquared === 0) {
        const dx = px - x1;
        const dy = py - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    // Compute projection parameter t = -((x1 - px) * (x2 - x1) + (y1 - py) * (y2 - y1)) / l_squared
    let t = -((x1 - px) * abX + (y1 - py) * abY) / lSquared;
    
    // Clamp t to [0, 1]
    if (t < 0) t = 0;
    if (t > 1) t = 1;
    
    // Compute closest point C = (x1 + t * (x2 - x1), y1 + t * (y2 - y1))
    const cX = x1 + t * abX;
    const cY = y1 + t * abY;
    
    // Compute distance from point to closest point
    const dx = px - cX;
    const dy = py - cY;
    return Math.sqrt(dx * dx + dy * dy);
}

export function getFaceId(face) {
    if (face.id) return face.id;
    if (face.vertexIds) {
        return `face_${[...face.vertexIds].sort().join('_')}`;
    }
    return null;
}

export function getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, angularGridState, getMultipleRect = false) {
    const candidates = [];
    if (gridDisplayMode === 'none' || !gridInterval || gridInterval <= 0) {
        return candidates;
    }

    if (gridDisplayMode === 'polar') {
        const mouseAngleDeg = (Math.atan2(mouseDataPos.y, mouseDataPos.x) * 180 / Math.PI + 360) % 360;
        const mouseRadius = Math.hypot(mouseDataPos.x, mouseDataPos.y);
        const snappedRadius = Math.round(mouseRadius / gridInterval) * gridInterval;

        angularGridState.forEach(level => {
            if (level.alpha > 0.01 && level.angle > 0) {
                const angularInterval = level.angle;
                const snappedAngleDeg = Math.round(mouseAngleDeg / angularInterval) * angularInterval;
                const snappedAngleRad = snappedAngleDeg * Math.PI / 180;
                candidates.push({ x: snappedRadius * Math.cos(snappedAngleRad), y: snappedRadius * Math.sin(snappedAngleRad), isGridPoint: true });
            }
        });
    } else if (gridDisplayMode === 'triangular') {
        const y_step = gridInterval * C.TRIANGULAR_GRID_Y_STEP_FACTOR;
        const i_f = (mouseDataPos.x / gridInterval) - (mouseDataPos.y / (gridInterval * Math.sqrt(3)));
        const j_f = mouseDataPos.y / y_step;

        let i_r = Math.round(i_f);
        let j_r = Math.round(j_f);
        let k_r = Math.round(-i_f - j_f);

        const i_diff = Math.abs(i_r - i_f);
        const j_diff = Math.abs(j_r - j_f);
        const k_diff = Math.abs(k_r - (-i_f - j_f));

        if (i_diff > j_diff && i_diff > k_diff) {
            i_r = -j_r - k_r;
        } else if (j_diff > k_diff) {
            j_r = -i_r - k_r;
        }

        const snappedX = i_r * gridInterval + j_r * gridInterval / 2;
        const snappedY = j_r * y_step;
        candidates.push({ x: snappedX, y: snappedY, isGridPoint: true });
    } else {
        if (getMultipleRect) {
            const gridX = Math.floor(mouseDataPos.x / gridInterval) * gridInterval;
            const gridY = Math.floor(mouseDataPos.y / gridInterval) * gridInterval;
            candidates.push(
                { x: gridX, y: gridY, isGridPoint: true },
                { x: gridX + gridInterval, y: gridY, isGridPoint: true },
                { x: gridX, y: gridY + gridInterval, isGridPoint: true },
                { x: gridX + gridInterval, y: gridY + gridInterval, isGridPoint: true }
            );
        } else {
            candidates.push({ x: Math.round(mouseDataPos.x / gridInterval) * gridInterval, y: Math.round(mouseDataPos.y / gridInterval) * gridInterval, isGridPoint: true });
        }
    }
    return candidates;
}

export function findAllVertexMerges(sourceVertices, targetVertices, snapRadius) {
    const mergeCandidates = [];

    for (const source of sourceVertices) {
        for (const target of targetVertices) {
            // A vertex cannot snap to itself.
            // This checks if they represent the same original vertex at the same transformation step.
            if (source.originalId === target.originalId && source.transformIndex === target.transformIndex) {
                continue;
            }

            const dist = distance(source, target);
            if (dist < snapRadius) {
                mergeCandidates.push({
                    dist,
                    sourceVertex: source,
                    targetVertex: target,
                    // A target is "static" if it's not a moving copy (i.e., it has no transformIndex or its index is 0).
                    targetIsStatic: target.transformIndex === undefined || target.transformIndex === 0
                });
            }
        }
    }
    return mergeCandidates;
}

export function findVertexToEdgeSnaps(sourceVertices, targetEdges, snapRadius) {
    const candidates = [];
    console.log(`[DEBUG-4] findVertexToEdgeSnaps: Checking ${sourceVertices.length} sources against ${targetEdges.length} targets.`);

    for (const sourceVertex of sourceVertices) {
        for (const targetEdge of targetEdges) {
            if (!targetEdge || !targetEdge.originalEdge || !targetEdge.p1 || !targetEdge.p2) {
                continue;
            }
            
            const isSameInstance = sourceVertex.transformIndex === targetEdge.transformIndex;
            const isOwnEndpoint = sourceVertex.originalId === targetEdge.originalEdge.id1 || sourceVertex.originalId === targetEdge.originalEdge.id2;

            if (isSameInstance && isOwnEndpoint) {
                continue;
            }

            const closest = getClosestPointOnLineSegment(sourceVertex, targetEdge.p1, targetEdge.p2);
            const shouldSnap = closest.distance < snapRadius && closest.onSegmentStrict;

            if (shouldSnap) {
                const edgeId = getEdgeId(targetEdge.originalEdge);
                console.log(`[DEBUG-5] findVertexToEdgeSnaps: SUCCESS! V:${sourceVertex.originalId} is snapping to E:${edgeId}. Dist: ${closest.distance.toFixed(4)}`);
                candidates.push({
                    dist: closest.distance,
                    sourceVertex: sourceVertex,
                    targetEdge: targetEdge,
                    snapPoint: { x: closest.x, y: closest.y },
                    snapType: 'vertex-to-edge'
                });
            }
        }
    }
    return candidates;
}

export function generateUniqueId() {
    return crypto.randomUUID();
}

export function normalizeAngle(angleRad) {
    while (angleRad < 0) angleRad += C.RADIANS_IN_CIRCLE;
    while (angleRad >= C.RADIANS_IN_CIRCLE) angleRad -= C.RADIANS_IN_CIRCLE;
    return angleRad;
}

export function calculateRotationAngle(initialStartAngle, currentMouseAngle, totalAccumulatedRotationFromStart = 0) {
    let rawDeltaAngle = currentMouseAngle - initialStartAngle;
    let numRevolutions = Math.round((totalAccumulatedRotationFromStart - rawDeltaAngle) / (2 * Math.PI));
    let continuousDeltaAngle = rawDeltaAngle + numRevolutions * (2 * Math.PI);
    return continuousDeltaAngle;
}

export function normalizeAngleToPi(angleRad) {
    angleRad = normalizeAngle(angleRad);
    if (angleRad > Math.PI) {
        angleRad -= C.RADIANS_IN_CIRCLE;
    }
    return angleRad;
}

export function normalizeAngleDegrees(angleDeg) {
    while (angleDeg < 0) angleDeg += C.DEGREES_IN_CIRCLE;
    while (angleDeg >= C.DEGREES_IN_CIRCLE) angleDeg -= C.DEGREES_IN_CIRCLE;
    return angleDeg;
}

export function getLineCircleIntersection(line, circle) {
    const { p1, p2 } = line;
    const { center, radius } = circle;
    const d = { x: p2.x - p1.x, y: p2.y - p1.y };
    const f = { x: p1.x - center.x, y: p1.y - center.y };
    const a = d.x * d.x + d.y * d.y;
    const b = 2 * (f.x * d.x + f.y * d.y);
    const c = f.x * f.x + f.y * f.y - radius * radius;
    let discriminant = b * b - 4 * a * c;

    if (discriminant < 0) return [];

    discriminant = Math.sqrt(discriminant);
    const t1 = (-b - discriminant) / (2 * a);
    const t2 = (-b + discriminant) / (2 * a);

    return [
        { x: p1.x + t1 * d.x, y: p1.y + t1 * d.y },
        { x: p1.x + t2 * d.x, y: p1.y + t2 * d.y }
    ];
}

export function getLineLineIntersection(line1, line2) {
    const p1 = line1.p1, p2 = line1.p2, p3 = line2.p1, p4 = line2.p2;
    const den = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
    if (Math.abs(den) < C.GEOMETRY_CALCULATION_EPSILON) return null;
    const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / den;
    const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / den;
    
    if (u >= 0 && u <= 1) {
        return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
    }
    return null;
}

export function simplifySquareRoot(n) {
    if (n < 0 || !Number.isInteger(n)) return [null, null];
    if (n === 0) return [0, 1];
    
    let coefficient = 1;
    let radicand = n;

    for (let i = 2; i * i <= radicand; i++) {
        while (radicand % (i * i) === 0) {
            radicand /= (i * i);
            coefficient *= i;
        }
    }

    return [coefficient, radicand];
}

export function formatSimplifiedRoot(coeff, radicand, symbol = '') {
    const symString = symbol ? `\\${symbol}` : '';

    if (radicand === 1) {
        if (coeff === 1 && symbol) return symString;
        return `${coeff}${symString}`;
    }
    if (coeff === 1) {
        return `\\sqrt{${radicand}}${symString}`;
    }
    return `${coeff}\\sqrt{${radicand}}${symString}`;
}

export function distance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

export function formatFraction(decimal, tolerance = C.FRACTION_FORMAT_TOLERANCE, maxDisplayDenominator = C.FRACTION_FORMAT_MAX_DENOMINATOR) {
    if (Math.abs(decimal) < C.ZERO_TOLERANCE) return "0";
    const originalSign = decimal < 0 ? "-" : "";
    const absDecimal = Math.abs(decimal);

    if (Math.abs(absDecimal - Math.round(absDecimal)) < tolerance) {
        const rounded = Math.round(absDecimal);
        return originalSign + rounded.toString();
    }

    const fractions = [
        [1,2],[1,3],[2,3],[1,4],[3,4],[1,5],[2,5],[3,5],[4,5],[1,6],[5,6],
        [1,8],[3,8],[5,8],[7,8],[1,10],[3,10],[7,10],[9,10],
        [1,12],[5,12],[7,12],[11,12],[1,16],[3,16],[5,16],[7,16],[9,16],[11,16],[13,16],[15,16]
    ];

    for (const [num, den] of fractions) {
        if (den <= maxDisplayDenominator) {
            if (Math.abs(absDecimal - num/den) < tolerance) {
                return originalSign + `${num}/${den}`;
            }
        }
    }

    for (let currentDen = 1; currentDen <= maxDisplayDenominator; currentDen++) {
        const currentNum = Math.round(absDecimal * currentDen);
        if (currentNum === 0 && absDecimal > C.ZERO_TOLERANCE) continue;
        if (Math.abs(absDecimal - currentNum / currentDen) < tolerance / currentDen) {
            const common = gcd(currentNum, currentDen);
            const n = currentNum/common;
            const d = currentDen/common;
            if (d === 1) return originalSign + `${n}`;
            return originalSign + `${n}/${d}`;
        }
    }
    let fixedPrecision = 2;
        if (absDecimal < 0.01) fixedPrecision = 3;
    else if (absDecimal < 0.1)  fixedPrecision = 2;
    else if (absDecimal < 10)   fixedPrecision = 1;
    else                        fixedPrecision = 0;
    
    return originalSign + absDecimal.toFixed(fixedPrecision);
}

export function isVertexInPolygon(vertex, vertices) {
    if (vertices.length < 3) return false;

    const x = vertex.x;
    const y = vertex.y;
    let inside = false;

    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        const xi = vertices[i].x;
        const yi = vertices[i].y;
        const xj = vertices[j].x;
        const yj = vertices[j].y;

        // Check if the point is on a vertex of the polygon
        if ((xi === x && yi === y)) {
            return true;
        }

        // Check if the point is on a horizontal or vertical edge
        if (yi === yj && yi === y && x >= Math.min(xi, xj) && x <= Math.max(xi, xj)) {
            return true; // On a horizontal edge
        }
        if (xi === xj && xi === x && y >= Math.min(yi, yj) && y <= Math.max(yi, yj)) {
            return true; // On a vertical edge
        }

        // Standard ray-casting intersection test, which now correctly handles non-horizontal edges
        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) {
            inside = !inside;
        }
    }

    return inside;
}

export function applyDirectionalProjection(vertex, center, startVector) {
    const vec = { x: vertex.x - center.x, y: vertex.y - center.y };
    const axis_dist = Math.hypot(startVector.x, startVector.y);
    const axis_norm = { x: startVector.x / axis_dist, y: startVector.y / axis_dist };
    const parallel_dist = vec.x * axis_norm.x + vec.y * axis_norm.y;
    const perp_vec = { x: vec.x - parallel_dist * axis_norm.x, y: vec.y - parallel_dist * axis_norm.y };
    
    return {
        x: center.x + perp_vec.x,
        y: center.y + perp_vec.y
    };
}

export function parseColor(colorString) {
    if (!colorString || typeof colorString !== 'string') {
        return { r: 255, g: 255, b: 255, a: 1.0 };
    }
    
    if (colorString.startsWith('rgba(')) {
        const match = colorString.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        if (match) {
            return {
                r: Math.max(0, Math.min(255, parseInt(match[1]))),
                g: Math.max(0, Math.min(255, parseInt(match[2]))),
                b: Math.max(0, Math.min(255, parseInt(match[3]))),
                a: Math.max(0, Math.min(1, parseFloat(match[4])))
            };
        }
    }
    
    if (colorString.startsWith('rgb(')) {
        const match = colorString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (match) {
            return {
                r: Math.max(0, Math.min(255, parseInt(match[1]))),
                g: Math.max(0, Math.min(255, parseInt(match[2]))),
                b: Math.max(0, Math.min(255, parseInt(match[3]))),
                a: 1.0
            };
        }
    }
    
    if (colorString.startsWith('#')) {
        const hex = colorString.slice(1);
        if (hex.length === 6) {
            return {
                r: parseInt(hex.slice(0, 2), 16),
                g: parseInt(hex.slice(2, 4), 16),
                b: parseInt(hex.slice(4, 6), 16),
                a: 1.0
            };
        }
        if (hex.length === 3) {
            return {
                r: parseInt(hex[0] + hex[0], 16),
                g: parseInt(hex[1] + hex[1], 16),
                b: parseInt(hex[2] + hex[2], 16),
                a: 1.0
            };
        }
    }
    
    return { r: 255, g: 255, b: 255, a: 1.0 };
}

export function findCoordinateSystemElement(screenPos, face, dataToScreen) {
    const coordSystem = face.localCoordSystem;
    if (!coordSystem) return null;

    const centerScreen = dataToScreen(coordSystem.origin);
    const centerSelectRadius = C.COORD_SYSTEM_ELEMENT_SELECT_RADIUS;

    if (distance(screenPos, centerScreen) < centerSelectRadius) {
        return { face, type: 'center' };
    }

    const armSelectThreshold = C.COORD_SYSTEM_AXIS_SELECT_THRESHOLD;

    const xAxisEndGlobal = localToGlobal({ x: 1, y: 0 }, coordSystem);
    const xAxisScreenEnd = dataToScreen(xAxisEndGlobal);
    const closestOnX = getClosestPointOnLineSegment(screenPos, centerScreen, xAxisScreenEnd);
    if (closestOnX.distance < armSelectThreshold) {
        return { face, type: 'x_axis' };
    }

    const yAxisEndGlobal = localToGlobal({ x: 0, y: 1 }, coordSystem);
    const yAxisScreenEnd = dataToScreen(yAxisEndGlobal);
    const closestOnY = getClosestPointOnLineSegment(screenPos, centerScreen, yAxisScreenEnd);
    if (closestOnY.distance < armSelectThreshold) {
        return { face, type: 'y_axis' };
    }

    return null;
}

export function clampPointToPolygon(point, vertices) {
    if (isVertexInPolygon(point, vertices)) {
        return point;
    }
    
    let closestPoint = point;
    let minDistance = Infinity;
    
    // Check distance to each edge and find closest point
    for (let i = 0; i < vertices.length; i++) {
        const v1 = vertices[i];
        const v2 = vertices[(i + 1) % vertices.length];
        const edgeClosest = getClosestPointOnLineSegment(point, v1, v2);
        
        if (edgeClosest.distance < minDistance) {
            minDistance = edgeClosest.distance;
            closestPoint = { x: edgeClosest.x, y: edgeClosest.y };
        }
    }
    
    return closestPoint;
}

export function getClickedUIElement(screenPos, canvasUI, { isToolbarExpanded, isColorPaletteExpanded, isTransformPanelExpanded, isDisplayPanelExpanded, isVisibilityPanelExpanded }) {
    const isInside = (pos, rect) => {
        if (!rect) return false;
        return pos.x >= rect.x && pos.x <= rect.x + rect.width &&
               pos.y >= rect.y && pos.y <= rect.y + rect.height;
    };

    if (isColorPaletteExpanded) {
        for (const icon of (canvasUI.colorTargetIcons || [])) {
            if (isInside(screenPos, icon)) return { ...icon, type: 'colorTargetIcon' };
        }
        for (const swatch of (canvasUI.colorSwatches || [])) {
            if (isInside(screenPos, swatch)) return { ...swatch, type: 'colorSwatch' };
        }
        if (isInside(screenPos, canvasUI.applyColorsButton)) return { ...canvasUI.applyColorsButton, type: 'button' };
        if (isInside(screenPos, canvasUI.randomColorButton)) return { ...canvasUI.randomColorButton, type: 'button' };
        if (isInside(screenPos, canvasUI.removeColorButton)) return { ...canvasUI.removeColorButton, type: 'button' };
        if (isInside(screenPos, canvasUI.addColorButton)) return { ...canvasUI.addColorButton, type: 'button' };
    }

    if (isTransformPanelExpanded) {
        for (const icon of (canvasUI.transformIcons || [])) {
            if (isInside(screenPos, icon)) return { ...icon, type: 'transformIcon' };
        }
    }
    
    if (isDisplayPanelExpanded) {
        for (const icon of (canvasUI.displayIcons || [])) {
            if (isInside(screenPos, icon)) return { ...icon, type: 'displayIcon' };
        }
    }
    
    if (isVisibilityPanelExpanded) {
        for (const icon of (canvasUI.visibilityIcons || [])) {
            if (isInside(screenPos, icon)) return { ...icon, type: 'visibilityIcon' };
        }
    }

    if (isToolbarExpanded) {
        if (isInside(screenPos, canvasUI.colorToolButton)) return { ...canvasUI.colorToolButton, type: 'toolButton' };
        if (isInside(screenPos, canvasUI.transformToolButton)) return { ...canvasUI.transformToolButton, type: 'toolButton' };
        if (isInside(screenPos, canvasUI.displayToolButton)) return { ...canvasUI.displayToolButton, type: 'toolButton' };
        if (isInside(screenPos, canvasUI.visibilityToolButton)) return { ...canvasUI.visibilityToolButton, type: 'toolButton' };
        if (isInside(screenPos, canvasUI.themeToggleButton)) return { ...canvasUI.themeToggleButton, type: 'toolButton' };
    }

    if (isInside(screenPos, canvasUI.toolbarButton)) return { ...canvasUI.toolbarButton, type: 'menuButton' };

    return null;
}

export function normalize(v) {
    const mag = Math.hypot(v.x, v.y);
    if (mag === 0) return { x: 0, y: 0 };
    return { x: v.x / mag, y: v.y / mag };
}

export function getClosestPointOnLineSegment(p, a, b) {
    const abx = b.x - a.x;
    const aby = b.y - a.y;
    const acx = p.x - a.x;
    const acy = p.y - a.y;
    const lenSqAB = abx * abx + aby * aby;

    if (lenSqAB === 0) {
        return { x: a.x, y: a.y, distance: distance(p, a), onSegmentStrict: true, t: 0 };
    }
    let t = (acx * abx + acy * aby) / lenSqAB;
    const onSegmentStrict = t > C.ON_SEGMENT_STRICT_T_MIN && t < C.ON_SEGMENT_STRICT_T_MAX;
    const clampedT = Math.max(0, Math.min(1, t));
    const closestX = a.x + clampedT * abx;
    const closestY = a.y + clampedT * aby;
    const dist = distance(p, { x: closestX, y: closestY });
    return { x: closestX, y: closestY, distance: dist, onSegmentStrict: onSegmentStrict, t: clampedT };
}

export function getClosestPointOnLine(p, a, b) {
    const abx = b.x - a.x;
    const aby = b.y - a.y;
    const acx = p.x - a.x;
    const acy = p.y - a.y;
    const lenSqAB = abx * abx + aby * aby;

    if (lenSqAB === 0) {
        return { x: a.x, y: a.y, distance: distance(p, a) };
    }
    let t = (acx * abx + acy * aby) / lenSqAB;
    const closestX = a.x + t * abx;
    const closestY = a.y + t * aby;
    const dist = distance(p, { x: closestX, y: closestY });
    return { x: closestX, y: closestY, distance: dist };
}

export function findCircleFromPointsAndAngle(p1, p2, referenceAngle, referencePointForSide) {
    if (Math.abs(referenceAngle) < C.GEOMETRY_CALCULATION_EPSILON || Math.abs(referenceAngle - Math.PI) < C.GEOMETRY_CALCULATION_EPSILON) {
        return null;
    }

    const d = distance(p1, p2);
    const radius = Math.abs((d / 2) / Math.sin(referenceAngle));
    
    const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
    const h = Math.sqrt(Math.max(0, radius * radius - (d / 2) * (d / 2)));
    
    const perpVec = { x: -(p2.y - p1.y), y: p2.x - p1.x };
    const perpVecMag = Math.hypot(perpVec.x, perpVec.y);
    const perpVecNorm = { x: perpVec.x / perpVecMag, y: perpVec.y / perpVecMag };
    
    const center1 = { x: midPoint.x + h * perpVecNorm.x, y: midPoint.y + h * perpVecNorm.y };
    const center2 = { x: midPoint.x - h * perpVecNorm.x, y: midPoint.y - h * perpVecNorm.y };

    const crossProduct = (p2.x - p1.x) * (referencePointForSide.y - p1.y) - (p2.y - p1.y) * (referencePointForSide.x - p1.x);
    const crossProductCenter1 = (p2.x - p1.x) * (center1.y - p1.y) - (p2.y - p1.y) * (center1.x - p1.x);

    const center = (crossProduct * crossProductCenter1 > 0) ? center1 : center2;
    
    return { center, radius };
}

export function getMousePosOnCanvas(event, canvasElement) {
    const rect = canvasElement.getBoundingClientRect();
    return { x: event.clientX - rect.left, y: event.clientY - rect.top };
}

export function findFacesToSplit(vertexId1, vertexId2, allFaces, findVertexById) {
    const facesToSplit = [];
    
    allFaces.forEach(face => {
        if (!face.vertexIds || face.vertexIds.length < 3) return;
        
        const hasVertex1 = face.vertexIds.includes(vertexId1);
        const hasVertex2 = face.vertexIds.includes(vertexId2);
        
        
        if (hasVertex1 && hasVertex2) {
            const index1 = face.vertexIds.indexOf(vertexId1);
            const index2 = face.vertexIds.indexOf(vertexId2);
            const faceLength = face.vertexIds.length;
            
            const areAdjacent = 
                (index1 === (index2 + 1) % faceLength) || 
                (index2 === (index1 + 1) % faceLength);
            
            
            if (!areAdjacent) {
                facesToSplit.push(face);
            }
        }
    });
    
    return facesToSplit;
}

function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0;
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}

export function getCoordinateSystemSnapPosition(mouseDataPos, snapTargets, isShiftPressed, gridDisplayMode, lastGridState, lastAngularGridState) {
    if (!isShiftPressed) {
        return mouseDataPos;
    }
    
    let closestSnap = null;
    let minDistance = Infinity;
    
    if (snapTargets) {
        // Check vertex snaps
        snapTargets.vertices.forEach(vertex => {
            const dist = distance(mouseDataPos, vertex);
            if (dist < minDistance) {
                minDistance = dist;
                closestSnap = vertex;
            }
        });
        
        // Check edge midpoints
        snapTargets.edgeMidvertices.forEach(midpoint => {
            const dist = distance(mouseDataPos, midpoint);
            if (dist < minDistance) {
                minDistance = dist;
                closestSnap = midpoint;
            }
        });
        
        // Check other face centers
        snapTargets.faceCenters.forEach(center => {
            const dist = distance(mouseDataPos, center);
            if (dist < minDistance) {
                minDistance = dist;
                closestSnap = center;
            }
        });
    }
    
    // Check grid snaps
    if (gridDisplayMode && gridDisplayMode !== 'none' && lastGridState && lastGridState.interval1) {
        const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) 
            ? lastGridState.interval2 
            : lastGridState.interval1;
        
        const gridCandidates = getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true);
        gridCandidates.forEach(gridPoint => {
            const dist = distance(mouseDataPos, gridPoint);
            if (dist < minDistance) {
                minDistance = dist;
                closestSnap = gridPoint;
            }
        });
    }
    
    return closestSnap || mouseDataPos;
}

export function getAxisSnapAngle(mouseDataPos, origin, isShiftPressed, snapTargets, snapRadius = null) {
    const rawAngle = Math.atan2(mouseDataPos.y - origin.y, mouseDataPos.x - origin.x);
    
    if (!isShiftPressed || !snapTargets) {
        return { angle: rawAngle, edgeIndex: null, snapType: null, snapped: false, targetVertexId: null };
    }
    
    const snapThreshold = C.COORD_SYSTEM_AXIS_SNAP_THRESHOLD_RAD;
    let bestSnap = { angle: rawAngle, difference: Infinity, edgeIndex: null, snapType: null, targetVertexId: null };

    const priorities = {
        edge: 1,
        vertex_direction: 2,
        cardinal: 3
    };

    const checkSnap = (snapAngle, snapType, edgeIndex = null, targetVertexId = null) => {
        const normalizedSnap = normalizeAngleToPi(snapAngle);
        const diff = Math.abs(normalizeAngleToPi(rawAngle - normalizedSnap));

        if (diff < snapThreshold) {
            const newSnapPriority = priorities[snapType];
            const oldSnapPriority = bestSnap.snapType ? priorities[bestSnap.snapType] : Infinity;
            
            if (newSnapPriority < oldSnapPriority) {
                bestSnap = { angle: normalizedSnap, difference: diff, edgeIndex, snapType, targetVertexId };
            } else if (newSnapPriority === oldSnapPriority && diff < bestSnap.difference) {
                bestSnap = { angle: normalizedSnap, difference: diff, edgeIndex, snapType, targetVertexId };
            }
        }
    };

    // Check for snaps in order of priority (lower is better)
    
    // Priority 1: Edges
    if (snapTargets.edgeAngles) {
        snapTargets.edgeAngles.forEach((angle, edgeIndex) => {
            [angle, angle + Math.PI / 2, angle - Math.PI / 2, angle + Math.PI].forEach(checkAngle => {
                checkSnap(checkAngle, 'edge', edgeIndex);
            });
        });
    }

    // Priority 2: Vertices
    if (snapTargets.vertices) {
        snapTargets.vertices.forEach(vertex => {
            if (distance(origin, vertex) > C.GEOMETRY_CALCULATION_EPSILON) {
                const angleToVertex = Math.atan2(vertex.y - origin.y, vertex.x - origin.x);
                checkSnap(angleToVertex, 'vertex_direction', null, vertex.id);
            }
        });
    }

    // Priority 3: Cardinal Directions
    const cardinalAngles = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
    cardinalAngles.forEach(angle => checkSnap(angle, 'cardinal'));
    
    return {
        angle: bestSnap.angle,
        edgeIndex: bestSnap.edgeIndex,
        snapType: bestSnap.snapType,
        snapped: bestSnap.difference < Infinity,
        targetVertexId: bestSnap.targetVertexId
    };
}

export function getAxisScaleSnap(origin, axisAngle, snapTargets, face, findVertexById, currentScale = null, viewTransform = null, draggedAxisType = 'x_axis') {
    if (!currentScale || !viewTransform || !snapTargets.alignedEdgeInfo) {
        return { snapped: false };
    }
    
    const pixelSnapThreshold = C.COORD_SYSTEM_AXIS_SCALE_SNAP_THRESHOLD_PIXELS / viewTransform.scale;
    let snapCandidates = [];
    
    const { v1Id, v2Id } = snapTargets.alignedEdgeInfo;
    const v1 = findVertexById(v1Id);
    const v2 = findVertexById(v2Id);
    
    if (v1 && v2 && v1.type === 'regular' && v2.type === 'regular') {
        const edgeLength = distance(v1, v2);
        const fractions = [0.25, 1/3, 0.5, 2/3, 0.75, 1.0];
        
        fractions.forEach(frac => {
            const targetScale = edgeLength * frac;
            const scaleDifference = Math.abs(currentScale - targetScale);
            
            snapCandidates.push({
                scale: targetScale,
                distance: scaleDifference,
                type: 'edge_fraction',
                priority: frac === 0.5 ? 1 : (frac === 1.0 ? 2 : 3),
                fraction: frac
            });
        });
    }
    
    if (snapCandidates.length === 0) {
        return { snapped: false };
    }

    snapCandidates.sort((a, b) => {
        if (a.priority !== b.priority) return a.priority - b.priority;
        return a.distance - b.distance;
    });
    
    const closestSnap = snapCandidates.find(candidate => candidate.distance < pixelSnapThreshold);
    
    if (closestSnap) {
        return {
            snapped: true,
            scale: closestSnap.scale,
            snapType: 'edge_fraction',
            edgeFraction: closestSnap.fraction
        };
    }
    
    return { snapped: false };
}

export function getCoordinateSystemCenterSnap(mouseDataPos, snapTargets, gridDisplayMode, lastGridState, lastAngularGridState) {
    let bestSnap = null;
    let minDistance = Infinity;
    
    if (snapTargets) {
        // Check vertex snaps
        if (snapTargets.vertices) {
            snapTargets.vertices.forEach(vertex => {
                const dist = distance(mouseDataPos, vertex);
                if (dist < minDistance) {
                    minDistance = dist;
                    bestSnap = {
                        snapped: true,
                        snapPoint: vertex,
                        snapType: 'vertex',
                        vertexId: vertex.id
                    };
                }
            });
        }
        
        // Check edge midpoints
        if (snapTargets.edgeMidvertices) {
            snapTargets.edgeMidvertices.forEach(midpoint => {
                const dist = distance(mouseDataPos, midpoint);
                if (dist < minDistance) {
                    minDistance = dist;
                    bestSnap = {
                        snapped: true,
                        snapPoint: midpoint,
                        snapType: 'edge'
                    };
                }
            });
        }
        
        // Check other face centers
        if (snapTargets.faceCenters) {
            snapTargets.faceCenters.forEach(center => {
                const dist = distance(mouseDataPos, center);
                if (dist < minDistance) {
                    minDistance = dist;
                    bestSnap = {
                        snapped: true,
                        snapPoint: center,
                        snapType: 'faceCenter'
                    };
                }
            });
        }
    }
    
    // Check grid snaps
    if (gridDisplayMode && gridDisplayMode !== 'none' && lastGridState && lastGridState.interval1) {
        const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) 
            ? lastGridState.interval2 
            : lastGridState.interval1;
        
        const gridCandidates = getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true);
        gridCandidates.forEach(gridPoint => {
            const dist = distance(mouseDataPos, gridPoint);
            if (dist < minDistance) {
                minDistance = dist;
                bestSnap = {
                    snapped: true,
                    snapPoint: gridPoint,
                    snapType: 'grid'
                };
            }
        });
    }
    
    return bestSnap || { snapped: false };
}

export function invertGrayscaleValue(value) {
    if (Array.isArray(value)) {
        const [h, s, l] = rgbToHsl(value[0], value[1], value[2]);
        const invertedL = 1 - l;
        const [newR, newG, newB] = hslToRgb(h, s, invertedL);
        return [newR, newG, newB];
    }
    
    if (typeof value === 'string') {
        if (value.startsWith('rgba(')) {
            const match = value.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
            if (match) {
                const [, r, g, b, a] = match;
                const rVal = parseInt(r), gVal = parseInt(g), bVal = parseInt(b);
                const [h, s, l] = rgbToHsl(rVal, gVal, bVal);
                const invertedL = 1 - l;
                const [newR, newG, newB] = hslToRgb(h, s, invertedL);
                return `rgba(${newR}, ${newG}, ${newB}, ${a})`;
            }
        }
        
        if (value.startsWith('#')) {
            if (value.length === 7) {
                const r = parseInt(value.slice(1, 3), 16);
                const g = parseInt(value.slice(3, 5), 16);
                const b = parseInt(value.slice(5, 7), 16);
                const [h, s, l] = rgbToHsl(r, g, b);
                const invertedL = 1 - l;
                const [newR, newG, newB] = hslToRgb(h, s, invertedL);
                return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
            }
        }
        
        if (value === 'white') return 'black';
        if (value === 'black') return 'white';
    }
    
    return value;
}

export function shoelaceArea(vertices) {
    let area = 0.0;
    const n = vertices.length;
    for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        area += vertices[i].x * vertices[j].y;
        area -= vertices[j].x * vertices[i].y;
    }
    return area / 2.0;
}

export function clamp(v, minv, maxv) {
    return Math.max(minv, Math.min(maxv, v));
}

export function computeAngle(prev, curr, next) {
    const u = { x: prev.x - curr.x, y: prev.y - curr.y };
    const v = { x: next.x - curr.x, y: next.y - curr.y };
    const dot = u.x * v.x + u.y * v.y;
    const mag_u = Math.hypot(u.x, u.y);
    const mag_v = Math.hypot(v.x, v.y);
    if (mag_u === 0 || mag_v === 0) return Math.PI;
    const cos_theta = dot / (mag_u * mag_v);
    return Math.acos(clamp(cos_theta, -1, 1));
}

export function triangulatePolygon(vertices) {
    let n = vertices.length;
    if (n < 3) return [];
    
    let area = shoelaceArea(vertices);
    let windingSign = area > 0 ? 1 : (area < 0 ? -1 : 1);
    
    const triangles = [];
    const indices = Array.from({length: n}, (_, i) => i);
    
    function isEar(i, verts, indices, windingSign) {
        const prevIdx = (i - 1 + indices.length) % indices.length;
        const currIdx = i;
        const nextIdx = (i + 1) % indices.length;
        
        const prev = verts[indices[prevIdx]];
        const curr = verts[indices[currIdx]];
        const next = verts[indices[nextIdx]];
        
        const dx1 = curr.x - prev.x;
        const dy1 = curr.y - prev.y;
        const dx2 = next.x - curr.x;
        const dy2 = next.y - curr.y;
        const cross = dx1 * dy2 - dy1 * dx2;
        if (cross * windingSign <= 0) return false;
        
        const tri = [prev, curr, next];
        for (let j = 0; j < indices.length; j++) {
            const idx = indices[j];
            if (idx === indices[prevIdx] || idx === indices[currIdx] || idx === indices[nextIdx]) continue;
            if (vertexInTriangle(verts[idx], tri)) return false;
        }
        return true;
    }
    
    function vertexInTriangle(pt, tri) {
        const [p1, p2, p3] = tri;
        const denom = (p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y);
        if (Math.abs(denom) < 1e-10) return false;
        
        const a = ((p2.y - p3.y) * (pt.x - p3.x) + (p3.x - p2.x) * (pt.y - p3.y)) / denom;
        const b = ((p3.y - p1.y) * (pt.x - p3.x) + (p1.x - p3.x) * (pt.y - p3.y)) / denom;
        const c = 1 - a - b;
        
        return a >= 0 && a <= 1 && b >= 0 && b <= 1 && c >= 0 && c <= 1;
    }
    
    while (indices.length > 3) {
        const ears = [];
        for (let i = 0; i < indices.length; i++) {
            if (isEar(i, vertices, indices, windingSign)) {
                const prevIdx = (i - 1 + indices.length) % indices.length;
                const currIdx = i;
                const nextIdx = (i + 1) % indices.length;
                const angle = computeAngle(vertices[indices[prevIdx]], vertices[indices[currIdx]], vertices[indices[nextIdx]]);
                ears.push({ index: i, angle });
            }
        }
        
        if (ears.length === 0) break;
        
        ears.sort((a, b) => a.angle - b.angle);
        
        const earToClip = ears[0];
        const i = earToClip.index;
        
        const prev = indices[(i - 1 + indices.length) % indices.length];
        const curr = indices[i];
        const next = indices[(i + 1) % indices.length];
        
        triangles.push([prev, curr, next]);
        indices.splice(i, 1);
    }
    
    if (indices.length === 3) {
        triangles.push([indices[0], indices[1], indices[2]]);
    }
    
    return triangles;
}

export function getCurrentTheme(activeThemeName, darkTheme) {
    if (activeThemeName === 'light') {
        return C.LIGHT_THEME;
    }
    return darkTheme;
}

export function hslToRgb(h, s, l) {
    let r, g, b;

    if (s === 0) {
        r = g = b = l;
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (6 * (2 / 3 - t));
            return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

export function formatSnapFactor(factor, symbol) {
    const fractionStr = formatFraction(factor, 0.001);
    const newSymbol = symbol === 'A' ? '\\theta' : (symbol === 'D' ? '\\delta' : symbol);
    
    if (fractionStr === "0") return `0${newSymbol}`;
    if (fractionStr === "1") return newSymbol;
    if (fractionStr === "-1") return `-${newSymbol}`;

    if (fractionStr.endsWith("/1")) {
        return `${fractionStr.slice(0, -2)}${newSymbol}`;
    }

    if (fractionStr.includes('/')) {
        let sign = '';
        let workStr = fractionStr;
        if (workStr.startsWith('-')) {
            sign = '-';
            workStr = workStr.substring(1);
        }

        const parts = workStr.split('/');
        const num = parts[0];
        const den = parts[1];
        
        if (num === "1") return `${sign}\\frac{1}{${den}}${newSymbol}`;
        return `${sign}\\frac{${num}}{${den}}${newSymbol}`;
    }
    return `${fractionStr}${newSymbol}`;
}

export function applyTransformToVertex(vertex, center, rotation, scale, directionalScale, startVector) {
    const pointVector = { x: vertex.x - center.x, y: vertex.y - center.y };

    if (directionalScale) {
        const startDist = Math.hypot(startVector.x, startVector.y);
        if (startDist > C.GEOMETRY_CALCULATION_EPSILON) {
            const startNormalized = { x: startVector.x / startDist, y: startVector.y / startDist };

            const parallelComponent = (pointVector.x * startNormalized.x + pointVector.y * startNormalized.y);
            const perpVector = {
                x: pointVector.x - parallelComponent * startNormalized.x,
                y: pointVector.y - parallelComponent * startNormalized.y
            };

            const scaledParallelComponent = parallelComponent * scale;

            const newVector = {
                x: scaledParallelComponent * startNormalized.x + perpVector.x,
                y: scaledParallelComponent * startNormalized.y + perpVector.y
            };

            return { x: center.x + newVector.x, y: center.y + newVector.y };
        }
        return { x: vertex.x, y: vertex.y };
    } else {
        let transformedVector = { ...pointVector };

        transformedVector.x *= scale;
        transformedVector.y *= scale;

        const x = transformedVector.x;
        const y = transformedVector.y;
        transformedVector.x = x * Math.cos(rotation) - y * Math.sin(rotation);
        transformedVector.y = x * Math.sin(rotation) + y * Math.cos(rotation);

        return { x: center.x + transformedVector.x, y: center.y + transformedVector.y };
    }
}

export function calculateIncenter(vertices) {
    if (vertices.length < 3) return null;

    if (vertices.length === 3) {
        const [a, b, c] = vertices;
        const sideA = distance(b, c);
        const sideB = distance(a, c);
        const sideC = distance(a, b);
        const perimeter = sideA + sideB + sideC;
        if (perimeter < C.GEOMETRY_CALCULATION_EPSILON) return null;
        const incenterX = (sideA * a.x + sideB * b.x + sideC * c.x) / perimeter;
        const incenterY = (sideA * a.y + sideB * b.y + sideC * c.y) / perimeter;
        const area = Math.abs((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y)) / 2;
        const inradius = (2 * area) / perimeter;
        return {
            center: { x: incenterX, y: incenterY },
            radius: inradius
        };
    }

    return findLargestInscribedCircle(vertices);
}


export function getCorrectionVectorForCircleSnap(point, circleCenter, circleRadius) {
    const vectorToPoint = { x: point.x - circleCenter.x, y: point.y - circleCenter.y };
    const mag = Math.hypot(vectorToPoint.x, vectorToPoint.y);

    if (mag < C.GEOMETRY_CALCULATION_EPSILON) {
        return { x: 0, y: 0 };
    }

    const snappedPoint = {
        x: circleCenter.x + (vectorToPoint.x / mag) * circleRadius,
        y: circleCenter.y + (vectorToPoint.y / mag) * circleRadius
    };
    
    return {
        x: snappedPoint.x - point.x,
        y: snappedPoint.y - point.y
    };
}

export function getBestFractionalSnap(pointOnEdge, p1, p2) {
    const bestFraction = C.ALT_SNAP_FRACTIONS.reduce((best, current) => {
        return Math.abs(current - pointOnEdge.t) < Math.abs(best - pointOnEdge.t) ? current : best;
    });
    
    const finalPoint = {
        x: p1.x + bestFraction * (p2.x - p1.x),
        y: p1.y + bestFraction * (p2.y - p1.y)
    };
    
    return {
        fraction: bestFraction,
        point: finalPoint
    };
}

export function findLargestInscribedCircle(vertices) {
    if (vertices.length < 3) return null;

    let centroid = {
        x: vertices.reduce((sum, v) => sum + v.x, 0) / vertices.length,
        y: vertices.reduce((sum, v) => sum + v.y, 0) / vertices.length
    };

    if (!isVertexInPolygon(centroid, vertices)) {
        centroid.x = (vertices[0].x + vertices[1].x + vertices[2].x) / 3;
        centroid.y = (vertices[0].y + vertices[1].y + vertices[2].y) / 3;
    }

    let bestCenter = centroid;
    let bestRadius = distanceToPolygonEdges(centroid, vertices);

    for (let iter = 0; iter < C.INSCRIBED_CIRCLE_ITERATIONS; iter++) {
        let improved = false;
        const stepSize = bestRadius * C.INSCRIBED_CIRCLE_STEP_FACTOR;

        const directions = [
            { x: stepSize, y: 0 }, { x: -stepSize, y: 0 },
            { x: 0, y: stepSize }, { x: 0, y: -stepSize },
            { x: stepSize * Math.SQRT1_2, y: stepSize * Math.SQRT1_2 },
            { x: -stepSize * Math.SQRT1_2, y: stepSize * Math.SQRT1_2 },
            { x: stepSize * Math.SQRT1_2, y: -stepSize * Math.SQRT1_2 },
            { x: -stepSize * Math.SQRT1_2, y: -stepSize * Math.SQRT1_2 }
        ];

        for (const dir of directions) {
            const testPoint = {
                x: bestCenter.x + dir.x,
                y: bestCenter.y + dir.y
            };

            if (isVertexInPolygon(testPoint, vertices)) {
                const testRadius = distanceToPolygonEdges(testPoint, vertices);
                if (testRadius > bestRadius) {
                    bestCenter = testPoint;
                    bestRadius = testRadius;
                    improved = true;
                }
            }
        }

        if (!improved) break;
    }

    return {
        center: bestCenter,
        radius: Math.max(bestRadius, C.GEOMETRY_CALCULATION_EPSILON)
    };
}

export function distanceToPolygonEdges(point, vertices) {
    let minDistance = Infinity;
    for (let i = 0; i < vertices.length; i++) {
        const v1 = vertices[i];
        const v2 = vertices[(i + 1) % vertices.length];
        const edgeDistance = distancePointToLineSegment(point, v1, v2);
        minDistance = Math.min(minDistance, edgeDistance);
    }
    return minDistance;
}

export function distancePointToLineSegment(point, lineStart, lineEnd) {
    return getClosestPointOnLineSegment(point, lineStart, lineEnd).distance;
}

export function updateFaceLocalCoordinateSystems(allFaces, findPointById) {
    allFaces.forEach(face => {
        if (!face.localCoordSystem) {
            face.localCoordSystem = createFaceLocalCoordinateSystem(face, findPointById);
        } else if (!face.localCoordSystem.isCustom) {
            // Recalculate if not manually positioned
            const newSystem = createFaceLocalCoordinateSystem(face, findPointById);
            if (newSystem) {
                face.localCoordSystem.origin = newSystem.origin;
                face.localCoordSystem.scale = newSystem.scale;
            }
        }
    });
}

function walkMinimalFaceDirected(startVertex, secondVertex, adjacencyMap) {
    const facePath = [startVertex];
    let prevNode = startVertex;
    let currentNode = secondVertex;
    
    const maxSteps = adjacencyMap.size + 2;
    for (let stepCount = 0; stepCount < maxSteps; stepCount++) {
        facePath.push(currentNode);

        if (currentNode === startVertex) {
            facePath.pop();
            return facePath;
        }

        const neighbors = adjacencyMap.get(currentNode);
        if (!neighbors || neighbors.length < 1) return null; 

        const prevNodeIndex = neighbors.indexOf(prevNode);
        if (prevNodeIndex === -1) return null;

        const nextNodeIndex = (prevNodeIndex + 1) % neighbors.length;
        const nextNode = neighbors[nextNodeIndex];
        
        prevNode = currentNode;
        currentNode = nextNode;
    }
    return null;
}

function filterCompositeFaces(allFaces, allEdges, findPointById) {
    if (allFaces.length <= 1) return allFaces;

    const edgeSet = new Set(allEdges.map(edge => [edge.id1, edge.id2].sort().join('_')));

    return allFaces.filter(face => {
        const faceVertexIds = face.vertexIds;
        if (faceVertexIds.length < 3) return false;

        for (let i = 0; i < faceVertexIds.length; i++) {
            for (let j = i + 2; j < faceVertexIds.length; j++) {
                if (i === 0 && j === faceVertexIds.length - 1) continue;

                const v1 = faceVertexIds[i];
                const v2 = faceVertexIds[j];
                const edgeKey = [v1, v2].sort().join('_');
                
                if (edgeSet.has(edgeKey)) {
                    return false;
                }
            }
        }
        return true;
    });
}

export function detectClosedPolygons(allEdges, findPointById) {
    const adjacencyMap = new Map();
    const vertices = new Map();

    allEdges.forEach(edge => {
        const p1 = findPointById(edge.id1);
        const p2 = findPointById(edge.id2);
        if (!p1 || !p2 || p1.type !== 'regular' || p2.type !== 'regular') return;
        if (!vertices.has(p1.id)) vertices.set(p1.id, p1);
        if (!vertices.has(p2.id)) vertices.set(p2.id, p2);
        if (!adjacencyMap.has(edge.id1)) adjacencyMap.set(edge.id1, []);
        if (!adjacencyMap.has(edge.id2)) adjacencyMap.set(edge.id2, []);
        adjacencyMap.get(edge.id1).push(edge.id2);
        adjacencyMap.get(edge.id2).push(edge.id1);
    });

    for (const [vertexId, neighbors] of adjacencyMap.entries()) {
        const centerPoint = vertices.get(vertexId);
        if (!centerPoint) continue;
        neighbors.sort((a, b) => {
            const pA = vertices.get(a);
            const pB = vertices.get(b);
            if (!pA || !pB) return 0;
            const angleA = Math.atan2(pA.y - centerPoint.y, pA.x - centerPoint.x);
            const angleB = Math.atan2(pB.y - centerPoint.y, pB.x - centerPoint.x);
            return angleA - angleB;
        });
    }

    const allPossibleFaces = [];
    const processedDirectedEdges = new Set();
    
    for (const [startVertex, neighbors] of adjacencyMap.entries()) {
        for (const nextVertex of neighbors) {
            const directedEdgeKey = `${startVertex}->${nextVertex}`;
            if (processedDirectedEdges.has(directedEdgeKey)) continue;

            const facePath = walkMinimalFaceDirected(startVertex, nextVertex, adjacencyMap);
            
            if (facePath && facePath.length >= 3) {
                const uniqueVertices = new Set(facePath);
                if (uniqueVertices.size === facePath.length) {
                    for (let i = 0; i < facePath.length; i++) {
                        const v1 = facePath[i];
                        const v2 = facePath[(i + 1) % facePath.length];
                        processedDirectedEdges.add(`${v1}->${v2}`);
                    }
                    
                    const newFace = { vertexIds: facePath };
                    newFace.id = getFaceId(newFace);
                    allPossibleFaces.push(newFace);
                }
            }
        }
    }

    const principleFaces = filterCompositeFaces(allPossibleFaces, allEdges, findPointById);

    const uniqueFaces = [];
    const seenFaceVertexSets = new Set();
    
    principleFaces.forEach(face => {
        const sortedVertexIds = [...face.vertexIds].sort().join('_');
        if (!seenFaceVertexSets.has(sortedVertexIds)) {
            uniqueFaces.push(face);
            seenFaceVertexSets.add(sortedVertexIds);
        }
    });

    return uniqueFaces;
}

export function createEdge(v1, v2, gridInterval, getColorForTarget) {
    const newEdge = { id1: v1.id, id2: v2.id };

    const deltaX = v1.x - v2.x;
    const deltaY = v1.y - v2.y;
    const dx_grid_float = deltaX / gridInterval;
    const dy_grid_float = deltaY / gridInterval;
    const epsilon = 1e-5;

    const isGridVector = gridInterval &&
        Math.abs(dx_grid_float - Math.round(dx_grid_float)) < epsilon &&
        Math.abs(dy_grid_float - Math.round(dy_grid_float)) < epsilon;

    if (isGridVector) {
        newEdge.labelMode = 'exact';
        const dx_grid = Math.round(dx_grid_float);
        const dy_grid = Math.round(dy_grid_float);
        newEdge.exactValue = {
            g2gSquaredSum: dx_grid * dx_grid + dy_grid * dy_grid,
            gridInterval: gridInterval
        };
    } else {
        newEdge.labelMode = 'decimal';
    }
    
    newEdge.color = getColorForTarget(C.COLOR_TARGET_EDGE);
    return newEdge;
}

export function detectFacesFromNewEdge(newEdge, allEdges, findPointById, deletedFaceIds = new Set()) {
    // Get all possible faces with the current edge set
    const allPossibleFaces = detectClosedPolygons(allEdges, findPointById);
    
    // Create a set of edges before adding the new edge
    const edgesWithoutNew = allEdges.filter(e => 
        !(e.id1 === newEdge.id1 && e.id2 === newEdge.id2) && 
        !(e.id1 === newEdge.id2 && e.id2 === newEdge.id1)
    );
    
    // Get faces that existed before
    const facesBefore = detectClosedPolygons(edgesWithoutNew, findPointById);
    const faceIdsBefore = new Set(facesBefore.map(f => `face_${[...f.vertexIds].sort().join('_')}`));
    
    // Return only the new faces that weren't there before and aren't blacklisted
    const newFaces = allPossibleFaces.filter(face => {
        if (!face.vertexIds || face.vertexIds.length < 3) return false;
        
        const faceId = `face_${[...face.vertexIds].sort().join('_')}`;
        
        // Skip if blacklisted or existed before
        if (deletedFaceIds.has(faceId) || faceIdsBefore.has(faceId)) return false;
        
        return true;
    });
    
    return newFaces.map(face => ({
        ...face,
        id: `face_${[...face.vertexIds].sort().join('_')}`
    }));
}

export function findClosestUIElement(pos, elements) {
    let closest = null;
    let minDist = Infinity;
    elements.forEach(el => {
        if (!el) return;
        const dist = Math.abs(pos.x - (el.x + el.width / 2));
        if (dist < minDist && dist < (el.width / 2 + C.UI_BUTTON_PADDING)) {
            minDist = dist;
            closest = el;
        }
    });
    return closest;
}

export function convertColorToColormapFormat(colormapData) {
    // Handle colormap selector format (uses 'points' instead of 'vertices')
    if (colormapData && colormapData.points) {
        const processedVertices = colormapData.points.map(p => ({
            pos: p.pos,
            color: Array.isArray(p.color) ? p.color : [p.color.r || 0, p.color.g || 0, p.color.b || 0],
            alpha: p.alpha !== undefined ? p.alpha : 1.0
        }));
        
        if (processedVertices.length === 1) {
            const singlePoint = processedVertices[0];
            const colorValue = (singlePoint.alpha !== undefined && singlePoint.alpha < 1)
                ? `rgba(${singlePoint.color.join(',')},${singlePoint.alpha})`
                : `rgb(${singlePoint.color.join(',')})`;
            return { type: 'color', value: colorValue };
        }
        
        return {
            type: 'colormap',
            vertices: processedVertices,
            isCyclic: colormapData.isCyclic === true
        };
    }
    
    if (colormapData && colormapData.vertices && colormapData.vertices.length === 1) {
        const singlePoint = colormapData.vertices[0];
        const colorValue = (singlePoint.alpha !== undefined && singlePoint.alpha < 1)
            ? `rgba(${singlePoint.color.join(',')},${singlePoint.alpha})`
            : `rgb(${singlePoint.color.join(',')})`;
        return { type: 'color', value: colorValue };
    } else if (colormapData && colormapData.vertices) {
        const processedVertices = colormapData.vertices.map(p => ({
            ...p,
            alpha: p.alpha !== undefined ? p.alpha : 1.0
        }));
        return {
            type: 'colormap',
            vertices: processedVertices,
            isCyclic: colormapData.isCyclic === true
        };
    }
    return colormapData;
}

export function sampleColormap(colormapItem, t) {
    if (!colormapItem || colormapItem.type !== 'colormap' || !colormapItem.vertices) {
        return '#ffffff';
    }

    const vertices = colormapItem.vertices;
    if (vertices.length === 0) return '#ffffff';
    if (vertices.length === 1) {
        const p = vertices[0];
        const alpha = p.alpha !== undefined ? p.alpha : 1.0;
        return `rgba(${p.color.join(',')},${alpha})`;
    }

    // Clamp t to [0, 1]
    t = Math.max(0, Math.min(1, t));

    // Find the two vertices to interpolate between
    let leftPoint = vertices[0];
    let rightPoint = vertices[vertices.length - 1];

    for (let i = 0; i < vertices.length - 1; i++) {
        if (t >= vertices[i].pos && t <= vertices[i + 1].pos) {
            leftPoint = vertices[i];
            rightPoint = vertices[i + 1];
            break;
        }
    }

    // Interpolate between the two vertices
    const range = rightPoint.pos - leftPoint.pos;
    const localT = range > 0 ? (t - leftPoint.pos) / range : 0;

    const r = Math.round(leftPoint.color[0] + (rightPoint.color[0] - leftPoint.color[0]) * localT);
    const g = Math.round(leftPoint.color[1] + (rightPoint.color[1] - leftPoint.color[1]) * localT);
    const b = Math.round(leftPoint.color[2] + (rightPoint.color[2] - leftPoint.color[2]) * localT);

    const leftAlpha = leftPoint.alpha !== undefined ? leftPoint.alpha : 1.0;
    const rightAlpha = rightPoint.alpha !== undefined ? rightPoint.alpha : 1.0;
    const alpha = leftAlpha + (rightAlpha - leftAlpha) * localT;

    return `rgba(${r},${g},${b},${alpha})`;
}

export function createFaceLocalCoordinateSystem(face, findPointById) {
    const vertices = face.vertexIds
        .map(id => findPointById(id))
        .filter(p => p && p.type === 'regular');
    
    if (vertices.length < 3) return null;
    
    const incircle = calculateIncenter(vertices);
    if (!incircle) return null;
    
    return {
        origin: { ...incircle.center },
        angle: 0,
        scale: incircle.radius,
        isCustom: false,
        showCoordSystem: false
    };
}
export function globalToLocal(globalPoint, coordSystem) {
    if (!coordSystem) return globalPoint;
    const translated = {
        x: globalPoint.x - coordSystem.origin.x,
        y: globalPoint.y - coordSystem.origin.y
    };
    const cos = Math.cos(-coordSystem.angle);
    const sin = Math.sin(-coordSystem.angle);
    const rotated = {
        x: translated.x * cos - translated.y * sin,
        y: translated.x * sin + translated.y * cos
    };
    if (coordSystem.scale === 0) return { x: 0, y: 0 };
    return {
        x: rotated.x / coordSystem.scale,
        y: rotated.y / coordSystem.scale
    };
}

export function findNeighbors(vertexId, allEdges) {
    const neighbors = new Set();
    allEdges.forEach(edge => {
        if (edge.id1 === vertexId) {
            neighbors.add(edge.id2);
        } else if (edge.id2 === vertexId) {
            neighbors.add(edge.id1);
        }
    });
    return Array.from(neighbors);
}

export function localToGlobal(localPoint, coordSystem) {
    if (!coordSystem) return localPoint;

    const scaled = {
        x: localPoint.x * coordSystem.scale,
        y: localPoint.y * coordSystem.scale
    };

    const cos = Math.cos(coordSystem.angle);
    const sin = Math.sin(coordSystem.angle);
    const rotated = {
        x: scaled.x * cos - scaled.y * sin,
        y: scaled.x * sin + scaled.y * cos
    };
    return {
        x: rotated.x + coordSystem.origin.x,
        y: rotated.y + coordSystem.origin.y
    };
}

export function getPerpendicularBisector(p1, p2) {
    const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
    const perpVector = { x: -(p2.y - p1.y), y: p2.x - p1.x };
    return {
        p1: midPoint,
        p2: {
            x: midPoint.x + perpVector.x,
            y: midPoint.y + perpVector.y
        }
    };
}

export function getCircleCircleIntersection(c1, c2) {
    const d = distance(c1.center, c2.center);

    if (d > c1.radius + c2.radius || d < Math.abs(c1.radius - c2.radius) || d === 0) {
        return [];
    }

    const a = (c1.radius * c1.radius - c2.radius * c2.radius + d * d) / (2 * d);
    const h = Math.sqrt(Math.max(0, c1.radius * c1.radius - a * a));
    const p2x = c1.center.x + a * (c2.center.x - c1.center.x) / d;
    const p2y = c1.center.y + a * (c2.center.y - c1.center.y) / d;

    const p3x_offset = h * (c2.center.y - c1.center.y) / d;
    const p3y_offset = h * (c2.center.x - c1.center.x) / d;

    const pA = { x: p2x + p3x_offset, y: p2y - p3y_offset };
    const pB = { x: p2x - p3x_offset, y: p2y + p3y_offset };

    if (h === 0) return [pA];
    return [pA, pB];
}

function getLineSegmentIntersection(p1, p2, p3, p4) {
    const den = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
    if (Math.abs(den) < C.GEOMETRY_CALCULATION_EPSILON) {
        return null; // Lines are parallel or collinear
    }

    const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / den;
    const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / den;

    // Check if intersection occurs strictly within both line segments (not at endpoints)
    if (t > C.GEOMETRY_CALCULATION_EPSILON && t < 1 - C.GEOMETRY_CALCULATION_EPSILON &&
        u > C.GEOMETRY_CALCULATION_EPSILON && u < 1 - C.GEOMETRY_CALCULATION_EPSILON) {
        return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
    }

    return null;
}

export function areVerticesContainedInPolygon(verticesToCheck, boundaryVertices) {
    if (!verticesToCheck || !boundaryVertices || verticesToCheck.length === 0 || boundaryVertices.length < 3) {
        return false;
    }

    for (const vertex of verticesToCheck) {
        // First, check if the vertex is on the boundary of the parent polygon.
        // If it is, it's not strictly inside, so we return false.
        for (let i = 0; i < boundaryVertices.length; i++) {
            const p1 = boundaryVertices[i];
            const p2 = boundaryVertices[(i + 1) % boundaryVertices.length];
            if (distancePointToLineSegment(vertex, p1, p2) < C.GEOMETRY_CALCULATION_EPSILON) {
                return false; // On the boundary, so not strictly contained.
            }
        }

        // If it's not on the boundary, check if it's inside using the standard algorithm.
        if (!isVertexInPolygon(vertex, boundaryVertices)) {
            return false; // Not on boundary and not inside.
        }
    }
    
    // All vertices are strictly inside.
    return true;
}

export function doGraphEdgesIntersectPolygon(childEdges, parentBoundaryVertices, findVertexById) {
    const parentEdges = [];
    for (let i = 0; i < parentBoundaryVertices.length; i++) {
        parentEdges.push({
            p1: parentBoundaryVertices[i],
            p2: parentBoundaryVertices[(i + 1) % parentBoundaryVertices.length]
        });
    }

    for (const childEdge of childEdges) {
        const c1 = findVertexById(childEdge.id1);
        const c2 = findVertexById(childEdge.id2);
        if (!c1 || !c2) continue;

        for (const parentEdge of parentEdges) {
            if (getLineSegmentIntersection(c1, c2, parentEdge.p1, parentEdge.p2)) {
                // A proper intersection was found, meaning the child graph is not fully contained.
                return true;
            }
        }
    }

    return false;
}

export function getRaySegmentIntersection(rayOrigin, rayPoint, segP1, segP2) {
    const p1 = rayOrigin, p2 = rayPoint, p3 = segP1, p4 = segP2;
    const den = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
    if (Math.abs(den) < C.GEOMETRY_CALCULATION_EPSILON) return null;

    const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / den;
    const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / den;
    
    if (t >= -C.GEOMETRY_CALCULATION_EPSILON && u >= -C.GEOMETRY_CALCULATION_EPSILON && u <= 1 + C.GEOMETRY_CALCULATION_EPSILON) {
        return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
    }
    return null;
}

=== vite.config.js ===
import { defineConfig } from 'vite';
import { resolve } from 'path';

export default defineConfig({
  base: '/', // This is correct for custom domain
  resolve: {
    alias: {
      'colormap-selector': resolve(process.cwd(), 'node_modules/colormap-selector')
    }
  }
});


=== LLM Instructions ===
Now please just read the project and the rules for writing code and just wait for instructions.

Here are the rules:
1. DONT write comments, placeholders or docstrings if not explicitely told.
2. Write functions with the correct initial indentation so that if the function is indented so is your code that you write.
3. DO NOT USE NON-TERMINATED SPACES. MAKE SURE TO FOLLOW THIS! ITS SUPER IMPORTANT AND YOU SEEM TO BREAK IT, PLEASE!!!
4. For changes that require multiple replacements please tell me what to replace with what instead of rewriting large portions of text. You can use vscode valid regexp for instance.
5. For small functions less than 100 lines of code please rewrite the full function. For larger functions please only write complete control statements if/while/case.
6. Never omit/change working logic if not explicitely statet that it should be removed/change
7. DONT use the CANVAS TOOL where code is written in artifacts.
8. Write only functions that are new seperately from functions that needs updates.
9. Make sure to write what has been change where to place/what to replace for each code snippet.

So only confirm that you have read and then wait for instructions!
