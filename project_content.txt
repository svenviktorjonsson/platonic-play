=== Project Directory Structure ===
Root: C:\Users\viktor.jonsson\OneDrive - CellMax Technologies AB\Documents\Repositories\svenviktorjonsson\platonic-play
Relevant files and folders (excluding specified patterns):

.
├── constants.js
├── index.html
├── project_content.txt
├── readme.md
├── refactor.py
├── renderer.js
├── script.js
├── style.css
├── utils.js
├── write_content_to_file.py


=== File Contents ===

=== constants.js ===
// constants.js

export const THEMES = {
  dark: {
    // Page & Canvas
    background: '#1a1a1a',
    htmlBody: '#1e1e1e',

    // Grid & Axes
    grid: [136, 136, 136],
    axis: 'rgba(255, 255, 255, 1)',
    axisTickLabel: [255, 255, 255],

    // Geometry & Feedback
    defaultStroke: 'white',
    point: '#ffffff',
    frozenReference: 'rgba(240, 240, 130, 0.95)',
    feedbackDefault: [230, 230, 230],
    feedbackSnapped: 'rgba(240, 240, 130, 0.95)',
    geometryInfoText: 'rgba(255, 255, 255, 0.95)',
    geometryInfoTextSnapped: 'rgba(240, 240, 130, 0.95)',
    mouseCoords: 'rgba(255, 255, 255, 0.7)',

    // UI & Icons
    uiIcon: 'white',
    uiIconDefault: '#9CA3AF',
    uiIconSelected: '#F9FAFB',
    uiTextSelected: '#E0F2FE',
    uiTextDefault: '#D1D5DB',
    uiDefault: 'rgba(255, 255, 255, 0.8)',
    selectionGlow: '#4da6ff',
    activeCenterGlow: '#00ffff',
  },
  light: {
    // Page & Canvas
    background: '#f5f5f5',
    htmlBody: '#e7e5e4',

    // Grid & Axes
    grid: [203, 203, 203],
    axis: 'rgba(0, 0, 0, 1)',
    axisTickLabel: [0, 0, 0],

    // Geometry & Feedback
    defaultStroke: 'black',
    point: '#1f2937',
    frozenReference: 'rgba(217, 119, 6, 0.95)',
    feedbackDefault: [50, 50, 50],
    feedbackSnapped: 'rgba(217, 119, 6, 0.95)',
    geometryInfoText: 'rgba(0, 0, 0, 0.95)',
    geometryInfoTextSnapped: 'rgba(217, 119, 6, 0.95)',
    mouseCoords: 'rgba(0, 0, 0, 0.7)',

    // UI & Icons
    uiIcon: '#1f2937',
    uiIconDefault: '#4B5563',
    uiIconSelected: '#1f2937',
    uiTextSelected: '#1E40AF',
    uiTextDefault: '#374151',
    uiDefault: 'rgba(0, 0, 0, 0.8)',
    selectionGlow: '#2563EB',
    activeCenterGlow: '#0891B2',
  }
};


// --- GEOMETRY & DRAWING ---
export const POINT_RADIUS = 5;
export const CENTER_POINT_VISUAL_RADIUS = POINT_RADIUS * 2;
export const POINT_SELECT_RADIUS = 10;
export const LINE_WIDTH = 2;
export const GRID_LINEWIDTH = 1;
export const DASH_PATTERN = [6, 6];
export const DASH_PATTERN_SMALL = [3, 3];
export const SELECTED_INDICATOR_OFFSET = 3;
export const DEGREES_IN_CIRCLE = 360;
export const DEGREES_IN_HALF_CIRCLE = 180;
export const DEGREES_IN_QUADRANT = 90;
export const RADIANS_IN_CIRCLE = 2 * Math.PI;
export const MIN_ALPHA_FOR_DRAWING = 0.01;
export const TRIANGULAR_GRID_Y_STEP_FACTOR = Math.sqrt(3) / 2;
export const POLAR_TO_LINE_TRANSITION_RADIUS_FACTOR = 400;
export const ORIGIN_TICK_ANGLE_RAD = Math.PI / 3;
export const AXIS_MAJOR_TICK_SCALE_FACTOR = 1.5;
export const AXIS_ARROW_ANGLE_RAD = Math.PI / 6;
export const MAJOR_TICK_LINE_WIDTH = 1.5;
export const HELPER_LINE_DASH_PATTERN = [2, 3];
export const REF_LINE_DASH_PATTERN = [1, 3];

// --- INTERACTION ---
export const EDGE_ID_DELIMITER = '_EDGE_';
export const DOUBLE_CLICK_MS = 300;
export const DRAG_THRESHOLD = 3;
export const EDGE_CLICK_THRESHOLD = 7;
export const MIN_SCALE_VALUE = 1e-20;
export const ZOOM_FACTOR = 1.15;
export const KEYBOARD_ZOOM_FACTOR = 1.15;
export const ANGLE_SNAP_THRESHOLD_RAD = Math.PI / 24;
export const ON_SEGMENT_STRICT_T_MIN = 1e-5;
export const ON_SEGMENT_STRICT_T_MAX = 1 - 1e-5;
export const MIN_TRANSFORM_ACTION_THRESHOLD = 0.001;
export const BISECTOR_LINE_EXTENSION_FACTOR = 100000;
export const GRID_SNAP_THRESHOLD_FACTOR = 0.8;

// --- AXES & TICKS ---
export const AXIS_LINE_WIDTH = 1.5;
export const AXIS_TICK_SIZE = 4;
export const AXIS_TICK_LABEL_ALPHA = 0.9;
export const AXIS_NAME_FONT_SIZE = 24;
export const AXIS_TICK_FONT_SIZE = 10;
export const AXIS_LABEL_OFFSET = 8;
export const AXIS_LABEL_PADDING = 20;
export const AXIS_ARROW_SIZE = 12;
export const INITIAL_POLAR_REL_RADIUS = 0.309;
export const X_AXIS_LABEL_DISTANCE = 5;
export const X_AXIS_LABEL_ARROW_DIST = 20;
export const Y_AXIS_LABEL_DISTANCE = 10;
export const Y_AXIS_LABEL_ARROW_DIST = 5;
export const POLAR_THETA_LABEL_DISTANCE = 20;
export const POLAR_THETA_LABEL_ARROW_DIST = 12;
export const ANGLE_PRECISION_FACTOR = 1e6;
export const BOUNDARY_ANGLE_PRECISION = 7;
export const LABEL_ID_PRECISION_FACTOR = 1e15;
export const ORIGIN_LABEL_TEXT = '\\phantom{-}0';
export const POLAR_AXIS_RADIUS_BUFFER_FACTOR = 1.1;
export const TICK_LABEL_SIGFIG_THRESH_1 = 80;
export const TICK_LABEL_SIGFIG_THRESH_2 = 40;
export const TICK_LABEL_SIGFIG_THRESH_3 = 20;
export const FINE_TICK_ANGLE_THRESHOLD_DEG = 5;
export const IMAGINARY_UNIT_SYMBOL = 'i';
export const POLAR_RADIUS_SYMBOL = 'r';
export const COMPLEX_REAL_LABEL = '\\mathrm{Re}';
export const COMPLEX_IMAGINARY_LABEL = '\\mathrm{Im}';

// --- DEFAULTS ---
export const DEFAULT_CALIBRATION_VIEW_SCALE = 80.0;
export const DEFAULT_REFERENCE_DISTANCE = 1.0;
export const DEFAULT_REFERENCE_ANGLE_RAD = Math.PI / 2;
export const DEFAULT_POLAR_ANGLE_DIFF = 30;

// --- UI & TOOLBAR ---
export const UI_BUTTON_PADDING = 10;
export const UI_TOOLBAR_WIDTH = 56;
export const UI_SWATCH_SIZE = 30;
export const UI_PADDING = 10;
export const MENU_BUTTON_WIDTH = 36;
export const MENU_BUTTON_HEIGHT = 30;
export const TOOL_BUTTON_HEIGHT = 40;
export const TOOLBAR_SECTION_GAP = 20;
export const UI_ICON_BASE_SIZE = 32;
export const UI_ICON_LINE_WIDTH = 2;
export const UI_ICON_LINE_WIDTH_SMALL = 1.5;
export const UI_ICON_DASH_PATTERN = [2, 2];
export const UI_ICON_POINT_RADIUS = 1.5;
export const UI_ICON_LABEL_FONT_SIZE = 10;
export const UI_MENU_ICON_LINE_WIDTH = 3;
export const TRANSFORM_ICON_SIZE = 30;
export const TRANSFORM_ICON_PADDING = 15;
export const TRANSFORM_ICON_Y_OFFSET = 5;
export const UI_TRANSFORM_TOOL_LABEL_FONT_SIZE = 24;
export const UI_TRANSFORM_TOOL_LABEL_TEXT = 'T';
export const DISPLAY_ICON_SIZE = 40;
export const DISPLAY_ICON_PADDING = 15;
export const UI_DISPLAY_ICON_BAR_WIDTH_PADDING = 12;
export const UI_DISPLAY_ICON_Y_OFFSET = 10;
export const UI_DISPLAY_ICON_Y_SPACING = 10;
export const UI_DISPLAY_ICON_KNOB_RADIUS = 3;
export const UI_SWATCH_SELECTED_BORDER_WIDTH = 3;
export const UI_BUTTON_BORDER_WIDTH = 2;
export const UI_BUTTON_ICON_PADDING = 7;
export const UI_GHOST_ICON_SIZE = 30;
export const COLOR_PALETTE_Y_OFFSET = 5;
export const COLOR_WHEEL_FADE_START_RADIUS_FACTOR = 0.75;

// --- FEEDBACK LABELS & TEXT ---
export const FEEDBACK_LABEL_FONT_SIZE = 12;
export const FEEDBACK_ARC_RADIUS_SCREEN = 30;
export const FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN = 18;
export const FEEDBACK_LINE_VISUAL_WIDTH = 1;
export const REF_TEXT_SCREEN_PIXEL_THRESHOLD = 1.5;
export const REF_TEXT_KATEX_FONT_SIZE = 11;
export const REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN = 18;
export const REF_TEXT_ANGLE_LABEL_OFFSET_SCREEN = 50;
export const ANGLE_LABEL_RADIUS_SCREEN = 75;
export const REF_CIRCLE_MIN_DISPLAY_RADIUS = 20;
export const REF_CIRCLE_MIN_TICK_SPACING = 8;
export const REF_CIRCLE_THETA_LABEL_OFFSET = 30;
export const REF_ARC_RADIUS_SCREEN = 35;
export const SNAP_ANGLE_LABEL_OFFSET = 60;
export const TRANSFORM_ANGLE_LABEL_OFFSET = 20;
export const TRANSFORM_SCALE_LABEL_OFFSET = 18;
export const SCIENTIFIC_NOTATION_UPPER_BOUND = 1000;
export const SCIENTIFIC_NOTATION_LOWER_BOUND = 0.001;
export const MAX_DECIMAL_PLACES_FORMAT = 10;
export const ZERO_TOLERANCE = 0.00001;
export const FRACTION_FORMAT_TOLERANCE = 0.015;
export const FRACTION_FORMAT_MAX_DENOMINATOR = 32;
export const FRACTION_FORMAT_MAX_DENOMINATOR_TRANSFORM = 10;
export const COORD_PRECISION_FACTOR = 0.999;
export const MAX_COORD_DECIMAL_PLACES = 6;
export const MAX_ANGLE_DECIMAL_PLACES = 4;
export const MOUSE_COORD_FONT_SIZE = 14;
export const KATEX_MINUS_PHANTOM = '\\hphantom{-}';
export const PI_SYMBOL_KATEX = '\\pi';
export const DELTA_SYMBOL_KATEX = '\\delta';
export const DELTA_EQUALS_KATEX = '\\delta = ';
export const THETA_EQUALS_KATEX = '\\theta = ';
export const SELECTION_GLOW_BLUR_RADIUS = 15;
export const SELECTION_GLOW_ALPHA = 0.8;
export const SELECTION_GLOW_RADIUS_OFFSET = 3;
export const SELECTION_GLOW_LINE_WIDTH = 2;
export const EDGE_SELECTION_GLOW_WIDTH_OFFSET = 4;

// --- GRID CALCULATIONS ---
export const GRID_TARGET_SPACING = 140;
export const GRID_ALPHA_TRANSITION_START = 0.4;
export const GRID_ALPHA_TRANSITION_END = 0.9;
export const GRID_ALPHA_CLAMP_THRESHOLD = 0.05;
export const GRID_POLAR_CIRCLE_MIN_SPACING = 10;
export const GRID_POLAR_SPOKE_MIN_SPACING = 10;
export const GRID_POLAR_SPOKE_MIN_RADIUS = 50;
export const GRID_POINT_RADIUS = 1.5;
export const ANGULAR_GRID_PREDEFINED_LEVELS = [15, 5, 1];
export const ANGULAR_GRID_TARGET_SPACING = 80;
export const ANGULAR_GRID_FADE_IN_THRESHOLD = 0.01;

// --- SNAPPING PARAMETERS ---
export const GEOMETRY_CALCULATION_EPSILON = 1e-9;
export const FLOATING_POINT_PRECISION_LIMIT = 1e-15;
export const VERTICAL_LINE_COS_THRESHOLD = 0.1;
export const SNAP_STICKINESS_RADIUS_SCREEN = 30;
export const LINE_TO_SNAP_RADIUS_SCREEN = 10;
export const POINT_ON_LINE_SNAP_RADIUS_SCREEN = 15;
export const DRAG_SNAP_GEOMETRIC_DISTANCE_FACTORS = [0.5, 1, 1.5, 2, 3, 4, 5];
export const DRAW_SNAP_CANDIDATE_COUNT_PER_SIDE = 2;
export const DRAW_SNAP_DISTANCE_FACTOR_STEP = 0.5;
export const DRAW_SNAP_DISTANCE_FACTOR_LIMIT = 50;
export const GHOST_SNAP_RADIUS_SCREEN = 30;
export const MAX_HISTORY_SIZE = 50;

// --- SNAP GENERATION PARAMETERS ---
export const MAX_FRACTION_DENOMINATOR_FOR_ANGLE_SNAPS = 6;
export const MAX_BASE_ANGLE_MULTIPLIER_FOR_SNAPS = 2;
export const MAX_INITIAL_METER_SNAP_MULTIPLIER = 10;
export const MAX_SNAP_DENOMINATOR = 6;
export const MAX_SNAP_INTEGER = 10;

export const NINETY_DEG_ANGLE_SNAP_FRACTIONS = (() => {
    const uniqueFractions = new Set();
    const denominators = [1, 2, 3, 4, 5, 6];
    for (const q of denominators) {
        for (let p = 1; p <= q * 4; p++) {
            uniqueFractions.add(p / q);
        }
    }
    return Array.from(uniqueFractions).sort((a, b) => a - b);
})();


function generateSnapFactors(maxDenominator, maxInteger) {
    const fractionsSet = new Set();
    fractionsSet.add(0);
    for (let q = 1; q <= maxDenominator; q++) {
        for (let p = 1; p <= q * maxInteger; p++) {
            fractionsSet.add(p / q);
        }
    }
    return Array.from(fractionsSet).sort((a, b) => a - b);
}

export const SNAP_FACTORS = generateSnapFactors(MAX_SNAP_DENOMINATOR, MAX_SNAP_INTEGER);

// --- ENUMS & LITERALS ---
export const POINT_TYPE_REGULAR = 'regular';
export const TRANSFORM_TYPE_ROTATE_SCALE = 'center_rotate_scale';
export const TRANSFORM_TYPE_ROTATE_ONLY = 'center_rotate_only';
export const TRANSFORM_TYPE_SCALE_ONLY = 'center_scale_only';
export const COORDS_DISPLAY_MODE_NONE = 'none';
export const COORDS_DISPLAY_MODE_REGULAR = 'regular';
export const COORDS_DISPLAY_MODE_COMPLEX = 'complex';
export const COORDS_DISPLAY_MODE_POLAR = 'polar';
export const GRID_DISPLAY_MODE_NONE = 'none';
export const GRID_DISPLAY_MODE_LINES = 'lines';
export const GRID_DISPLAY_MODE_POINTS = 'points';
export const GRID_DISPLAY_MODE_TRIANGULAR = 'triangular';
export const GRID_DISPLAY_MODE_POLAR = 'polar';
export const ANGLE_DISPLAY_MODE_DEGREES = 'degrees';
export const ANGLE_DISPLAY_MODE_RADIANS = 'radians';
export const ANGLE_DISPLAY_MODE_NONE = 'none';
export const DISTANCE_DISPLAY_MODE_ON = 'on';
export const DISTANCE_DISPLAY_MODE_NONE = 'none';
export const KEY_SPACE = ' ';
export const KEY_ESCAPE = 'Escape';
export const KEY_DELETE = 'Delete';
export const KEY_BACKSPACE = 'Backspace';
export const KEY_REPEAT = 'r';
export const KEY_ZOOM_IN = '=';
export const KEY_ZOOM_IN_PLUS = '+';
export const KEY_ZOOM_OUT = '-';
export const KEY_COPY = 'c';
export const KEY_PASTE = 'v';
export const KEY_CUT = 'x';
export const KEY_UNDO = 'z';
export const KEY_REDO = 'y';
export const KEY_SELECT_ALL = 'a';



=== index.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Platonic Play</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <div class="canvas-wrapper-relative">
                <canvas id="drawingCanvas"></canvas>
                <div id="html-overlay"></div>
            </div>
        </div>
    </div>

    <input type="color" id="colorPicker" value="#ffffff">

    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script type="module" src="script.js"></script>
</body>
</html>

=== project_content.txt ===
--- CONTENT EXCLUDED (listed in exclude_files) ---


=== readme.md ===



=== refactor.py ===
# refactor_signatures.py
import os
import re

def update_renderer_signatures():
    """
    Updates function signatures in renderer.js to accept the 'colors' object,
    and updates the internal calls to helper functions.
    """
    filename = 'renderer.js'
    if not os.path.exists(filename):
        print(f"ERROR: File '{filename}' not found.")
        return

    try:
        with open(filename, 'r', encoding='utf-8') as f:
            content = f.read()

        # This list defines the exact signature replacements.
        # It finds the old function definition and replaces it with the new one.
        signature_replacements = [
            (
                "export function drawGrid(ctx, state, dataToScreen, screenToData, lastGridState, lastAngularGridState)",
                "export function drawGrid(ctx, { gridDisplayMode, canvas, dpr, viewTransform, gridAlpha, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState)"
            ),
            (
                "export function drawAxes(ctx, htmlOverlay, state, dataToScreen, screenToData, lastGridState, lastAngularGridState, updateHtmlLabel)",
                "export function drawAxes(ctx, htmlOverlay, { canvas, dpr, coordsDisplayMode, viewTransform, angleDisplayMode, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState, updateHtmlLabel)"
            ),
            (
                "export function drawPoint(ctx, point, state, dataToScreen)",
                "export function drawPoint(ctx, point, { selectedPointIds, selectedCenterIds, activeCenterId, currentColor, colors }, dataToScreen)"
            ),
            (
                "export function drawAllEdges(ctx, state, dataToScreen, findPointById, getEdgeId)",
                "export function drawAllEdges(ctx, { allEdges, selectedEdgeIds, isDragConfirmed, dragPreviewPoints, currentColor, colors }, dataToScreen, findPointById, getEdgeId)"
            ),
            (
                "export function drawDragFeedback(ctx, htmlOverlay, targetPointId, currentPointStates, state, dataToScreen, findNeighbors, getEdgeId, isSnapping = false, excludedEdgeId = null, updateHtmlLabel = null)",
                "export function drawDragFeedback(ctx, htmlOverlay, targetPointId, currentPointStates, { lastGridState, showDistances, showAngles, distanceSigFigs, angleDisplayMode, angleSigFigs, currentShiftPressed, viewTransform, colors }, dataToScreen, findNeighbors, getEdgeId, isSnapping = false, excludedEdgeId = null, updateHtmlLabel = null)"
            ),
            (
                "export function drawTransformIndicators(ctx, htmlOverlay, state, dataToScreen, updateHtmlLabel)",
                "export function drawTransformIndicators(ctx, htmlOverlay, { transformIndicatorData, angleSigFigs, distanceSigFigs, colors }, dataToScreen, updateHtmlLabel)"
            ),
            (
                "export function drawReferenceElementsGeometry(ctx, context, dataToScreen, screenToData, state)",
                "export function drawReferenceElementsGeometry(ctx, context, dataToScreen, screenToData, { showAngles, showDistances, viewTransform, mousePos, colors })"
            ),
            (
                "export function prepareSnapInfoTexts(ctx, htmlOverlay, startPointData, targetDataPos, snappedOutput, state, dataToScreen, drawingContext, updateHtmlLabel)",
                "export function prepareSnapInfoTexts(ctx, htmlOverlay, startPointData, targetDataPos, snappedOutput, { showDistances, showAngles, currentShiftPressed, distanceSigFigs, angleSigFigs, angleDisplayMode, viewTransform, frozenReference_D_du, gridDisplayMode, frozenReference_A_rad, colors }, dataToScreen, drawingContext, updateHtmlLabel)"
            ),
            (
                "export function prepareReferenceElementsTexts(htmlOverlay, context, state, screenToData, dataToScreen, updateHtmlLabel)",
                "export function prepareReferenceElementsTexts(htmlOverlay, context, { showAngles, showDistances, viewTransform, mousePos, frozenReference_D_du, distanceSigFigs, angleDisplayMode, colors }, screenToData, dataToScreen, updateHtmlLabel)"
            ),
            (
                "export function updateMouseCoordinates(htmlOverlay, state, screenToData, updateHtmlLabel)",
                "export function updateMouseCoordinates(htmlOverlay, { coordsDisplayMode, isMouseOverCanvas, currentShiftPressed, ghostPointPosition, gridDisplayMode, lastGridState, angleDisplayMode, canvas, dpr, mousePos, colors}, screenToData, updateHtmlLabel)"
            ),
            (
                "export function drawDisplayIcon(ctx, icon, state, htmlOverlay, updateHtmlLabel)",
                "export function drawDisplayIcon(ctx, icon, { coordsDisplayMode, gridDisplayMode, angleDisplayMode, distanceDisplayMode, colors }, htmlOverlay, updateHtmlLabel)"
            ),
            (
                "export function drawCanvasUI(ctx, htmlOverlay, state, updateHtmlLabel)",
                "export function drawCanvasUI(ctx, htmlOverlay, { dpr, canvasUI, isToolbarExpanded, isColorPaletteExpanded, isTransformPanelExpanded, isDisplayPanelExpanded, isPlacingTransform, placingTransformType, placingSnapPos, mousePos, selectedSwatchIndex, recentColors, activeThemeName, colors }, updateHtmlLabel)"
            ),
            # Helper functions that need the `colors` object passed to them
            ("function drawZeroTickAndTickLabel(ctx, origin, canvasWidth, canvasHeight, coordsDisplayMode, updateHtmlLabel)", "function drawZeroTickAndTickLabel(ctx, origin, canvasWidth, canvasHeight, coordsDisplayMode, updateHtmlLabel, colors)"),
            ("function drawCenterSymbol(ctx, point, dataToScreen)", "function drawCenterSymbol(ctx, point, dataToScreen, colors)"),
            ("function drawUITransformSymbol(ctx, icon)", "function drawUITransformSymbol(ctx, icon, colors)"),
            ("function drawCoordsIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel)", "function drawCoordsIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors)"),
            ("function drawAngleIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel)", "function drawAngleIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors)"),
            ("function drawDistanceIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel)", "function drawDistanceIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors)"),
            ("function drawGridIcon(ctx, rect, mode, isSelected)", "function drawGridIcon(ctx, rect, mode, isSelected, colors)")
        ]

        # Update the main function signatures first
        for find_sig, replace_sig in signature_replacements:
            if find_sig in content:
                content = content.replace(find_sig, replace_sig)

        # Then, update the calls to the internal helper functions
        content = content.replace(
            "drawZeroTickAndTickLabel(ctx, origin, canvasWidth, canvasHeight, coordsDisplayMode, updateHtmlLabel);",
            "drawZeroTickAndTickLabel(ctx, origin, canvasWidth, canvasHeight, coordsDisplayMode, updateHtmlLabel, colors);"
        )
        content = content.replace(
            "drawCenterSymbol(ctx, point, dataToScreen);",
            "drawCenterSymbol(ctx, point, dataToScreen, colors);"
        )
        content = content.replace(
            "drawUITransformSymbol(ctx, ghostIcon);",
            "drawUITransformSymbol(ctx, ghostIcon, colors);"
        )
        content = content.replace(
            "drawUITransformSymbol(ctx, icon);",
            "drawUITransformSymbol(ctx, icon, colors);"
        )
        # The state object needs to be passed through to the display icon helpers
        content = content.replace(
            "drawCoordsIcon(ctx, rect, coordsDisplayMode, isSelected, htmlOverlay, updateHtmlLabel);",
            "drawCoordsIcon(ctx, rect, coordsDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);"
        )
        content = content.replace(
            "drawGridIcon(ctx, rect, gridDisplayMode, isSelected);",
            "drawGridIcon(ctx, rect, gridDisplayMode, isSelected, colors);"
        )
        content = content.replace(
            "drawAngleIcon(ctx, rect, angleDisplayMode, isSelected, htmlOverlay, updateHtmlLabel);",
            "drawAngleIcon(ctx, rect, angleDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);"
        )
        content = content.replace(
            "drawDistanceIcon(ctx, rect, distanceDisplayMode, isSelected, htmlOverlay, updateHtmlLabel);",
            "drawDistanceIcon(ctx, rect, distanceDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);"
        )
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"SUCCESS: Updated function signatures in '{filename}'.")

    except Exception as e:
        print(f"ERROR processing {filename}: {e}")

if __name__ == "__main__":
    print("--- Starting Signature Refactoring Script ---")
    update_renderer_signatures()
    print("--- Script Finished ---")

=== renderer.js ===
import {
    formatNumber,
    normalizeAngleToPi,
    normalizeAngleDegrees,
    distance,
    formatFraction,
    hslToRgb,
    formatSnapFactor,
    simplifySquareRoot,
    formatSimplifiedRoot,
    gcd
} from './utils.js';

import {
    // --- GEOMETRY & DRAWING ---
    POINT_RADIUS,
    CENTER_POINT_VISUAL_RADIUS,
    LINE_WIDTH,
    GRID_LINEWIDTH,
    DASH_PATTERN,
    DASH_PATTERN_SMALL,
    DEGREES_IN_CIRCLE,
    DEGREES_IN_HALF_CIRCLE,
    DEGREES_IN_QUADRANT,
    RADIANS_IN_CIRCLE,
    MIN_ALPHA_FOR_DRAWING,
    TRIANGULAR_GRID_Y_STEP_FACTOR,
    POLAR_TO_LINE_TRANSITION_RADIUS_FACTOR,
    ORIGIN_TICK_ANGLE_RAD,
    AXIS_MAJOR_TICK_SCALE_FACTOR,
    AXIS_ARROW_ANGLE_RAD,
    MAJOR_TICK_LINE_WIDTH,
    HELPER_LINE_DASH_PATTERN,
    REF_LINE_DASH_PATTERN,

    // --- INTERACTION ---
    MIN_TRANSFORM_ACTION_THRESHOLD,

    // --- AXES & TICKS ---
    AXIS_LINE_WIDTH,
    AXIS_TICK_SIZE,
    AXIS_TICK_LABEL_ALPHA,
    AXIS_NAME_FONT_SIZE,
    AXIS_TICK_FONT_SIZE,
    AXIS_LABEL_OFFSET,
    AXIS_LABEL_PADDING,
    AXIS_ARROW_SIZE,
    X_AXIS_LABEL_DISTANCE,
    X_AXIS_LABEL_ARROW_DIST,
    Y_AXIS_LABEL_DISTANCE,
    Y_AXIS_LABEL_ARROW_DIST,
    POLAR_THETA_LABEL_DISTANCE,
    POLAR_THETA_LABEL_ARROW_DIST,
    ANGLE_PRECISION_FACTOR,
    BOUNDARY_ANGLE_PRECISION,
    LABEL_ID_PRECISION_FACTOR,
    ORIGIN_LABEL_TEXT,
    POLAR_AXIS_RADIUS_BUFFER_FACTOR,
    TICK_LABEL_SIGFIG_THRESH_1,
    TICK_LABEL_SIGFIG_THRESH_2,
    TICK_LABEL_SIGFIG_THRESH_3,
    FINE_TICK_ANGLE_THRESHOLD_DEG,
    IMAGINARY_UNIT_SYMBOL,
    POLAR_RADIUS_SYMBOL,
    COMPLEX_REAL_LABEL,
    COMPLEX_IMAGINARY_LABEL,

    // --- DEFAULTS ---
    DEFAULT_REFERENCE_DISTANCE,

    // --- UI & TOOLBAR ---
    UI_PADDING,
    UI_ICON_BASE_SIZE,
    UI_ICON_LINE_WIDTH,
    UI_ICON_LINE_WIDTH_SMALL,
    UI_ICON_DASH_PATTERN,
    UI_ICON_POINT_RADIUS,
    UI_ICON_LABEL_FONT_SIZE,
    UI_MENU_ICON_LINE_WIDTH,
    UI_TRANSFORM_TOOL_LABEL_FONT_SIZE,
    UI_TRANSFORM_TOOL_LABEL_TEXT,
    UI_DISPLAY_ICON_BAR_WIDTH_PADDING,
    UI_DISPLAY_ICON_Y_OFFSET,
    UI_DISPLAY_ICON_Y_SPACING,
    UI_DISPLAY_ICON_KNOB_RADIUS,
    UI_SWATCH_SELECTED_BORDER_WIDTH,
    UI_BUTTON_BORDER_WIDTH,
    UI_BUTTON_ICON_PADDING,
    UI_GHOST_ICON_SIZE,
    COLOR_WHEEL_FADE_START_RADIUS_FACTOR,

    // --- FEEDBACK LABELS & TEXT ---
    FEEDBACK_LABEL_FONT_SIZE,
    FEEDBACK_ARC_RADIUS_SCREEN,
    FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN,
    FEEDBACK_LINE_VISUAL_WIDTH,
    REF_TEXT_SCREEN_PIXEL_THRESHOLD,
    REF_TEXT_KATEX_FONT_SIZE,
    REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN,
    REF_TEXT_ANGLE_LABEL_OFFSET_SCREEN,
    ANGLE_LABEL_RADIUS_SCREEN,
    REF_CIRCLE_MIN_DISPLAY_RADIUS,
    REF_CIRCLE_MIN_TICK_SPACING,
    REF_CIRCLE_THETA_LABEL_OFFSET,
    REF_ARC_RADIUS_SCREEN,
    SNAP_ANGLE_LABEL_OFFSET,
    TRANSFORM_ANGLE_LABEL_OFFSET,
    TRANSFORM_SCALE_LABEL_OFFSET,
    FRACTION_FORMAT_TOLERANCE,
    FRACTION_FORMAT_MAX_DENOMINATOR,
    FRACTION_FORMAT_MAX_DENOMINATOR_TRANSFORM,
    COORD_PRECISION_FACTOR,
    MAX_COORD_DECIMAL_PLACES,
    MAX_ANGLE_DECIMAL_PLACES,
    MOUSE_COORD_FONT_SIZE,
    KATEX_MINUS_PHANTOM,
    PI_SYMBOL_KATEX,
    DELTA_SYMBOL_KATEX,
    DELTA_EQUALS_KATEX,
    THETA_EQUALS_KATEX,
    SELECTION_GLOW_BLUR_RADIUS,
    SELECTION_GLOW_ALPHA,
    SELECTION_GLOW_RADIUS_OFFSET,
    SELECTION_GLOW_LINE_WIDTH,
    EDGE_SELECTION_GLOW_WIDTH_OFFSET,

    // --- GRID CALCULATIONS ---
    GRID_TARGET_SPACING,
    GRID_ALPHA_TRANSITION_START,
    GRID_ALPHA_TRANSITION_END,
    GRID_ALPHA_CLAMP_THRESHOLD,
    GRID_POLAR_CIRCLE_MIN_SPACING,
    GRID_POLAR_SPOKE_MIN_SPACING,
    GRID_POLAR_SPOKE_MIN_RADIUS,
    GRID_POINT_RADIUS,
    ANGULAR_GRID_PREDEFINED_LEVELS,
    ANGULAR_GRID_TARGET_SPACING,
    ANGULAR_GRID_FADE_IN_THRESHOLD,

    // --- SNAPPING PARAMETERS ---
    GEOMETRY_CALCULATION_EPSILON,
    FLOATING_POINT_PRECISION_LIMIT,
    VERTICAL_LINE_COS_THRESHOLD,
    NINETY_DEG_ANGLE_SNAP_FRACTIONS,
    SNAP_FACTORS,

    // --- ENUMS & LITERALS ---
    POINT_TYPE_REGULAR,
    TRANSFORM_TYPE_ROTATE_SCALE,
    TRANSFORM_TYPE_ROTATE_ONLY,
    TRANSFORM_TYPE_SCALE_ONLY,
    COORDS_DISPLAY_MODE_NONE,
    COORDS_DISPLAY_MODE_REGULAR,
    COORDS_DISPLAY_MODE_COMPLEX,
    COORDS_DISPLAY_MODE_POLAR,
    GRID_DISPLAY_MODE_NONE,
    GRID_DISPLAY_MODE_LINES,
    GRID_DISPLAY_MODE_POINTS,
    GRID_DISPLAY_MODE_TRIANGULAR,
    GRID_DISPLAY_MODE_POLAR,
    ANGLE_DISPLAY_MODE_DEGREES,
    ANGLE_DISPLAY_MODE_RADIANS,
    ANGLE_DISPLAY_MODE_NONE,
    DISTANCE_DISPLAY_MODE_ON,
    DISTANCE_DISPLAY_MODE_NONE
} from './constants.js';


let colorWheelIcon = null



export function calculateGridIntervals(viewTransformScale) {
    const effectiveDataInterval = GRID_TARGET_SPACING / viewTransformScale;

    let lowerPowerOf10 = Math.pow(10, Math.floor(Math.log10(effectiveDataInterval)));
    let higherPowerOf10 = Math.pow(10, Math.ceil(Math.log10(effectiveDataInterval)));

    if (Math.abs(lowerPowerOf10 - higherPowerOf10) < GEOMETRY_CALCULATION_EPSILON || lowerPowerOf10 === 0) {
        higherPowerOf10 = lowerPowerOf10 === 0 ? 0.001 : lowerPowerOf10 * 10;
        if (lowerPowerOf10 === 0) lowerPowerOf10 = 0.0001;
    }

    const grid1Interval = lowerPowerOf10;
    const grid2Interval = higherPowerOf10;

    let logInterpFactor = 0;
    if (grid2Interval > grid1Interval && grid1Interval > 0) {
        logInterpFactor = (Math.log10(effectiveDataInterval) - Math.log10(grid1Interval)) / (Math.log10(grid2Interval) - Math.log10(grid1Interval));
    }

    let interpValue = (logInterpFactor - GRID_ALPHA_TRANSITION_START) / (GRID_ALPHA_TRANSITION_END - GRID_ALPHA_TRANSITION_START);
    interpValue = Math.max(0, Math.min(1, interpValue));
    interpValue = interpValue * interpValue * (3 - 2 * interpValue);

    let alpha1 = 1 - interpValue;
    let alpha2 = interpValue;

    if (alpha1 < GRID_ALPHA_CLAMP_THRESHOLD) alpha1 = 0; else if (alpha1 > 1 - GRID_ALPHA_CLAMP_THRESHOLD) alpha1 = 1;
    if (alpha2 < GRID_ALPHA_CLAMP_THRESHOLD) alpha2 = 0; else if (alpha2 > 1 - GRID_ALPHA_CLAMP_THRESHOLD) alpha2 = 1;

    const totalAlpha = alpha1 + alpha2;
    if (totalAlpha > 0 && totalAlpha !== 2) {
        alpha1 /= totalAlpha;
        alpha2 /= totalAlpha;
    }

    return { grid1Interval, grid2Interval, alpha1, alpha2 };
}

export function getDynamicAngularIntervals(viewTransform, canvasWidth, canvasHeight, dataToScreen) {
    const originScreen = dataToScreen({ x: 0, y: 0 });
    const screenCenter = { x: canvasWidth / 2, y: canvasHeight / 2 };

    const radiusToCenterScreen = distance(originScreen, screenCenter);
    let targetAngleDeg;

    // Calculate targetAngleDeg. If origin is very close to center, default to a larger angle.
    // This helps stabilize calculations when zoom is extremely high and originScreen is pan-aligned.
    if (radiusToCenterScreen < 1e-6) { // Use a very small epsilon for near-zero distance
        targetAngleDeg = ANGULAR_GRID_TARGET_SPACING; // Use target spacing directly if effectively at origin
    } else {
        const targetAngleRad = ANGULAR_GRID_TARGET_SPACING / radiusToCenterScreen;
        targetAngleDeg = targetAngleRad * (180 / Math.PI);
    }

    // Ensure targetAngleDeg is always a positive, meaningful value.
    // If it becomes extremely small (due to massive zoom), set a practical minimum
    // to avoid log(0) or log(negative) issues and floating point precision problems.
    if (isNaN(targetAngleDeg) || targetAngleDeg <= GEOMETRY_CALCULATION_EPSILON) {
        targetAngleDeg = GEOMETRY_CALCULATION_EPSILON; // Ensures log10 is valid and a very small angle is processed
    }

    const results = [];
    let allLevels = [...ANGULAR_GRID_PREDEFINED_LEVELS];

    // Dynamically generate finer levels.
    // FIXED: Generate many more levels to handle extreme zoom scenarios
    let lastGeneratedLevel = allLevels[allLevels.length - 1];
    
    // Generate levels down to extremely fine detail - only limited by floating point precision
    // We'll generate at least 20 orders of magnitude finer than the current finest level
    const absoluteMinimum = 1e-15; // Close to JavaScript's floating point precision limit
    
    while (lastGeneratedLevel > absoluteMinimum) {
        lastGeneratedLevel /= 10;
        // Avoid adding duplicates if the predefined levels already contain this
        if (!allLevels.includes(lastGeneratedLevel)) {
            allLevels.push(lastGeneratedLevel);
        }
    }

    // Sort all levels in descending order (largest to smallest). This is crucial for
    // iterating through them to find the primary and secondary levels correctly.
    allLevels.sort((a, b) => b - a);

    let primaryLevel = null;
    let secondaryLevel = null;

    // Find the 'primaryLevel': the coarsest level that is still coarser than targetAngleDeg
    // and 'secondaryLevel': the next finer level for smooth transitions.
    for (let i = allLevels.length - 1; i >= 0; i--) {
        const currentLevel = allLevels[i];

        if (targetAngleDeg < currentLevel) {
            // Found the primary level (coarsest that's still coarser than target)
            primaryLevel = { angle: currentLevel, alpha: 1.0 };
            // The next finer level is a candidate for secondaryLevel
            if (i + 1 < allLevels.length) {
                secondaryLevel = { angle: allLevels[i + 1], alpha: 0 };
            }
            break; // Found our primary, exit loop
        }
    }

    // Edge case: If targetAngleDeg is larger than *all* generated levels,
    // then use the largest level as primary and second largest as secondary.
    if (!primaryLevel && allLevels.length > 0) {
        primaryLevel = { angle: allLevels[0], alpha: 1.0 }; // Largest level
        if (allLevels.length > 1) {
            secondaryLevel = { angle: allLevels[1], alpha: 0 };
        }
    } else if (!primaryLevel && allLevels.length === 0) {
        // Fallback if no levels were generated (should not happen if PREDEFINED_LEVELS is not empty)
        primaryLevel = { angle: ANGULAR_GRID_PREDEFINED_LEVELS[0], alpha: 1.0 };
    }

    results.push(primaryLevel);

    // Calculate alpha for the secondary level if it exists
    if (secondaryLevel) {
        const logPrimary = Math.log10(primaryLevel.angle);
        const logSecondary = Math.log10(secondaryLevel.angle);
        const logTarget = Math.log10(targetAngleDeg);

        // Interpolate 'interpValue' based on where targetAngleDeg falls between primary and secondary levels.
        // If targetAngleDeg is exactly primaryLevel, interpValue should be 0.
        // If targetAngleDeg is exactly secondaryLevel, interpValue should be 1.
        let interpValue;
        if (logSecondary === logPrimary) { // Avoid division by zero
            interpValue = 0;
        } else {
            // Normalize targetAngleDeg's position between primary and secondary log scales
            interpValue = (logTarget - logPrimary) / (logSecondary - logPrimary);
        }

        interpValue = Math.max(0, Math.min(1, interpValue)); // Clamp between 0 and 1

        // Apply smoothstep for a visually pleasing fade.
        const fadeInAlpha = interpValue * interpValue * (3 - 2 * interpValue);

        // Only add secondary level if its alpha is sufficiently high
        if (fadeInAlpha > ANGULAR_GRID_FADE_IN_THRESHOLD) {
            secondaryLevel.alpha = fadeInAlpha;
            results.push(secondaryLevel);
        }
    }

    // Final filtering for unique angles and ensuring proper order (largest angle first for draw order)
    const uniqueResults = [];
    const seenAngles = new Set();
    // Re-sort results by angle descending to ensure consistent drawing order in `drawPolarReferenceCircle`
    // (though `forEach` on `lastAngularGridState` doesn't strictly guarantee order, it's good practice)
    results.sort((a, b) => b.angle - a.angle);

    for (const res of results) {
        if (!seenAngles.has(res.angle)) {
            uniqueResults.push(res);
            seenAngles.add(res.angle);
        }
    }

    // If for some reason uniqueResults is empty, add a default coarse level
    if (uniqueResults.length === 0) {
        uniqueResults.push({ angle: ANGULAR_GRID_PREDEFINED_LEVELS[0], alpha: 1.0 });
    }

    return uniqueResults;
}



function getLineCircleIntersections(x1, y1, x2, y2, cx, cy, r) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const fx = x1 - cx;
    const fy = y1 - cy;

    const a = dx * dx + dy * dy;
    const b = 2 * (fx * dx + fy * dy);
    const c = (fx * fx + fy * fy) - r * r;

    const discriminant = b * b - 4 * a * c;
    
    if (discriminant < 0) {
        return [];
    }

    const discriminantSqrt = Math.sqrt(discriminant);
    const t1 = (-b - discriminantSqrt) / (2 * a);
    const t2 = (-b + discriminantSqrt) / (2 * a);

    const intersections = [];
    
    if (t1 >= 0 && t1 <= 1) {
        intersections.push({
            x: x1 + t1 * dx,
            y: y1 + t1 * dy
        });
    }
    
    if (t2 >= 0 && t2 <= 1 && Math.abs(t2 - t1) > 1e-10) {
        intersections.push({
            x: x1 + t2 * dx,
            y: y1 + t2 * dy
        });
    }

    return intersections;
}

function calculateVisibleAngleRange(originScreen, screenRadius, canvasWidth, canvasHeight) {
    // If origin is visible, show all angles
    if (originScreen.x >= 0 && originScreen.x <= canvasWidth && 
        originScreen.y >= 0 && originScreen.y <= canvasHeight) {
        return { minAngle: 0, maxAngle: 360, isFullCircle: true };
    }

    const rect = {
        left: 0,
        right: canvasWidth,
        top: 0,
        bottom: canvasHeight
    };

    // Check if circle is completely outside viewport
    if (originScreen.x + screenRadius < rect.left || 
        originScreen.x - screenRadius > rect.right ||
        originScreen.y + screenRadius < rect.top || 
        originScreen.y - screenRadius > rect.bottom) {
        return null;
    }

    // Check if circle completely contains the viewport
    const corners = [
        { x: rect.left, y: rect.top },
        { x: rect.right, y: rect.top },
        { x: rect.right, y: rect.bottom },
        { x: rect.left, y: rect.bottom }
    ];

    const allCornersInside = corners.every(corner => {
        const distSq = (corner.x - originScreen.x) ** 2 + (corner.y - originScreen.y) ** 2;
        return distSq <= screenRadius ** 2;
    });

    if (allCornersInside) {
        return { minAngle: 0, maxAngle: 360, isFullCircle: true };
    }

    // Collect all intersection angles
    const intersectionAngles = [];

    // Add corner angles if corners are outside the circle
    corners.forEach(corner => {
        const distSq = (corner.x - originScreen.x) ** 2 + (corner.y - originScreen.y) ** 2;
        if (distSq > screenRadius ** 2) {
            const dx = corner.x - originScreen.x;
            const dy = corner.y - originScreen.y;
            const angle = Math.atan2(-dy, dx); // Note: -dy for screen coordinates
            const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle;
            intersectionAngles.push(normalizedAngle * 180 / Math.PI);
        }
    });

    // Add edge-circle intersections
    const edges = [
        { x1: rect.left, y1: rect.top, x2: rect.right, y2: rect.top },      // top
        { x1: rect.right, y1: rect.top, x2: rect.right, y2: rect.bottom },  // right
        { x1: rect.right, y1: rect.bottom, x2: rect.left, y2: rect.bottom }, // bottom
        { x1: rect.left, y1: rect.bottom, x2: rect.left, y2: rect.top }     // left
    ];

    edges.forEach(edge => {
        const intersections = getLineCircleIntersections(
            edge.x1, edge.y1, edge.x2, edge.y2,
            originScreen.x, originScreen.y, screenRadius
        );
        
        intersections.forEach(point => {
            const dx = point.x - originScreen.x;
            const dy = point.y - originScreen.y;
            const angle = Math.atan2(-dy, dx);
            const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle;
            intersectionAngles.push(normalizedAngle * 180 / Math.PI);
        });
    });

    if (intersectionAngles.length === 0) {
        return { minAngle: 0, maxAngle: 360, isFullCircle: true };
    }

    // Remove duplicates and sort
    const uniqueAngles = [...new Set(intersectionAngles.map(a => Math.round(a * 1e6) / 1e6))].sort((a, b) => a - b);

    if (uniqueAngles.length < 2) {
        return { minAngle: 0, maxAngle: 360, isFullCircle: true };
    }

    // Find the largest gap between consecutive angles to determine the invisible sector
    let maxGap = 0;
    let maxGapStartAngle = 0;
    let maxGapEndAngle = 0;

    for (let i = 0; i < uniqueAngles.length; i++) {
        const currentAngle = uniqueAngles[i];
        const nextAngle = uniqueAngles[(i + 1) % uniqueAngles.length];
        
        let gap;
        if (i === uniqueAngles.length - 1) {
            // Gap from last angle to first angle (wrapping around)
            gap = (360 - currentAngle) + nextAngle;
        } else {
            gap = nextAngle - currentAngle;
        }

        if (gap > maxGap) {
            maxGap = gap;
            maxGapStartAngle = currentAngle;
            maxGapEndAngle = nextAngle;
        }
    }

    // FIXED: The largest gap represents the INVISIBLE area
    // The visible range is everything EXCEPT the largest gap
    if (maxGapEndAngle > maxGapStartAngle) {
        // Invisible gap doesn't cross 0°, so visible range wraps around 0°
        return {
            minAngle: maxGapEndAngle,
            maxAngle: maxGapStartAngle + 360,
            isFullCircle: false
        };
    } else {
        // Invisible gap crosses 0°, so visible range is normal
        return {
            minAngle: maxGapEndAngle,
            maxAngle: maxGapStartAngle,
            isFullCircle: false
        };
    }
}

function generateOptimizedAngleSequence(angleStep, minAngle, maxAngle) {
    const angles = [];
    
    // FIXED: Properly detect wraparound case
    const isWraparound = maxAngle > 360;
    
    if (isWraparound) {
        // Handle wraparound case
        const actualMaxAngle = maxAngle - 360;
        
        // Add angles from minAngle to 360
        const startAngle1 = Math.floor(minAngle / angleStep) * angleStep;
        for (let angle = startAngle1; angle < 360; angle += angleStep) {
            if (angle >= minAngle) {
                angles.push(angle);
            }
        }
        
        // Add angles from 0 to actualMaxAngle
        for (let angle = 0; angle <= actualMaxAngle + angleStep; angle += angleStep) {
            if (angle <= actualMaxAngle) {
                angles.push(angle);
            }
        }
    } else {
        // Normal case - no wraparound
        const startAngle = Math.floor(minAngle / angleStep) * angleStep;
        for (let angle = startAngle; angle <= maxAngle + angleStep; angle += angleStep) {
            if (angle >= minAngle && angle <= maxAngle && angle >= 0 && angle < 360) {
                angles.push(angle);
            }
        }
    }
    
    return [...new Set(angles)].sort((a, b) => a - b);
}

function isTickVisible(tickEnd, canvasWidth, canvasHeight) {
    return tickEnd.x >= -AXIS_LABEL_PADDING && 
           tickEnd.x <= canvasWidth + AXIS_LABEL_PADDING && 
           tickEnd.y >= -AXIS_LABEL_PADDING && 
           tickEnd.y <= canvasHeight + AXIS_LABEL_PADDING;
}

export function drawPolarReferenceCircle(ctx, htmlOverlay, updateHtmlLabel, radius, alpha, { canvas, dpr, viewTransform, angleDisplayMode, colors }, dataToScreen, lastAngularGridState) {
    if (typeof dataToScreen !== 'function' || typeof updateHtmlLabel !== 'function') {
        return;
    }

    const originScreen = dataToScreen({ x: 0, y: 0 });
    const canvasWidthCSS = canvas.width / dpr;
    const canvasHeightCSS = canvas.height / dpr;
    const screenCenter = { x: canvasWidthCSS / 2, y: canvasHeightCSS / 2 };
    const baseRadius = Math.min(canvasWidthCSS, canvasHeightCSS) / 4;
    const panDistance = distance(originScreen, screenCenter);
    const screenRadius = baseRadius + panDistance;

    if (screenRadius < REF_CIRCLE_MIN_DISPLAY_RADIUS || !isCircleInView(originScreen.x, originScreen.y, screenRadius, canvasWidthCSS, canvasHeightCSS)) {
        return;
    }

    ctx.save();
    ctx.strokeStyle = `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;
    ctx.lineWidth = FEEDBACK_LINE_VISUAL_WIDTH;

    const transitionRadius = Math.min(canvasWidthCSS, canvasHeightCSS) * 400;
    const isLineMode = screenRadius > transitionRadius;

    let visibleAngleRange = null;

    if (isLineMode) {
        const screenRect = { x: 0, y: 0, w: canvasWidthCSS, h: canvasHeightCSS };
        const circle = { x: originScreen.x, y: originScreen.y, r: screenRadius };
        const intersections = getCircleRectIntersections(circle, screenRect);

        if (intersections.length >= 2) {
            let p1 = intersections[0], p2 = intersections[1];
            let maxDistSq = 0;
            for (let i = 0; i < intersections.length; i++) {
                for (let j = i + 1; j < intersections.length; j++) {
                    const dSq = (intersections[i].x - intersections[j].x)**2 + (intersections[i].y - intersections[j].y)**2;
                    if (dSq > maxDistSq) {
                        maxDistSq = dSq;
                        p1 = intersections[i];
                        p2 = intersections[j];
                    }
                }
            }
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            const angle1 = (Math.atan2(originScreen.y - p1.y, p1.x - originScreen.x) * 180 / Math.PI + 360) % 360;
            const angle2 = (Math.atan2(originScreen.y - p2.y, p2.x - originScreen.x) * 180 / Math.PI + 360) % 360;
            visibleAngleRange = { minAngle: Math.min(angle1, angle2), maxAngle: Math.max(angle1, angle2), isFullCircle: false };
            if (Math.abs(angle1 - angle2) > 180) {
                 visibleAngleRange = { minAngle: Math.max(angle1, angle2), maxAngle: Math.min(angle1, angle2) + 360, isFullCircle: false };
            }
        }
    } else {
        ctx.beginPath();
        ctx.arc(originScreen.x, originScreen.y, screenRadius, 0, 2 * Math.PI);
        ctx.stroke();
        visibleAngleRange = calculateVisibleAngleRange(originScreen, screenRadius, canvasWidthCSS, canvasHeightCSS);
    }
    
    ctx.restore();
    
    if (!visibleAngleRange) return;

    const dataRadius = screenRadius / (viewTransform.scale / dpr);
    const drawnAnglesSimple = new Set(); // For degrees mode
    const drawnAnglesComplex = new Map(); // For radians mode - key: "deg-levelAngle"

    lastAngularGridState.forEach(level => {
        const tickAlpha = level.alpha;
        if (tickAlpha < 0.01) return;

        const screenSeparation = screenRadius * (level.angle * Math.PI / 180);
        
        if (screenSeparation < REF_CIRCLE_MIN_TICK_SPACING * 0.5) return;

        const finalColor = `rgba(${colors.feedbackDefault.join(',')}, ${tickAlpha * 0.95})`;

        let anglesToProcess;
        if (visibleAngleRange.isFullCircle) {
            anglesToProcess = [];
            for (let deg = 0; deg < 360; deg += level.angle) {
                anglesToProcess.push(deg);
            }
        } else {
            anglesToProcess = generateOptimizedAngleSequence(
                level.angle,
                visibleAngleRange.minAngle,
                visibleAngleRange.maxAngle
            );
        }

        anglesToProcess.forEach(deg => {
            // Original simple behavior for degrees mode
            if (angleDisplayMode === 'degrees') {
                if (drawnAnglesSimple.has(deg)) return;
            }
            // For radians mode, allow multiple levels per angle
            else if (angleDisplayMode === 'radians') {
                const levelKey = `${deg}-${level.angle}`;
                if (drawnAnglesComplex.has(levelKey)) return; // This specific level already drawn
            }

            const angleRad = deg * Math.PI / 180;
            let labelOptions = { textAlign: 'center', textBaseline: 'middle' };
            
            // In radians mode, use left alignment to minimize visual overlap
            if (angleDisplayMode === 'radians') {
                labelOptions = { textAlign: 'left', textBaseline: 'middle' };
            }
            
            let labelPos;

            ctx.save();
            ctx.strokeStyle = finalColor;
            ctx.lineWidth = GRID_LINEWIDTH;

            if (deg % 90 === 0 && deg < 360) {
                const pointOnCircle = { 
                    x: originScreen.x + screenRadius * Math.cos(angleRad), 
                    y: originScreen.y - screenRadius * Math.sin(angleRad) 
                };

                let tickVec;
                const tickLength = AXIS_TICK_SIZE * 1.5;
                
                switch (deg) {
                    case 0:
                        tickVec = { x: Math.SQRT1_2, y: -Math.SQRT1_2 };
                        labelOptions = { textAlign: 'left', textBaseline: 'bottom' };
                        break;
                    case 90:
                        tickVec = { x: Math.SQRT1_2, y: -Math.SQRT1_2 };
                        labelOptions = { textAlign: 'left', textBaseline: 'bottom' };
                        break;
                    case 180:
                        tickVec = { x: -Math.SQRT1_2, y: -Math.SQRT1_2 };
                        labelOptions = { textAlign: 'right', textBaseline: 'bottom' };
                        break;
                    case 270:
                        tickVec = { x: Math.SQRT1_2, y: Math.SQRT1_2 };
                        labelOptions = { textAlign: 'left', textBaseline: 'top' };
                        break;
                }
                
                const tickEnd = {
                    x: pointOnCircle.x + tickVec.x * tickLength,
                    y: pointOnCircle.y + tickVec.y * tickLength
                };

                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(pointOnCircle.x, pointOnCircle.y);
                ctx.lineTo(tickEnd.x, tickEnd.y);
                ctx.stroke();
                
                labelPos = { x: tickEnd.x, y: tickEnd.y };

            } else {
                const tickStart = { 
                    x: originScreen.x + (screenRadius - POINT_RADIUS) * Math.cos(angleRad), 
                    y: originScreen.y - (screenRadius - POINT_RADIUS) * Math.sin(angleRad) 
                };
                const tickEnd = { 
                    x: originScreen.x + (screenRadius + POINT_RADIUS) * Math.cos(angleRad), 
                    y: originScreen.y - (screenRadius + POINT_RADIUS) * Math.sin(angleRad) 
                };
                if (isTickVisible(tickEnd, canvasWidthCSS, canvasHeightCSS)) {
                    ctx.beginPath();
                    ctx.moveTo(tickStart.x, tickStart.y);
                    ctx.lineTo(tickEnd.x, tickEnd.y);
                    ctx.stroke();
                }
                labelPos = { 
                    x: originScreen.x + (screenRadius + REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN) * Math.cos(angleRad), 
                    y: originScreen.y - (screenRadius + REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN) * Math.sin(angleRad) 
                };
            }
            
            ctx.restore();
            
            let angleText = '';
            if (angleDisplayMode === 'degrees') {
                let precision = Math.max(0, (level.angle.toString().split('.')[1] || '').length);
                
                if (level.angle < 1) {
                    precision = Math.max(precision, Math.ceil(-Math.log10(level.angle)) + 1);
                }
                
                const formattedDeg = parseFloat(deg.toFixed(precision));
                angleText = `${formattedDeg}^{\\circ}`;
            } else {
                if (deg === 0 && angleDisplayMode === 'radians') {
                    angleText = '0';
                } else if (deg !== 0) {
                    const isFineTick = level.angle <= 5;
                    
                    if (isFineTick) {
                        const radianValue = deg * Math.PI / 180;
                        
                        let precision;
                        if (level.angle >= 1) {
                            precision = 3;
                        } else if (level.angle >= 0.1) {
                            precision = 4;
                        } else if (level.angle >= 0.01) {
                            precision = 5;
                        } else if (level.angle >= 0.001) {
                            precision = 6;
                        } else {
                            precision = 7;
                        }
                        
                        let formattedRadian = radianValue.toFixed(precision);
                        
                        if (parseFloat(formattedRadian) !== 0) {
                            angleText = formattedRadian;
                        }
                    } else {
                        const numerator = deg;
                        const denominator = 180;
                        
                        const gcdValue = gcd(numerator, denominator);
                        const simplifiedNum = numerator / gcdValue;
                        const simplifiedDen = denominator / gcdValue;
                        
                        if (simplifiedDen === 1) {
                            if (simplifiedNum === 1) angleText = '\\pi';
                            else if (simplifiedNum === -1) angleText = '-\\pi';
                            else angleText = `${simplifiedNum}\\pi`;
                        } else {
                            if (simplifiedNum === 1) angleText = `\\frac{\\pi}{${simplifiedDen}}`;
                            else if (simplifiedNum === -1) angleText = `-\\frac{\\pi}{${simplifiedDen}}`;
                            else if (simplifiedNum < 0) angleText = `-\\frac{${Math.abs(simplifiedNum)}\\pi}{${simplifiedDen}}`;
                            else angleText = `\\frac{${simplifiedNum}\\pi}{${simplifiedDen}}`;
                        }
                    }
                }
            }

            if (angleText) {
                const labelId = angleDisplayMode === 'radians' 
                    ? `circ-label-${deg}-${level.angle}-${dataRadius.toExponential(15)}`
                    : `circ-label-${deg}-${dataRadius.toExponential(15)}`;
                    
                updateHtmlLabel({ 
                    id: labelId, 
                    content: angleText, 
                    x: labelPos.x, 
                    y: labelPos.y, 
                    color: finalColor, 
                    fontSize: REF_TEXT_KATEX_FONT_SIZE, 
                    options: labelOptions
                });
                
                // Store tracking info differently for each mode
                if (angleDisplayMode === 'degrees') {
                    drawnAnglesSimple.add(deg);
                } else {
                    const levelKey = `${deg}-${level.angle}`;
                    drawnAnglesComplex.set(levelKey, { 
                        levelAngle: level.angle, 
                        alpha: tickAlpha,
                        labelId: labelId 
                    });
                }
            }
        });
    });

    const arrowColor = colors.feedbackDefault;
    let stickyArrowAngle = -Infinity;
    const zeroDegPoint = { x: originScreen.x + screenRadius, y: originScreen.y };
    if (zeroDegPoint.x > -AXIS_LABEL_PADDING && zeroDegPoint.x < canvasWidthCSS + AXIS_LABEL_PADDING && zeroDegPoint.y > -AXIS_LABEL_PADDING && zeroDegPoint.y < canvasHeightCSS + AXIS_LABEL_PADDING) {
        stickyArrowAngle = 0;
    } else {
        const screenRect = { x: 0, y: 0, w: canvasWidthCSS, h: canvasHeightCSS };
        const circle = { x: originScreen.x, y: originScreen.y, r: screenRadius };
        const intersections = getCircleRectIntersections(circle, screenRect);
        let boundaryAngles = intersections.map(p => Math.atan2(originScreen.y - p.y, p.x - originScreen.x));
        const corners = [{x:0,y:0}, {x:screenRect.w,y:0}, {x:screenRect.w,y:screenRect.h}, {x:0,y:screenRect.h}];
        corners.forEach(c => {
            if (distance(c, circle) < circle.r) {
                boundaryAngles.push(Math.atan2(originScreen.y - c.y, c.x - originScreen.x));
            }
        });

        if (boundaryAngles.length > 0) {
            boundaryAngles = boundaryAngles.map(a => (a < 0) ? a + 2 * Math.PI : a).sort((a, b) => a - b);
            let uniqueAngles = [...new Set(boundaryAngles.map(a => parseFloat(a.toFixed(7))))];
            if (uniqueAngles.length > 0) {
                uniqueAngles.push(uniqueAngles[0] + 2 * Math.PI);
                let lastVisibleEndAngle = -Infinity;
                for (let i = 0; i < uniqueAngles.length - 1; i++) {
                    const startAngle = uniqueAngles[i];
                    const endAngle = uniqueAngles[i+1];
                    const midAngle = (startAngle + endAngle) / 2;
                    const midPoint = { x: circle.x + circle.r * Math.cos(midAngle), y: circle.y - circle.r * Math.sin(midAngle) };
                    if (midPoint.x > 0 && midPoint.x < screenRect.w && midPoint.y > 0 && midPoint.y < screenRect.h) {
                        lastVisibleEndAngle = endAngle;
                    }
                }
                if (lastVisibleEndAngle > -Infinity) {
                    stickyArrowAngle = lastVisibleEndAngle % (2 * Math.PI);
                }
            }
        }
    }

    if (stickyArrowAngle > -Infinity) {
        const arrowAngle = stickyArrowAngle;
        const tipPos = { x: originScreen.x + screenRadius * Math.cos(arrowAngle), y: originScreen.y - screenRadius * Math.sin(arrowAngle) };
        const tangentVec = { x: -Math.sin(arrowAngle), y: -Math.cos(arrowAngle) };
        const radialVec = { x: Math.cos(arrowAngle), y: -Math.sin(arrowAngle) };
        const p1 = { x: tipPos.x - AXIS_ARROW_SIZE * tangentVec.x + (AXIS_ARROW_SIZE / 2) * radialVec.x, y: tipPos.y - AXIS_ARROW_SIZE * tangentVec.y + (AXIS_ARROW_SIZE / 2) * radialVec.y };
        const p2 = { x: tipPos.x - AXIS_ARROW_SIZE * tangentVec.x - (AXIS_ARROW_SIZE / 2) * radialVec.x, y: tipPos.y - AXIS_ARROW_SIZE * tangentVec.y - (AXIS_ARROW_SIZE / 2) * radialVec.y };
        ctx.save();
        ctx.fillStyle = `rgba(${arrowColor.join(',')}, 1.0)`;
        ctx.beginPath();
        ctx.moveTo(tipPos.x, tipPos.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        let labelPos;
        if (arrowAngle === 0) {
            labelPos = {
                x: tipPos.x - POLAR_THETA_LABEL_DISTANCE,
                y: tipPos.y + POLAR_THETA_LABEL_ARROW_DIST + AXIS_ARROW_SIZE
            };
        } else {
            const radialVecInward = { x: -Math.cos(arrowAngle), y: Math.sin(arrowAngle) };
            labelPos = {
                x: tipPos.x + radialVecInward.x * (POLAR_THETA_LABEL_ARROW_DIST + AXIS_ARROW_SIZE) + tangentVec.x * POLAR_THETA_LABEL_DISTANCE,
                y: tipPos.y + radialVecInward.y * (POLAR_THETA_LABEL_ARROW_DIST + AXIS_ARROW_SIZE) + tangentVec.y * POLAR_THETA_LABEL_DISTANCE
            };
        }
        updateHtmlLabel({ id: `theta-label-sticky`, content: '\\theta', x: labelPos.x, y: labelPos.y, color: `rgba(${arrowColor.join(',')}, 1.0)`, fontSize: AXIS_NAME_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } });
    }
}

function getCircleRectIntersections(circle, rect) {
    // This function has no constants to refactor
    const { x: cx, y: cy, r } = circle;
    const { x: rx, y: ry, w: rw, h: rh } = rect;
    const intersections = [];
    const checkLine = (x1, y1, x2, y2) => {
        const dx = x2 - x1, dy = y2 - y1;
        const a = dx * dx + dy * dy;
        const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
        const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
        const discriminant = b * b - 4 * a * c;
        if (discriminant < 0) return;
        const sqrtD = Math.sqrt(discriminant);
        const t1 = (-b + sqrtD) / (2 * a);
        const t2 = (-b - sqrtD) / (2 * a);
        [t1, t2].forEach(t => {
            if (t >= 0 && t <= 1) {
                intersections.push({ x: x1 + t * dx, y: y1 + t * dy });
            }
        });
    };
    checkLine(rx, ry, rx + rw, ry);
    checkLine(rx + rw, ry, rx + rw, ry + rh);
    checkLine(rx + rw, ry + rh, rx, ry + rh);
    checkLine(rx, ry + rh, rx, ry);
    return intersections;
}

export function isCircleInView(circleX, circleY, circleRadius, canvasWidth, canvasHeight) {
    // This function has no constants to refactor
    if (circleX + circleRadius < 0 ||
        circleX - circleRadius > canvasWidth ||
        circleY + circleRadius < 0 ||
        circleY - circleRadius > canvasHeight) {
        return false;
    }
    return true;
}

function drawZeroTickAndTickLabel(ctx, origin, canvasWidth, canvasHeight, coordsDisplayMode, updateHtmlLabel, colors) {
    const tickColor = `rgba(${colors.axisTickLabel.join(',')}, ${AXIS_TICK_LABEL_ALPHA})`;
    const longTickSize = AXIS_TICK_SIZE * AXIS_MAJOR_TICK_SCALE_FACTOR;
    
    ctx.save();
    ctx.strokeStyle = tickColor;
    ctx.lineWidth = MAJOR_TICK_LINE_WIDTH;
    ctx.setLineDash([]);
    
    const yLength = longTickSize;
    const xLength = yLength / Math.tan(ORIGIN_TICK_ANGLE_RAD);
    
    const endX = origin.x - xLength;
    const endY = origin.y + yLength;
    
    ctx.beginPath();
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
    ctx.restore();
    
    updateHtmlLabel({
        id: 'tick-label-origin',
        content: ORIGIN_LABEL_TEXT,
        x: origin.x - AXIS_TICK_SIZE - AXIS_LABEL_OFFSET,
        y: origin.y + AXIS_TICK_SIZE + AXIS_LABEL_OFFSET,
        color: tickColor,
        fontSize: AXIS_TICK_FONT_SIZE,
        options: { textAlign: 'right', textBaseline: 'top' }
    });
}

export function drawAxes(ctx, htmlOverlay, { canvas, dpr, coordsDisplayMode, viewTransform, angleDisplayMode, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState, updateHtmlLabel) {
    ctx.save();
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;
    const origin = dataToScreen({ x: 0, y: 0 });

    const drawAxisWithArrows = (x1, y1, x2, y2) => {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        const angle = Math.atan2(y2 - y1, x2 - x1);
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - AXIS_ARROW_SIZE * Math.cos(angle - AXIS_ARROW_ANGLE_RAD), y2 - AXIS_ARROW_SIZE * Math.sin(angle - AXIS_ARROW_ANGLE_RAD));
        ctx.lineTo(x2 - AXIS_ARROW_SIZE * Math.cos(angle + AXIS_ARROW_ANGLE_RAD), y2 - AXIS_ARROW_SIZE * Math.sin(angle + AXIS_ARROW_ANGLE_RAD));
        ctx.closePath();
        ctx.fill();
    };

    const drawTicksAndLabels = (interval1, alpha1, interval2, alpha2, isPolar) => {
        const drawnXPositions = new Map();
        const drawnYPositions = new Map();
        
        const addTicksForInterval = (interval, alpha, isCoarser) => {
            if (!interval || alpha < MIN_ALPHA_FOR_DRAWING) return;
            const topLeftData = screenToData({ x: 0, y: 0 });
            const bottomRightData = screenToData({ x: canvasWidth, y: canvasHeight });
            const localZeroThreshold = interval * GEOMETRY_CALCULATION_EPSILON;
            
            if (isPolar) {
                const maxRadiusData = Math.hypot(Math.max(Math.abs(topLeftData.x), Math.abs(bottomRightData.x)), Math.max(Math.abs(topLeftData.y), Math.abs(bottomRightData.y))) * POLAR_AXIS_RADIUS_BUFFER_FACTOR;
                
                for (let r_data = interval; r_data <= maxRadiusData; r_data += interval) {
                    if (Math.abs(r_data) < localZeroThreshold) continue;
                    const existing = drawnXPositions.get(r_data);
                    if (!existing) {
                        drawnXPositions.set(r_data, { alpha, isCoarser });
                    } else if (isCoarser) {
                        drawnXPositions.set(r_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                    } else {
                        if (!existing.isCoarser) {
                            drawnXPositions.set(r_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                        }
                    }
                }
            } else {
                const startTickX = Math.floor(topLeftData.x / interval) * interval;
                const endTickX = Math.ceil(bottomRightData.x / interval) * interval;
                const startTickY = Math.floor(bottomRightData.y / interval) * interval;
                const endTickY = Math.ceil(topLeftData.y / interval) * interval;
                
                for (let x_data = startTickX; x_data <= endTickX; x_data += interval) {
                    if (Math.abs(x_data) < localZeroThreshold) continue;
                    const existing = drawnXPositions.get(x_data);
                    if (!existing) {
                        drawnXPositions.set(x_data, { alpha, isCoarser });
                    } else if (isCoarser) {
                        drawnXPositions.set(x_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                    } else {
                        if (!existing.isCoarser) {
                            drawnXPositions.set(x_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                        }
                    }
                }
                
                for (let y_data = startTickY; y_data <= endTickY; y_data += interval) {
                    if (Math.abs(y_data) < localZeroThreshold) continue;
                    const existing = drawnYPositions.get(y_data);
                    if (!existing) {
                        drawnYPositions.set(y_data, { alpha, isCoarser });
                    } else if (isCoarser) {
                        drawnYPositions.set(y_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                    } else {
                        if (!existing.isCoarser) {
                            drawnYPositions.set(y_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                        }
                    }
                }
            }
        };
        
        const interval1IsCoarser = !interval2 || interval1 >= interval2;
        
        addTicksForInterval(interval1, alpha1, interval1IsCoarser);
        addTicksForInterval(interval2, alpha2, !interval1IsCoarser);
        
        drawnXPositions.forEach((tickInfo, x_data) => {
            const effectiveAlpha = tickInfo.isCoarser ? 1.0 : tickInfo.alpha;
            const tickLabelColor = `rgba(${colors.axisTickLabel.join(',')}, ${AXIS_TICK_LABEL_ALPHA * effectiveAlpha})`;
            ctx.strokeStyle = tickLabelColor;
            ctx.lineWidth = GRID_LINEWIDTH;
            
            let sourceInterval = interval1;
            if (interval2 && Math.abs(x_data % interval2) < Math.abs(x_data % interval1)) {
                sourceInterval = interval2;
            }
            const screenSpacing = sourceInterval * viewTransform.scale;
            let sigFigsForLabel = 0;
            if (screenSpacing > TICK_LABEL_SIGFIG_THRESH_1) sigFigsForLabel = 3; 
            else if (screenSpacing > TICK_LABEL_SIGFIG_THRESH_2) sigFigsForLabel = 2; 
            else if (screenSpacing > TICK_LABEL_SIGFIG_THRESH_3) sigFigsForLabel = 1; 
            else sigFigsForLabel = 0;
            
            const decimalPlacesInInterval = sourceInterval > 0 ? -Math.floor(Math.log10(sourceInterval)) : 0;
            if (decimalPlacesInInterval > 0) {
                sigFigsForLabel = Math.max(sigFigsForLabel, decimalPlacesInInterval + 1);
            }
            
            if (isPolar) {
                const labelText = formatNumber(x_data, sigFigsForLabel);
                const stableIdPart = x_data.toExponential(15);
                
                const isYAxisOnScreen = origin.y > -AXIS_LABEL_PADDING && origin.y < canvasHeight + AXIS_LABEL_PADDING;
                const isXAxisOnScreen = origin.x > -AXIS_LABEL_PADDING && origin.x < canvasWidth + AXIS_LABEL_PADDING;

                const pX = dataToScreen({ x: x_data, y: 0 });
                if (isYAxisOnScreen && pX.x > -AXIS_LABEL_PADDING && pX.x < canvasWidth + AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(pX.x, origin.y - AXIS_TICK_SIZE / 2); 
                    ctx.lineTo(pX.x, origin.y + AXIS_TICK_SIZE / 2); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-x-${stableIdPart}`, 
                        content: labelText, 
                        x: pX.x, 
                        y: origin.y + AXIS_TICK_SIZE + AXIS_LABEL_OFFSET, 
                        color: tickLabelColor, 
                        fontSize: AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'center', textBaseline: 'top' } 
                    });
                }
                
                const pNegX = dataToScreen({ x: -x_data, y: 0 });
                if (isYAxisOnScreen && pNegX.x > -AXIS_LABEL_PADDING && pNegX.x < canvasWidth + AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(pNegX.x, origin.y - AXIS_TICK_SIZE / 2); 
                    ctx.lineTo(pNegX.x, origin.y + AXIS_TICK_SIZE / 2); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-negx-${stableIdPart}`, 
                        content: labelText, 
                        x: pNegX.x, 
                        y: origin.y + AXIS_TICK_SIZE + AXIS_LABEL_OFFSET, 
                        color: tickLabelColor, 
                        fontSize: AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'center', textBaseline: 'top' } 
                    });
                }
                
                const pPosY = dataToScreen({ x: 0, y: x_data });
                if (isXAxisOnScreen && pPosY.y > -AXIS_LABEL_PADDING && pPosY.y < canvasHeight + AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(origin.x - AXIS_TICK_SIZE / 2, pPosY.y); 
                    ctx.lineTo(origin.x + AXIS_TICK_SIZE / 2, pPosY.y); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-posy-${stableIdPart}`, 
                        content: labelText, 
                        x: origin.x - AXIS_TICK_SIZE - AXIS_LABEL_OFFSET, 
                        y: pPosY.y, 
                        color: tickLabelColor, 
                        fontSize: AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'right', textBaseline: 'middle' } 
                    });
                }
                
                const pNegY = dataToScreen({ x: 0, y: -x_data });
                if (isXAxisOnScreen && pNegY.y > -AXIS_LABEL_PADDING && pNegY.y < canvasHeight + AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(origin.x - AXIS_TICK_SIZE / 2, pNegY.y); 
                    ctx.lineTo(origin.x + AXIS_TICK_SIZE / 2, pNegY.y); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-negy-${stableIdPart}`, 
                        content: labelText, 
                        x: origin.x - AXIS_TICK_SIZE - AXIS_LABEL_OFFSET, 
                        y: pNegY.y, 
                        color: tickLabelColor, 
                        fontSize: AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'right', textBaseline: 'middle' } 
                    });
                }
            } else {
                const screenX = dataToScreen({ x: x_data, y: 0 }).x;
                ctx.beginPath(); 
                ctx.moveTo(screenX, origin.y); 
                ctx.lineTo(screenX, origin.y + AXIS_TICK_SIZE); 
                ctx.stroke();
                
                const getStableId = (prefix, num) => `${prefix}-${num.toExponential(15)}`;
                updateHtmlLabel({ 
                    id: getStableId('tick-label-x', x_data), 
                    content: formatNumber(x_data, sigFigsForLabel), 
                    x: screenX, 
                    y: origin.y + AXIS_TICK_SIZE + AXIS_LABEL_OFFSET, 
                    color: tickLabelColor, 
                    fontSize: AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'center', textBaseline: 'top' } 
                });
            }
        });
        
        if (!isPolar) {
            drawnYPositions.forEach((tickInfo, y_data) => {
                const effectiveAlpha = tickInfo.isCoarser ? 1.0 : tickInfo.alpha;
                const tickLabelColor = `rgba(${colors.axisTickLabel.join(',')}, ${AXIS_TICK_LABEL_ALPHA * effectiveAlpha})`;
                ctx.strokeStyle = tickLabelColor;
                ctx.lineWidth = GRID_LINEWIDTH;
                
                let sourceInterval = interval1;
                if (interval2 && Math.abs(y_data % interval2) < Math.abs(y_data % interval1)) {
                    sourceInterval = interval2;
                }
                const screenSpacing = sourceInterval * viewTransform.scale;
                let sigFigsForLabel = 0;
                if (screenSpacing > TICK_LABEL_SIGFIG_THRESH_1) sigFigsForLabel = 3; 
                else if (screenSpacing > TICK_LABEL_SIGFIG_THRESH_2) sigFigsForLabel = 2; 
                else if (screenSpacing > TICK_LABEL_SIGFIG_THRESH_3) sigFigsForLabel = 1; 
                else sigFigsForLabel = 0;
                
                const decimalPlacesInInterval = sourceInterval > 0 ? -Math.floor(Math.log10(sourceInterval)) : 0;
                if (decimalPlacesInInterval > 0) {
                    sigFigsForLabel = Math.max(sigFigsForLabel, decimalPlacesInInterval + 1);
                }
                
                const screenY = dataToScreen({ x: 0, y: y_data }).y;
                let yLabelContent = formatNumber(y_data, sigFigsForLabel);
                if (coordsDisplayMode === COORDS_DISPLAY_MODE_COMPLEX && yLabelContent !== "0") {
                    if (yLabelContent === '1') yLabelContent = IMAGINARY_UNIT_SYMBOL;
                    else if (yLabelContent === '-1') yLabelContent = `-${IMAGINARY_UNIT_SYMBOL}`;
                    else yLabelContent += IMAGINARY_UNIT_SYMBOL;
                }
                
                ctx.beginPath(); 
                ctx.moveTo(origin.x, screenY); 
                ctx.lineTo(origin.x - AXIS_TICK_SIZE, screenY); 
                ctx.stroke();
                
                const getStableId = (prefix, num) => `${prefix}-${num.toExponential(15)}`;
                updateHtmlLabel({ 
                    id: getStableId('tick-label-y', y_data), 
                    content: yLabelContent, 
                    x: origin.x - AXIS_TICK_SIZE - AXIS_LABEL_OFFSET, 
                    y: screenY, 
                    color: tickLabelColor, 
                    fontSize: AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'right', textBaseline: 'middle' } 
                });
            });
        }
    };

    ctx.lineWidth = AXIS_LINE_WIDTH;
    ctx.strokeStyle = colors.axis;
    ctx.fillStyle = colors.axis;

    if (coordsDisplayMode === COORDS_DISPLAY_MODE_POLAR) {
        const { interval1, interval2, alpha1, alpha2 } = lastGridState;
        ctx.lineWidth = GRID_LINEWIDTH;
        
        const posXVisible = canvasWidth > origin.x;
        const negXVisible = 0 < origin.x;
        const posYVisible = 0 < origin.y;
        const negYVisible = canvasHeight > origin.y;
        
        if (posXVisible) {
            drawAxisWithArrows(origin.x, origin.y, canvasWidth, origin.y);
            updateHtmlLabel({ 
                id: 'axis-label-r-posx', 
                content: POLAR_RADIUS_SYMBOL, 
                x: canvasWidth - AXIS_ARROW_SIZE - X_AXIS_LABEL_ARROW_DIST, 
                y: origin.y - X_AXIS_LABEL_DISTANCE, 
                color: colors.axis, 
                fontSize: AXIS_NAME_FONT_SIZE, 
                options: { textAlign: 'center', textBaseline: 'bottom' } 
            });
        }
        
        if (negXVisible) {
            drawAxisWithArrows(origin.x, origin.y, 0, origin.y);
            updateHtmlLabel({ 
                id: 'axis-label-r-negx', 
                content: POLAR_RADIUS_SYMBOL, 
                x: AXIS_ARROW_SIZE + X_AXIS_LABEL_ARROW_DIST, 
                y: origin.y - X_AXIS_LABEL_DISTANCE, 
                color: colors.axis, 
                fontSize: AXIS_NAME_FONT_SIZE, 
                options: { textAlign: 'center', textBaseline: 'bottom' } 
            });
        }
        
        if (posYVisible) {
            drawAxisWithArrows(origin.x, origin.y, origin.x, 0);
            updateHtmlLabel({ 
                id: 'axis-label-r-posy', 
                content: POLAR_RADIUS_SYMBOL, 
                x: origin.x + Y_AXIS_LABEL_DISTANCE, 
                y: AXIS_ARROW_SIZE + Y_AXIS_LABEL_ARROW_DIST, 
                color: colors.axis, 
                fontSize: AXIS_NAME_FONT_SIZE, 
                options: { textAlign: 'left', textBaseline: 'middle' } 
            });
        }
        
        if (negYVisible) {
            drawAxisWithArrows(origin.x, origin.y, origin.x, canvasHeight);
            updateHtmlLabel({ 
                id: 'axis-label-r-negy', 
                content: POLAR_RADIUS_SYMBOL, 
                x: origin.x + Y_AXIS_LABEL_DISTANCE, 
                y: canvasHeight - AXIS_ARROW_SIZE - Y_AXIS_LABEL_ARROW_DIST, 
                color: colors.axis, 
                fontSize: AXIS_NAME_FONT_SIZE, 
                options: { textAlign: 'left', textBaseline: 'middle' } 
            });
        }
        
        drawTicksAndLabels(interval1, alpha1, interval2, alpha2, true);
        drawPolarReferenceCircle(ctx, htmlOverlay, updateHtmlLabel, 0, 0, { canvas, dpr, coordsDisplayMode, viewTransform, angleDisplayMode, colors }, dataToScreen, lastAngularGridState);
    } else {
        if (origin.y > 0 && origin.y < canvasHeight) drawAxisWithArrows(0, origin.y, canvasWidth, origin.y);
        if (origin.x > 0 && origin.x < canvasWidth) drawAxisWithArrows(origin.x, canvasHeight, origin.x, 0);
        
        let xLabel = 'x';
        let yLabel = 'y';
        if (coordsDisplayMode === COORDS_DISPLAY_MODE_COMPLEX) {
            xLabel = COMPLEX_REAL_LABEL;
            yLabel = COMPLEX_IMAGINARY_LABEL;
        }
        
        updateHtmlLabel({ 
            id: 'axis-label-x', 
            content: xLabel, 
            x: canvasWidth - AXIS_ARROW_SIZE - X_AXIS_LABEL_ARROW_DIST, 
            y: origin.y - X_AXIS_LABEL_DISTANCE, 
            color: colors.axis, 
            fontSize: AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'center', textBaseline: 'bottom' } 
        });
        
        updateHtmlLabel({ 
            id: 'axis-label-y', 
            content: yLabel, 
            x: origin.x + Y_AXIS_LABEL_DISTANCE, 
            y: AXIS_ARROW_SIZE + Y_AXIS_LABEL_ARROW_DIST, 
            color: colors.axis, 
            fontSize: AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'left', textBaseline: 'middle' } 
        });
        
        drawTicksAndLabels(lastGridState.interval1, lastGridState.alpha1, lastGridState.interval2, lastGridState.alpha2, false);
    }

    drawZeroTickAndTickLabel(ctx, origin, canvasWidth, canvasHeight, coordsDisplayMode, updateHtmlLabel, colors);

    ctx.restore();
}

export function drawGrid(ctx, { gridDisplayMode, canvas, dpr, viewTransform, gridAlpha, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState) {
    
    if (gridDisplayMode === GRID_DISPLAY_MODE_NONE) return;

    ctx.save();

    const origin = dataToScreen({ x: 0, y: 0 });
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;

    if (gridDisplayMode === GRID_DISPLAY_MODE_POLAR) {
        const topLeftData = screenToData({ x: 0, y: 0 });
        const bottomRightData = screenToData({ x: canvasWidth, y: canvasHeight });
        const maxDataRadius = Math.hypot(Math.max(Math.abs(topLeftData.x), Math.abs(bottomRightData.x)), Math.max(Math.abs(topLeftData.y), Math.abs(bottomRightData.y)));
        const transitionRadius = Math.min(canvasWidth, canvasHeight) * POLAR_TO_LINE_TRANSITION_RADIUS_FACTOR;

        const drawPolarCircles = (interval, alpha) => {
            if (!interval || alpha < MIN_ALPHA_FOR_DRAWING) return;
            
            const screenSpacing = interval * viewTransform.scale / dpr;
            if (screenSpacing < GRID_POLAR_CIRCLE_MIN_SPACING) return;

            ctx.strokeStyle = `rgba(${colors.grid.join(',')}, ${alpha * gridAlpha})`;
            ctx.lineWidth = GRID_LINEWIDTH;
            for (let r = interval; r <= maxDataRadius; r += interval) {
                const screenRadius = r * viewTransform.scale / dpr;
                
                if (screenRadius > transitionRadius) {
                    const circle = { x: origin.x, y: origin.y, r: screenRadius };
                    const intersections = getCircleRectIntersections(circle, {x: 0, y: 0, w: canvasWidth, h: canvasHeight});
                    if (intersections.length >= 2) {
                        let p1 = intersections[0], p2 = intersections[1], maxDistSq = 0;
                        for (let i = 0; i < intersections.length; i++) {
                            for (let j = i + 1; j < intersections.length; j++) {
                                const dSq = (intersections[i].x - intersections[j].x)**2 + (intersections[i].y - intersections[j].y)**2;
                                if (dSq > maxDistSq) {
                                    maxDistSq = dSq;
                                    p1 = intersections[i];
                                    p2 = intersections[j];
                                }
                            }
                        }
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                } else {
                    if (isCircleInView(origin.x, origin.y, screenRadius, canvasWidth, canvasHeight)) {
                        ctx.beginPath();
                        ctx.arc(origin.x, origin.y, screenRadius, 0, RADIANS_IN_CIRCLE);
                        ctx.stroke();
                    }
                }
            }
        };

        drawPolarCircles(lastGridState.interval1, lastGridState.alpha1);
        drawPolarCircles(lastGridState.interval2, lastGridState.alpha2);

        const screenRadiusForSpokes = maxDataRadius * viewTransform.scale / dpr;
        const drawnAngles = new Set();
        
        let visibleAngleInfo = null;
        if (screenRadiusForSpokes < canvasWidth * 10) {
            visibleAngleInfo = { ranges: [[0, 360]], isFullCircle: true };
        } else {
            visibleAngleInfo = calculateVisibleAngleRange(origin, screenRadiusForSpokes, canvasWidth, canvasHeight);
        }

        if (!visibleAngleInfo) {
            ctx.restore();
            return;
        }

        lastAngularGridState.forEach(level => {
            if (level.alpha < MIN_ALPHA_FOR_DRAWING) return;

            const screenSeparation = screenRadiusForSpokes * (level.angle * Math.PI / 180);
            if (screenSeparation < GRID_POLAR_SPOKE_MIN_SPACING && screenRadiusForSpokes > GRID_POLAR_SPOKE_MIN_RADIUS) return;

            ctx.strokeStyle = `rgba(${colors.grid.join(',')}, ${level.alpha * gridAlpha})`;
            ctx.lineWidth = GRID_LINEWIDTH;

            let anglesToProcess = [];
            if (visibleAngleInfo.isFullCircle) {
                for (let deg = 0; deg < DEGREES_IN_CIRCLE; deg += level.angle) {
                    anglesToProcess.push(deg);
                }
            } else {
                visibleAngleInfo.ranges.forEach(range => {
                    const [min, max] = range;
                    anglesToProcess.push(...generateOptimizedAngleSequence(level.angle, min, max));
                });
                anglesToProcess = [...new Set(anglesToProcess)];
            }

            anglesToProcess.forEach(angle => {
                if (drawnAngles.has(angle)) return;

                const rad = angle * Math.PI / 180;
                const endX = origin.x + screenRadiusForSpokes * Math.cos(rad);
                const endY = origin.y - screenRadiusForSpokes * Math.sin(rad);
                ctx.beginPath();
                ctx.moveTo(origin.x, origin.y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                drawnAngles.add(angle);
            });
        });

    } else {
        const drawGridElements = (interval, alpha) => {
            if (!interval || alpha < MIN_ALPHA_FOR_DRAWING) return;
            const gridElementColor = `rgba(${colors.grid.join(',')}, ${alpha * gridAlpha})`;

            const start = screenToData({ x: 0, y: canvasHeight });
            const end = screenToData({ x: canvasWidth, y: 0 });
            const startTickX = Math.floor(start.x / interval) * interval;
            const endTickX = Math.ceil(end.x / interval) * interval;
            const startTickY = Math.floor(start.y / interval) * interval;
            const endTickY = Math.ceil(end.y / interval) * interval;

            if (gridDisplayMode === GRID_DISPLAY_MODE_LINES) {
                ctx.strokeStyle = gridElementColor;
                ctx.lineWidth = GRID_LINEWIDTH;
                for (let x = startTickX; x <= endTickX; x += interval) {
                    const screenX = dataToScreen({ x: x, y: 0 }).x;
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, canvasHeight);
                    ctx.stroke();
                }
                for (let y = startTickY; y <= endTickY; y += interval) {
                    const screenY = dataToScreen({ x: 0, y: y }).y;
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(canvasWidth, screenY);
                    ctx.stroke();
                }
            } else if (gridDisplayMode === GRID_DISPLAY_MODE_POINTS) {
                ctx.fillStyle = gridElementColor;
                const pointRadius = GRID_POINT_RADIUS * dpr;
                for (let x = startTickX; x <= endTickX; x += interval) {
                    for (let y = startTickY; y <= endTickY; y += interval) {
                        const screenPos = dataToScreen({ x: x, y: y });
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, pointRadius, 0, RADIANS_IN_CIRCLE);
                        ctx.fill();
                    }
                }
            } else if (gridDisplayMode === GRID_DISPLAY_MODE_TRIANGULAR) {
                ctx.fillStyle = gridElementColor;
                const pointRadius = GRID_POINT_RADIUS * dpr;
                const y_step = interval * TRIANGULAR_GRID_Y_STEP_FACTOR;
                
                const startTickY_tri = Math.floor(start.y / y_step) * y_step;
                const endTickY_tri = Math.ceil(end.y / y_step) * y_step;
                
                for (let y = startTickY_tri; y <= endTickY_tri; y += y_step) {
                    const rowIndex = Math.round(y / y_step);
                    const x_offset = (rowIndex % 2 !== 0) ? interval / 2 : 0;
                    for (let x = startTickX; x <= endTickX; x += interval) {
                        const finalX = x + x_offset;
                        const screenPos = dataToScreen({ x: finalX, y: y });
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, pointRadius, 0, RADIANS_IN_CIRCLE);
                        ctx.fill();
                    }
                }
            }
        };
        drawGridElements(lastGridState.interval1, lastGridState.alpha1);
        drawGridElements(lastGridState.interval2, lastGridState.alpha2);
    }
    ctx.restore();
}

export function drawAngleArc(ctx, centerScreen, dataStartAngleRad, dataEndAngleRad, radius, color, isDashed = false) {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = GRID_LINEWIDTH;
    ctx.setLineDash(isDashed ? DASH_PATTERN_SMALL : []);
    const canvasStartAngle = -dataStartAngleRad;
    const canvasEndAngle = -dataEndAngleRad;
    let signedAngleDiffData = normalizeAngleToPi(dataEndAngleRad - dataStartAngleRad);
    ctx.beginPath();
    ctx.arc(centerScreen.x, centerScreen.y, radius, canvasStartAngle, canvasEndAngle, signedAngleDiffData > 0);
    ctx.stroke();
    ctx.restore();
}

function drawCenterSymbol(ctx, point, dataToScreen, colors) {
    const screenPos = dataToScreen(point); const radius = CENTER_POINT_VISUAL_RADIUS;
    ctx.strokeStyle = colors.defaultStroke;
    ctx.setLineDash([]); ctx.lineWidth = LINE_WIDTH;
    if (point.type === 'center_rotate_scale') {
        ctx.beginPath(); ctx.arc(screenPos.x, screenPos.y, radius, 0, 2 * Math.PI); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(screenPos.x - radius, screenPos.y); ctx.lineTo(screenPos.x + radius, screenPos.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(screenPos.x, screenPos.y - radius); ctx.lineTo(screenPos.x, screenPos.y + radius); ctx.stroke();
    } else if (point.type === 'center_rotate_only') {
        ctx.beginPath(); ctx.arc(screenPos.x, screenPos.y, radius, 0, 2 * Math.PI); ctx.stroke();
    } else if (point.type === 'center_scale_only') {
        ctx.beginPath(); ctx.moveTo(screenPos.x - radius, screenPos.y); ctx.lineTo(screenPos.x + radius, screenPos.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(screenPos.x, screenPos.y - radius); ctx.lineTo(screenPos.x, screenPos.y + radius); ctx.stroke();
    }
}

export function drawPoint(ctx, point, { selectedPointIds, selectedCenterIds, activeCenterId, currentColor, colors }, dataToScreen) {
        let isSelected;
    if (point.type === POINT_TYPE_REGULAR) {
        isSelected = selectedPointIds.includes(point.id);
    } else {
        isSelected = selectedCenterIds.includes(point.id);
    }

    const pointColor = point.color || currentColor;
    const screenPos = dataToScreen(point);

    if (point.type !== POINT_TYPE_REGULAR) {
        drawCenterSymbol(ctx, point, dataToScreen, colors);
    } else {
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, POINT_RADIUS, 0, RADIANS_IN_CIRCLE);
        ctx.fillStyle = pointColor;
        ctx.fill();
    }

    if (isSelected) {
        ctx.save();
        ctx.shadowColor = point.id === activeCenterId ? colors.activeCenterGlow : colors.selectionGlow;
        ctx.shadowBlur = SELECTION_GLOW_BLUR_RADIUS;
        ctx.globalAlpha = SELECTION_GLOW_ALPHA;

        ctx.beginPath();
        const glowRadius = point.type !== POINT_TYPE_REGULAR ? CENTER_POINT_VISUAL_RADIUS + SELECTION_GLOW_RADIUS_OFFSET : POINT_RADIUS + SELECTION_GLOW_RADIUS_OFFSET;
        ctx.arc(screenPos.x, screenPos.y, glowRadius, 0, RADIANS_IN_CIRCLE);
        ctx.strokeStyle = point.id === activeCenterId ? colors.activeCenterGlow : colors.selectionGlow;
        ctx.lineWidth = SELECTION_GLOW_LINE_WIDTH;
        ctx.stroke();

        ctx.restore();
    }
}

export function drawAllEdges(ctx, { allEdges, selectedEdgeIds, isDragConfirmed, dragPreviewPoints, currentColor, colors }, dataToScreen, findPointById, getEdgeId) {
    ctx.lineWidth = LINE_WIDTH;
    allEdges.forEach(edge => {
        const p1_orig = findPointById(edge.id1);
        const p2_orig = findPointById(edge.id2);
        if (!p1_orig || !p2_orig || p1_orig.type !== POINT_TYPE_REGULAR || p2_orig.type !== POINT_TYPE_REGULAR) return;

        let p1_render = { ...p1_orig };
        let p2_render = { ...p2_orig };
        let isBeingDragged = false;

        if (isDragConfirmed && dragPreviewPoints.length > 0) {
            const p1Preview = dragPreviewPoints.find(dp => dp.id === p1_orig.id);
            const p2Preview = dragPreviewPoints.find(dp => dp.id === p2_orig.id);
            if (p1Preview) { p1_render.x = p1Preview.x; p1_render.y = p1Preview.y; }
            if (p2Preview) { p2_render.x = p2Preview.x; p2_render.y = p2Preview.y; }
            if (p1Preview || p2Preview) isBeingDragged = true;
        }

        const p1Screen = dataToScreen(p1_render);
        const p2Screen = dataToScreen(p2_render);
        const edgeId = getEdgeId(edge);
        const isSelected = selectedEdgeIds.includes(edgeId);

        ctx.beginPath();
        ctx.moveTo(p1Screen.x, p1Screen.y);
        ctx.lineTo(p2Screen.x, p2Screen.y);

        const color1 = p1_orig.color || currentColor;
        const color2 = p2_orig.color || currentColor;
        if (color1 === color2) {
            ctx.strokeStyle = color1;
        } else {
            const gradient = ctx.createLinearGradient(p1Screen.x, p1Screen.y, p2Screen.x, p2Screen.y);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);
            ctx.strokeStyle = gradient;
        }

        ctx.setLineDash(isBeingDragged ? DASH_PATTERN : []);
        ctx.lineWidth = LINE_WIDTH;
        ctx.stroke();
        ctx.setLineDash([]);

        if (isSelected) {
            ctx.beginPath();
            ctx.moveTo(p1Screen.x, p1Screen.y);
            ctx.lineTo(p2Screen.x, p2Screen.y);
            ctx.strokeStyle = colors.selectionGlow;
            ctx.globalAlpha = SELECTION_GLOW_ALPHA;
            ctx.lineWidth = LINE_WIDTH + EDGE_SELECTION_GLOW_WIDTH_OFFSET;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }
    });
    ctx.setLineDash([]);
    ctx.strokeStyle = colors.defaultStroke;
}

export function drawDragFeedback(ctx, htmlOverlay, targetPointId, currentPointStates, { lastGridState, showDistances, showAngles, distanceSigFigs, angleDisplayMode, angleSigFigs, currentShiftPressed, viewTransform, colors }, dataToScreen, findNeighbors, getEdgeId, isSnapping = false, excludedEdgeId = null, updateHtmlLabel = null) {
        const feedbackColor = isSnapping ? colors.feedbackSnapped : `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;

    const livePoints = new Map(currentPointStates.map(p => [p.id, { ...p }]));
    const getLivePoint = (id) => livePoints.get(id);

    const vertex = getLivePoint(targetPointId);
    if (!vertex) return;

    const neighbors = findNeighbors(vertex.id).map(getLivePoint).filter(Boolean);
    if (neighbors.length === 0) return;

    const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

    const isPointOnGrid = (point, interval) => {
        if (!interval || interval <= 0) return false;
        const epsilon = interval * GEOMETRY_CALCULATION_EPSILON;
        const isOnGridX = Math.abs(point.x / interval - Math.round(point.x / interval)) < epsilon;
        const isOnGridY = Math.abs(point.y / interval - Math.round(point.y / interval)) < epsilon;
        return isOnGridX && isOnGridY;
    };

    const vertexScreen = dataToScreen(vertex);

    neighbors.forEach(neighbor => {
        const dist = distance(vertex, neighbor);
        if (dist < GEOMETRY_CALCULATION_EPSILON) return;

        const currentEdgeId = getEdgeId({ id1: vertex.id, id2: neighbor.id });

        if (currentEdgeId !== excludedEdgeId) {
            if (showDistances) {
                let distText;
                const areBothPointsOnGrid = gridInterval && isPointOnGrid(vertex, gridInterval) && isPointOnGrid(neighbor, gridInterval);
                if (areBothPointsOnGrid) {
                    const deltaX = vertex.x - neighbor.x;
                    const deltaY = vertex.y - neighbor.y;
                    const dx_grid = Math.round(deltaX / gridInterval);
                    const dy_grid = Math.round(deltaY / gridInterval);
                    const g2gSquaredSumForDisplay = dx_grid * dx_grid + dy_grid * dy_grid;
                    if (g2gSquaredSumForDisplay === 0) {
                        distText = '0';
                    } else {
                        const [coeff, radicand] = simplifySquareRoot(g2gSquaredSumForDisplay);
                        const finalCoeff = gridInterval * coeff;
                        const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                        distText = formatSimplifiedRoot(roundedFinalCoeff, radicand);
                    }
                } else {
                    distText = formatNumber(dist, distanceSigFigs);
                }

                const neighborScreen = dataToScreen(neighbor);
                const edgeAngleScreen = Math.atan2(neighborScreen.y - vertexScreen.y, neighborScreen.x - vertexScreen.x);

                const midX = (vertexScreen.x + neighborScreen.x) / 2;
                const midY = (vertexScreen.y + neighborScreen.y) / 2;

                const labelId = `drag-dist-${vertex.id}-${neighbor.id}`;

                if (Math.abs(Math.cos(edgeAngleScreen)) < VERTICAL_LINE_COS_THRESHOLD) {
                    const distanceTextX = midX + FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                    const distanceTextY = midY;
                    updateHtmlLabel({ id: labelId, content: distText, x: distanceTextX, y: distanceTextY, color: feedbackColor, fontSize: FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle', rotation: 90 } }, htmlOverlay);
                } else {
                    let textPerpAngle = edgeAngleScreen - Math.PI / 2;
                    if (Math.sin(textPerpAngle) > 0) {
                        textPerpAngle += Math.PI;
                    }
                    const distanceTextX = midX + Math.cos(textPerpAngle) * FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                    const distanceTextY = midY + Math.sin(textPerpAngle) * FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;

                    let rotationDeg = edgeAngleScreen * (180 / Math.PI);
                    if (rotationDeg > 90 || rotationDeg < -90) {
                        rotationDeg += 180;
                    }

                    updateHtmlLabel({ id: labelId, content: distText, x: distanceTextX, y: distanceTextY, color: feedbackColor, fontSize: FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle', rotation: rotationDeg } }, htmlOverlay);
                }
            }
        }
    });

    if (showAngles && neighbors.length >= 2) {
        const sortedNeighbors = [...neighbors].sort((a, b) => {
            const angleA = Math.atan2(a.y - vertex.y, a.x - vertex.x);
            const angleB = Math.atan2(b.y - vertex.y, b.x - vertex.x);
            return angleA - angleB;
        });

        for (let i = 0; i < sortedNeighbors.length; i++) {
            const p1 = sortedNeighbors[i];
            const p2 = sortedNeighbors[(i + 1) % sortedNeighbors.length];
            const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };
            const v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };
            const angle1_data = Math.atan2(v1.y, v1.x);
            const angle2_data = Math.atan2(v2.y, v2.x);
            let angleToDisplayRad = angle2_data - angle1_data;
            if (angleToDisplayRad < 0) {
                angleToDisplayRad += RADIANS_IN_CIRCLE;
            }
            if (angleToDisplayRad < GEOMETRY_CALCULATION_EPSILON) continue;
            
            const bisectorAngle = angle1_data + (angleToDisplayRad / 2);
            ctx.save();
            ctx.strokeStyle = feedbackColor;
            ctx.lineWidth = FEEDBACK_LINE_VISUAL_WIDTH;
            ctx.beginPath();
            ctx.arc(vertexScreen.x, vertexScreen.y, FEEDBACK_ARC_RADIUS_SCREEN, -angle1_data, -angle2_data, false);
            ctx.stroke();
            ctx.restore();

            let angleText;
            if (angleDisplayMode === ANGLE_DISPLAY_MODE_DEGREES) {
                angleText = `${formatNumber(angleToDisplayRad * (DEGREES_IN_HALF_CIRCLE / Math.PI), angleSigFigs)}^{\\circ}`;
            } else if (angleDisplayMode === ANGLE_DISPLAY_MODE_RADIANS) {
                if (currentShiftPressed) {
                    angleText = formatFraction(angleToDisplayRad / Math.PI, FRACTION_FORMAT_TOLERANCE, FRACTION_FORMAT_MAX_DENOMINATOR) + PI_SYMBOL_KATEX;
                    if (angleText.startsWith(`1${PI_SYMBOL_KATEX}`)) angleText = PI_SYMBOL_KATEX;
                    if (angleText.startsWith(`-1${PI_SYMBOL_KATEX}`)) angleText = `-${PI_SYMBOL_KATEX}`;
                    if (angleText === `0${PI_SYMBOL_KATEX}`) angleText = "0";
                } else {
                    angleText = formatNumber(angleToDisplayRad, angleSigFigs);
                }
            }

            if (angleText) {
                const angleLabelDataPos = {
                    x: vertex.x + (ANGLE_LABEL_RADIUS_SCREEN / viewTransform.scale) * Math.cos(bisectorAngle),
                    y: vertex.y + (ANGLE_LABEL_RADIUS_SCREEN / viewTransform.scale) * Math.sin(bisectorAngle)
                };
                const angleLabelScreenPos = dataToScreen(angleLabelDataPos);
                const labelId = `drag-angle-${vertex.id}-${p1.id}-${p2.id}`;
                updateHtmlLabel({ id: labelId, content: angleText, x: angleLabelScreenPos.x, y: angleLabelScreenPos.y, color: feedbackColor, fontSize: FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
            }
        }
    }
}

export function drawTransformIndicators(ctx, htmlOverlay, { transformIndicatorData, angleSigFigs, distanceSigFigs, colors }, dataToScreen, updateHtmlLabel) {
        if (!transformIndicatorData) return;

    const { center, startPos, currentPos, rotation, scale, isSnapping, snappedScaleValue, transformType } = transformIndicatorData;

    const centerScreen = dataToScreen(center);
    const startScreen = dataToScreen(startPos);
    const currentScreen = dataToScreen(currentPos);

    const color = isSnapping ? colors.feedbackSnapped : colors.feedbackDefault_STATIC;

    const startVecScreen = { x: startScreen.x - centerScreen.x, y: startScreen.y - centerScreen.y };
    const currentVecScreen = { x: currentScreen.x - centerScreen.x, y: currentScreen.y - centerScreen.y };

    const startAngleScreen = Math.atan2(startVecScreen.y, startVecScreen.x);
    const currentAngleScreen = Math.atan2(currentVecScreen.y, currentVecScreen.x);
    const arcRadius = Math.hypot(startVecScreen.x, startVecScreen.y);

    ctx.save();
    ctx.setLineDash(DASH_PATTERN);
    ctx.strokeStyle = color;
    ctx.lineWidth = FEEDBACK_LINE_VISUAL_WIDTH;

    ctx.beginPath();
    ctx.moveTo(centerScreen.x, centerScreen.y);
    ctx.lineTo(startScreen.x, startScreen.y);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(centerScreen.x, centerScreen.y);
    ctx.lineTo(currentScreen.x, currentScreen.y);
    ctx.stroke();

    ctx.setLineDash([]);

    if (transformType !== TRANSFORM_TYPE_SCALE_ONLY && Math.abs(rotation) > MIN_TRANSFORM_ACTION_THRESHOLD) {
        const screenRotation = -rotation;
        const anticlockwise = screenRotation < 0;
        ctx.beginPath();
        ctx.arc(centerScreen.x, centerScreen.y, arcRadius, startAngleScreen, startAngleScreen + screenRotation, anticlockwise);
        ctx.stroke();
    }
    ctx.restore();

    if (transformType !== TRANSFORM_TYPE_SCALE_ONLY && Math.abs(rotation) > MIN_TRANSFORM_ACTION_THRESHOLD) {
        const angleDeg = rotation * (DEGREES_IN_HALF_CIRCLE / Math.PI);
        const angleText = `${formatNumber(angleDeg, angleSigFigs)}^{\\circ}`;
        const angleDiff = normalizeAngleToPi(currentAngleScreen - startAngleScreen);
        const bisectorAngle = startAngleScreen + angleDiff / 2;
        const labelRadius = arcRadius + TRANSFORM_ANGLE_LABEL_OFFSET;
        const angleTextX = centerScreen.x + labelRadius * Math.cos(bisectorAngle);
        const angleTextY = centerScreen.y + labelRadius * Math.sin(bisectorAngle);

        updateHtmlLabel({ id: 'transform-angle-indicator', content: angleText, x: angleTextX, y: angleTextY, color: color, fontSize: FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }

    if (transformType !== TRANSFORM_TYPE_ROTATE_ONLY && Math.abs(scale - 1) > MIN_TRANSFORM_ACTION_THRESHOLD) {
        let scaleText;
        if (isSnapping && snappedScaleValue !== null) {
            scaleText = `\\times ${formatFraction(snappedScaleValue, FRACTION_FORMAT_TOLERANCE, FRACTION_FORMAT_MAX_DENOMINATOR_TRANSFORM)}`;
        } else {
            scaleText = `\\times ${formatNumber(scale, distanceSigFigs)}`;
        }

        const midX = (centerScreen.x + currentScreen.x) / 2;
        const midY = (centerScreen.y + currentScreen.y) / 2;
        let textPerpAngle = currentAngleScreen - Math.PI / 2;
        const scaleTextX = midX + Math.cos(textPerpAngle) * TRANSFORM_SCALE_LABEL_OFFSET;
        const scaleTextY = midY + Math.sin(textPerpAngle) * TRANSFORM_SCALE_LABEL_OFFSET;

        let rotationDeg = currentAngleScreen * (DEGREES_IN_HALF_CIRCLE / Math.PI);
        if (rotationDeg > DEGREES_IN_QUADRANT || rotationDeg < -DEGREES_IN_QUADRANT) {
            rotationDeg += DEGREES_IN_HALF_CIRCLE;
        }

        updateHtmlLabel({ id: 'transform-scale-indicator', content: scaleText, x: scaleTextX, y: scaleTextY, color: color, fontSize: FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'bottom', rotation: rotationDeg } }, htmlOverlay);
    }
}

export function drawReferenceElementsGeometry(ctx, context, dataToScreen, screenToData, { showAngles, showDistances, viewTransform, mousePos, colors }) {
    if ((!showAngles && !showDistances) || !context.frozen_Origin_Data_to_display) return;
    
    const startPointData = context.frozen_Origin_Data_to_display;
    const mouseDataPos = screenToData(mousePos);
    const previewDistance = distance(startPointData, mouseDataPos);
    
    if (previewDistance < GEOMETRY_CALCULATION_EPSILON) return;

    const refElementColor = colors.frozenReference;

    const turnAngleData = context.displayAngleA_valueRad_for_A_equals_label;
    const baseAngleData = context.frozen_A_baseRad_to_display !== null ? context.frozen_A_baseRad_to_display : 0;
    const distanceData = context.frozen_D_du_to_display;

    if (!startPointData) return;

    const frozenOriginScreen = dataToScreen(startPointData);
    const absoluteAngleForRefLine = baseAngleData + turnAngleData;

    ctx.save();
    ctx.lineWidth = FEEDBACK_LINE_VISUAL_WIDTH;
    ctx.strokeStyle = refElementColor;

    if (showAngles && context.displayAngleA_valueRad_for_A_equals_label !== null && Math.abs(context.displayAngleA_valueRad_for_A_equals_label) > GEOMETRY_CALCULATION_EPSILON) {
        const effectiveRadiusForLine = REF_ARC_RADIUS_SCREEN + ctx.lineWidth / 2;

        const dottedLineEndPointData = {
            x: startPointData.x + Math.cos(baseAngleData) * (effectiveRadiusForLine / viewTransform.scale),
            y: startPointData.y + Math.sin(baseAngleData) * (effectiveRadiusForLine / viewTransform.scale)
        };
        const dottedLineEndPointScreen = dataToScreen(dottedLineEndPointData);

        ctx.beginPath();
        ctx.moveTo(frozenOriginScreen.x, frozenOriginScreen.y);
        ctx.lineTo(dottedLineEndPointScreen.x, dottedLineEndPointScreen.y);
        ctx.setLineDash(REF_LINE_DASH_PATTERN);
        ctx.stroke();

        drawAngleArc(ctx, frozenOriginScreen, baseAngleData, absoluteAngleForRefLine, REF_ARC_RADIUS_SCREEN, refElementColor, false);
    }
    ctx.restore();
}

export function prepareSnapInfoTexts(ctx, htmlOverlay, startPointData, targetDataPos, snappedOutput, { showDistances, showAngles, currentShiftPressed, distanceSigFigs, angleSigFigs, angleDisplayMode, viewTransform, frozenReference_D_du, gridDisplayMode, frozenReference_A_rad, colors }, dataToScreen, drawingContext, updateHtmlLabel) {
    if ((!showAngles && !showDistances) || snappedOutput.distance < GEOMETRY_CALCULATION_EPSILON) {
        return;
    }

    const startScreen = dataToScreen(startPointData);
    const { angle: snappedAbsoluteAngleDeg, distance: snappedDistanceData, lengthSnapFactor, angleSnapFactor, angleTurn, gridToGridSquaredSum, gridInterval } = snappedOutput;
    const { offsetAngleRad, isFirstSegmentBeingDrawn } = drawingContext;
    const currentElementColor = currentShiftPressed ? colors.geometryInfoTextSnapped : colors.geometryInfoText;
    const currentLineAbsoluteAngle = Math.atan2(targetDataPos.y - startPointData.y, targetDataPos.x - startPointData.x);

    if (showDistances) {
        let distanceText = '';

        if (currentShiftPressed && !isFirstSegmentBeingDrawn && frozenReference_D_du !== null) {
            const currentExactDistance = snappedDistanceData;

            if (gridToGridSquaredSum !== null && gridInterval) {
                const actualGridDistance = gridInterval * Math.sqrt(gridToGridSquaredSum);
                if (Math.abs(actualGridDistance - frozenReference_D_du) < GEOMETRY_CALCULATION_EPSILON) {
                    distanceText = DELTA_SYMBOL_KATEX;
                } else {
                    const ratio = actualGridDistance / frozenReference_D_du;
                    let foundFraction = false;
                    for (const factor of SNAP_FACTORS) {
                        if (Math.abs(ratio - factor) < GEOMETRY_CALCULATION_EPSILON) {
                            distanceText = formatSnapFactor(factor, 'D');
                            foundFraction = true;
                            break;
                        }
                    }
                    if (!foundFraction) {
                        const [coeff, radicand] = simplifySquareRoot(gridToGridSquaredSum);
                        const finalCoeff = gridInterval * coeff;
                        const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                        distanceText = formatSimplifiedRoot(roundedFinalCoeff, radicand);
                    }
                }
            } else if (frozenReference_D_du > GEOMETRY_CALCULATION_EPSILON) {
                const ratio = currentExactDistance / frozenReference_D_du;
                let foundFraction = false;
                for (const factor of SNAP_FACTORS) {
                    if (Math.abs(ratio - factor) < GEOMETRY_CALCULATION_EPSILON) {
                        distanceText = formatSnapFactor(factor, 'D');
                        foundFraction = true;
                        break;
                    }
                }
                if (!foundFraction) {
                    distanceText = formatNumber(snappedDistanceData, distanceSigFigs);
                }
            } else {
                distanceText = formatNumber(snappedDistanceData, distanceSigFigs);
            }
        } else if (currentShiftPressed && isFirstSegmentBeingDrawn && gridDisplayMode !== GRID_DISPLAY_MODE_NONE && gridInterval) {
            if (gridToGridSquaredSum !== null && gridInterval) {
                if (gridToGridSquaredSum >= 0) {
                    const [coeff, radicand] = simplifySquareRoot(gridToGridSquaredSum);
                    const finalCoeff = gridInterval * coeff;
                    const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                    distanceText = formatSimplifiedRoot(roundedFinalCoeff, radicand);
                }
            } else {
                distanceText = formatNumber(snappedDistanceData, distanceSigFigs);
            }
        } else {
            distanceText = formatNumber(snappedDistanceData, distanceSigFigs);
        }

        if (distanceText) {
            const startScreenPos = dataToScreen(startPointData);
            const endScreenPos = dataToScreen(targetDataPos);
            const edgeAngleScreen = Math.atan2(endScreenPos.y - startScreenPos.y, endScreenPos.x - startScreenPos.x);
            const midX = (startScreenPos.x + endScreenPos.x) / 2;
            const midY = (startScreenPos.y + endScreenPos.y) / 2;

            if (Math.abs(Math.cos(edgeAngleScreen)) < VERTICAL_LINE_COS_THRESHOLD) {
                const distanceTextX = midX + FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                const distanceTextY = midY;
                updateHtmlLabel({ id: 'snap-dist', content: distanceText, x: distanceTextX, y: distanceTextY, color: currentElementColor, fontSize: FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle', rotation: 90 } }, htmlOverlay);
            } else {
                let textPerpAngle;
                const baseAngleForArc = isFirstSegmentBeingDrawn ? 0 : offsetAngleRad;

                if (showAngles && snappedDistanceData > GEOMETRY_CALCULATION_EPSILON && Math.abs(angleTurn) > GEOMETRY_CALCULATION_EPSILON) {
                    const canvasStartAngle = -baseAngleForArc;
                    const canvasEndAngle = -currentLineAbsoluteAngle;
                    const sumCos = Math.cos(canvasStartAngle) + Math.cos(canvasEndAngle);
                    const sumSin = Math.sin(canvasStartAngle) + Math.sin(canvasEndAngle);
                    const angleLabelBisectorRad = Math.atan2(sumSin, sumCos);
                    const perp1 = edgeAngleScreen - Math.PI / 2;
                    const perp2 = edgeAngleScreen + Math.PI / 2;
                    const diff1 = Math.abs(normalizeAngleToPi(perp1 - angleLabelBisectorRad));
                    const diff2 = Math.abs(normalizeAngleToPi(perp2 - angleLabelBisectorRad));
                    textPerpAngle = diff1 > diff2 ? perp1 : perp2;
                } else {
                    textPerpAngle = edgeAngleScreen - Math.PI / 2;
                    if (Math.sin(textPerpAngle) > 0) {
                        textPerpAngle += Math.PI;
                    }
                }
                const distanceTextX = midX + Math.cos(textPerpAngle) * FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                const distanceTextY = midY + Math.sin(textPerpAngle) * FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                let rotationDeg = edgeAngleScreen * (DEGREES_IN_HALF_CIRCLE / Math.PI);
                if (rotationDeg > DEGREES_IN_QUADRANT || rotationDeg < -DEGREES_IN_QUADRANT) {
                    rotationDeg += DEGREES_IN_HALF_CIRCLE;
                }
                updateHtmlLabel({ id: 'snap-dist', content: distanceText, x: distanceTextX, y: distanceTextY, color: currentElementColor, fontSize: FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle', rotation: rotationDeg } }, htmlOverlay);
            }
        }
    }

    if (showAngles && snappedDistanceData > GEOMETRY_CALCULATION_EPSILON && Math.abs(angleTurn) > GEOMETRY_CALCULATION_EPSILON) {
        const baseAngleForArc = isFirstSegmentBeingDrawn ? 0 : offsetAngleRad;

        drawAngleArc(ctx, startScreen, baseAngleForArc, currentLineAbsoluteAngle, FEEDBACK_ARC_RADIUS_SCREEN, currentElementColor);

        ctx.save();
        ctx.beginPath();
        const effectiveRadiusForLine = FEEDBACK_ARC_RADIUS_SCREEN + ctx.lineWidth / 2;
        const baseLineEndData = {
            x: startPointData.x + (effectiveRadiusForLine / viewTransform.scale) * Math.cos(baseAngleForArc),
            y: startPointData.y + (effectiveRadiusForLine / viewTransform.scale) * Math.sin(baseAngleForArc)
        };
        const baseLineEndScreen = dataToScreen(baseLineEndData);
        ctx.moveTo(startScreen.x, startScreen.y);
        ctx.lineTo(baseLineEndScreen.x, baseLineEndScreen.y);
        ctx.strokeStyle = colors.helperLine;
        ctx.setLineDash(HELPER_LINE_DASH_PATTERN);
        ctx.lineWidth = FEEDBACK_LINE_VISUAL_WIDTH;
        ctx.stroke();
        ctx.restore();

        let angleText = '';
        const canReferToTheta = !isFirstSegmentBeingDrawn && frozenReference_A_rad !== null && Math.abs(frozenReference_A_rad) > GEOMETRY_CALCULATION_EPSILON;

        if (angleDisplayMode === ANGLE_DISPLAY_MODE_DEGREES) {
            if (currentShiftPressed && canReferToTheta) {
                const referenceAngleRad = Math.abs(drawingContext.currentSegmentReferenceA_for_display);
                let potentialFactor = null;

                if (typeof angleSnapFactor === 'number') {
                    potentialFactor = angleSnapFactor;
                } else if (angleTurn !== null) {
                    if (Math.abs(referenceAngleRad) > GEOMETRY_CALCULATION_EPSILON) {
                        const calculatedFactor = angleTurn / referenceAngleRad;
                        for (const frac of NINETY_DEG_ANGLE_SNAP_FRACTIONS) {
                            if (Math.abs(Math.abs(calculatedFactor) - frac) < GEOMETRY_CALCULATION_EPSILON) {
                                potentialFactor = calculatedFactor < 0 ? -frac : frac;
                                break;
                            }
                        }
                    }
                }
                if (potentialFactor !== null && Math.abs(potentialFactor) > GEOMETRY_CALCULATION_EPSILON) {
                    angleText = formatSnapFactor(potentialFactor, 'A');
                } else {
                    let degrees = angleTurn * (DEGREES_IN_HALF_CIRCLE / Math.PI);
                    if (Math.abs(degrees) > GEOMETRY_CALCULATION_EPSILON) {
                        angleText = `${formatNumber(degrees, angleSigFigs)}^{\\circ}`;
                    }
                }
            } else {
                let angleToFormatRad = isFirstSegmentBeingDrawn ? currentLineAbsoluteAngle : angleTurn;
                if (currentShiftPressed && !isFirstSegmentBeingDrawn) {
                    let angleToFormatDeg = angleToFormatRad * (DEGREES_IN_HALF_CIRCLE / Math.PI);
                    if (Math.abs(angleToFormatDeg) > GEOMETRY_CALCULATION_EPSILON) {
                        angleText = `${formatNumber(angleToFormatDeg, angleSigFigs)}^{\\circ}`;
                    }
                } else {
                    let angleToFormatDeg = normalizeAngleToPi(angleToFormatRad) * (DEGREES_IN_HALF_CIRCLE / Math.PI);
                    if (Math.abs(angleToFormatDeg) > GEOMETRY_CALCULATION_EPSILON) {
                        angleText = `${formatNumber(angleToFormatDeg, angleSigFigs)}^{\\circ}`;
                    }
                }
            }
        } else if (angleDisplayMode === ANGLE_DISPLAY_MODE_RADIANS) {
            if (currentShiftPressed && canReferToTheta) {
                const referenceAngleRad = Math.abs(drawingContext.currentSegmentReferenceA_for_display);
                let potentialFactor = null;

                if (typeof angleSnapFactor === 'number') {
                    potentialFactor = angleSnapFactor;
                } else if (angleTurn !== null) {
                    if (Math.abs(referenceAngleRad) > GEOMETRY_CALCULATION_EPSILON) {
                        const calculatedFactor = angleTurn / referenceAngleRad;
                        for (const frac of NINETY_DEG_ANGLE_SNAP_FRACTIONS) {
                            if (Math.abs(Math.abs(calculatedFactor) - frac) < GEOMETRY_CALCULATION_EPSILON) {
                                potentialFactor = calculatedFactor < 0 ? -frac : frac;
                                break;
                            }
                        }
                    }
                }
                if (potentialFactor !== null && Math.abs(potentialFactor) > GEOMETRY_CALCULATION_EPSILON) {
                    const fracStr = formatSnapFactor(potentialFactor, null);
                    angleText = `${fracStr === '0' ? '0' : fracStr + PI_SYMBOL_KATEX}`;
                    if (angleText.startsWith(`1${PI_SYMBOL_KATEX}`)) angleText = PI_SYMBOL_KATEX;
                    if (angleText.startsWith(`-1${PI_SYMBOL_KATEX}`)) angleText = `-${PI_SYMBOL_KATEX}`;
                } else {
                    let radians = angleTurn;
                    if (Math.abs(radians) > GEOMETRY_CALCULATION_EPSILON) {
                        angleText = formatNumber(radians, angleSigFigs);
                    }
                }
            } else {
                let angleToFormatRad = isFirstSegmentBeingDrawn ? currentLineAbsoluteAngle : angleTurn;
                if (currentShiftPressed && !isFirstSegmentBeingDrawn) {
                    let radians = angleToFormatRad;
                    if (Math.abs(radians) > GEOMETRY_CALCULATION_EPSILON) {
                        angleText = formatNumber(radians, angleSigFigs);
                    }
                } else {
                    let radians = normalizeAngleToPi(angleToFormatRad);
                    if (Math.abs(radians) > GEOMETRY_CALCULATION_EPSILON) {
                        angleText = formatNumber(radians, angleSigFigs);
                    }
                }
            }
        }

        if (angleText) {
            const canvasStartAngle = -baseAngleForArc;
            const canvasEndAngle = -currentLineAbsoluteAngle;
            const sumCos = Math.cos(canvasStartAngle) + Math.cos(canvasEndAngle);
            const sumSin = Math.sin(canvasStartAngle) + Math.sin(canvasEndAngle);
            let bisectorCanvasAngle = Math.atan2(sumSin, sumCos);
            const angleTextX = startScreen.x + Math.cos(bisectorCanvasAngle) * SNAP_ANGLE_LABEL_OFFSET;
            const angleTextY = startScreen.y + Math.sin(bisectorCanvasAngle) * SNAP_ANGLE_LABEL_OFFSET;
            updateHtmlLabel({ id: 'snap-angle', content: angleText, x: angleTextX, y: angleTextY, color: currentElementColor, fontSize: FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
        }
    }
}

export function prepareReferenceElementsTexts(htmlOverlay, context, { showAngles, showDistances, viewTransform, mousePos, frozenReference_D_du, distanceSigFigs, angleSigFigs, angleDisplayMode, colors }, screenToData, dataToScreen, updateHtmlLabel) {
    const dataThreshold = REF_TEXT_SCREEN_PIXEL_THRESHOLD / viewTransform.scale;

    let previewDistance = -1;
    if (context.frozen_Origin_Data_to_display) {
        const startPointData = context.frozen_Origin_Data_to_display;
        const mouseDataPos = screenToData(mousePos);
        previewDistance = distance(startPointData, mouseDataPos);
    }

    if ((!showAngles && !showDistances) || !context.frozen_Origin_Data_to_display || previewDistance < dataThreshold) {
        return;
    }

    const refElementColor = colors.frozenReference;

    const startPointData = context.frozen_Origin_Data_to_display;
    const turnAngleData = context.displayAngleA_valueRad_for_A_equals_label;
    const baseAngleData = context.frozen_A_baseRad_to_display !== null ? context.frozen_A_baseRad_to_display : 0;
    const distanceData = context.frozen_D_du_to_display;
    const frozenG2GSquaredSum = context.frozen_D_g2g_to_display ? context.frozen_D_g2g_to_display.g2gSquaredSum : null;
    const frozenG2GInterval = context.frozen_D_g2g_to_display ? context.frozen_D_g2g_to_display.interval : null;

    if (!startPointData) {
        return;
    }

    const absoluteAngleForRefLine = baseAngleData + turnAngleData;
    const endPointData = {
        x: startPointData.x + distanceData * Math.cos(absoluteAngleForRefLine),
        y: startPointData.y + distanceData * Math.sin(absoluteAngleForRefLine)
    };

    const startPointScreen = dataToScreen(startPointData);
    const endPointScreen = dataToScreen(endPointData);

    if (showDistances && distanceData !== null && distanceData > dataThreshold && frozenReference_D_du !== null) {
        let distanceText = '';

        if (frozenG2GSquaredSum !== null && frozenG2GSquaredSum > 0 && frozenG2GInterval) {
            const [coeff, radicand] = simplifySquareRoot(frozenG2GSquaredSum);
            const finalCoeff = frozenG2GInterval * coeff;
            const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
            distanceText = `${DELTA_EQUALS_KATEX}${formatSimplifiedRoot(roundedFinalCoeff, radicand)}`;
        } else {
            const platonicValue = distanceData / DEFAULT_REFERENCE_DISTANCE;
            distanceText = `${DELTA_EQUALS_KATEX}${formatNumber(platonicValue, distanceSigFigs)}`;
        }

        const edgeAngleScreen = Math.atan2(endPointScreen.y - startPointScreen.y, endPointScreen.x - startPointScreen.x);
        const midX_screen = (startPointScreen.x + endPointScreen.x) / 2;
        const midY_screen = (startPointScreen.y + endPointScreen.y) / 2;
        
        let rotationDeg = edgeAngleScreen * (DEGREES_IN_HALF_CIRCLE / Math.PI);
        if (rotationDeg > DEGREES_IN_QUADRANT || rotationDeg < -DEGREES_IN_QUADRANT) {
            rotationDeg += DEGREES_IN_HALF_CIRCLE;
        }
        let textPerpAngle;

        if (showAngles && turnAngleData !== null && Math.abs(turnAngleData) > GEOMETRY_CALCULATION_EPSILON) {
            const canvasStartAngle = -baseAngleData;
            const canvasEndAngle = -(baseAngleData + turnAngleData);
            const sumCos = Math.cos(canvasStartAngle) + Math.cos(canvasEndAngle);
            const sumSin = Math.sin(canvasStartAngle) + Math.sin(canvasEndAngle);
            const angleLabelBisectorRad = Math.atan2(sumSin, sumCos);
            const perp1 = edgeAngleScreen - Math.PI / 2;
            const perp2 = edgeAngleScreen + Math.PI / 2;
            const diff1 = Math.abs(normalizeAngleToPi(perp1 - angleLabelBisectorRad));
            const diff2 = Math.abs(normalizeAngleToPi(perp2 - angleLabelBisectorRad));
            textPerpAngle = diff1 > diff2 ? perp1 : perp2;
        } else {
            textPerpAngle = edgeAngleScreen - Math.PI / 2;
            if (Math.sin(textPerpAngle) > 0) {
                textPerpAngle += Math.PI;
            }
        }
        const textDistLabelX_D = midX_screen + Math.cos(textPerpAngle) * REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN;
        const textDistLabelY_D = midY_screen + Math.sin(textPerpAngle) * REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN;

        updateHtmlLabel({ id: 'ref-dist', content: distanceText, x: textDistLabelX_D, y: textDistLabelY_D, color: refElementColor, fontSize: REF_TEXT_KATEX_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle', rotation: rotationDeg } }, htmlOverlay);
    }

    if (showAngles && turnAngleData !== null && Math.abs(turnAngleData) > GEOMETRY_CALCULATION_EPSILON) {
        const startAngleCanvas = -baseAngleData;
        const endAngleCanvas = -(baseAngleData + turnAngleData);

        const sumCos = Math.cos(startAngleCanvas) + Math.cos(endAngleCanvas);
        const sumSin = Math.sin(startAngleCanvas) + Math.sin(endAngleCanvas);
        let bisectorCanvasAngle = Math.atan2(sumSin, sumCos);
        const angleLabelOffsetDistance = REF_TEXT_ANGLE_LABEL_OFFSET_SCREEN;

        const textAngleLabelX_A = startPointScreen.x + Math.cos(bisectorCanvasAngle) * angleLabelOffsetDistance;
        const textAngleLabelY_A = startPointScreen.y + Math.sin(bisectorCanvasAngle) * angleLabelOffsetDistance;

        let aKatexText = '';
        if (angleDisplayMode === ANGLE_DISPLAY_MODE_DEGREES) {
            let aValueDeg = turnAngleData * (DEGREES_IN_HALF_CIRCLE / Math.PI);
            aKatexText = `${THETA_EQUALS_KATEX}${formatNumber(aValueDeg, angleSigFigs)}^{\\circ}`;
        } else if (angleDisplayMode === ANGLE_DISPLAY_MODE_RADIANS) {
            let aValueRad = turnAngleData;
            aKatexText = `${THETA_EQUALS_KATEX}${formatFraction(aValueRad / Math.PI, FRACTION_FORMAT_TOLERANCE, FRACTION_FORMAT_MAX_DENOMINATOR)}${PI_SYMBOL_KATEX}`;
            if (aKatexText === `${THETA_EQUALS_KATEX}1${PI_SYMBOL_KATEX}`) aKatexText = PI_SYMBOL_KATEX;
            if (aKatexText === `${THETA_EQUALS_KATEX}-1${PI_SYMBOL_KATEX}`) aKatexText = `-${PI_SYMBOL_KATEX}`;
            if (aKatexText === `${THETA_EQUALS_KATEX}0${PI_SYMBOL_KATEX}`) aKatexText = "0";
        }

        updateHtmlLabel({ id: 'ref-angle', content: aKatexText, x: textAngleLabelX_A, y: textAngleLabelY_A, color: refElementColor, fontSize: REF_TEXT_KATEX_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function updateMouseCoordinates(htmlOverlay, { coordsDisplayMode, isMouseOverCanvas, currentShiftPressed, ghostPointPosition, gridDisplayMode, lastGridState, angleDisplayMode, canvas, dpr, mousePos, colors}, screenToData, updateHtmlLabel) {
    
    if (coordsDisplayMode === COORDS_DISPLAY_MODE_NONE || !mousePos || !isMouseOverCanvas) {
        return;
    }

    let displayPos;
    if (currentShiftPressed && ghostPointPosition) {
        displayPos = ghostPointPosition;
    } else {
        displayPos = screenToData(mousePos);
    }

    let effectiveGridInterval = 1;
    if (gridDisplayMode !== GRID_DISPLAY_MODE_NONE && lastGridState && lastGridState.interval1) {
        effectiveGridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
    }

    let decimalPlaces = 0;
    if (effectiveGridInterval > 0) {
        decimalPlaces = Math.max(0, -Math.floor(Math.log10(effectiveGridInterval * COORD_PRECISION_FACTOR)));
        decimalPlaces = Math.min(decimalPlaces + 1, MAX_COORD_DECIMAL_PLACES);
    }

    const angleDecimalPlaces = Math.min(decimalPlaces + 1, MAX_ANGLE_DECIMAL_PLACES);
    let textContent = '';

    switch (coordsDisplayMode) {
        case COORDS_DISPLAY_MODE_REGULAR: {
            let xValue = displayPos.x;
            let yValue = displayPos.y;
            let xText = xValue.toFixed(decimalPlaces);
            if (xValue >= 0) xText = `${KATEX_MINUS_PHANTOM}${xText}`;
            let yText = yValue.toFixed(decimalPlaces);
            if (yValue >= 0) yText = `${KATEX_MINUS_PHANTOM}${yText}`;
            textContent = `\\begin{pmatrix*}[r] x \\\\ y \\end{pmatrix*} = \\begin{pmatrix*}[r] ${xText} \\\\ ${yText} \\end{pmatrix*}`;
            break;
        }
        case COORDS_DISPLAY_MODE_COMPLEX: {
            let reValue = displayPos.x;
            let imValue = displayPos.y;
            let rePart = reValue.toFixed(decimalPlaces);
            if (reValue >= 0) rePart = `${KATEX_MINUS_PHANTOM}${rePart}`;
            let imPartAbs = Math.abs(imValue).toFixed(decimalPlaces);
            const sign = imValue < 0 ? '-' : '+';
            textContent = `z = ${rePart} ${sign} ${imPartAbs}${IMAGINARY_UNIT_SYMBOL}`;
            break;
        }
        case COORDS_DISPLAY_MODE_POLAR: {
            let rValue = Math.hypot(displayPos.x, displayPos.y);
            let thetaRaw = Math.atan2(displayPos.y, displayPos.x);
            let rText = rValue.toFixed(decimalPlaces);
            if (rValue >= 0) rText = `${KATEX_MINUS_PHANTOM}${rText}`;
            let angleStr;
            if (angleDisplayMode === ANGLE_DISPLAY_MODE_DEGREES) {
                let thetaDeg = normalizeAngleDegrees(thetaRaw * 180 / Math.PI);
                angleStr = thetaDeg.toFixed(angleDecimalPlaces);
                if (thetaDeg >= 0) angleStr = `${KATEX_MINUS_PHANTOM}${angleStr}`;
                angleStr += `^{\\circ}`;
            } else {
                let thetaRad = normalizeAngleToPi(thetaRaw);
                angleStr = thetaRad.toFixed(angleDecimalPlaces);
                if (thetaRad >= 0) angleStr = `${KATEX_MINUS_PHANTOM}${angleStr}`;
            }
            textContent = `\\begin{pmatrix*}[r] r \\\\ \\theta \\end{pmatrix*} = \\begin{pmatrix*}[r] ${rText} \\\\ ${angleStr} \\end{pmatrix*}`;
            break;
        }
    }

    const canvasWidth = canvas.width / dpr;
    updateHtmlLabel({ id: 'mouse-coord-text', content: textContent, x: canvasWidth - UI_PADDING, y: UI_PADDING, color: colors.mouseCoords, fontSize: MOUSE_COORD_FONT_SIZE, options: { textAlign: 'right', textBaseline: 'top' } }, htmlOverlay);
}

export function createColorWheelIcon(size, dpr) {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = size * dpr;
    tempCanvas.height = size * dpr;
    const tempCtx = tempCanvas.getContext('2d');
    const imageData = tempCtx.createImageData(tempCanvas.width, tempCanvas.height);
    const pixels = imageData.data;
    const centerX = tempCanvas.width / 2;
    const centerY = tempCanvas.height / 2;
    const radius = tempCanvas.width / 2;
    for (let y = 0; y < tempCanvas.height; y++) {
        for (let x = 0; x < tempCanvas.width; x++) {
            const i = (y * tempCanvas.width + x) * 4;
            const dx = x - centerX;
            const dy = y - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > radius) continue;
            const hue = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
            const saturation = 100;
            const lightness = 50;
            let alpha;
            const fadeStartRadius = radius * 0.75;
            if (dist < fadeStartRadius) {
                alpha = 1.0;
            } else {
                const fadeDistance = radius - fadeStartRadius;
                alpha = 1.0 - ((dist - fadeStartRadius) / fadeDistance);
            }
            const [R, G, B] = hslToRgb(hue / 360, saturation / 100, lightness / 100);
            pixels[i] = R;
            pixels[i + 1] = G;
            pixels[i + 2] = B;
            pixels[i + 3] = Math.round(Math.max(0, alpha) * 255);
        }
    }
    tempCtx.putImageData(imageData, 0, 0);
    return tempCanvas;
}

function drawThemeIcon(ctx, rect, activeThemeName, colors) {
    ctx.save();
    const centerX = rect.x + rect.width / 2;
    const centerY = rect.y + rect.height / 2;
    const radius = rect.width / 2 * 0.6; // Make icon slightly smaller than button bounds

    ctx.strokeStyle = colors.uiIcon;
    ctx.fillStyle = colors.uiIcon;
    ctx.lineWidth = 2;

    if (activeThemeName === 'dark') {
        // Draw a Sun Icon
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 0.7, 0, 2 * Math.PI);
        ctx.fill();
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * 2 * Math.PI;
            const startX = centerX + Math.cos(angle) * (radius * 0.85);
            const startY = centerY + Math.sin(angle) * (radius * 0.85);
            const endX = centerX + Math.cos(angle) * (radius * 1.1);
            const endY = centerY + Math.sin(angle) * (radius * 1.1);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
    } else {
        // Draw a Moon Icon
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(centerX - 5, centerY - 3, radius, 0, 2 * Math.PI);
        ctx.fillStyle = colors.background; // Use background color to "cut out" the crescent
        ctx.fill();
    }
    ctx.restore();
}

export function drawUITransformSymbol(ctx, icon, colors) {
    const screenPos = { x: icon.x + icon.width / 2, y: icon.y + icon.height / 2 };
    const radius = icon.width / 2;
    ctx.strokeStyle = colors.uiIcon;
    ctx.setLineDash([]);
    ctx.lineWidth = UI_ICON_LINE_WIDTH;
    if (icon.type === TRANSFORM_TYPE_ROTATE_SCALE) {
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, radius, 0, RADIANS_IN_CIRCLE);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(screenPos.x - radius, screenPos.y);
        ctx.lineTo(screenPos.x + radius, screenPos.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(screenPos.x, screenPos.y - radius);
        ctx.lineTo(screenPos.x, screenPos.y + radius);
        ctx.stroke();
    } else if (icon.type === TRANSFORM_TYPE_ROTATE_ONLY) {
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, radius, 0, RADIANS_IN_CIRCLE);
        ctx.stroke();
    } else if (icon.type === TRANSFORM_TYPE_SCALE_ONLY) {
        ctx.beginPath();
        ctx.moveTo(screenPos.x - radius, screenPos.y);
        ctx.lineTo(screenPos.x + radius, screenPos.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(screenPos.x, screenPos.y - radius);
        ctx.lineTo(screenPos.x, screenPos.y + radius);
        ctx.stroke();
    }
}

export function drawCoordsIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    const x_offset = 1;
    ctx.strokeStyle = colorStrong;
    ctx.lineWidth = UI_ICON_LINE_WIDTH_SMALL;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(2 + x_offset, 30); ctx.lineTo(30 + x_offset, 30);
    ctx.moveTo(2 + x_offset, 30); ctx.lineTo(2 + x_offset, 2);
    ctx.stroke();
    ctx.fillStyle = colorStrong;
    const point = { x: 16 + x_offset, y: 16 };
    let labelPos = { x: 17 + x_offset, y: 8 };
    let label = '';
    switch (mode) {
        case COORDS_DISPLAY_MODE_REGULAR:
            ctx.setLineDash(UI_ICON_DASH_PATTERN);
            ctx.beginPath();
            ctx.moveTo(point.x, point.y); ctx.lineTo(point.x, 30);
            ctx.moveTo(point.x, point.y); ctx.lineTo(2 + x_offset, point.y);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(point.x, point.y, UI_ICON_POINT_RADIUS, 0, RADIANS_IN_CIRCLE);
            ctx.fill();
            label = '(x,y)';
            break;
        case COORDS_DISPLAY_MODE_COMPLEX:
            ctx.setLineDash(UI_ICON_DASH_PATTERN);
            ctx.beginPath();
            ctx.moveTo(2 + x_offset, 30); ctx.lineTo(point.x, point.y);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(point.x, point.y, UI_ICON_POINT_RADIUS, 0, RADIANS_IN_CIRCLE);
            ctx.fill();
            label = 'x+iy';
            break;
        case COORDS_DISPLAY_MODE_POLAR:
            ctx.setLineDash(UI_ICON_DASH_PATTERN);
            ctx.beginPath();
            ctx.moveTo(2 + x_offset, 30); ctx.lineTo(point.x, point.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(2 + x_offset, 30, 8, -Math.atan2(30 - point.y, point.x - (2 + x_offset)), 0);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(point.x, point.y, UI_ICON_POINT_RADIUS, 0, RADIANS_IN_CIRCLE);
            ctx.fill();
            label = '(r,\\theta)';
            break;
        case COORDS_DISPLAY_MODE_NONE:
            break;
    }
    ctx.restore();
    if (label) {
        const labelId = 'icon-label-coords';
        const labelColor = isSelected ? colors.uiTextSelected : colors.uiTextDefault;
        updateHtmlLabel({ id: labelId, content: label, x: center.x + (labelPos.x - 16) * scale, y: center.y + (labelPos.y - 16) * scale, color: labelColor, fontSize: UI_ICON_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function drawAngleIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    ctx.strokeStyle = colorStrong;
    ctx.lineWidth = UI_ICON_LINE_WIDTH_SMALL;
    const p1 = { x: 28, y: 30 };
    const p2 = { x: 4, y: 30 };
    const p3 = { x: 16, y: 8 };
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.lineTo(p3.x, p3.y);
    ctx.stroke();
    let label = '';
    let labelPos = { x: 20, y: 22 };
    if (mode !== ANGLE_DISPLAY_MODE_NONE) {
        ctx.beginPath();
        const angle = Math.atan2(p3.y - p2.y, p3.x - p2.x);
        ctx.arc(p2.x, p2.y, 8, angle, 0);
        ctx.stroke();
        if (mode === ANGLE_DISPLAY_MODE_DEGREES) {
            label = '60^\\circ';
        } else if (mode === ANGLE_DISPLAY_MODE_RADIANS) {
            label = '\\pi/3';
        }
    }
    ctx.restore();
    if (label) {
        const labelId = 'icon-label-angles';
        const labelColor = isSelected ? colors.uiTextSelected : colors.uiTextDefault;
        updateHtmlLabel({ id: labelId, content: label, x: center.x + (labelPos.x - 16) * scale, y: center.y + (labelPos.y - 16) * scale, color: labelColor, fontSize: UI_ICON_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function drawDistanceIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    ctx.strokeStyle = colorStrong;
    ctx.lineWidth = UI_ICON_LINE_WIDTH_SMALL;
    ctx.beginPath();
    ctx.moveTo(2, 30);
    ctx.lineTo(30, 30);
    ctx.stroke();
    let label = '';
    let labelPos = { x: 16, y: 22 };
    if (mode === DISTANCE_DISPLAY_MODE_ON) {
        label = '3.14';
    }
    ctx.restore();
    if (label) {
        const labelId = 'icon-label-distances';
        const labelColor = isSelected ? colors.uiTextSelected : colors.uiTextDefault;
        updateHtmlLabel({ id: labelId, content: label, x: center.x + (labelPos.x - 16) * scale, y: center.y + (labelPos.y - 16) * scale, color: labelColor, fontSize: 12, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function drawGridIcon(ctx, rect, mode, isSelected, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    ctx.strokeStyle = colorStrong;
    ctx.fillStyle = colorStrong;
    ctx.lineWidth = UI_ICON_LINE_WIDTH_SMALL;
    switch (mode) {
        case GRID_DISPLAY_MODE_LINES:
            ctx.strokeRect(2, 2, 28, 28);
            ctx.beginPath();
            ctx.moveTo(2, 16); ctx.lineTo(30, 16);
            ctx.moveTo(16, 2); ctx.lineTo(16, 30);
            ctx.stroke();
            break;
        case GRID_DISPLAY_MODE_POINTS:
            ctx.strokeRect(2, 2, 28, 28);
            ctx.beginPath();
            [8, 16, 24].forEach(x => {
                [8, 16, 24].forEach(y => {
                    ctx.moveTo(x, y);
                    ctx.arc(x, y, UI_ICON_POINT_RADIUS, 0, RADIANS_IN_CIRCLE);
                });
            });
            ctx.fill();
            break;
        case GRID_DISPLAY_MODE_TRIANGULAR:
            ctx.strokeRect(2, 2, 28, 28);
            const triRadius = 8;
            const triCenterX = 16;
            const triCenterY = 16;
            ctx.beginPath();
            ctx.arc(triCenterX, triCenterY, UI_ICON_POINT_RADIUS, 0, RADIANS_IN_CIRCLE);
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const x = triCenterX + triRadius * Math.cos(angle);
                const y = triCenterY + triRadius * Math.sin(angle);
                ctx.moveTo(x, y);
                ctx.arc(x, y, UI_ICON_POINT_RADIUS, 0, RADIANS_IN_CIRCLE);
            }
            ctx.fill();
            break;
        case GRID_DISPLAY_MODE_POLAR:
            ctx.beginPath();
            ctx.arc(16, 16, 14, 0, RADIANS_IN_CIRCLE);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(16, 16, 7, 0, RADIANS_IN_CIRCLE);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(2, 16); ctx.lineTo(30, 16);
            ctx.moveTo(16, 2); ctx.lineTo(16, 30);
            ctx.stroke();
            break;
        case GRID_DISPLAY_MODE_NONE:
            ctx.strokeRect(2, 2, 28, 28);
            break;
    }
    ctx.restore();
}

export function drawDisplayIcon(ctx, icon, state, htmlOverlay, updateHtmlLabel) {
    const { coordsDisplayMode, gridDisplayMode, angleDisplayMode, distanceDisplayMode, colors } = state;
    console.log(`Drawing ${icon.group} icon:`, {
        coordsDisplayMode,
        gridDisplayMode, 
        angleDisplayMode,
        distanceDisplayMode
    });
    let isSelected = false;
    switch (icon.group) {
        case 'coords':
            isSelected = coordsDisplayMode !== COORDS_DISPLAY_MODE_NONE;
            break;
        case 'grid':
            isSelected = gridDisplayMode !== GRID_DISPLAY_MODE_NONE;
            break;
        case 'angles':
            isSelected = angleDisplayMode !== ANGLE_DISPLAY_MODE_NONE;
            break;
        case 'distances':
            isSelected = distanceDisplayMode === DISTANCE_DISPLAY_MODE_ON;
            break;
    }
    const rect = { x: icon.x, y: icon.y, width: icon.width, height: icon.height };
    switch (icon.group) {
        case 'coords':
            drawCoordsIcon(ctx, rect, coordsDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);
            break;
        case 'grid':
            drawGridIcon(ctx, rect, gridDisplayMode, isSelected, colors);
            break;
        case 'angles':
            drawAngleIcon(ctx, rect, angleDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);
            break;
        case 'distances':
            drawDistanceIcon(ctx, rect, distanceDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);
            break;
    }
}

export function drawCanvasUI(ctx, htmlOverlay, state, updateHtmlLabel) {
    // The state object is now passed through correctly
    const { dpr, canvasUI, isToolbarExpanded, isColorPaletteExpanded, isTransformPanelExpanded, isDisplayPanelExpanded, isPlacingTransform, placingTransformType, placingSnapPos, mousePos, selectedSwatchIndex, recentColors, activeThemeName, colors } = state;
    
    ctx.save();
    ctx.resetTransform();
    ctx.scale(dpr, dpr);

    const btn = canvasUI.toolbarButton;
    ctx.strokeStyle = colors.uiDefault;
    ctx.lineWidth = UI_MENU_ICON_LINE_WIDTH;
    ctx.beginPath();
    for (let i = 0; i < 3; i++) {
        const lineY = btn.y + 5 + i * 10;
        ctx.moveTo(btn.x + 4, lineY);
        ctx.lineTo(btn.x + btn.width - 4, lineY);
    }
    ctx.stroke();

    if (isToolbarExpanded) {
        const ctb = canvasUI.colorToolButton;
        if (ctb) {
            if (!colorWheelIcon) {
                colorWheelIcon = createColorWheelIcon(ctb.width, dpr);
            }
            ctx.drawImage(colorWheelIcon, ctb.x, ctb.y, ctb.width, ctb.height);
        }

        const ttb = canvasUI.transformToolButton;
        if (ttb) {
            updateHtmlLabel({ id: 'transform-tool-label', content: UI_TRANSFORM_TOOL_LABEL_TEXT, x: ttb.x + ttb.width / 2, y: ttb.y + ttb.height / 2, color: colors.uiIcon, fontSize: UI_TRANSFORM_TOOL_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
        }

        const dtb = canvasUI.displayToolButton;
        if (dtb) {
            ctx.strokeStyle = colors.uiDefault;
            ctx.fillStyle = colors.uiDefault;
            ctx.lineWidth = UI_ICON_LINE_WIDTH;
            const barWidth = dtb.width - UI_DISPLAY_ICON_BAR_WIDTH_PADDING;
            for (let i = 0; i < 3; i++) {
                const y = dtb.y + UI_DISPLAY_ICON_Y_OFFSET + i * UI_DISPLAY_ICON_Y_SPACING;
                ctx.beginPath();
                ctx.moveTo(dtb.x + 6, y);
                ctx.lineTo(dtb.x + 6 + barWidth, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(dtb.x + 6 + barWidth * (i / 2), y, UI_DISPLAY_ICON_KNOB_RADIUS, 0, RADIANS_IN_CIRCLE);
                ctx.fill();
            }
        }
        
        const themeBtn = canvasUI.themeToggleButton;
        if (themeBtn) {
            drawThemeIcon(ctx, themeBtn, activeThemeName, colors);
        }
    }

    if (isColorPaletteExpanded) {
        const removeBtn = canvasUI.removeColorButton;
        if (removeBtn) {
            ctx.strokeStyle = colors.uiDefault;
            ctx.lineWidth = UI_BUTTON_BORDER_WIDTH;
            ctx.strokeRect(removeBtn.x, removeBtn.y, removeBtn.width, removeBtn.height);
            ctx.beginPath();
            ctx.moveTo(removeBtn.x + UI_BUTTON_ICON_PADDING, removeBtn.y + removeBtn.height / 2);
            ctx.lineTo(removeBtn.x + removeBtn.width - UI_BUTTON_ICON_PADDING, removeBtn.y + removeBtn.height / 2);
            ctx.stroke();
        }
        canvasUI.colorSwatches.forEach((swatch, index) => {
            ctx.fillStyle = swatch.color;
            ctx.fillRect(swatch.x, swatch.y, swatch.width, swatch.height);
            if (index === selectedSwatchIndex) {
                ctx.strokeStyle = colors.activeCenterGlow;
                ctx.lineWidth = UI_SWATCH_SELECTED_BORDER_WIDTH;
                ctx.strokeRect(swatch.x - 1, swatch.y - 1, swatch.width + 2, swatch.height + 2);
            }
        });
        const addBtn = canvasUI.addColorButton;
        if (addBtn) {
            ctx.strokeStyle = colors.uiDefault;
            ctx.lineWidth = UI_BUTTON_BORDER_WIDTH;
            ctx.strokeRect(addBtn.x, addBtn.y, addBtn.width, addBtn.height);
            ctx.beginPath();
            ctx.moveTo(addBtn.x + addBtn.width / 2, addBtn.y + UI_BUTTON_ICON_PADDING);
            ctx.lineTo(addBtn.x + addBtn.width / 2, addBtn.y + addBtn.height - UI_BUTTON_ICON_PADDING);
            ctx.moveTo(addBtn.x + UI_BUTTON_ICON_PADDING, addBtn.y + addBtn.height / 2);
            ctx.lineTo(addBtn.x + addBtn.width - UI_BUTTON_ICON_PADDING, addBtn.y + addBtn.height / 2);
            ctx.stroke();
        }
    }

    if (isTransformPanelExpanded) {
        canvasUI.transformIcons.forEach(icon => {
            drawUITransformSymbol(ctx, icon, colors);
        });
    }

    if (isDisplayPanelExpanded) {
        canvasUI.displayIcons.forEach(icon => {
            // This now correctly passes the complete state object, which contains
            // the necessary display modes and colors for the icons to draw correctly.
            drawDisplayIcon(ctx, icon, state, htmlOverlay, updateHtmlLabel);
        });
    }

    if (isPlacingTransform) {
        const finalDrawPos = placingSnapPos || mousePos;
        if (finalDrawPos) {
            const iconHalfSize = UI_GHOST_ICON_SIZE / 2;
            const ghostIcon = { type: placingTransformType, x: finalDrawPos.x - iconHalfSize, y: finalDrawPos.y - iconHalfSize, width: UI_GHOST_ICON_SIZE, height: UI_GHOST_ICON_SIZE };
            drawUITransformSymbol(ctx, ghostIcon, colors);
        }
    }

    ctx.restore();
}

=== script.js ===
import {
    solveForPoint,
    generateUniqueId,
    normalizeAngleToPi,
    distance,
    getClosestPointOnLineSegment,
    getMousePosOnCanvas,
    getLineCircleIntersection,
    getLineLineIntersection,
} from './utils.js';

import {
    // Import the main THEMES object
    THEMES,

    // --- GEOMETRY & DRAWING ---
    POINT_RADIUS,
    CENTER_POINT_VISUAL_RADIUS,
    POINT_SELECT_RADIUS,
    LINE_WIDTH,
    DASH_PATTERN,

    // --- INTERACTION ---
    DOUBLE_CLICK_MS,
    DRAG_THRESHOLD,
    EDGE_CLICK_THRESHOLD,
    EDGE_ID_DELIMITER,
    MIN_SCALE_VALUE,
    ZOOM_FACTOR,
    KEYBOARD_ZOOM_FACTOR,
    GRID_SNAP_THRESHOLD_FACTOR,
    BISECTOR_LINE_EXTENSION_FACTOR,
    
    // --- DEFAULTS ---
    DEFAULT_CALIBRATION_VIEW_SCALE,
    DEFAULT_REFERENCE_DISTANCE,
    DEFAULT_REFERENCE_ANGLE_RAD,

    // --- UI & TOOLBAR ---
    UI_BUTTON_PADDING,
    UI_TOOLBAR_WIDTH,
    UI_SWATCH_SIZE,
    MENU_BUTTON_WIDTH,
    MENU_BUTTON_HEIGHT,
    TOOLBAR_SECTION_GAP,
    TOOL_BUTTON_HEIGHT,
    DISPLAY_ICON_SIZE,
    DISPLAY_ICON_PADDING,
    TRANSFORM_ICON_SIZE,
    TRANSFORM_ICON_PADDING,
    TRANSFORM_ICON_Y_OFFSET,
    COLOR_PALETTE_Y_OFFSET,

    // --- SNAPPING PARAMETERS ---
    GEOMETRY_CALCULATION_EPSILON,
    SNAP_STICKINESS_RADIUS_SCREEN,
    LINE_TO_SNAP_RADIUS_SCREEN,
    POINT_ON_LINE_SNAP_RADIUS_SCREEN,
    DRAG_SNAP_GEOMETRIC_DISTANCE_FACTORS,
    DRAW_SNAP_DISTANCE_FACTOR_STEP,
    DRAW_SNAP_DISTANCE_FACTOR_LIMIT,
    MAX_HISTORY_SIZE,
    NINETY_DEG_ANGLE_SNAP_FRACTIONS,
    SNAP_FACTORS,

    // --- ENUMS & LITERALS ---
    POINT_TYPE_REGULAR,
    TRANSFORM_TYPE_ROTATE_SCALE,
    TRANSFORM_TYPE_ROTATE_ONLY,
    TRANSFORM_TYPE_SCALE_ONLY,
    COORDS_DISPLAY_MODE_REGULAR,
    COORDS_DISPLAY_MODE_COMPLEX,
    COORDS_DISPLAY_MODE_POLAR,
    COORDS_DISPLAY_MODE_NONE,
    GRID_DISPLAY_MODE_LINES,
    GRID_DISPLAY_MODE_POINTS,
    GRID_DISPLAY_MODE_TRIANGULAR,
    GRID_DISPLAY_MODE_POLAR,
    GRID_DISPLAY_MODE_NONE,
    ANGLE_DISPLAY_MODE_DEGREES,
    ANGLE_DISPLAY_MODE_RADIANS,
    ANGLE_DISPLAY_MODE_NONE,
    DISTANCE_DISPLAY_MODE_ON,
    DISTANCE_DISPLAY_MODE_NONE,
    KEY_SPACE,
    KEY_ESCAPE,
    KEY_DELETE,
    KEY_BACKSPACE,
    KEY_REPEAT,
    KEY_ZOOM_IN,
    KEY_ZOOM_IN_PLUS,
    KEY_ZOOM_OUT,
    KEY_COPY,
    KEY_PASTE,
    KEY_CUT,
    KEY_UNDO,
    KEY_REDO,
    KEY_SELECT_ALL

} from './constants.js';

import {drawPoint, 
        drawAllEdges,
        drawGrid,
        drawCanvasUI,
        updateMouseCoordinates,
        drawTransformIndicators,
        drawDragFeedback,
        calculateGridIntervals,
        getDynamicAngularIntervals,
        drawAxes,
        prepareSnapInfoTexts,
        prepareReferenceElementsTexts,
        drawReferenceElementsGeometry
        } from './renderer.js';


const canvas = document.getElementById('drawingCanvas');
const ctx = canvas.getContext('2d');
const htmlOverlay = document.getElementById('html-overlay');
const colorPicker = document.getElementById('colorPicker');
const dpr = window.devicePixelRatio || 1;
const activeHtmlLabels = new Map();
const canvasUI = {
    toolbarButton: null,
    mainToolbar: null,
    colorToolButton: null,
    colorSwatches: [],
    addColorButton: null,
    transformToolButton: null,
    transformIcons: [],     
    displayToolButton: null,
    displayIcons: []
};






let frozenReference_A_rad = null;
let frozenReference_A_baseRad = null;
let frozenReference_D_du = null;
let frozenReference_Origin_Data = null;
let isMouseOverCanvas = false;
let placingSnapPos = null;
let isDisplayPanelExpanded = false;
let coordsDisplayMode = 'regular';    // Options: 'regular', 'complex', 'polar', 'none'
let gridDisplayMode = 'lines';      // Options: 'lines', 'points', 'none'
let angleDisplayMode = 'degrees';  // Options: 'degrees', 'radians', 'none'
let distanceDisplayMode = 'on';    // Options: 'on', 'none'
let isEdgeTransformDrag = false;
let isDraggingCenter = false;
let allPoints = [];
let allEdges = [];
let selectedPointIds = [];
let selectedEdgeIds = [];
let activeCenterId = null;
let mousePos = { x: 0, y: 0 };
let frozenReference_D_g2g = null;
let isToolbarExpanded = false;
let isColorPaletteExpanded = false;
let selectedSwatchIndex = null;
let isTransformPanelExpanded = false;
let isPlacingTransform = false;
let placingTransformType = null;
let drawingSequence = [];
let currentSequenceIndex = 0;
let showAngles = true;
let showDistances = true;
let angleSigFigs = 4;
let distanceSigFigs = 3;
let gridAlpha = 0.5;
let transformIndicatorData = null;
let isActionInProgress = false;
let isDragConfirmed = false;
let isPanningBackground = false;
let isRectangleSelecting = false;
let currentMouseButton = -1;
let actionStartPos = { x: 0, y: 0 };
let backgroundPanStartOffset = { x: 0, y: 0 };
let initialDragPointStates = [];
let rectangleSelectStartPos = { x: 0, y: 0 };
let actionContext = null;
let recentColors = ['#ffffff', '#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#44ffff', '#ffa544'];
let isDrawingMode = false;
let previewLineStartPointId = null;
let actionTargetPoint = null;
let dragPreviewPoints = [];
let currentShiftPressed = false;
let clipboard = { points: [], edges: [], referencePoint: null };
let clickData = { targetId: null, type: null, count: 0, timestamp: 0 };
let undoStack = [];
let redoStack = [];
let ghostPointPosition = null;
let selectedCenterIds = []; // ADD THIS NEW STATE VARIABLE
let lastGridState = {
    interval1: null,
    interval2: null,
    alpha1: 0,
    alpha2: 0,
    scale: null
};
let viewTransform = {
    scale: DEFAULT_CALIBRATION_VIEW_SCALE,
    offsetX: 0,
    offsetY: 0
};
let lastAngularGridState = {
    angle1: 30,
    angle2: 15,
    alpha1: 1,
    alpha2: 0,
};
let labelsToKeepThisFrame = new Set();

let activeThemeName = 'dark';
let currentColor = THEMES[activeThemeName].point;



function updateHtmlLabel({ id, content, x, y, color, fontSize, options = {} }) {
    labelsToKeepThisFrame.add(id);
    let el = activeHtmlLabels.get(id);

    if (!el) {
        el = document.createElement('div');
        el.style.position = 'absolute';
        el.style.fontFamily = 'KaTeX_Main, Times New Roman, serif';
        el.style.whiteSpace = 'nowrap';
        htmlOverlay.appendChild(el);
        activeHtmlLabels.set(id, el);
    }

    let transform = '';
    if (options.textAlign === 'center') {
        transform += ' translateX(-50%)';
    } else if (options.textAlign === 'right') {
        transform += ' translateX(-100%)';
    }

    if (options.textBaseline === 'middle') {
        transform += ' translateY(-50%)';
    } else if (options.textBaseline === 'bottom') {
        transform += ' translateY(-100%)';
    }

    if (options.rotation !== undefined) {
        transform += ` rotate(${options.rotation}deg)`;
    }

    el.style.transform = transform.trim();
    el.style.left = `${x}px`;
    el.style.top = `${y}px`;
    el.style.color = color;
    el.style.fontSize = `${fontSize}px`;

    if (el.katexContent !== content) {
        if (typeof window.katex !== 'undefined') {
            katex.render(content, el, {
                throwOnError: false,
                displayMode: false
            });
        } else {
            el.textContent = content.replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, "$1/$2").replace(/[\\{}]/g, "");
        }
        el.katexContent = content;
    }
}

function cleanupHtmlLabels() {
    for (const [id, el] of activeHtmlLabels.entries()) {
        if (!labelsToKeepThisFrame.has(id)) {
            el.remove();
            activeHtmlLabels.delete(id);
        }
    }
}

function handleCenterSelection(centerId, shiftKey, ctrlKey) {
    if (ctrlKey) {
        const index = selectedCenterIds.indexOf(centerId);
        if (index > -1) {
            selectedCenterIds.splice(index, 1);
        } else {
            selectedCenterIds.push(centerId);
        }
    } else if (shiftKey) {
        if (!selectedCenterIds.includes(centerId)) {
            selectedCenterIds.push(centerId);
        }
    } else {
        // If the clicked center is already the only one selected, do nothing.
        if (selectedCenterIds.length === 1 && selectedCenterIds[0] === centerId) {
            return;
        }
        // Otherwise, select only the clicked center.
        selectedCenterIds = [centerId];
    }
    
    // Update the active center to be the last one selected.
    activeCenterId = selectedCenterIds.length > 0 ? selectedCenterIds[selectedCenterIds.length - 1] : null;
}

function getBestSnapPosition(mouseDataPos) {
    const candidates = [];
    const distanceSq = (p1, p2) => (p1.x - p2.x)**2 + (p1.y - p2.y)**2;
    
    if (gridDisplayMode !== 'none') {
        const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        if (gridInterval > 0) {
            if (gridDisplayMode === 'polar') {
                const mouseAngleDeg = (Math.atan2(mouseDataPos.y, mouseDataPos.x) * 180 / Math.PI + 360) % 360;
                const mouseRadius = Math.hypot(mouseDataPos.x, mouseDataPos.y);
                const snappedRadius = Math.round(mouseRadius / gridInterval) * gridInterval;

                lastAngularGridState.forEach(level => {
                    if (level.alpha > 0.01 && level.angle > 0) {
                        const angularInterval = level.angle;
                        const snappedAngleDeg = Math.round(mouseAngleDeg / angularInterval) * angularInterval;
                        const snappedAngleRad = snappedAngleDeg * Math.PI / 180;
                        const gridPoint = { x: snappedRadius * Math.cos(snappedAngleRad), y: snappedRadius * Math.sin(snappedAngleRad) };
                        candidates.push({ pos: gridPoint, distSq: distanceSq(mouseDataPos, gridPoint) });
                    }
                });
            } else if (gridDisplayMode === 'triangular') {
                const y_step = gridInterval * Math.sqrt(3) / 2;
                const i_f = (mouseDataPos.x / gridInterval) - (mouseDataPos.y / (gridInterval * Math.sqrt(3)));
                const j_f = mouseDataPos.y / y_step;

                let i_r = Math.round(i_f);
                let j_r = Math.round(j_f);
                let k_r = Math.round(-i_f - j_f);

                const i_diff = Math.abs(i_r - i_f);
                const j_diff = Math.abs(j_r - j_f);
                const k_diff = Math.abs(k_r - (-i_f - j_f));

                if (i_diff > j_diff && i_diff > k_diff) {
                    i_r = -j_r - k_r;
                } else if (j_diff > k_diff) {
                    j_r = -i_r - k_r;
                }

                const snappedX = i_r * gridInterval + j_r * gridInterval / 2;
                const snappedY = j_r * y_step;
                const gridPoint = { x: snappedX, y: snappedY };
                candidates.push({ pos: gridPoint, distSq: distanceSq(mouseDataPos, gridPoint) });
            } else {
                const gridPoint = { x: Math.round(mouseDataPos.x / gridInterval) * gridInterval, y: Math.round(mouseDataPos.y / gridInterval) * gridInterval };
                candidates.push({ pos: gridPoint, distSq: distanceSq(mouseDataPos, gridPoint) });
            }
        }
    }

    allPoints.forEach(p => { 
        if (p.type === 'regular') {
            candidates.push({ pos: p, distSq: distanceSq(mouseDataPos, p) }); 
        }
    });

    allEdges.forEach(edge => {
        const p1 = findPointById(edge.id1);
        const p2 = findPointById(edge.id2);
        if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
            const midpoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            candidates.push({ pos: midpoint, distSq: distanceSq(mouseDataPos, midpoint) });
        }
    });

    if (candidates.length === 0) return null;
    const bestCandidate = candidates.sort((a, b) => a.distSq - b.distSq)[0];
    return bestCandidate.pos;
}

function getTransformSnap(center, mouseDataPos, startReferencePoint, transformType) {
    const allCandidates = [];
    const startVector = { x: startReferencePoint.x - center.x, y: startReferencePoint.y - center.y };
    const startDist = Math.hypot(startVector.x, startVector.y);
    const startAngle = Math.atan2(startVector.y, startVector.x);

    if (gridDisplayMode !== 'none') {
        const mouseRelativeToCenter = { x: mouseDataPos.x - center.x, y: mouseDataPos.y - center.y };

        if (gridDisplayMode === 'polar') {
            const dominantRadialInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
            if (dominantRadialInterval > 0) {
                const mouseAngleDeg = (Math.atan2(mouseRelativeToCenter.y, mouseRelativeToCenter.x) * 180 / Math.PI + 360) % 360;
                const mouseRadius = Math.hypot(mouseRelativeToCenter.x, mouseRelativeToCenter.y);
                const snappedRadius = Math.round(mouseRadius / dominantRadialInterval) * dominantRadialInterval;
                
                lastAngularGridState.forEach(level => {
                    if (level.alpha > 0.01 && level.angle > 0) {
                        const angularInterval = level.angle;
                        const snappedAngleDeg = Math.round(mouseAngleDeg / angularInterval) * angularInterval;
                        const snappedAngleRad = snappedAngleDeg * Math.PI / 180;
                        allCandidates.push({
                            pos: { x: center.x + snappedRadius * Math.cos(snappedAngleRad), y: center.y + snappedRadius * Math.sin(snappedAngleRad) },
                            type: 'grid', pureRotation: null, pureScale: null
                        });
                    }
                });
            }
        } else {
            const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
            if (gridInterval > 0) {
                const snappedRelativeX = Math.round(mouseRelativeToCenter.x / gridInterval) * gridInterval;
                const snappedRelativeY = Math.round(mouseRelativeToCenter.y / gridInterval) * gridInterval;
                allCandidates.push({
                    pos: { x: center.x + snappedRelativeX, y: center.y + snappedRelativeY },
                    type: 'grid', pureRotation: null, pureScale: null
                });
            }
        }
    }

    if (startDist > GEOMETRY_CALCULATION_EPSILON) {
        const scaleSnapFactors = SNAP_FACTORS.filter(f => f > 0);
        const angleSnapFractions = NINETY_DEG_ANGLE_SNAP_FRACTIONS;
        const useAngleSnaps = transformType !== 'center_scale_only';
        const useScaleSnaps = transformType !== 'center_rotate_only';
        const rotationSnaps = useAngleSnaps ? angleSnapFractions.flatMap(f => (f === 0 ? [0] : [f * Math.PI / 2, -f * Math.PI / 2])) : [0];
        const scaleSnaps = useScaleSnaps ? scaleSnapFactors : [1];
        for (const rot of rotationSnaps) {
            for (const factor of scaleSnaps) {
                const dist = startDist * factor;
                allCandidates.push({
                    pos: { x: center.x + dist * Math.cos(startAngle + rot), y: center.y + dist * Math.sin(startAngle + rot) },
                    type: 'transform', pureRotation: rot, pureScale: factor
                });
            }
        }
    }

    if (allCandidates.length === 0) return { snapped: false };

    let bestCandidate = allCandidates.reduce((best, current) => {
        const distSq = (p, c) => (p.x - c.pos.x) ** 2 + (p.y - c.pos.y) ** 2;
        return distSq(mouseDataPos, current) < distSq(mouseDataPos, best) ? current : best;
    });

    const finalVec = { x: bestCandidate.pos.x - center.x, y: bestCandidate.pos.y - center.y };
    const finalScale = (startDist > GEOMETRY_CALCULATION_EPSILON) ? Math.hypot(finalVec.x, finalVec.y) / startDist : 1;
    let finalRotation;
    if (bestCandidate.pureRotation !== null) {
        const rawMouseRotation = normalizeAngleToPi(Math.atan2(mouseDataPos.y - center.y, mouseDataPos.x - center.x) - startAngle);
        const pureRot = bestCandidate.pureRotation;
        const rotationsToTest = [pureRot, pureRot + 2 * Math.PI, pureRot - 2 * Math.PI];
        finalRotation = rotationsToTest.reduce((best, current) => {
            return Math.abs(current - rawMouseRotation) < Math.abs(best - rawMouseRotation) ? current : best;
        });
    } else {
        finalRotation = normalizeAngleToPi(Math.atan2(finalVec.y, finalVec.x) - startAngle);
    }
    return {
        snapped: true, pos: bestCandidate.pos, rotation: finalRotation,
        scale: bestCandidate.pureScale ?? finalScale,
        pureScaleForDisplay: bestCandidate.pureScale
    };
}

function getSnappedPosition(startPoint, mouseScreenPos, shiftPressed) {
    const mouseDataPos = screenToData(mouseScreenPos);
    const drawingContext = getDrawingContext(startPoint.id);

    const distanceSq = (p1, p2) => (p1.x - p2.x)**2 + (p1.y - p2.y)**2;

    const pointSelectRadiusData = POINT_SELECT_RADIUS / viewTransform.scale;
    for (const p of allPoints) {
        if (p.id !== startPoint.id && p.type === "regular" && distance(mouseDataPos, p) < pointSelectRadiusData) {
            const finalAngleRad = Math.atan2(p.y - startPoint.y, p.x - startPoint.x) || 0;
            return { x: p.x, y: p.y, angle: finalAngleRad * (180 / Math.PI), distance: distance(startPoint, p), snapped: true, gridSnapped: false, lengthSnapFactor: null, angleSnapFactor: null, angleTurn: normalizeAngleToPi(finalAngleRad, 0), gridToGridSquaredSum: null, gridInterval: null };
        }
    }

    const edgeClickThresholdData = EDGE_CLICK_THRESHOLD / viewTransform.scale;
    for (const edge of allEdges) {
        const p1 = findPointById(edge.id1);
        const p2 = findPointById(edge.id2);
        if (p1 && p2 && p1.type === "regular" && p2.type === "regular" && p1.id !== startPoint.id && p2.id !== startPoint.id) {
            const closest = getClosestPointOnLineSegment(mouseDataPos, p1, p2);
            if (closest.distance < edgeClickThresholdData && closest.onSegmentStrict) {
                const finalAngleRad = Math.atan2(closest.y - startPoint.y, closest.x - startPoint.x) || 0;
                return { x: closest.x, y: closest.y, angle: finalAngleRad * (180 / Math.PI), distance: distance(startPoint, closest), snapped: true, gridSnapped: false, lengthSnapFactor: null, angleSnapFactor: null, angleTurn: normalizeAngleToPi(finalAngleRad, 0), gridToGridSquaredSum: null, gridInterval: null };
            }
        }
    }

    if (!shiftPressed) {
        const finalAngleRad = Math.atan2(mouseDataPos.y - startPoint.y, mouseDataPos.x - startPoint.x) || 0;
        return {
            x: mouseDataPos.x, y: mouseDataPos.y,
            angle: finalAngleRad * (180 / Math.PI),
            distance: distance(startPoint, mouseDataPos),
            snapped: false, gridSnapped: false, lengthSnapFactor: null, angleSnapFactor: null,
            angleTurn: normalizeAngleToPi(finalAngleRad - drawingContext.offsetAngleRad),
            gridToGridSquaredSum: null, gridInterval: null
        };
    }

    const gridSnapThreshold = POINT_SELECT_RADIUS / viewTransform.scale * 0.8;
    let priorityGridCandidate = null;
    
    if (gridDisplayMode !== 'none' && lastGridState.interval1) {
        const dominantGridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        if (dominantGridInterval > 0) {
            if (gridDisplayMode === 'polar') {
                const mouseAngleDeg = (Math.atan2(mouseDataPos.y, mouseDataPos.x) * 180 / Math.PI + 360) % 360;
                const mouseRadius = Math.hypot(mouseDataPos.x, mouseDataPos.y);
                const snappedRadius = Math.round(mouseRadius / dominantGridInterval) * dominantGridInterval;
                lastAngularGridState.forEach(level => {
                    if (level.alpha > 0.01 && level.angle > 0) {
                        const angularInterval = level.angle;
                        const snappedAngleDeg = Math.round(mouseAngleDeg / angularInterval) * angularInterval;
                        const snappedAngleRad = snappedAngleDeg * Math.PI / 180;
                        const pos = { x: snappedRadius * Math.cos(snappedAngleRad), y: snappedRadius * Math.sin(snappedAngleRad) };
                        const gridDist = distance(mouseDataPos, pos);
                        if (gridDist < gridSnapThreshold) {
                            if (!priorityGridCandidate || gridDist < distance(mouseDataPos, priorityGridCandidate.pos)) {
                                priorityGridCandidate = { pos: pos, isGridPoint: true, type: 'polar_grid_snap' };
                            }
                        }
                    }
                });
            } else if (gridDisplayMode === 'triangular') {
                const y_step = dominantGridInterval * Math.sqrt(3) / 2;
                const i_f = (mouseDataPos.x / dominantGridInterval) - (mouseDataPos.y / (dominantGridInterval * Math.sqrt(3)));
                const j_f = mouseDataPos.y / y_step;

                let i_r = Math.round(i_f);
                let j_r = Math.round(j_f);
                let k_r = Math.round(-i_f - j_f);

                const i_diff = Math.abs(i_r - i_f);
                const j_diff = Math.abs(j_r - j_f);
                const k_diff = Math.abs(k_r - (-i_f - j_f));

                if (i_diff > j_diff && i_diff > k_diff) {
                    i_r = -j_r - k_r;
                } else if (j_diff > k_diff) {
                    j_r = -i_r - k_r;
                }
                const snappedX = i_r * dominantGridInterval + j_r * dominantGridInterval / 2;
                const snappedY = j_r * y_step;
                const pos = { x: snappedX, y: snappedY };
                const gridDist = distance(mouseDataPos, pos);
                if (gridDist < gridSnapThreshold) {
                    priorityGridCandidate = { pos: pos, isGridPoint: true, type: 'triangular_grid_snap' };
                }
            } else {
                const gridX = Math.round(mouseDataPos.x / dominantGridInterval) * dominantGridInterval;
                const gridY = Math.round(mouseDataPos.y / dominantGridInterval) * dominantGridInterval;
                const pos = { x: gridX, y: gridY };
                const gridDist = distance(mouseDataPos, pos);
                if (gridDist < gridSnapThreshold) {
                    priorityGridCandidate = { pos: pos, isGridPoint: true, type: 'rect_grid_snap' };
                }
            }
        }
    }
    
    if (priorityGridCandidate) {
        const finalAngle = Math.atan2(priorityGridCandidate.pos.y - startPoint.y, priorityGridCandidate.pos.x - startPoint.x) || 0;
        const snappedDistanceOutput = parseFloat(distance(startPoint, priorityGridCandidate.pos).toFixed(10));
        
        let gridToGridSquaredSum = null;
        let finalGridInterval = null;
        if (gridDisplayMode !== 'polar') {
            const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
            const epsilon = gridInterval * GEOMETRY_CALCULATION_EPSILON;
            const startIsOnGridX = Math.abs(startPoint.x / gridInterval - Math.round(startPoint.x / gridInterval)) < epsilon;
            const startIsOnGridY = Math.abs(startPoint.y / gridInterval - Math.round(startPoint.y / gridInterval)) < epsilon;
            if (startIsOnGridX && startIsOnGridY) {
                const deltaX = priorityGridCandidate.pos.x - startPoint.x;
                const deltaY = priorityGridCandidate.pos.y - startPoint.y;
                const dx_grid = Math.round(deltaX / gridInterval);
                const dy_grid = Math.round(deltaY / gridInterval);
                gridToGridSquaredSum = dx_grid * dx_grid + dy_grid * dy_grid;
                finalGridInterval = gridInterval;
            }
        }
        
        const rawAngle = Math.atan2(mouseDataPos.y - startPoint.y, mouseDataPos.x - startPoint.x);
        const snappedTurnRaw = finalAngle - drawingContext.offsetAngleRad;
        const rawTurn = rawAngle - drawingContext.offsetAngleRad;
        const turnOptions = [snappedTurnRaw, snappedTurnRaw + 2 * Math.PI, snappedTurnRaw - 2 * Math.PI];
        const finalAngleTurn = turnOptions.reduce((best, current) => {
            return Math.abs(current - rawTurn) < Math.abs(best - rawTurn) ? current : best;
        });
        
        return {
            x: parseFloat(priorityGridCandidate.pos.x.toFixed(10)),
            y: parseFloat(priorityGridCandidate.pos.y.toFixed(10)),
            angle: finalAngle * (180 / Math.PI),
            distance: snappedDistanceOutput,
            snapped: true,
            gridSnapped: true,
            isGridPointSnap: true,
            lengthSnapFactor: null,
            angleSnapFactor: null,
            angleTurn: finalAngleTurn,
            gridToGridSquaredSum: gridToGridSquaredSum,
            gridInterval: finalGridInterval
        };
    }

    const categorizedSnapCandidates = [];
    let closestGridPoint = null;

    if (gridDisplayMode !== 'none' && lastGridState.interval1) {
        const dominantGridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        if (dominantGridInterval > 0) {
            if (gridDisplayMode === 'triangular') {
                const y_step = dominantGridInterval * Math.sqrt(3) / 2;
                const i_f = (mouseDataPos.x / dominantGridInterval) - (mouseDataPos.y / (dominantGridInterval * Math.sqrt(3)));
                const j_f = mouseDataPos.y / y_step;
                let i_r = Math.round(i_f), j_r = Math.round(j_f), k_r = Math.round(-i_f - j_f);
                const i_diff = Math.abs(i_r - i_f), j_diff = Math.abs(j_r - j_f), k_diff = Math.abs(k_r - (-i_f - j_f));
                if (i_diff > j_diff && i_diff > k_diff) { i_r = -j_r - k_r; } else if (j_diff > k_diff) { j_r = -i_r - k_r; }
                const snappedX = i_r * dominantGridInterval + j_r * dominantGridInterval / 2;
                const snappedY = j_r * y_step;
                closestGridPoint = { pos: { x: snappedX, y: snappedY }, isGridPoint: true, type: 'triangular_grid_snap' };
            } else if (gridDisplayMode === 'polar') {
                const mouseAngleDeg = (Math.atan2(mouseDataPos.y, mouseDataPos.x) * 180 / Math.PI + 360) % 360;
                const mouseRadius = Math.hypot(mouseDataPos.x, mouseDataPos.y);
                const snappedRadius = Math.round(mouseRadius / dominantGridInterval) * dominantGridInterval;
                let bestPolarDist = Infinity;
                lastAngularGridState.forEach(level => {
                    if (level.alpha > 0.01 && level.angle > 0) {
                        const angularInterval = level.angle;
                        const snappedAngleDeg = Math.round(mouseAngleDeg / angularInterval) * angularInterval;
                        const snappedAngleRad = snappedAngleDeg * Math.PI / 180;
                        const pos = { x: snappedRadius * Math.cos(snappedAngleRad), y: snappedRadius * Math.sin(snappedAngleRad) };
                        const dist = distanceSq(mouseDataPos, pos);
                        if (dist < bestPolarDist) {
                            bestPolarDist = dist;
                            closestGridPoint = { pos, isGridPoint: true, type: 'polar_grid_snap' };
                        }
                    }
                });
            } else {
                const baseX = Math.floor(mouseDataPos.x / dominantGridInterval) * dominantGridInterval;
                const baseY = Math.floor(mouseDataPos.y / dominantGridInterval) * dominantGridInterval;
                const candidates = [
                    { x: baseX, y: baseY },
                    { x: baseX + dominantGridInterval, y: baseY },
                    { x: baseX, y: baseY + dominantGridInterval },
                    { x: baseX + dominantGridInterval, y: baseY + dominantGridInterval }
                ];
                let bestDistSq = Infinity;
                let bestPos = null;
                candidates.forEach(pos => {
                    const dist = distanceSq(mouseDataPos, pos);
                    if (dist < bestDistSq) {
                        bestDistSq = dist;
                        bestPos = pos;
                    }
                });
                closestGridPoint = { pos: bestPos, isGridPoint: true, type: 'rect_grid_snap' };
            }
        }
    }
    if (closestGridPoint) {
        categorizedSnapCandidates.push(closestGridPoint);
    }
    
    let closestAngleDistanceSnap = null;
    let minAngleDistSnapSq = Infinity;
    const referenceAngleForSnapping = drawingContext.currentSegmentReferenceA_for_display;
    const baseUnitDistance = drawingContext.currentSegmentReferenceD;
    const symmetricalAngleFractions = new Set([0, ...NINETY_DEG_ANGLE_SNAP_FRACTIONS.flatMap(f => [f, -f])]);
    const sortedSymmetricalFractions = Array.from(symmetricalAngleFractions).sort((a, b) => a - b);
    const allSnapAngles = sortedSymmetricalFractions.map(f => ({ factor: f, angle: normalizeAngleToPi(drawingContext.offsetAngleRad + (f * referenceAngleForSnapping)), turn: normalizeAngleToPi(f * referenceAngleForSnapping) }));
    const allSnapDistances = [];
    for (let i = 0; i <= DRAW_SNAP_DISTANCE_FACTOR_LIMIT / DRAW_SNAP_DISTANCE_FACTOR_STEP; i++) {
        const factor = i * DRAW_SNAP_DISTANCE_FACTOR_STEP;
        allSnapDistances.push({ factor: factor, dist: factor * baseUnitDistance });
    }
    if (allSnapAngles.length > 0 && allSnapDistances.length > 0) {
        for (const angleData of allSnapAngles) {
            for (const distData of allSnapDistances) {
                const pos = { x: startPoint.x + distData.dist * Math.cos(angleData.angle), y: startPoint.y + distData.dist * Math.sin(angleData.angle) };
                const dist = distanceSq(mouseDataPos, pos);
                if (dist < minAngleDistSnapSq) {
                    minAngleDistSnapSq = dist;
                    closestAngleDistanceSnap = {
                        pos: pos,
                        type: 'angle_distance_snap',
                        lengthSnapFactor: distData.factor,
                        angleSnapFactor: angleData.factor,
                        angleTurn: angleData.turn
                    };
                }
            }
        }
    }
    if (closestAngleDistanceSnap) {
        categorizedSnapCandidates.push(closestAngleDistanceSnap);
    }

    if (categorizedSnapCandidates.length > 0) {
        const bestOverallCandidate = categorizedSnapCandidates.reduce((best, current) =>
            distanceSq(mouseDataPos, current.pos) < distanceSq(mouseDataPos, best.pos) ? current : best
        );

        const finalAngle = Math.atan2(bestOverallCandidate.pos.y - startPoint.y, bestOverallCandidate.pos.x - startPoint.x) || 0;
        const snappedDistanceOutput = parseFloat(distance(startPoint, bestOverallCandidate.pos).toFixed(10));

        let gridToGridSquaredSum = null;
        let finalGridInterval = null;
        if (bestOverallCandidate.isGridPoint && gridDisplayMode !== 'polar') {
            const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
            const epsilon = gridInterval * GEOMETRY_CALCULATION_EPSILON;
            const startIsOnGridX = Math.abs(startPoint.x / gridInterval - Math.round(startPoint.x / gridInterval)) < epsilon;
            const startIsOnGridY = Math.abs(startPoint.y / gridInterval - Math.round(startPoint.y / gridInterval)) < epsilon;
            if (startIsOnGridX && startIsOnGridY) {
                const deltaX = bestOverallCandidate.pos.x - startPoint.x;
                const deltaY = bestOverallCandidate.pos.y - startPoint.y;
                const dx_grid = Math.round(deltaX / gridInterval);
                const dy_grid = Math.round(deltaY / gridInterval);
                gridToGridSquaredSum = dx_grid * dx_grid + dy_grid * dy_grid;
                finalGridInterval = gridInterval;
            }
        }

        let finalAngleTurn;
        if (bestOverallCandidate.angleTurn != null) {
            finalAngleTurn = bestOverallCandidate.angleTurn;
        } else {
            const rawAngle = Math.atan2(mouseDataPos.y - startPoint.y, mouseDataPos.x - startPoint.x);
            const snappedTurnRaw = finalAngle - drawingContext.offsetAngleRad;
            const rawTurn = rawAngle - drawingContext.offsetAngleRad;
            const turnOptions = [snappedTurnRaw, snappedTurnRaw + 2 * Math.PI, snappedTurnRaw - 2 * Math.PI];
            finalAngleTurn = turnOptions.reduce((best, current) => {
                return Math.abs(current - rawTurn) < Math.abs(best - rawTurn) ? current : best;
            });
        }

        return {
            x: parseFloat(bestOverallCandidate.pos.x.toFixed(10)),
            y: parseFloat(bestOverallCandidate.pos.y.toFixed(10)),
            angle: finalAngle * (180 / Math.PI),
            distance: snappedDistanceOutput,
            snapped: true,
            gridSnapped: !!bestOverallCandidate.isGridPoint,
            isGridPointSnap: !!bestOverallCandidate.isGridPoint,
            lengthSnapFactor: bestOverallCandidate.lengthSnapFactor || null,
            angleSnapFactor: bestOverallCandidate.angleSnapFactor || null,
            angleTurn: finalAngleTurn,
            gridToGridSquaredSum: gridToGridSquaredSum,
            gridInterval: finalGridInterval,
        };
    }

    const finalAngleRad = Math.atan2(mouseDataPos.y - startPoint.y, mouseDataPos.x - startPoint.x) || 0;
    return {
        x: mouseDataPos.x, y: mouseDataPos.y,
        angle: finalAngleRad * (180 / Math.PI),
        distance: distance(startPoint, mouseDataPos),
        snapped: false, gridSnapped: false, lengthSnapFactor: null, angleSnapFactor: null,
        angleTurn: normalizeAngleToPi(finalAngleRad - drawingContext.offsetAngleRad),
        gridToGridSquaredSum: null, gridInterval: null,
    };
}

function getDragSnapPosition(dragOrigin, mouseDataPos) {
    const neighbors = findNeighbors(dragOrigin.id).map(id => allPoints.find(p => p.id === id)).filter(Boolean);
    const distanceSq = (p1, p2) => (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
    const lineToSnapRadius = LINE_TO_SNAP_RADIUS_SCREEN / viewTransform.scale;
    const pointOnLineSnapRadius = POINT_ON_LINE_SNAP_RADIUS_SCREEN / viewTransform.scale;
    let bestBisector = null;
    let minDistToBisector = Infinity;
    let bestBisectorNeighbors = null;
    for (let i = 0; i < neighbors.length; i++) {
        for (let j = i + 1; j < neighbors.length; j++) {
            const p1 = neighbors[i];
            const p2 = neighbors[j];
            const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            const perpVec = { x: -(p2.y - p1.y), y: p2.x - p1.x };
            if (Math.hypot(perpVec.x, perpVec.y) < GEOMETRY_CALCULATION_EPSILON) continue;
            const bisectorP1 = { x: midPoint.x - perpVec.x * BISECTOR_LINE_EXTENSION_FACTOR, y: midPoint.y - perpVec.y * BISECTOR_LINE_EXTENSION_FACTOR };
            const bisectorP2 = { x: midPoint.x + perpVec.x * BISECTOR_LINE_EXTENSION_FACTOR, y: midPoint.y + perpVec.y * BISECTOR_LINE_EXTENSION_FACTOR };
            const closestPointOnLine = getClosestPointOnLineSegment(mouseDataPos, bisectorP1, bisectorP2);
            if (closestPointOnLine.distance < minDistToBisector) {
                minDistToBisector = closestPointOnLine.distance;
                bestBisector = { p1: bisectorP1, p2: bisectorP2, projection: closestPointOnLine };
                bestBisectorNeighbors = [p1, p2];
            }
        }
    }
    if (bestBisector && minDistToBisector < lineToSnapRadius) {
        const secondOrderCandidates = [];
        const [p1, p2] = bestBisectorNeighbors;
        const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        const d_half = distance(p1, midPoint);
        const perpVec = { x: -(p2.y - p1.y), y: p2.x - p1.x };
        const perpVecMag = Math.hypot(perpVec.x, perpVec.y);
        if (d_half > GEOMETRY_CALCULATION_EPSILON && perpVecMag > GEOMETRY_CALCULATION_EPSILON) {
            const normPerpVec = { x: perpVec.x / perpVecMag, y: perpVec.y / perpVecMag };
            const geometricSnapAnglesRad = NINETY_DEG_ANGLE_SNAP_FRACTIONS
                .map(f => f * (Math.PI / 2))
                .filter(angle => angle > GEOMETRY_CALCULATION_EPSILON && angle < Math.PI);
            geometricSnapAnglesRad.forEach(angleRad => {
                const tanHalfTheta = Math.tan(angleRad / 2);
                if (Math.abs(tanHalfTheta) > GEOMETRY_CALCULATION_EPSILON) {
                    const h = d_half / tanHalfTheta;
                    secondOrderCandidates.push({ x: midPoint.x + h * normPerpVec.x, y: midPoint.y + h * normPerpVec.y });
                }
            });
        }
        if (gridDisplayMode !== 'none') {
            const topLeftData = screenToData({ x: 0, y: 0 });
            const bottomRightData = screenToData({ x: canvas.width / dpr, y: canvas.height / dpr });
            const maxViewDim = Math.max(Math.abs(bottomRightData.x - topLeftData.x), Math.abs(topLeftData.y - bottomRightData.y));
            if (gridDisplayMode === 'polar') {
                const dominantRadialInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
                for(let r = dominantRadialInterval; r < maxViewDim; r += dominantRadialInterval) {
                    secondOrderCandidates.push(...getLineCircleIntersection(bestBisector, { center: {x:0, y:0}, radius: r }));
                }
                lastAngularGridState.forEach(level => {
                    if (level.alpha > 0.01 && level.angle > 0) {
                        for (let angle = 0; angle < 360; angle += level.angle) {
                            const rad = angle * Math.PI / 180;
                            const rayLine = { p1: {x:0, y:0}, p2: {x: Math.cos(rad), y: Math.sin(rad)} };
                            const intersection = getLineLineIntersection(bestBisector, rayLine);
                            if(intersection) secondOrderCandidates.push(intersection);
                        }
                    }
                });
            } else {
                const dominantGridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
                const startX = Math.floor(topLeftData.x / dominantGridInterval) * dominantGridInterval;
                const endX = Math.ceil(bottomRightData.x / dominantGridInterval) * dominantGridInterval;
                const startY = Math.floor(bottomRightData.y / dominantGridInterval) * dominantGridInterval;
                const endY = Math.ceil(topLeftData.y / dominantGridInterval) * dominantGridInterval;
                for (let x = startX; x <= endX; x += dominantGridInterval) {
                    const intersection = getLineLineIntersection(bestBisector, { p1: { x: x, y: -BISECTOR_LINE_EXTENSION_FACTOR }, p2: { x: x, y: BISECTOR_LINE_EXTENSION_FACTOR } });
                    if (intersection) secondOrderCandidates.push(intersection);
                }
                for (let y = startY; y <= endY; y += dominantGridInterval) {
                    const intersection = getLineLineIntersection(bestBisector, { p1: { x: -BISECTOR_LINE_EXTENSION_FACTOR, y: y }, p2: { x: BISECTOR_LINE_EXTENSION_FACTOR, y: y } });
                    if (intersection) secondOrderCandidates.push(intersection);
                }
            }
        }
        if (secondOrderCandidates.length > 0) {
            const projectedPos = { x: bestBisector.projection.x, y: bestBisector.projection.y };
            const bestOnLineCandidate = secondOrderCandidates.reduce((best, current) => distanceSq(projectedPos, current) < distanceSq(projectedPos, best) ? current : best);
            if (distance(projectedPos, bestOnLineCandidate) < pointOnLineSnapRadius) {
                return { point: bestOnLineCandidate, snapped: true, constraints: null };
            }
        }
        return { point: { x: bestBisector.projection.x, y: bestBisector.projection.y }, snapped: true, constraints: null };
    }
    let allCandidates = [];
    if (gridDisplayMode !== 'none') {
        const dominantGridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        if (dominantGridInterval > 0) {
            if (gridDisplayMode === 'triangular') {
                const y_step = dominantGridInterval * Math.sqrt(3) / 2;
                const i_f = (mouseDataPos.x / dominantGridInterval) - (mouseDataPos.y / (dominantGridInterval * Math.sqrt(3)));
                const j_f = mouseDataPos.y / y_step;

                let i_r = Math.round(i_f);
                let j_r = Math.round(j_f);
                let k_r = Math.round(-i_f - j_f);

                const i_diff = Math.abs(i_r - i_f);
                const j_diff = Math.abs(j_r - j_f);
                const k_diff = Math.abs(k_r - (-i_f - j_f));

                if (i_diff > j_diff && i_diff > k_diff) {
                    i_r = -j_r - k_r;
                } else if (j_diff > k_diff) {
                    j_r = -i_r - k_r;
                }
                const snappedX = i_r * dominantGridInterval + j_r * dominantGridInterval / 2;
                const snappedY = j_r * y_step;
                allCandidates.push({ x: snappedX, y: snappedY });

            } else if (gridDisplayMode === 'polar') {
                const mouseAngleDeg = (Math.atan2(mouseDataPos.y, mouseDataPos.x) * 180 / Math.PI + 360) % 360;
                const mouseRadius = Math.hypot(mouseDataPos.x, mouseDataPos.y);
                const snappedRadius = Math.round(mouseRadius / dominantGridInterval) * dominantGridInterval;
                lastAngularGridState.forEach(level => {
                    if (level.alpha > 0.01 && level.angle > 0) {
                        const angularInterval = level.angle;
                        const snappedAngleDeg = Math.round(mouseAngleDeg / angularInterval) * angularInterval;
                        const snappedAngleRad = snappedAngleDeg * Math.PI / 180;
                        allCandidates.push({ x: snappedRadius * Math.cos(snappedAngleRad), y: snappedRadius * Math.sin(snappedAngleRad) });
                    }
                });
            } else {
                const baseGridX = Math.round(mouseDataPos.x / dominantGridInterval) * dominantGridInterval;
                const baseGridY = Math.round(mouseDataPos.y / dominantGridInterval) * dominantGridInterval;
                allCandidates.push({ x: baseGridX, y: baseGridY });
            }
        }
    }
    for (const p of allPoints) {
        if (p.id !== dragOrigin.id && p.type === 'regular') {
            allCandidates.push({ x: p.x, y: p.y });
        }
    }
    if (gridDisplayMode !== 'polar') {
        const majorSnapAnglesRad = NINETY_DEG_ANGLE_SNAP_FRACTIONS.map(f => f * (Math.PI / 2)).filter(angle => angle > GEOMETRY_CALCULATION_EPSILON && angle < Math.PI);
        const majorSortedSnapDistances = DRAG_SNAP_GEOMETRIC_DISTANCE_FACTORS.map(f => f * DEFAULT_REFERENCE_DISTANCE);
        for (let i = 0; i < neighbors.length; i++) {
            for (let j = i + 1; j < neighbors.length; j++) {
                for (const d1 of majorSortedSnapDistances) {
                    for (const alpha of majorSnapAnglesRad) {
                        allCandidates.push(...solveForPoint(neighbors[i], neighbors[j], d1, alpha));
                    }
                }
            }
        }
    }
    if (allCandidates.length === 0) return { point: mouseDataPos, snapped: false };
    const bestCandidate = allCandidates.reduce((best, current) => distanceSq(mouseDataPos, current) < distanceSq(mouseDataPos, best) ? current : best);
    const snapStickinessRadius = SNAP_STICKINESS_RADIUS_SCREEN / viewTransform.scale;
    if (distance(mouseDataPos, bestCandidate) < snapStickinessRadius) {
        return { point: bestCandidate, snapped: true, constraints: { dist: bestCandidate.dist || null, angle: bestCandidate.angle || null } };
    }
    return { point: mouseDataPos, snapped: false };
}


function initializeCanvasUI() {
    canvasUI.toolbarButton = {
        id: "toolbar-button",
        x: UI_BUTTON_PADDING,
        y: UI_BUTTON_PADDING,
        width: MENU_BUTTON_WIDTH,
        height: MENU_BUTTON_HEIGHT,
        type: "menuButton"
    };
}



function buildTransformPanelUI() {
    canvasUI.transformIcons = [];
    const panelX = UI_TOOLBAR_WIDTH + UI_BUTTON_PADDING;
    const iconY = canvasUI.transformToolButton.y;
    const iconSize = TRANSFORM_ICON_SIZE;
    const iconPadding = TRANSFORM_ICON_PADDING;
    const transformTypes = [TRANSFORM_TYPE_ROTATE_SCALE, TRANSFORM_TYPE_ROTATE_ONLY, TRANSFORM_TYPE_SCALE_ONLY];

    transformTypes.forEach((type, index) => {
        canvasUI.transformIcons.push({
            id: `transform-icon-${type}`,
            type: type,
            x: panelX + index * (iconSize + iconPadding),
            y: iconY + TRANSFORM_ICON_Y_OFFSET, // Align vertically with the T button
            width: iconSize,
            height: iconSize
        });
    });
}

function buildDisplayPanelUI() {
    canvasUI.displayIcons = [];
    if (!canvasUI.displayToolButton) return;

    const panelX = UI_TOOLBAR_WIDTH + UI_BUTTON_PADDING;
    const iconY = canvasUI.displayToolButton.y;
    const iconSize = DISPLAY_ICON_SIZE;
    const iconPadding = DISPLAY_ICON_PADDING;

    const iconGroups = ['coords', 'grid', 'angles', 'distances'];

    iconGroups.forEach((group, index) => {
        canvasUI.displayIcons.push({
            id: `display-icon-${group}`,
            group: group,
            x: panelX + index * (iconSize + iconPadding),
            y: iconY,
            width: iconSize,
            height: iconSize
        });
    });
}

function buildColorPaletteUI() {
    canvasUI.colorSwatches = [];
    const paletteY = canvasUI.colorToolButton.y;

    const removeBtnX = UI_TOOLBAR_WIDTH + UI_BUTTON_PADDING;
    canvasUI.removeColorButton = {
        id: "remove-color-button",
        type: "button",
        x: removeBtnX,
        y: paletteY + COLOR_PALETTE_Y_OFFSET,
        width: UI_SWATCH_SIZE,
        height: UI_SWATCH_SIZE,
    };

    const swatchesX = removeBtnX + UI_SWATCH_SIZE + UI_BUTTON_PADDING;
    recentColors.forEach((color, index) => {
        canvasUI.colorSwatches.push({
            id: `swatch-${color}-${index}`,
            type: "colorSwatch",
            x: swatchesX + index * (UI_SWATCH_SIZE + UI_BUTTON_PADDING),
            y: paletteY + COLOR_PALETTE_Y_OFFSET,
            width: UI_SWATCH_SIZE,
            height: UI_SWATCH_SIZE,
            index: index,
            color: color
        });
    });

    const addButtonX = swatchesX + recentColors.length * (UI_SWATCH_SIZE + UI_BUTTON_PADDING);
    canvasUI.addColorButton = {
        id: "add-color-button",
        type: "button",
        x: addButtonX,
        y: paletteY + COLOR_PALETTE_Y_OFFSET,
        width: UI_SWATCH_SIZE,
        height: UI_SWATCH_SIZE,
    };
}

function buildMainToolbarUI() {
    const canvasHeight = canvas.height / dpr;
    canvasUI.mainToolbar = {
        id: "main-toolbar-bg",
        x: 0,
        y: 0,
        width: UI_TOOLBAR_WIDTH,
        height: canvasHeight,
        type: "toolbar"
    };

    canvasUI.colorToolButton = {
        id: "color-tool-button",
        type: "toolButton",
        x: UI_BUTTON_PADDING,
        y: canvasUI.toolbarButton.y + canvasUI.toolbarButton.height + TOOLBAR_SECTION_GAP,
        width: UI_TOOLBAR_WIDTH - (2 * UI_BUTTON_PADDING),
        height: TOOL_BUTTON_HEIGHT,
    };
    
    canvasUI.transformToolButton = {
        id: "transform-tool-button",
        type: "toolButton",
        x: UI_BUTTON_PADDING,
        y: canvasUI.colorToolButton.y + canvasUI.colorToolButton.height + UI_BUTTON_PADDING,
        width: UI_TOOLBAR_WIDTH - (2 * UI_BUTTON_PADDING),
        height: TOOL_BUTTON_HEIGHT,
    };

    canvasUI.displayToolButton = {
        id: "display-tool-button",
        type: "toolButton",
        x: UI_BUTTON_PADDING,
        y: canvasUI.transformToolButton.y + canvasUI.transformToolButton.height + UI_BUTTON_PADDING,
        width: UI_TOOLBAR_WIDTH - (2 * UI_BUTTON_PADDING),
        height: TOOL_BUTTON_HEIGHT,
    };

    // Add theme toggle button
    canvasUI.themeToggleButton = {
        id: "theme-toggle-button",
        type: "toolButton",
        x: UI_BUTTON_PADDING,
        y: canvasUI.displayToolButton.y + canvasUI.displayToolButton.height + UI_BUTTON_PADDING,
        width: UI_TOOLBAR_WIDTH - (2 * UI_BUTTON_PADDING),
        height: TOOL_BUTTON_HEIGHT,
    };
}

function handleCanvasUIClick(screenPos) {
    const btn = canvasUI.toolbarButton;
    if (screenPos.x >= btn.x && screenPos.x <= btn.x + btn.width &&
        screenPos.y >= btn.y && screenPos.y <= btn.y + btn.height) {
        isToolbarExpanded = !isToolbarExpanded;
        if (isToolbarExpanded) {
            buildMainToolbarUI();
        } else {
            isColorPaletteExpanded = false;
            isTransformPanelExpanded = false;
            isDisplayPanelExpanded = false;
            selectedSwatchIndex = null;
        }
        return true;
    }

    if (isToolbarExpanded) {
        const ctb = canvasUI.colorToolButton;
        if (ctb && screenPos.x >= ctb.x && screenPos.x <= ctb.x + ctb.width &&
            screenPos.y >= ctb.y && screenPos.y <= ctb.y + ctb.height) {
            isColorPaletteExpanded = !isColorPaletteExpanded;
            if (isColorPaletteExpanded) {
                buildColorPaletteUI();
                const currentIndex = recentColors.indexOf(currentColor);
                selectedSwatchIndex = (currentIndex > -1) ? currentIndex : null;
            } else {
                selectedSwatchIndex = null;
            }
            return true;
        }

        const ttb = canvasUI.transformToolButton;
        if (ttb && screenPos.x >= ttb.x && screenPos.x <= ttb.x + ttb.width &&
            screenPos.y >= ttb.y && screenPos.y <= ttb.y + ttb.height) {
            isTransformPanelExpanded = !isTransformPanelExpanded;
            if (isTransformPanelExpanded) buildTransformPanelUI();
            return true;
        }

        const dtb = canvasUI.displayToolButton;
        if (dtb && screenPos.x >= dtb.x && screenPos.x <= dtb.x + dtb.width &&
            screenPos.y >= dtb.y && screenPos.y <= dtb.y + dtb.height) {
            isDisplayPanelExpanded = !isDisplayPanelExpanded;
            if (isDisplayPanelExpanded) buildDisplayPanelUI();
            return true;
        }

        // Add theme toggle button click handler
        const themeBtn = canvasUI.themeToggleButton;
        if (themeBtn && screenPos.x >= themeBtn.x && screenPos.x <= themeBtn.x + themeBtn.width &&
            screenPos.y >= themeBtn.y && screenPos.y <= themeBtn.y + themeBtn.height) {
            // Toggle between light and dark themes
            activeThemeName = activeThemeName === 'dark' ? 'light' : 'dark';
            
            // Update the current color to match the new theme
            currentColor = THEMES[activeThemeName].point;
            
            // Update color picker to match new theme
            colorPicker.value = currentColor;
            
            return true;
        }
    }

    if (isColorPaletteExpanded) {
        for (const swatch of canvasUI.colorSwatches) {
            if (screenPos.x >= swatch.x && screenPos.x <= swatch.x + swatch.width &&
                screenPos.y >= swatch.y && screenPos.y <= swatch.y + swatch.height) {
                setCurrentColor(swatch.color);
                selectedSwatchIndex = swatch.index;
                return true;
            }
        }
        const removeBtn = canvasUI.removeColorButton;
        if (removeBtn && screenPos.x >= removeBtn.x && screenPos.x <= removeBtn.x + removeBtn.width &&
            screenPos.y >= removeBtn.y && screenPos.y <= removeBtn.y + removeBtn.height) {
            if (selectedSwatchIndex === null && recentColors.length > 0) {
                selectedSwatchIndex = 0;
            }
            if (selectedSwatchIndex !== null) {
                recentColors.splice(selectedSwatchIndex, 1);
                if (recentColors.length === 0) {
                    selectedSwatchIndex = null;
                } else {
                    selectedSwatchIndex = Math.min(selectedSwatchIndex, recentColors.length - 1);
                }
                if (selectedSwatchIndex !== null) {
                    setCurrentColor(recentColors[selectedSwatchIndex]);
                }
                buildColorPaletteUI();
            }
            return true;
        }
        const addBtn = canvasUI.addColorButton;
        if (addBtn && screenPos.x >= addBtn.x && screenPos.x <= addBtn.x + addBtn.width &&
            screenPos.y >= addBtn.y && screenPos.y <= addBtn.y + addBtn.height) {
            setTimeout(() => {
                colorPicker.click();
            }, 0);
            return true;
        }
    }

    if (isTransformPanelExpanded) {
        for (const icon of canvasUI.transformIcons) {
            if (screenPos.x >= icon.x && screenPos.x <= icon.x + icon.width &&
                screenPos.y >= icon.y && screenPos.y <= icon.y + icon.height) {
                isPlacingTransform = true;
                placingTransformType = icon.type;
                return true;
            }
        }
    }

    if (isDisplayPanelExpanded) {
        for (const icon of canvasUI.displayIcons) {
            if (screenPos.x >= icon.x && screenPos.x <= icon.x + icon.width &&
                screenPos.y >= icon.y && screenPos.y <= icon.y + icon.height) {

                switch (icon.group) {
                    case 'coords':
                        const coordsModes = [COORDS_DISPLAY_MODE_NONE, COORDS_DISPLAY_MODE_REGULAR, COORDS_DISPLAY_MODE_COMPLEX, COORDS_DISPLAY_MODE_POLAR];
                        coordsDisplayMode = coordsModes[(coordsModes.indexOf(coordsDisplayMode) + 1) % coordsModes.length];
                        break;
                    case 'grid':
                        const gridModes = [GRID_DISPLAY_MODE_LINES, GRID_DISPLAY_MODE_POINTS, GRID_DISPLAY_MODE_TRIANGULAR, GRID_DISPLAY_MODE_POLAR, GRID_DISPLAY_MODE_NONE];
                        gridDisplayMode = gridModes[(gridModes.indexOf(gridDisplayMode) + 1) % gridModes.length];
                        break;
                    case 'angles':
                        const angleModes = [ANGLE_DISPLAY_MODE_DEGREES, ANGLE_DISPLAY_MODE_RADIANS, ANGLE_DISPLAY_MODE_NONE];
                        angleDisplayMode = angleModes[(angleModes.indexOf(angleDisplayMode) + 1) % angleModes.length];
                        showAngles = angleDisplayMode !== ANGLE_DISPLAY_MODE_NONE;
                        break;
                    case 'distances':
                        const distModes = [DISTANCE_DISPLAY_MODE_ON, DISTANCE_DISPLAY_MODE_NONE];
                        distanceDisplayMode = distModes[(distModes.indexOf(distanceDisplayMode) + 1) % distModes.length];
                        showDistances = distanceDisplayMode === DISTANCE_DISPLAY_MODE_ON;
                        break;
                }
                return true;
            }
        }
    }

    return false;
}

function addToRecentColors(color) {
    if (recentColors.includes(color)) {
        return;
    }
    recentColors.push(color);

    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }
}

function getPrecedingSegment(pointId, edgesToIgnoreIds = []) {
    const currentPoint = findPointById(pointId);
    if (!currentPoint) return null;
    for (let i = allEdges.length - 1; i >= 0; i--) {
        const edge = allEdges[i];
        const edgeIdentifier = edge.id1 < edge.id2 ? edge.id1 + edge.id2 : edge.id2 + edge.id1;
        if (edgesToIgnoreIds.includes(edgeIdentifier)) continue;
        let otherPointId = null;
        if (edge.id1 === pointId) otherPointId = edge.id2;
        else if (edge.id2 === pointId) otherPointId = edge.id1;
        if (otherPointId) {
            const otherPoint = findPointById(otherPointId);
            if (otherPoint) {
                const dx = currentPoint.x - otherPoint.x; const dy = currentPoint.y - otherPoint.y;
                return { p1: otherPoint, p2: currentPoint, angleRad: Math.atan2(dy, dx), length: Math.sqrt(dx*dx + dy*dy), edgeId: edgeIdentifier };
            }
        }
    }
    return null;
}

function saveStateForUndo() {
    const state = {
        points: JSON.parse(JSON.stringify(allPoints)),
        edges: JSON.parse(JSON.stringify(allEdges)),
        selectedPointIds: JSON.parse(JSON.stringify(selectedPointIds)),
        selectedEdgeIds: JSON.parse(JSON.stringify(selectedEdgeIds)),
        activeCenterId: activeCenterId,
        isDrawingMode: isDrawingMode,
        previewLineStartPointId: previewLineStartPointId,
        frozenReference_A_rad, frozenReference_A_baseRad, frozenReference_D_du, frozenReference_Origin_Data,
        frozenReference_D_g2g // <-- ADD THIS
    };
    undoStack.push(state);
    if (undoStack.length > MAX_HISTORY_SIZE) undoStack.shift();
    redoStack = [];
}

function restoreState(state) {
    allPoints = JSON.parse(JSON.stringify(state.points));
    allEdges = JSON.parse(JSON.stringify(state.edges));
    selectedPointIds = JSON.parse(JSON.stringify(state.selectedPointIds || []));
    selectedEdgeIds = JSON.parse(JSON.stringify(state.selectedEdgeIds || []));
    activeCenterId = state.activeCenterId !== undefined ? state.activeCenterId : null;
    isDrawingMode = state.isDrawingMode !== undefined ? state.isDrawingMode : false;
    previewLineStartPointId = state.previewLineStartPointId !== undefined ? state.previewLineStartPointId : null;
    frozenReference_A_rad = state.frozenReference_A_rad !== undefined ? state.frozenReference_A_rad : null;
    frozenReference_A_baseRad = state.frozenReference_A_baseRad !== undefined ? state.frozenReference_A_baseRad : null;
    frozenReference_D_du = state.frozenReference_D_du !== undefined ? state.frozenReference_D_du : null;
    frozenReference_Origin_Data = state.frozenReference_Origin_Data !== undefined ? state.frozenReference_Origin_Data : null;
    frozenReference_D_g2g = state.frozenReference_D_g2g !== undefined ? state.frozenReference_D_g2g : null; // <-- ADD THIS
    isActionInProgress = false; isDragConfirmed = false; isRectangleSelecting = false;
    isPanningBackground = false; dragPreviewPoints = [];
    actionTargetPoint = null; currentMouseButton = -1;
    clickData = { pointId: null, count: 0, timestamp: 0 };
    canvas.style.cursor = 'crosshair';
}

function handleUndo() {
    if (undoStack.length === 0) return;
    const currentStateForRedo = {
        points: JSON.parse(JSON.stringify(allPoints)),
        edges: JSON.parse(JSON.stringify(allEdges)),
        selectedPointIds: JSON.parse(JSON.stringify(selectedPointIds)),
        selectedEdgeIds: JSON.parse(JSON.stringify(selectedEdgeIds)),
        activeCenterId: activeCenterId,
        isDrawingMode: isDrawingMode,
        previewLineStartPointId: previewLineStartPointId,
        frozenReference_A_rad, frozenReference_A_baseRad, frozenReference_D_du, frozenReference_Origin_Data
    };
    redoStack.push(currentStateForRedo);
    if (redoStack.length > MAX_HISTORY_SIZE) redoStack.shift();
    const prevState = undoStack.pop();
    restoreState(prevState);
}

function handleRedo() {
    if (redoStack.length === 0) return;
    const currentStateForUndo = {
        points: JSON.parse(JSON.stringify(allPoints)),
        edges: JSON.parse(JSON.stringify(allEdges)),
        selectedPointIds: JSON.parse(JSON.stringify(selectedPointIds)),
        selectedEdgeIds: JSON.parse(JSON.stringify(selectedEdgeIds)),
        activeCenterId: activeCenterId,
        isDrawingMode: isDrawingMode,
        previewLineStartPointId: previewLineStartPointId,
        frozenReference_A_rad, frozenReference_A_baseRad, frozenReference_D_du, frozenReference_Origin_Data
    };
    undoStack.push(currentStateForUndo);
    if (undoStack.length > MAX_HISTORY_SIZE) undoStack.shift();
    const nextState = redoStack.pop();
    restoreState(nextState);
}

function screenToData(screenPos_css_pixels) {
    const screenX_physical = screenPos_css_pixels.x * dpr;
    const screenY_physical = screenPos_css_pixels.y * dpr;
    const canvasHeight_physical = canvas.height;
    return {
        x: (screenX_physical - viewTransform.offsetX) / viewTransform.scale,
        y: (canvasHeight_physical - screenY_physical - viewTransform.offsetY) / viewTransform.scale
    };
}

function dataToScreen(dataPos) {
    const canvasHeight_physical = canvas.height;
    const screenX_physical = dataPos.x * viewTransform.scale + viewTransform.offsetX;
    const screenY_physical = canvasHeight_physical - (dataPos.y * viewTransform.scale + viewTransform.offsetY);
    return {
        x: screenX_physical / dpr,
        y: screenY_physical / dpr
    };
}

function resizeCanvas() {
    const canvasContainer = document.querySelector('.canvas-container');
    const canvasWrapper = document.querySelector('.canvas-wrapper-relative');

    if (!canvasContainer || !canvasWrapper) {
        console.error("Canvas container or wrapper not found. Ensure index.html structure has '.canvas-container' and '.canvas-wrapper-relative'.");
        return;
    }

    const cW = canvasWrapper.offsetWidth;
    const cH = canvasWrapper.offsetHeight;

    canvas.width = cW * dpr;
    canvas.height = cH * dpr;
    canvas.style.width = `${cW}px`;
    canvas.style.height = `${cH}px`;

    if (htmlOverlay) {
        htmlOverlay.style.width = `${cW}px`;
        htmlOverlay.style.height = `${cH}px`;
    }
}

function findPointById(id) { return allPoints.find(p => p.id === id); }

function findClickedPoint(clickPos) {
    const dataPos = screenToData(clickPos);
    const selectRadiusDataRegular = POINT_SELECT_RADIUS / viewTransform.scale;
    const selectRadiusDataCenter = (CENTER_POINT_VISUAL_RADIUS + POINT_SELECT_RADIUS / 2) / viewTransform.scale;

    // Prioritize center points for selection
    for (let i = allPoints.length - 1; i >= 0; i--) {
        const point = allPoints[i];
        if (point.type !== 'regular' && distance(dataPos, point) < selectRadiusDataCenter) return point;
    }

    // Then check for regular points
    for (let i = allPoints.length - 1; i >= 0; i--) {
        const point = allPoints[i];
        if (point.type === 'regular' && distance(dataPos, point) < selectRadiusDataRegular) return point;
    }
    return null;
}

function findClickedEdge(clickPos) {
    const dataPos = screenToData(clickPos);
    const edgeClickThresholdData = EDGE_CLICK_THRESHOLD / viewTransform.scale;
    
    for (let i = allEdges.length - 1; i >= 0; i--) {
        const edge = allEdges[i];
        const p1 = findPointById(edge.id1);
        const p2 = findPointById(edge.id2);
        if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
            const closest = getClosestPointOnLineSegment(dataPos, p1, p2);
            if (closest.distance < edgeClickThresholdData && closest.onSegmentStrict) {
                return edge;
            }
        }
    }
    return null;
}

function getEdgeId(edge) {
    const DELIMITER = '_EDGE_';
    return edge.id1 < edge.id2 ? `${edge.id1}${DELIMITER}${edge.id2}` : `${edge.id2}${DELIMITER}${edge.id1}`;
}

function findNeighbors(pointId) {
    const n = new Set();
    allEdges.forEach(e => { if (e.id1 === pointId) n.add(e.id2); else if (e.id2 === pointId) n.add(e.id1); });
    return Array.from(n);
}

function findNeighborEdges(pointId) {
    return allEdges.filter(e => e.id1 === pointId || e.id2 === pointId);
}

function findAllPointsInSubgraph(startPointId) {
    if (!findPointById(startPointId)) return [];
    const visited = new Set(); const queue = [startPointId]; const subgraphPointIds = [];
    visited.add(startPointId);
    while (queue.length > 0) {
        const currentPointId = queue.shift(); subgraphPointIds.push(currentPointId);
        findNeighbors(currentPointId).forEach(neighborId => {
            if (!visited.has(neighborId)) { visited.add(neighborId); queue.push(neighborId); }
        });
    }
    return subgraphPointIds;
}

function handleCopy() {
    const pointsToCopyIds = new Set(selectedPointIds);
    if (activeCenterId) pointsToCopyIds.add(activeCenterId);
    
    if (pointsToCopyIds.size === 0 && selectedEdgeIds.length === 0) return;
    
    selectedEdgeIds.forEach(edgeId => {
        const [id1, id2] = edgeId.split(EDGE_ID_DELIMITER);
        pointsToCopyIds.add(id1);
        pointsToCopyIds.add(id2);
    });
    
    clipboard.points = Array.from(pointsToCopyIds).map(id => {
        const p = findPointById(id);
        return p ? { ...p } : null;
    }).filter(p => p);
    
    clipboard.edges = [];
    selectedEdgeIds.forEach(edgeId => {
        const edge = allEdges.find(e => getEdgeId(e) === edgeId);
        if (edge) clipboard.edges.push({ ...edge });
    });
    
    allEdges.forEach(edge => {
        if (pointsToCopyIds.has(edge.id1) && pointsToCopyIds.has(edge.id2) && 
            findPointById(edge.id1)?.type === 'regular' && findPointById(edge.id2)?.type === 'regular') {
            const edgeId = getEdgeId(edge);
            if (!clipboard.edges.find(e => getEdgeId(e) === edgeId)) {
                clipboard.edges.push({ ...edge });
            }
        }
    });
    
    clipboard.referencePoint = screenToData(mousePos);
}

function handleCut() {
    if (selectedPointIds.length === 0 && selectedEdgeIds.length === 0 && selectedCenterIds.length === 0) return;
    
    saveStateForUndo();
    handleCopy();
    deleteSelectedItems();
}

function handlePaste() {
    if (clipboard.points.length === 0 || !clipboard.referencePoint) return;
    saveStateForUndo();
    const pastePosData = screenToData(mousePos);
    const deltaX = pastePosData.x - clipboard.referencePoint.x; const deltaY = pastePosData.y - clipboard.referencePoint.y;
    const oldToNewIdMap = new Map(); const newPastedRegularPointIds = []; let newPastedActiveCenterId = null;
    performEscapeAction();
    clipboard.points.forEach(cbPoint => {
        const newId = generateUniqueId();
        const newPoint = { ...cbPoint, id: newId, x: cbPoint.x + deltaX, y: cbPoint.y + deltaY };
        allPoints.push(newPoint); oldToNewIdMap.set(cbPoint.id, newId);
        if (newPoint.type === 'regular') newPastedRegularPointIds.push(newId);
        else newPastedActiveCenterId = newId;
    });
    clipboard.edges.forEach(cbEdge => {
        const newP1Id = oldToNewIdMap.get(cbEdge.id1); const newP2Id = oldToNewIdMap.get(cbEdge.id2);
        if (newP1Id && newP2Id) allEdges.push({ id1: newP1Id, id2: newP2Id });
    });
    selectedPointIds = newPastedRegularPointIds; 
    selectedEdgeIds = clipboard.edges.map(e => getEdgeId({id1: oldToNewIdMap.get(e.id1), id2: oldToNewIdMap.get(e.id2)}));
    activeCenterId = newPastedActiveCenterId;
}

function deleteSelectedItems() {
    if (selectedPointIds.length === 0 && selectedEdgeIds.length === 0 && selectedCenterIds.length === 0) return;
    
    saveStateForUndo();
    
    selectedEdgeIds.forEach(edgeId => {
        allEdges = allEdges.filter(edge => getEdgeId(edge) !== edgeId);
    });
    
    selectedPointIds.forEach(pointId => {
        const neighborEdges = findNeighborEdges(pointId);
        
        if (neighborEdges.length === 2) {
            const edge1 = neighborEdges[0];
            const edge2 = neighborEdges[1];
            
            const otherPoint1 = edge1.id1 === pointId ? edge1.id2 : edge1.id1;
            const otherPoint2 = edge2.id1 === pointId ? edge2.id2 : edge2.id1;
            
            if (otherPoint1 !== otherPoint2) {
                allEdges.push({ id1: otherPoint1, id2: otherPoint2 });
            }
        }
        
        allEdges = allEdges.filter(edge => edge.id1 !== pointId && edge.id2 !== pointId);
    });
    
    const idsToDelete = new Set([...selectedPointIds, ...selectedCenterIds]);
    
    allPoints = allPoints.filter(point => !idsToDelete.has(point.id));
    
    selectedPointIds = [];
    selectedEdgeIds = [];
    selectedCenterIds = [];
    activeCenterId = null;
    
    if (previewLineStartPointId && !findPointById(previewLineStartPointId)) {
        isDrawingMode = false;
        previewLineStartPointId = null;
        frozenReference_A_rad = null;
        frozenReference_A_baseRad = null;
        frozenReference_D_du = null;
        frozenReference_Origin_Data = null;
    }
}

function zoomAt(zoomCenterScreen_css_pixels, scaleFactor) {
    const oldScale = viewTransform.scale;
    let newScale = oldScale * scaleFactor;

    if (newScale < MIN_SCALE_VALUE) {
        newScale = MIN_SCALE_VALUE;
    }

    const mouseX_physical = zoomCenterScreen_css_pixels.x * dpr;
    const mouseY_physical = zoomCenterScreen_css_pixels.y * dpr;

    viewTransform.offsetX = mouseX_physical * (1 - scaleFactor) + viewTransform.offsetX * scaleFactor;
    
    viewTransform.offsetY = (canvas.height - mouseY_physical) * (1 - scaleFactor) + viewTransform.offsetY * scaleFactor;

    viewTransform.scale = newScale;
}

function getDrawingContext(currentDrawStartPointId) {
    let offsetAngleRad = 0;
    let currentSegmentReferenceD; // Will be set conditionally
    let currentSegmentReferenceA_for_display = Math.PI / 2;
    let isFirstSegmentBeingDrawn = true;

    const p_current = findPointById(currentDrawStartPointId);
    if (!p_current) {
        // This case implies no active drawing line, so it implicitly is the 'first segment' conceptually.
        isFirstSegmentBeingDrawn = true;
        // The currentSegmentReferenceD for a *new* drawing operation will be the grid interval or default.
        if (gridDisplayMode !== 'none' && lastGridState.interval1) {
            currentSegmentReferenceD = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        } else {
            currentSegmentReferenceD = DEFAULT_REFERENCE_DISTANCE;
        }
        // If a reference was globally frozen, that takes precedence even for the "first" segment
        // of a new drawing sequence, but it's more about "the current length unit"
        if (frozenReference_D_du !== null) {
            currentSegmentReferenceD = frozenReference_D_du;
        }

        return {
            offsetAngleRad,
            currentSegmentReferenceD,
            currentSegmentReferenceA_for_display,
            isFirstSegmentBeingDrawn,
            displayAngleA_valueRad_for_A_equals_label: null,
            displayAngleA_originPointData_for_A_equals_label: null,
            frozen_A_baseRad_to_display: null,
            frozen_D_du_to_display: null,
            frozen_D_g2g_to_display: null,
            frozen_Origin_Data_to_display: null
        };
    }

    const segment1_prev_to_current = getPrecedingSegment(p_current.id);

    if (segment1_prev_to_current) {
        isFirstSegmentBeingDrawn = false;
        offsetAngleRad = segment1_prev_to_current.angleRad;
        currentSegmentReferenceD = frozenReference_D_du !== null ? frozenReference_D_du : segment1_prev_to_current.length;

        if (frozenReference_A_rad !== null) {
            if (Math.abs(frozenReference_A_rad) < GEOMETRY_CALCULATION_EPSILON) {
                currentSegmentReferenceA_for_display = DEFAULT_REFERENCE_ANGLE_RAD;
            } else {
                currentSegmentReferenceA_for_display = Math.abs(frozenReference_A_rad);
            }
        } else {
            currentSegmentReferenceA_for_display = DEFAULT_REFERENCE_ANGLE_RAD;
        }
    } else {
        isFirstSegmentBeingDrawn = true;
        if (gridDisplayMode !== 'none' && lastGridState.interval1) {
            currentSegmentReferenceD = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        } else {
            currentSegmentReferenceD = DEFAULT_REFERENCE_DISTANCE;
        }
        if (frozenReference_D_du !== null) {
            currentSegmentReferenceD = frozenReference_D_du;
        }
        offsetAngleRad = 0;
        currentSegmentReferenceA_for_display = DEFAULT_REFERENCE_ANGLE_RAD;
    }

    return {
        offsetAngleRad,
        currentSegmentReferenceD,
        currentSegmentReferenceA_for_display,
        isFirstSegmentBeingDrawn,
        displayAngleA_valueRad_for_A_equals_label: frozenReference_A_rad,
        displayAngleA_originPointData_for_A_equals_label: frozenReference_Origin_Data,
        frozen_A_baseRad_to_display: frozenReference_A_baseRad,
        frozen_D_du_to_display: frozenReference_D_du,
        frozen_D_g2g_to_display: frozenReference_D_g2g
    };
}

function getCompletedSegmentProperties(startPoint, endPoint, existingEdges) {
    if (!startPoint || !endPoint) return null;

    const angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);
    const length = distance(startPoint, endPoint);

    let precedingSegmentAngle = 0;
    let isFirstSegmentOfLine = true;

    for (let i = existingEdges.length - 1; i >= 0; i--) {
        const edge = existingEdges[i];
        let otherPointId = null;
        if (edge.id1 === startPoint.id && findPointById(edge.id2)?.type === 'regular') otherPointId = edge.id2;
        else if (edge.id2 === startPoint.id && findPointById(edge.id1)?.type === 'regular') otherPointId = edge.id1;

        if (otherPointId && otherPointId !== endPoint.id) {
            const prevPoint = findPointById(otherPointId);
            if (prevPoint) {
                precedingSegmentAngle = Math.atan2(startPoint.y - prevPoint.y, startPoint.x - prevPoint.x);
                isFirstSegmentOfLine = false;
                break;
            }
        }
    }

    const angleTurn = normalizeAngleToPi(angle - precedingSegmentAngle);

    return {
        startPoint,
        endPoint,
        absoluteAngleRad: angle,
        length: length,
        precedingSegmentAbsoluteAngleRad: precedingSegmentAngle,
        turnAngleRad: angleTurn,
        isFirstSegmentOfLine: isFirstSegmentOfLine
    };
}

function completeGraphOnSelectedPoints() {
    if (selectedPointIds.length < 2) return;
    
    const regularPointIds = selectedPointIds.filter(id => {
        const point = findPointById(id);
        return point && point.type === 'regular';
    });
    
    if (regularPointIds.length < 2) return;
    
    saveStateForUndo();
    
    let edgesAdded = 0;
    
    for (let i = 0; i < regularPointIds.length; i++) {
        for (let j = i + 1; j < regularPointIds.length; j++) {
            const id1 = regularPointIds[i];
            const id2 = regularPointIds[j];
            
            const edgeExists = allEdges.some(edge => 
                (edge.id1 === id1 && edge.id2 === id2) || 
                (edge.id1 === id2 && edge.id2 === id1)
            );
            
            if (!edgeExists) {
                allEdges.push({ id1: id1, id2: id2 });
                edgesAdded++;
            }
        }
    }
}

function applySelectionLogic(pointIdsToSelect, edgeIdsToSelect, wantsShift, wantsCtrl, targetIsCenter = false) {
    if (targetIsCenter) {
        handleCenterSelection(pointIdsToSelect[0], wantsShift, wantsCtrl);
    } else {
        if (wantsShift) {
            selectedPointIds = [...new Set([...selectedPointIds, ...pointIdsToSelect])];
            selectedEdgeIds = [...new Set([...selectedEdgeIds, ...edgeIdsToSelect])];
        } else if (wantsCtrl) {
            pointIdsToSelect.forEach(id => {
                const index = selectedPointIds.indexOf(id);
                if (index > -1) selectedPointIds.splice(index, 1);
                else selectedPointIds.push(id);
            });
            edgeIdsToSelect.forEach(id => {
                const index = selectedEdgeIds.indexOf(id);
                if (index > -1) selectedEdgeIds.splice(index, 1);
                else selectedEdgeIds.push(id);
            });
        } else {
            selectedPointIds = [...pointIdsToSelect];
            selectedEdgeIds = [...edgeIdsToSelect];
        }
    }
}

function setCurrentColor(newColor) {
    const oldColor = currentColor;
    const colors = THEMES[activeThemeName];
    let changedPoints = [];
    if (selectedPointIds.length > 0) {
        selectedPointIds.forEach(id => {
            const point = findPointById(id);
            if (point && point.type === POINT_TYPE_REGULAR) {
                changedPoints.push({ id: point.id, oldColor: point.color || oldColor });
                point.color = newColor;
            }
        });
    }

    selectedCenterIds.forEach(id => {
        const center = findPointById(id);
        if (center && center.type !== POINT_TYPE_REGULAR) {
            // No color change for centers, they stay white as per drawCenterSymbol
        }
    });

    if (changedPoints.length > 0) {
        const actualUndoState = {
            points: allPoints.map(p => {
                const changed = changedPoints.find(cp => cp.id === p.id);
                if (p.type !== POINT_TYPE_REGULAR) {
                    return { ...p, color: colors.uiIcon };
                }
                return changed ? { ...p, color: changed.oldColor } : { ...p };
            }),
            edges: JSON.parse(JSON.stringify(allEdges)),
            selectedPointIds: JSON.parse(JSON.stringify(selectedPointIds)),
            selectedEdgeIds: JSON.parse(JSON.stringify(selectedEdgeIds)),
            activeCenterId,
            selectedCenterIds: JSON.parse(JSON.stringify(selectedCenterIds)),
            isDrawingMode,
            previewLineStartPointId
        };
        undoStack.push(actualUndoState);
        if (undoStack.length > MAX_HISTORY_SIZE) undoStack.shift();
        redoStack = [];
    }
    currentColor = newColor;
    colorPicker.value = newColor;
    addToRecentColors(newColor);
}

function redrawAll() {
    labelsToKeepThisFrame.clear();
    const colors = THEMES[activeThemeName]; // Get colors from current theme
    const actualCanvasWidth = canvas.width / dpr;
    const actualCanvasHeight = canvas.height / dpr;
    ctx.resetTransform();
    ctx.scale(dpr, dpr);
    ctx.fillStyle = colors.background;
    ctx.fillRect(0, 0, actualCanvasWidth, actualCanvasHeight);

    const { grid1Interval, grid2Interval, alpha1, alpha2 } = calculateGridIntervals(viewTransform.scale);
    lastGridState = { interval1: grid1Interval, interval2: grid2Interval, alpha1, alpha2, scale: viewTransform.scale };

    lastAngularGridState = getDynamicAngularIntervals(viewTransform, actualCanvasWidth, actualCanvasHeight, dataToScreen);

    // Pass `colors` object in the state parameter to all renderer functions
    drawGrid(ctx, { gridDisplayMode, canvas, dpr, viewTransform, gridAlpha, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState);

    if (coordsDisplayMode !== COORDS_DISPLAY_MODE_NONE) {
        const stateForAxes = { canvas, dpr, coordsDisplayMode, viewTransform, angleDisplayMode, colors };
        drawAxes(ctx, htmlOverlay, stateForAxes, dataToScreen, screenToData, lastGridState, lastAngularGridState, updateHtmlLabel);
    }

    if (isDrawingMode && currentShiftPressed) {
        if (frozenReference_Origin_Data) {
            const frozenDisplayContext = {
                frozen_Origin_Data_to_display: frozenReference_Origin_Data,
                displayAngleA_valueRad_for_A_equals_label: frozenReference_A_rad,
                frozen_A_baseRad_to_display: frozenReference_A_baseRad,
                frozen_D_du_to_display: frozenReference_D_du,
                frozen_D_g2g_to_display: frozenReference_D_g2g
            };
            const stateForRefGeo = { showAngles, showDistances, viewTransform, mousePos, colors };
            drawReferenceElementsGeometry(ctx, frozenDisplayContext, dataToScreen, screenToData, stateForRefGeo);
            const stateForRefTexts = { showAngles, showDistances, viewTransform, mousePos, frozenReference_D_du, distanceSigFigs, angleDisplayMode, colors };
            prepareReferenceElementsTexts(htmlOverlay, frozenDisplayContext, stateForRefTexts, screenToData, dataToScreen, updateHtmlLabel);
        }
    }

    if (transformIndicatorData) {
        const stateForTransform = { transformIndicatorData, angleSigFigs, distanceSigFigs, colors };
        drawTransformIndicators(ctx, htmlOverlay, stateForTransform, dataToScreen, updateHtmlLabel);
        labelsToKeepThisFrame.add('transform-angle-indicator');
        labelsToKeepThisFrame.add('transform-scale-indicator');
    }

    const stateForEdges = { allEdges, selectedEdgeIds, isDragConfirmed, dragPreviewPoints, currentColor, colors };
    drawAllEdges(ctx, stateForEdges, dataToScreen, findPointById, getEdgeId);

    allPoints.forEach(point => {
        let pointToDraw = { ...point };
        if (isDragConfirmed && dragPreviewPoints.length > 0) {
            const preview = dragPreviewPoints.find(dp => dp.id === point.id);
            if (preview) {
                pointToDraw.x = preview.x;
                pointToDraw.y = preview.y;
            }
        }
        drawPoint(ctx, pointToDraw, { selectedPointIds, selectedCenterIds, activeCenterId, currentColor, colors }, dataToScreen);
    });

    if (isDragConfirmed) {
        const hybridPointStates = allPoints.map(p => {
            const draggedVersion = dragPreviewPoints.find(dp => dp.id === p.id);
            return draggedVersion || p;
        });
        const stateForFeedback = { lastGridState, showDistances, showAngles, distanceSigFigs, angleDisplayMode, angleSigFigs, currentShiftPressed, viewTransform, colors };
        if (actionContext.targetPoint) {
            drawDragFeedback(ctx, htmlOverlay, actionContext.targetPoint.id, hybridPointStates, stateForFeedback, dataToScreen, findNeighbors, getEdgeId, currentShiftPressed, null, updateHtmlLabel);
        } else if (actionContext.targetEdge) {
            const draggedEdgeId = getEdgeId(actionContext.targetEdge);
            drawDragFeedback(ctx, htmlOverlay, actionContext.targetEdge.id1, hybridPointStates, stateForFeedback, dataToScreen, findNeighbors, getEdgeId, false, null, updateHtmlLabel);
            drawDragFeedback(ctx, htmlOverlay, actionContext.targetEdge.id2, hybridPointStates, stateForFeedback, dataToScreen, findNeighbors, getEdgeId, false, draggedEdgeId, updateHtmlLabel);
        }
    } else {
        const stateForFeedback = { lastGridState, showDistances, showAngles, distanceSigFigs, angleDisplayMode, angleSigFigs, currentShiftPressed, viewTransform, colors };
        if (selectedPointIds.length === 1 && selectedEdgeIds.length === 0) {
            drawDragFeedback(ctx, htmlOverlay, selectedPointIds[0], allPoints, stateForFeedback, dataToScreen, findNeighbors, getEdgeId, false, null, updateHtmlLabel);
        } else if (selectedEdgeIds.length === 1 && selectedPointIds.length <= 2) {
            const selectedEdgeId = selectedEdgeIds[0];
            const edge = allEdges.find(e => getEdgeId(e) === selectedEdgeId);
            if (edge) {
                drawDragFeedback(ctx, htmlOverlay, edge.id1, allPoints, stateForFeedback, dataToScreen, findNeighbors, getEdgeId, false, null, updateHtmlLabel);
                drawDragFeedback(ctx, htmlOverlay, edge.id2, allPoints, stateForFeedback, dataToScreen, findNeighbors, getEdgeId, false, selectedEdgeId, updateHtmlLabel);
            }
        }
    }

    if (ghostPointPosition) {
        const screenPos = dataToScreen(ghostPointPosition);
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, POINT_RADIUS, 0, 2 * Math.PI);
        ctx.fillStyle = colors.feedbackSnapped;
        ctx.fill();
    }

    if (isDrawingMode && previewLineStartPointId && !isActionInProgress) {
        const startPoint = findPointById(previewLineStartPointId);
        if (startPoint) {
            const currentPreviewDrawingContext = getDrawingContext(startPoint.id);
            const snappedData = getSnappedPosition(startPoint, mousePos, currentShiftPressed);
            const targetPosData = { x: snappedData.x, y: snappedData.y };
            const startScreen = dataToScreen(startPoint);
            const targetScreen = dataToScreen(targetPosData);
            ctx.beginPath();
            ctx.moveTo(startScreen.x, startScreen.y);
            ctx.lineTo(targetScreen.x, targetScreen.y);
            ctx.setLineDash(DASH_PATTERN);
            ctx.strokeStyle = currentShiftPressed ? colors.feedbackSnapped : currentColor;
            ctx.lineWidth = LINE_WIDTH;
            ctx.stroke();
            ctx.setLineDash([]);
            if (snappedData.snapped) {
                ctx.beginPath();
                ctx.arc(targetScreen.x, targetScreen.y, POINT_RADIUS, 0, 2 * Math.PI);
                ctx.fillStyle = colors.feedbackSnapped;
                ctx.fill();
            }
            const stateForSnapInfo = { showDistances, showAngles, currentShiftPressed, distanceSigFigs, angleSigFigs, angleDisplayMode, viewTransform, frozenReference_D_du, gridDisplayMode, frozenReference_A_rad, colors };
            prepareSnapInfoTexts(ctx, htmlOverlay, startPoint, targetPosData, snappedData, stateForSnapInfo, dataToScreen, currentPreviewDrawingContext, updateHtmlLabel);
        }
    }

    if (isRectangleSelecting && isDragConfirmed) {
        ctx.strokeStyle = colors.mouseCoords;
        ctx.lineWidth = 1;
        ctx.setLineDash(DASH_PATTERN);
        const rX = Math.min(rectangleSelectStartPos.x, mousePos.x);
        const rY = Math.min(rectangleSelectStartPos.y, mousePos.y);
        const rW = Math.abs(rectangleSelectStartPos.x - mousePos.x);
        const rH = Math.abs(rectangleSelectStartPos.y - mousePos.y);
        ctx.strokeRect(rX, rY, rW, rH);
        ctx.setLineDash([]);
    }

    updateMouseCoordinates(htmlOverlay, { coordsDisplayMode, isMouseOverCanvas, currentShiftPressed, ghostPointPosition, gridDisplayMode, lastGridState, angleDisplayMode, canvas, dpr, mousePos, colors}, screenToData, updateHtmlLabel);
    
    const stateForUI = { 
        dpr, 
        canvasUI, 
        isToolbarExpanded, 
        isColorPaletteExpanded, 
        isTransformPanelExpanded, 
        isDisplayPanelExpanded, 
        isPlacingTransform, 
        placingTransformType, 
        placingSnapPos, 
        mousePos, 
        selectedSwatchIndex, 
        recentColors, 
        activeThemeName, 
        colors,
        // Add these missing display mode properties:
        coordsDisplayMode,
        gridDisplayMode,
        angleDisplayMode,
        distanceDisplayMode
    };
    drawCanvasUI(ctx, htmlOverlay, stateForUI, updateHtmlLabel);
    
    cleanupHtmlLabels();
}

function performEscapeAction() {
    selectedPointIds = [];
    selectedEdgeIds = [];
    selectedCenterIds = [];
    activeCenterId = null;
    isDrawingMode = false;
    previewLineStartPointId = null;
    frozenReference_A_rad = null;
    frozenReference_A_baseRad = null;
    frozenReference_D_du = null;
    frozenReference_D_g2g = null;
    frozenReference_Origin_Data = null;
    isActionInProgress = false;
    isDragConfirmed = false;
    isRectangleSelecting = false;
    isEdgeTransformDrag = false;
    isDraggingCenter = false;
    isPanningBackground = false;
    dragPreviewPoints = [];
    actionTargetPoint = null;
    currentMouseButton = -1;
    clickData = { pointId: null, count: 0, timestamp: 0 };
    canvas.style.cursor = 'crosshair';
    transformIndicatorData = null;
    drawingSequence = [];
    currentSequenceIndex = 0;
}

function handleRepeat() {
    if (!isDrawingMode || !previewLineStartPointId || drawingSequence.length === 0) {
        return;
    }

    saveStateForUndo();

    const lastPoint = findPointById(previewLineStartPointId);
    if (!lastPoint) {
        console.error("handleRepeat: Last point not found. Cannot repeat.");
        performEscapeAction();
        return;
    }

    const precedingSegmentOfLastPoint = getPrecedingSegment(lastPoint.id);
    if (!precedingSegmentOfLastPoint) {
        console.error("handleRepeat: No preceding segment found for lastPoint, but drawingSequence is not empty. Aborting repeat.");
        performEscapeAction();
        return;
    }
    const currentAbsoluteDirection = precedingSegmentOfLastPoint.angleRad;

    // For the repeat pattern, we only use segments starting from index 1 (skipping the first segment)
    // If we only have the first segment, we can't repeat yet
    if (drawingSequence.length === 1) {
        console.log("handleRepeat: Only first segment exists, cannot repeat pattern yet.");
        return;
    }

    // Get the pattern step from the repeating portion (starting from index 1)
    const repeatPatternLength = drawingSequence.length - 1;
    const patternStepIndex = ((currentSequenceIndex - 1) % repeatPatternLength) + 1;
    const patternStep = drawingSequence[patternStepIndex];
    
    console.log("=== REPEAT DEBUG ===");
    console.log("drawingSequence:", drawingSequence);
    console.log("currentSequenceIndex:", currentSequenceIndex);
    console.log("repeatPatternLength:", repeatPatternLength);
    console.log("patternStepIndex:", patternStepIndex);
    console.log("patternStep:", patternStep);
    
    const lengthToDraw = patternStep.length;
    // For repeating patterns, the last segment (which has turn=0 as placeholder) 
    // should use the same turn as the first segment in the repeating cycle
    let turnToApplyForNextSegment;
    if (patternStepIndex === drawingSequence.length - 1) {
        // We're at the last segment - its turn is just a placeholder 0
        // Use the turn from the first segment of the repeating pattern (index 1, or index 0 if only 2 total)
        const firstRepeatSegmentIndex = drawingSequence.length > 2 ? 1 : 0;
        turnToApplyForNextSegment = drawingSequence[firstRepeatSegmentIndex].turn;
        console.log("Last segment - using turn from segment", firstRepeatSegmentIndex, ":", turnToApplyForNextSegment, "radians");
    } else {
        // Use the established turn for this segment
        turnToApplyForNextSegment = patternStep.turn;
        console.log("Using established turn from pattern step:", turnToApplyForNextSegment, "radians");
    }
        
    console.log("lengthToDraw:", lengthToDraw);
    console.log("turnToApplyForNextSegment (radians):", turnToApplyForNextSegment);
    console.log("turnToApplyForNextSegment (degrees):", turnToApplyForNextSegment * 180 / Math.PI);
    
    // Cycle through colors just like we cycle through angles
    // For proper alternating pattern, determine which color position we should be at
    let colorForNewPoint;
    let colorForCurrentPoint;
    
    if (patternStepIndex === drawingSequence.length - 1) {
        // We're at the last segment - figure out the proper alternating pattern
        // Based on the established pattern (segments 0 and 1), determine what colors should be
        const establishedColors = [drawingSequence[0].endPointColor, drawingSequence[1].endPointColor];
        
        // For the current point (where we're standing), use the alternating pattern
        const currentColorIndex = (currentSequenceIndex - 1) % establishedColors.length;
        colorForCurrentPoint = establishedColors[currentColorIndex];
        
        // For the new point, use the next color in the alternating pattern
        const newColorIndex = currentSequenceIndex % establishedColors.length;
        colorForNewPoint = establishedColors[newColorIndex];
        
        console.log("Last segment - alternating pattern:");
        console.log("Current point color should be:", colorForCurrentPoint);
        console.log("New point color should be:", colorForNewPoint);
        
        // Update the current point's color to match the pattern
        lastPoint.color = colorForCurrentPoint;
    } else {
        // Use the color that corresponds to this pattern step's position
        colorForNewPoint = patternStep.endPointColor;
        console.log("Using color from current pattern step:", colorForNewPoint);
    }

    // Calculate the new point's absolute angle
    const newSegmentAbsoluteAngle = normalizeAngle(currentAbsoluteDirection + turnToApplyForNextSegment);
    
    const targetX = lastPoint.x + lengthToDraw * Math.cos(newSegmentAbsoluteAngle);
    const targetY = lastPoint.y + lengthToDraw * Math.sin(newSegmentAbsoluteAngle);

    let newPoint = null;
    let merged = false;
    const mergeRadiusData = POINT_SELECT_RADIUS / viewTransform.scale;

    for (const p of allPoints) {
        if (p.type === 'regular' && distance({ x: targetX, y: targetY }, p) < mergeRadiusData) {
            newPoint = p;
            merged = true;
            break;
        }
    }

    if (!merged) {
        newPoint = { id: generateUniqueId(), x: targetX, y: targetY, type: 'regular', color: colorForNewPoint };
        allPoints.push(newPoint);
    }

    const edgeExists = allEdges.some(e => 
        (e.id1 === lastPoint.id && e.id2 === newPoint.id) || 
        (e.id2 === lastPoint.id && e.id1 === newPoint.id)
    );
    if (!edgeExists) {
        allEdges.push({ id1: lastPoint.id, id2: newPoint.id });
    }

    previewLineStartPointId = newPoint.id;
    
    // Update sequence index for next repeat
    currentSequenceIndex++;
    if (currentSequenceIndex >= drawingSequence.length) {
        currentSequenceIndex = 1; // Reset to start of repeat pattern (skipping first segment)
    }

    frozenReference_D_du = null;
    frozenReference_D_g2g = null;
    frozenReference_A_rad = null;
    frozenReference_A_baseRad = null;
    frozenReference_Origin_Data = null;
}

function gameLoop() {
    redrawAll();
    requestAnimationFrame(gameLoop);
}




colorPicker.addEventListener('change', (e) => {
    setCurrentColor(e.target.value);
});


canvas.addEventListener('wheel', (event) => {
    event.preventDefault();
    const mouseScreen = getMousePosOnCanvas(event, canvas);
    const scaleFactor = event.deltaY > 0 ? 1/1.15 : 1.15;
    zoomAt(mouseScreen, scaleFactor);
});

canvas.addEventListener('mouseenter', () => {
    isMouseOverCanvas = true;
});

canvas.addEventListener('mouseleave', () => {
    isMouseOverCanvas = false;
    redrawAll(); // To hide the mouse coordinates
});

canvas.addEventListener('contextmenu', (event) => event.preventDefault());

canvas.addEventListener('mousemove', (event) => {
    mousePos = getMousePosOnCanvas(event, canvas);
    currentShiftPressed = event.shiftKey;
    placingSnapPos = null; // Reset on each mousemove
    ghostPointPosition = null; // Reset ghost position at the start of the frame to ensure it's re-evaluated

    // Determine ghostPointPosition based on shift-press and current context
    if (currentShiftPressed) {
        const mouseDataPos = screenToData(mousePos);
        let potentialSnapPos = null; // This will hold the data position from snapping functions

        if (isPlacingTransform) {
            // When placing a transform center, the ghost snaps to grid or existing points.
            potentialSnapPos = getBestSnapPosition(mouseDataPos);
            if (potentialSnapPos) {
                placingSnapPos = dataToScreen(potentialSnapPos); // Visual cue for transform placement
            }
        } else if (isDrawingMode && previewLineStartPointId) {
            // When drawing a line, the ghost shows the snapped end point of the line.
            const startPoint = findPointById(previewLineStartPointId);
            if (startPoint) {
                const snappedData = getSnappedPosition(startPoint, mousePos, currentShiftPressed);
                potentialSnapPos = { x: snappedData.x, y: snappedData.y };
            }
        } else if (!isActionInProgress) {
            // For general canvas interaction (not drawing, not dragging, not placing transform),
            // the ghost snaps to common points/grid.
            potentialSnapPos = getBestSnapPosition(mouseDataPos);
        }

        // IMPORTANT: Always set ghostPointPosition to either the snapped position or the raw mouse position.
        // This ensures the ghost is always visible when Shift is pressed.
        if (potentialSnapPos) {
            ghostPointPosition = potentialSnapPos;
        } else {
            // Fallback to raw mouse position if no snap candidates were found by the respective functions.
            // This ensures the ghost is ALWAYS visible when Shift is down.
            ghostPointPosition = mouseDataPos; 
        }
    }

    // Handle ongoing actions (dragging, panning, rectangle selecting)
    if (!isActionInProgress) {
        return;
    }

    if (!isDragConfirmed && distance(mousePos, actionStartPos) > DRAG_THRESHOLD) {
        isDragConfirmed = true;
        isEdgeTransformDrag = false;

        if (currentMouseButton === 2) {
            isRectangleSelecting = true;
            return;
        }
        
        const { target, targetPoint, targetEdge, shiftKey, ctrlKey } = actionContext;

        if (isDraggingCenter) {
            initialDragPointStates = JSON.parse(JSON.stringify([targetPoint]));
            dragPreviewPoints = JSON.parse(JSON.stringify([targetPoint]));
            canvas.style.cursor = 'grabbing';
        }
        else if (targetEdge) {
            if (activeCenterId) isEdgeTransformDrag = true;

            const pointIdsToAffect = new Set(selectedPointIds);
            selectedEdgeIds.forEach(edgeId => {
                const edge = allEdges.find(e => getEdgeId(e) === edgeId);
                if(edge) {
                    pointIdsToAffect.add(edge.id1);
                    pointIdsToAffect.add(edge.id2);
                }
            });
            pointIdsToAffect.add(targetEdge.id1);
            pointIdsToAffect.add(targetEdge.id2);

            const pointsToDrag = Array.from(pointIdsToAffect).map(id => findPointById(id)).filter(Boolean);

            if (pointsToDrag.length > 0) {
                initialDragPointStates = JSON.parse(JSON.stringify(pointsToDrag));
                dragPreviewPoints = JSON.parse(JSON.stringify(pointsToDrag));
                canvas.style.cursor = 'grabbing';
            }
        }
        else if (target !== 'canvas') {
            actionTargetPoint = targetPoint;
            if (targetPoint?.type !== 'regular') {
                if (targetPoint) handleCenterSelection(targetPoint.id, shiftKey, ctrlKey);
            } else if (targetPoint && !selectedPointIds.includes(targetPoint.id)) {
                applySelectionLogic([targetPoint.id], [], shiftKey, ctrlKey, false);
            }

            let pointsToDragIds = new Set([...selectedPointIds, ...selectedCenterIds]);
            if (targetPoint && !pointsToDragIds.has(targetPoint.id)) {
                pointsToDragIds = new Set([targetPoint.id]);
                if (targetPoint.type === 'regular') {
                    selectedPointIds = [targetPoint.id];
                    selectedCenterIds = [];
                } else {
                    selectedPointIds = [];
                    selectedCenterIds = [targetPoint.id];
                }
                activeCenterId = selectedCenterIds.at(-1) ?? null;
            }
            const pointsToDrag = Array.from(pointsToDragIds).map(id => findPointById(id)).filter(Boolean);
            if (pointsToDrag.length > 0) {
                initialDragPointStates = JSON.parse(JSON.stringify(pointsToDrag));
                dragPreviewPoints = JSON.parse(JSON.stringify(pointsToDrag));
                canvas.style.cursor = 'grabbing';
            }
        }
        else if (currentMouseButton === 0) {
            isPanningBackground = true;
            backgroundPanStartOffset = { x: viewTransform.offsetX, y: viewTransform.offsetY };
            canvas.style.cursor = 'move';
        }
    }

    if (isDragConfirmed) {
        const isTransformingSelection = activeCenterId && selectedPointIds.length > 0;

        if (isPanningBackground) {
            const deltaX_css = mousePos.x - actionStartPos.x;
            const deltaY_css = mousePos.y - actionStartPos.y;
            viewTransform.offsetX = backgroundPanStartOffset.x + (deltaX_css * dpr);
            viewTransform.offsetY = backgroundPanStartOffset.y - (deltaY_css * dpr);
        } else if (isDraggingCenter) {
            const mouseData = screenToData(mousePos);
            const startMouseData = screenToData(actionStartPos);
            let finalDelta = { x: mouseData.x - startMouseData.x, y: mouseData.y - startMouseData.y };
            if (currentShiftPressed) {
                const targetSnapPos = { x: initialDragPointStates[0].x + finalDelta.x, y: initialDragPointStates[0].y + finalDelta.y };
                const snapResult = getDragSnapPosition(initialDragPointStates[0], targetSnapPos);
                if (snapResult.snapped) {
                    finalDelta = { x: snapResult.point.x - initialDragPointStates[0].x, y: snapResult.point.y - initialDragPointStates[0].y };
                }
            }
            dragPreviewPoints[0].x = initialDragPointStates[0].x + finalDelta.x;
            dragPreviewPoints[0].y = initialDragPointStates[0].y + finalDelta.y;
        }
        else if (isTransformingSelection || isEdgeTransformDrag) {
            const center = findPointById(activeCenterId);
            let startReferencePoint;
            if (isEdgeTransformDrag) {
                startReferencePoint = screenToData(actionStartPos);
            } else {
                const referencePoint = actionTargetPoint?.type === 'regular' ? actionTargetPoint : initialDragPointStates.find(p => selectedPointIds.includes(p.id));
                startReferencePoint = initialDragPointStates.find(p => p.id === referencePoint.id);
            }

            if (!center || !startReferencePoint) return;

            const mouseData = screenToData(mousePos);
            const centerType = center.type;
            let rotation, scale, finalMouseData, isSnapping, snappedScaleValue;
            isSnapping = false;
            snappedScaleValue = null;
            finalMouseData = mouseData;

            if (currentShiftPressed) {
                const snapResult = getTransformSnap(center, mouseData, startReferencePoint, centerType);
                if (snapResult.snapped) {
                    isSnapping = true;
                    finalMouseData = snapResult.pos;
                    rotation = snapResult.rotation;
                    scale = snapResult.scale;
                    snappedScaleValue = snapResult.pureScaleForDisplay;
                }
            }
            
            if (!isSnapping) {
                const startVector = { x: startReferencePoint.x - center.x, y: startReferencePoint.y - center.y };
                const currentVector = { x: mouseData.x - center.x, y: mouseData.y - center.y };
                const startDist = Math.hypot(startVector.x, startVector.y);
                const currentDist = Math.hypot(currentVector.x, currentVector.y);
                const startAngle = Math.atan2(startVector.y, startVector.x);
                const currentAngle = Math.atan2(currentVector.y, currentVector.x);
                rotation = normalizeAngleToPi(currentAngle - startAngle);
                scale = (startDist < GEOMETRY_CALCULATION_EPSILON) ? 1 : currentDist / startDist;
            }
        
            if (centerType === 'center_rotate_only') scale = 1.0;
            if (centerType === 'center_scale_only') rotation = 0.0;
        
            transformIndicatorData = { center, startPos: startReferencePoint, currentPos: finalMouseData, rotation, scale, isSnapping, snappedScaleValue, transformType: centerType };
        
            initialDragPointStates.forEach(p_initial => {
                if (!p_initial) return;
                const p_preview = dragPreviewPoints.find(p => p && p.id === p_initial.id);
                if (!p_preview) return;
                const initialPointVector = { x: p_initial.x - center.x, y: p_initial.y - center.y };
                let transformedVector = { ...initialPointVector };
                if (centerType !== 'center_rotate_only') {
                    transformedVector.x *= scale;
                    transformedVector.y *= scale;
                }
                if (centerType !== 'center_scale_only') {
                    const x = transformedVector.x;
                    const y = transformedVector.y;
                    transformedVector.x = x * Math.cos(rotation) - y * Math.sin(rotation);
                    transformedVector.y = x * Math.sin(rotation) + y * Math.cos(rotation);
                }
                p_preview.x = center.x + transformedVector.x;
                p_preview.y = center.y + transformedVector.y;
            });
        }
        else if (dragPreviewPoints.length > 0) {
            const mouseData = screenToData(mousePos);
            const startMouseData = screenToData(actionStartPos);
            let finalDelta = { x: mouseData.x - startMouseData.x, y: mouseData.y - startMouseData.y };
            if (currentShiftPressed && actionTargetPoint) {
                const dragOrigin = actionTargetPoint.type === 'regular' ? initialDragPointStates.find(p => p && p.id === actionTargetPoint.id) : null;
                if (dragOrigin) {
                    const targetSnapPos = { x: dragOrigin.x + finalDelta.x, y: dragOrigin.y + finalDelta.y };
                    const snapResult = getDragSnapPosition(dragOrigin, targetSnapPos);
                    if (snapResult.snapped) {
                        finalDelta = { x: snapResult.point.x - dragOrigin.x, y: snapResult.point.y - dragOrigin.y };
                    }
                }
            }
            initialDragPointStates.forEach(originalPointState => {
                if (!originalPointState) return;
                const previewPointToUpdate = dragPreviewPoints.find(dp => dp && dp.id === originalPointState.id);
                if (previewPointToUpdate) {
                    previewPointToUpdate.x = originalPointState.x + finalDelta.x;
                    previewPointToUpdate.y = originalPointState.y + finalDelta.y;
                }
            });
        }
    }
});

canvas.addEventListener('mousedown', (event) => {
    mousePos = getMousePosOnCanvas(event, canvas);
    isDraggingCenter = false; // Reset on each new click

    if (handleCanvasUIClick(mousePos)) {
        return;
    }

    if (isDrawingMode && event.button === 2) {
        performEscapeAction();
        return;
    }

    if (isPlacingTransform) {
        if (event.button === 0) { // Left-click: Place the transform object.
            saveStateForUndo();
            const finalPlacePos = placingSnapPos || mousePos;
            const dataPos = screenToData(finalPlacePos);
            const newCenter = {
                id: generateUniqueId(),
                x: dataPos.x,
                y: dataPos.y,
                type: placingTransformType,
                color: THEMES[activeThemeName].uiIcon
            };
            allPoints.push(newCenter);
            handleCenterSelection(newCenter.id, false, false);
        } else if (event.button === 2) { // Right-click: Cancel the placement tool.
            isPlacingTransform = false;
            placingTransformType = null;
            placingSnapPos = null;
        }
        return;
    }

    const clickedPoint = findClickedPoint(mousePos);
    let clickedEdge = findClickedEdge(mousePos);

    if (clickedPoint) {
        clickedEdge = null; // Prioritize point clicks over edge clicks
        if (clickedPoint.type !== 'regular') {
            isDraggingCenter = true;
            // When clicking a center, just manage its selection state.
            // Do not clear the selection of regular points.
            handleCenterSelection(clickedPoint.id, event.shiftKey, event.ctrlKey || event.metaKey);
        }
    }

    isActionInProgress = true;
    isDragConfirmed = false;
    isPanningBackground = false;
    isRectangleSelecting = false;
    initialDragPointStates = [];
    dragPreviewPoints = [];
    currentMouseButton = event.button;
    actionStartPos = mousePos;
    rectangleSelectStartPos = actionStartPos;

    actionContext = {
        targetPoint: clickedPoint,
        targetEdge: clickedEdge,
        target: clickedPoint || clickedEdge || 'canvas',
        shiftKey: event.shiftKey,
        ctrlKey: event.ctrlKey || event.metaKey,
    };

    if (event.altKey) {
        if (clickedPoint && clickedPoint.type === 'regular') {
            saveStateForUndo();
            performEscapeAction();
            isDrawingMode = true;
            previewLineStartPointId = clickedPoint.id;
            isActionInProgress = false;
            return;
        } else if (clickedEdge) {
            saveStateForUndo();
            performEscapeAction();
            const p1 = findPointById(clickedEdge.id1);
            const p2 = findPointById(clickedEdge.id2);
            if (p1 && p2) {
                const closest = getClosestPointOnLineSegment(screenToData(actionStartPos), p1, p2);
                const newPoint = { id: generateUniqueId(), x: closest.x, y: closest.y, type: 'regular', color: currentColor };
                allPoints.push(newPoint);
                allEdges = allEdges.filter(e => getEdgeId(e) !== getEdgeId(clickedEdge));
                allEdges.push({ id1: p1.id, id2: newPoint.id });
                allEdges.push({ id1: newPoint.id, id2: p2.id });
                isDrawingMode = true;
                previewLineStartPointId = newPoint.id;
                isActionInProgress = false;
            }
            return;
        }
    }
});

canvas.addEventListener('mouseup', (event) => {
    if (!isActionInProgress) return;

    const { shiftKey, ctrlKey, targetPoint, targetEdge, target } = actionContext;

    if (isDragConfirmed) {
        if (isRectangleSelecting) {
            const dataP1 = screenToData({ x: Math.min(actionStartPos.x, mousePos.x), y: Math.min(actionStartPos.y, mousePos.y) });
            const dataP2 = screenToData({ x: Math.max(actionStartPos.x, mousePos.x), y: Math.max(actionStartPos.y, mousePos.y) });
            const minX = Math.min(dataP1.x, dataP2.x),
                maxX = Math.max(dataP1.x, dataP2.x);
            const minY = Math.min(dataP1.y, dataP2.y),
                maxY = Math.max(dataP1.y, dataP2.y);

            const pointsInRect = allPoints.filter(p => p.type === 'regular' && p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY).map(p => p.id);
            const centersInRect = allPoints.filter(p => p.type !== 'regular' && p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY).map(p => p.id);

            if (!shiftKey && !ctrlKey) {
                selectedPointIds = pointsInRect;
                selectedEdgeIds = allEdges.filter(e => pointsInRect.includes(e.id1) && pointsInRect.includes(e.id2)).map(e => getEdgeId(e));
                selectedCenterIds = centersInRect;
            } else {
                if (shiftKey) {
                    selectedPointIds = [...new Set([...selectedPointIds, ...pointsInRect])];
                    const edgesInRect = allEdges.filter(e => pointsInRect.includes(e.id1) && pointsInRect.includes(e.id2)).map(e => getEdgeId(e));
                    selectedEdgeIds = [...new Set([...selectedEdgeIds, ...edgesInRect])];
                    selectedCenterIds = [...new Set([...selectedCenterIds, ...centersInRect])];
                } else {
                    pointsInRect.forEach(id => { const i = selectedPointIds.indexOf(id); if (i > -1) selectedPointIds.splice(i, 1); else selectedPointIds.push(id); });
                    centersInRect.forEach(id => { const i = selectedCenterIds.indexOf(id); if (i > -1) selectedCenterIds.splice(i, 1); else selectedCenterIds.push(id); });
                }
            }
            activeCenterId = selectedCenterIds.at(-1) ?? null;

        } else if (isPanningBackground) {
        }
        else if (dragPreviewPoints.length > 0) {
            let didMerge = false;
            if (targetPoint && targetPoint.type === 'regular' && dragPreviewPoints.length === 1 && dragPreviewPoints[0].id === targetPoint.id) {
                const finalDropPos = dragPreviewPoints[0];
                let mergeTargetPoint = null;
                const mergeRadiusData = POINT_SELECT_RADIUS / viewTransform.scale;

                for (const p of allPoints) {
                    if (p.id !== targetPoint.id && p.type === 'regular' && distance({ x: finalDropPos.x, y: finalDropPos.y }, p) < mergeRadiusData) {
                        mergeTargetPoint = p;
                        break;
                    }
                }

                if (mergeTargetPoint) {
                    didMerge = true;
                    saveStateForUndo();
                    const pointToDeleteId = targetPoint.id;
                    const pointToKeepId = mergeTargetPoint.id;
                    const edgesToRewire = allEdges.filter(edge => edge.id1 === pointToDeleteId || edge.id2 === pointToDeleteId);
                    const newEdges = [];
                    for (const edge of edgesToRewire) {
                        const otherEndId = (edge.id1 === pointToDeleteId) ? edge.id2 : edge.id1;
                        if (otherEndId !== pointToKeepId) {
                            const edgeAlreadyExists = allEdges.some(e => (e.id1 === pointToKeepId && e.id2 === otherEndId) || (e.id2 === pointToKeepId && e.id1 === otherEndId));
                            if (!edgeAlreadyExists) newEdges.push({ id1: pointToKeepId, id2: otherEndId });
                        }
                    }
                    allEdges = allEdges.filter(edge => edge.id1 !== pointToDeleteId && edge.id2 !== pointToDeleteId);
                    allPoints = allPoints.filter(p => p.id !== pointToDeleteId);
                    selectedPointIds = selectedPointIds.filter(id => id !== pointToDeleteId);
                    if (!selectedPointIds.includes(pointToKeepId)) {
                        selectedPointIds.push(pointToKeepId);
                    }
                    allEdges.push(...newEdges);
                }
            }
            if (!didMerge) {
                saveStateForUndo();
                dragPreviewPoints.forEach(dp => {
                    if (dp) {
                        const p = allPoints.find(point => point.id === dp.id);
                        if (p) {
                            p.x = dp.x;
                            p.y = dp.y;
                        }
                    }
                });
            }
        }
    } else {
        if (currentMouseButton === 0) {
            const startPoint = findPointById(previewLineStartPointId);
            if (isDrawingMode && startPoint) {
                saveStateForUndo();
                let newPoint = null;
                const snappedDataForCompletedSegment = getSnappedPosition(startPoint, mousePos, shiftKey);

                if (targetPoint && targetPoint.type === 'regular' && targetPoint.id !== startPoint.id) {
                    const edgeExists = allEdges.some(e => (e.id1 === startPoint.id && e.id2 === targetPoint.id) || (e.id2 === startPoint.id && e.id1 === targetPoint.id));
                    if (!edgeExists) allEdges.push({ id1: startPoint.id, id2: targetPoint.id });
                    newPoint = targetPoint;
                } else if (targetEdge) {
                    const p1 = findPointById(targetEdge.id1);
                    const p2 = findPointById(targetEdge.id2);
                    if (p1 && p2) {
                        const closest = getClosestPointOnLineSegment(screenToData(mousePos), p1, p2);
                        newPoint = { id: generateUniqueId(), x: closest.x, y: closest.y, type: 'regular', color: currentColor };
                        allPoints.push(newPoint);
                        allEdges = allEdges.filter(e => getEdgeId(e) !== getEdgeId(targetEdge));
                        allEdges.push({ id1: p1.id, id2: newPoint.id }, { id1: newPoint.id, id2: p2.id }, { id1: startPoint.id, id2: newPoint.id });
                    }
                } else {
                    newPoint = { id: generateUniqueId(), x: snappedDataForCompletedSegment.x, y: snappedDataForCompletedSegment.y, type: 'regular', color: currentColor };
                    allPoints.push(newPoint);
                    allEdges.push({ id1: startPoint.id, id2: newPoint.id });
                }

                if (newPoint) {
                    const completedSegmentProps = getCompletedSegmentProperties(startPoint, newPoint, allEdges);
                    if (completedSegmentProps) {
                        if (drawingSequence.length > 0) {
                            drawingSequence[drawingSequence.length - 1].turn = completedSegmentProps.turnAngleRad;
                        }
                        drawingSequence.push({
                            length: completedSegmentProps.length,
                            turn: 0,
                            endPointColor: newPoint.color
                        });
                        currentSequenceIndex = drawingSequence.length - 1;
                    }
                }

                if (shiftKey && newPoint && snappedDataForCompletedSegment) {
                    const completedSegmentProps = getCompletedSegmentProperties(startPoint, newPoint, allEdges);

                    if (completedSegmentProps) {
                        frozenReference_Origin_Data = completedSegmentProps.startPoint;

                        // --- START: MODIFIED SECTION (BUG FIX) ---
                        // Prioritize the exact grid-to-grid distance if it exists.
                        if (snappedDataForCompletedSegment.gridToGridSquaredSum > 0 && snappedDataForCompletedSegment.gridInterval) {
                            // Calculate the exact mathematical length from the grid data.
                            frozenReference_D_du = snappedDataForCompletedSegment.gridInterval * Math.sqrt(snappedDataForCompletedSegment.gridToGridSquaredSum);
                        } else {
                            // Otherwise, fall back to the calculated geometric length.
                            frozenReference_D_du = completedSegmentProps.length;
                        }
                        // --- END: MODIFIED SECTION ---

                        frozenReference_D_g2g = snappedDataForCompletedSegment.gridToGridSquaredSum > 0 ? { g2gSquaredSum: snappedDataForCompletedSegment.gridToGridSquaredSum, interval: snappedDataForCompletedSegment.gridInterval } : null;
                        frozenReference_A_rad = completedSegmentProps.turnAngleRad;
                        frozenReference_A_baseRad = completedSegmentProps.precedingSegmentAbsoluteAngleRad;
                    } else {
                        frozenReference_D_du = null;
                        frozenReference_D_g2g = null;
                        frozenReference_A_rad = null;
                        frozenReference_A_baseRad = null;
                        frozenReference_Origin_Data = null;
                    }
                } else {
                    frozenReference_D_du = null;
                    frozenReference_D_g2g = null;
                    frozenReference_A_rad = null;
                    frozenReference_A_baseRad = null;
                    frozenReference_Origin_Data = null;
                }
                if (newPoint) previewLineStartPointId = newPoint.id;
                else isDrawingMode = false;
                clickData.count = 0;
            } else {
                const now = Date.now();
                let primaryClickTarget = null;
                if (targetPoint && targetPoint.type !== 'regular') {
                    primaryClickTarget = targetPoint;
                } else if (targetPoint && targetPoint.type === 'regular') {
                    primaryClickTarget = targetPoint;
                } else if (targetEdge) {
                    primaryClickTarget = targetEdge;
                } else {
                    primaryClickTarget = 'canvas';
                }

                if (primaryClickTarget !== 'canvas') {
                    const targetId = primaryClickTarget.id || getEdgeId(primaryClickTarget);
                    const targetType = primaryClickTarget.id ? (primaryClickTarget.type !== 'regular' ? 'center' : 'point') : 'edge';

                    if (targetId && clickData.targetId === targetId && (now - clickData.timestamp) < DOUBLE_CLICK_MS) {
                        clickData.count++;
                    } else {
                        clickData.count = 1;
                        clickData.targetId = targetId;
                        clickData.type = targetType;
                    }
                    clickData.timestamp = now;

                    switch (clickData.count) {
                        case 1:
                            if (targetType === 'center') {
                                // This case is now handled in mousedown to set isDraggingCenter
                            } else if (targetType === 'point') {
                                applySelectionLogic([targetId], [], shiftKey, ctrlKey, false);
                            } else if (targetType === 'edge') {
                                applySelectionLogic([], [targetId], shiftKey, ctrlKey, false);
                            }
                            break;
                        case 2:
                            if (targetType === 'point') {
                                const neighbors = findNeighbors(clickData.targetId);
                                applySelectionLogic([clickData.targetId, ...neighbors], [], false, false);
                            } else if (targetType === 'edge') {
                                const edge = allEdges.find(e => getEdgeId(e) === clickData.targetId);
                                if (edge) {
                                    const validNeighborEdges = [...findNeighborEdges(edge.id1), ...findNeighborEdges(edge.id2)].filter(e => findPointById(e.id1) && findPointById(e.id2));
                                    applySelectionLogic([], Array.from(new Set(validNeighborEdges.map(e => getEdgeId(e)))), false, false);
                                }
                            } else if (targetType === 'center') {
                                const center = findPointById(clickData.targetId);
                                if (center) {
                                    const relatedPoints = allPoints.filter(p => p.type === 'regular' && distance(p, center) < (POINT_SELECT_RADIUS * 10 / viewTransform.scale)).map(p => p.id);
                                    const relatedEdges = allEdges.filter(e => relatedPoints.includes(e.id1) && relatedPoints.includes(e.id2)).map(e => getEdgeId(e));
                                    applySelectionLogic(relatedPoints, relatedEdges, shiftKey, ctrlKey, false);
                                }
                            }
                            break;
                        case 3:
                            if (targetType === 'point') {
                                const pointsInSubgraph = findAllPointsInSubgraph(clickData.targetId);
                                applySelectionLogic(pointsInSubgraph, [], false, false);
                            } else if (targetType === 'edge') {
                                const edge = allEdges.find(e => getEdgeId(e) === clickData.targetId);
                                if (edge) {
                                    const pointsInSubgraph = new Set(findAllPointsInSubgraph(edge.id1));
                                    const edgesInSubgraph = allEdges.filter(e => pointsInSubgraph.has(e.id1) && pointsInSubgraph.has(e.id2));
                                    applySelectionLogic([], edgesInSubgraph.map(e => getEdgeId(e)), false, false);
                                }
                            } else if (targetType === 'center') {
                                const allRegularPoints = allPoints.filter(p => p.type === 'regular').map(p => p.id);
                                const allGeometricEdges = allEdges.map(e => getEdgeId(e));
                                applySelectionLogic(allRegularPoints, allGeometricEdges, shiftKey, ctrlKey, false);
                            }
                            clickData.count = 0;
                            break;
                    }
                } else {
                    clickData.count = 0;
                    saveStateForUndo();
                    selectedPointIds = [];
                    selectedEdgeIds = [];
                    selectedCenterIds = [];
                    activeCenterId = null;
                    isDrawingMode = false;
                    previewLineStartPointId = null;
                    const startCoords = ghostPointPosition ? ghostPointPosition : screenToData(mousePos);
                    const newPoint = { id: generateUniqueId(), ...startCoords, type: 'regular', color: currentColor };
                    allPoints.push(newPoint);
                    isDrawingMode = true;
                    previewLineStartPointId = newPoint.id;
                    frozenReference_D_du = null;
                    frozenReference_D_g2g = null;
                    frozenReference_A_rad = null;
                    frozenReference_A_baseRad = null;
                    frozenReference_Origin_Data = null;
                    drawingSequence = [];
                    currentSequenceIndex = 0;
                }
            }
        } else if (currentMouseButton === 2) {
            performEscapeAction();
        }
    }

    isActionInProgress = false;
    isDragConfirmed = false;
    isPanningBackground = false;
    isRectangleSelecting = false;
    actionContext = null;
    actionTargetPoint = null;
    transformIndicatorData = null;
    isEdgeTransformDrag = false;
    isDraggingCenter = false;
    canvas.style.cursor = 'crosshair';
});


window.addEventListener('keyup', (event) => {
    if (event.key === 'Shift') {
        currentShiftPressed = false;
        ghostPointPosition = null;
    }
});

window.addEventListener('keydown', (event) => {
    const isCtrlOrCmd = event.ctrlKey || event.metaKey;
    
    if (isCtrlOrCmd && event.key.toLowerCase() === KEY_REPEAT) {
        event.preventDefault();
        if (isDrawingMode && previewLineStartPointId) {
            handleRepeat();
        }
        return;
    }

    if (event.key === 'Shift') {
        currentShiftPressed = true;
        if (!isActionInProgress && !isDrawingMode) {
            const mouseDataPos = screenToData(mousePos);
            ghostPointPosition = getBestSnapPosition(mouseDataPos);
        }
    }

    const allowedDuringAction = ['Shift', 'Control', 'Meta', 'Alt', 'Escape', 'Delete', 'Backspace'];
    if (isActionInProgress && !allowedDuringAction.includes(event.key) && !(isCtrlOrCmd && [KEY_COPY,KEY_CUT,KEY_PASTE,KEY_UNDO,KEY_REDO,KEY_SELECT_ALL,KEY_ZOOM_OUT,KEY_ZOOM_IN,KEY_ZOOM_IN_PLUS].includes(event.key.toLowerCase()))) return;

    if (isMouseOverCanvas && isCtrlOrCmd && (event.key === KEY_ZOOM_IN || event.key === KEY_ZOOM_IN_PLUS)) {
        event.preventDefault();
        const centerScreen = { x: (canvas.width/dpr)/2, y: (canvas.height/dpr)/2 };
        zoomAt(centerScreen, KEYBOARD_ZOOM_FACTOR);
        return;
    }
    if (isMouseOverCanvas && isCtrlOrCmd && event.key === KEY_ZOOM_OUT) {
        event.preventDefault();
        const centerScreen = { x: (canvas.width/dpr)/2, y: (canvas.height/dpr)/2 };
        zoomAt(centerScreen, 1/KEYBOARD_ZOOM_FACTOR);
        return;
    }

    if (event.key === KEY_SPACE) {
        event.preventDefault();
        completeGraphOnSelectedPoints();
    } else if (event.key === KEY_ESCAPE) {
        performEscapeAction();
    } else if (event.key === KEY_DELETE || event.key === KEY_BACKSPACE) {
        deleteSelectedItems();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === KEY_COPY) {
        event.preventDefault();
        handleCopy();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === KEY_CUT) {
        event.preventDefault();
        handleCut();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === KEY_PASTE) {
        event.preventDefault();
        handlePaste();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === KEY_UNDO && !event.shiftKey) {
        event.preventDefault();
        handleUndo();
    } else if (isCtrlOrCmd && (event.key.toLowerCase() === KEY_REDO || (event.shiftKey && event.key.toLowerCase() === KEY_UNDO))) {
        event.preventDefault();
        handleRedo();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === KEY_SELECT_ALL) {
        event.preventDefault();
        selectedPointIds = allPoints.filter(p => p.type === 'regular').map(p => p.id);
        selectedEdgeIds = allEdges.map(edge => getEdgeId(edge));
        
        selectedCenterIds = allPoints.filter(p => p.type !== 'regular').map(p => p.id);
        
        activeCenterId = selectedCenterIds.at(-1) ?? null;
        
    }
});

window.addEventListener('resize', resizeCanvas);

window.addEventListener('load', () => {
    if (typeof window.katex === 'undefined') {
        console.error("KaTeX library failed to load or initialize. Math rendering will be broken.");
    }
    initializeCanvasUI();
    buildMainToolbarUI();
    resizeCanvas();

    viewTransform.scale = 70;
    
    viewTransform.offsetX = canvas.width / 2;
    viewTransform.offsetY = canvas.height / 2;
    
    coordsDisplayMode = 'regular';

    setCurrentColor(currentColor);
    saveStateForUndo();
    gameLoop();
});

=== style.css ===
:root {
    --container-bg-color: #1e1e1e;
}

html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: Arial, sans-serif;
    background-color: var(--container-bg-color);
}

.container {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
}

.canvas-container {
    flex-grow: 1;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    box-sizing: border-box;
}

.canvas-wrapper-relative {
    position: relative;
    width: 100%;
    height: 100%;
}

canvas {
    display: block;
    background-color: #1a1a1a;
    cursor: crosshair;
}

#html-overlay {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    width: 100%;
    height: 100%;
}

/* A different method for hiding the color picker */
#colorPicker {
    position: absolute;
    top: 200;
    left: 200;
    width: 1px;
    height: 1px;
    opacity: 0;
    border: none;
    padding: 0;
    /* We are no longer positioning it far off-screen */
}

=== utils.js ===
import {
    SCIENTIFIC_NOTATION_UPPER_BOUND,
    SCIENTIFIC_NOTATION_LOWER_BOUND,
    MAX_DECIMAL_PLACES_FORMAT,
    GEOMETRY_CALCULATION_EPSILON,
    RADIANS_IN_CIRCLE,
    DEGREES_IN_CIRCLE,
    ZERO_TOLERANCE,
    FRACTION_FORMAT_TOLERANCE,
    FRACTION_FORMAT_MAX_DENOMINATOR,
    KATEX_MINUS_PHANTOM,
    ON_SEGMENT_STRICT_T_MIN,
    ON_SEGMENT_STRICT_T_MAX,
    ANGLE_SNAP_THRESHOLD_RAD
} from './constants.js';

export function formatNumber(value, sigFigs) {
    if (value === 0) return "0";
    const absValue = Math.abs(value);
    const sign = value < 0 ? "-" : "";
    let formattedString;
    if (absValue >= SCIENTIFIC_NOTATION_UPPER_BOUND || (absValue !== 0 && absValue < SCIENTIFIC_NOTATION_LOWER_BOUND)) {
        const expStr = absValue.toExponential(Math.max(0, sigFigs - 1));
        const parts = expStr.split('e');
        let coefficient = parseFloat(parts[0]).toString();
        let exponent = parseInt(parts[1], 10);
        formattedString = `${coefficient} \\cdot 10^{${exponent}}`;
    } else {
        const integerDigits = absValue < 1 ? 0 : Math.floor(Math.log10(absValue)) + 1;
        let decimalPlacesToDisplay;
        if (absValue === 0) {
            decimalPlacesToDisplay = sigFigs - 1;
        } else if (absValue < 1) {
            let k = 0;
            let temp = absValue;
            while (temp < 1 && k < sigFigs + 5) {
                temp *= 10;
                k++;
            }
            decimalPlacesToDisplay = Math.max(0, (k - 1) + sigFigs);
        } else {
            decimalPlacesToDisplay = Math.max(0, sigFigs - integerDigits);
        }
        decimalPlacesToDisplay = Math.min(decimalPlacesToDisplay, MAX_DECIMAL_PLACES_FORMAT);
        let fixedStr = absValue.toFixed(decimalPlacesToDisplay);
        let num = parseFloat(fixedStr);
        if (Math.abs(num) === 0 && value !== 0) {
            return "0";
        }
        formattedString = Math.abs(num).toString();
    }
    return sign + formattedString;
}

export function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b);
}

export function generateAngleSnapFractions(maxDenominator, maxResultingMultipleOfBase) {
    const fractionsSet = new Set();
    fractionsSet.add(0);
    for (let q = 1; q <= maxDenominator; q++) {
        for (let p = 0; p <= q * maxResultingMultipleOfBase; p++) {
            fractionsSet.add(p / q);
        }
    }
    return Array.from(fractionsSet).sort((a, b) => a - b);
}

export function solveForPoint(N1, N2, d1, alpha) {
    const d_n = distance(N1, N2);
    if (d_n < GEOMETRY_CALCULATION_EPSILON || Math.sin(alpha) < GEOMETRY_CALCULATION_EPSILON) return [];
    const solutions = [];
    const A = 1,
        B = -2 * d1 * Math.cos(alpha),
        C = d1 * d1 - d_n * d_n;
    const discriminant = B * B - 4 * A * C;
    if (discriminant < 0) return [];

    [(-B + Math.sqrt(discriminant)) / (2 * A), (-B - Math.sqrt(discriminant)) / (2 * A)].forEach(d2 => {
        if (d2 <= 0) return;
        const a = (d1 * d1 - d2 * d2 + d_n * d_n) / (2 * d_n);
        const h = Math.sqrt(Math.max(0, d1 * d1 - a * a));
        const x_mid = N1.x + a * (N2.x - N1.x) / d_n;
        const y_mid = N1.y + a * (N2.y - N1.y) / d_n;
        solutions.push({ x: x_mid + h * (N2.y - N1.y) / d_n, y: y_mid - h * (N2.x - N1.x) / d_n, dist: d1, angle: alpha });
        solutions.push({ x: x_mid - h * (N2.y - N1.y) / d_n, y: y_mid + h * (N2.x - N1.x) / d_n, dist: d1, angle: alpha });
    });
    return solutions;
}

export function generateDistanceSnapFactors() {
    const fractionsSet = new Set();
    fractionsSet.add(0);
    for (let q = 1; q <= 6; q++) {
        for (let p = 1; p <= q; p++) {
            fractionsSet.add(p / q);
        }
    }
    for (let i = 1; i <= 10; i++) {
        fractionsSet.add(i);
        if (i > 1) {
            fractionsSet.add(i - 0.5);
        }
    }
    return Array.from(fractionsSet).sort((a, b) => a - b);
}

export function generateUniqueId() {
    return crypto.randomUUID();
}

export function normalizeAngle(angleRad) {
    while (angleRad < 0) angleRad += RADIANS_IN_CIRCLE;
    while (angleRad >= RADIANS_IN_CIRCLE) angleRad -= RADIANS_IN_CIRCLE;
    return angleRad;
}

export function normalizeAngleToPi(angleRad) {
    angleRad = normalizeAngle(angleRad);
    if (angleRad > Math.PI) {
        angleRad -= RADIANS_IN_CIRCLE;
    }
    return angleRad;
}

export function normalizeAngleDegrees(angleDeg) {
    while (angleDeg < 0) angleDeg += DEGREES_IN_CIRCLE;
    while (angleDeg >= DEGREES_IN_CIRCLE) angleDeg -= DEGREES_IN_CIRCLE;
    return angleDeg;
}

export function getLineCircleIntersection(line, circle) {
    const { p1, p2 } = line;
    const { center, radius } = circle;
    const d = { x: p2.x - p1.x, y: p2.y - p1.y };
    const f = { x: p1.x - center.x, y: p1.y - center.y };
    const a = d.x * d.x + d.y * d.y;
    const b = 2 * (f.x * d.x + f.y * d.y);
    const c = f.x * f.x + f.y * f.y - radius * radius;
    let discriminant = b * b - 4 * a * c;

    if (discriminant < 0) return [];

    discriminant = Math.sqrt(discriminant);
    const t1 = (-b - discriminant) / (2 * a);
    const t2 = (-b + discriminant) / (2 * a);
    
    return [
        { x: p1.x + t1 * d.x, y: p1.y + t1 * d.y },
        { x: p1.x + t2 * d.x, y: p1.y + t2 * d.y }
    ];
}

export function getLineLineIntersection(line1, line2) {
    const p1 = line1.p1, p2 = line1.p2, p3 = line2.p1, p4 = line2.p2;
    const den = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
    if (Math.abs(den) < GEOMETRY_CALCULATION_EPSILON) return null;
    const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / den;
    const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / den;
    
    if (u >= 0 && u <= 1) { 
        return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
    }
    return null;
}

export function simplifySquareRoot(n) {
    if (n < 0 || !Number.isInteger(n)) return [null, null];
    if (n === 0) return [0, 1];
    
    let coefficient = 1;
    let radicand = n;

    for (let i = 2; i * i <= radicand; i++) {
        while (radicand % (i * i) === 0) {
            radicand /= (i * i);
            coefficient *= i;
        }
    }

    return [coefficient, radicand];
}

export function formatSimplifiedRoot(coeff, radicand, symbol = '') {
    const symString = symbol ? `\\${symbol}` : '';

    if (radicand === 1) {
        if (coeff === 1 && symbol) return symString;
        return `${coeff}${symString}`;
    }
    if (coeff === 1) {
        return `\\sqrt{${radicand}}${symString}`;
    }
    return `${coeff}\\sqrt{${radicand}}${symString}`;
}

export function snapTValue(t, fractions, snapThreshold = 0.05) {
    let bestSnappedT = t;
    let minDiff = snapThreshold;

    if (t < -snapThreshold || t > 1 + snapThreshold) {
        return Math.max(0, Math.min(1, t));
    }

    for (const snapFraction of fractions) {
        const diff = Math.abs(t - snapFraction);
        if (diff < minDiff) {
            minDiff = diff;
            bestSnappedT = snapFraction;
        }
    }
    return Math.max(0, Math.min(1, bestSnappedT));
}

export function distance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

export function formatFraction(decimal, tolerance = FRACTION_FORMAT_TOLERANCE, maxDisplayDenominator = FRACTION_FORMAT_MAX_DENOMINATOR) {
    if (Math.abs(decimal) < ZERO_TOLERANCE) return "0";
    const originalSign = decimal < 0 ? "-" : "";
    const absDecimal = Math.abs(decimal);

    if (Math.abs(absDecimal - Math.round(absDecimal)) < tolerance) {
        const rounded = Math.round(absDecimal);
        return originalSign + rounded.toString();
    }

    const fractions = [
        [1,2],[1,3],[2,3],[1,4],[3,4],[1,5],[2,5],[3,5],[4,5],[1,6],[5,6],
        [1,8],[3,8],[5,8],[7,8],[1,10],[3,10],[7,10],[9,10],
        [1,12],[5,12],[7,12],[11,12],[1,16],[3,16],[5,16],[7,16],[9,16],[11,16],[13,16],[15,16]
    ];

    for (const [num, den] of fractions) {
        if (den <= maxDisplayDenominator) {
            if (Math.abs(absDecimal - num/den) < tolerance) {
                return originalSign + `${num}/${den}`;
            }
        }
    }

    for (let currentDen = 1; currentDen <= maxDisplayDenominator; currentDen++) {
        const currentNum = Math.round(absDecimal * currentDen);
        if (currentNum === 0 && absDecimal > ZERO_TOLERANCE) continue;
        if (Math.abs(absDecimal - currentNum / currentDen) < tolerance / currentDen) {
            const common = gcd(currentNum, currentDen);
            const n = currentNum/common;
            const d = currentDen/common;
            if (d === 1) return originalSign + `${n}`;
            return originalSign + `${n}/${d}`;
        }
    }
    let fixedPrecision = 2;
        if (absDecimal < 0.01) fixedPrecision = 3;
    else if (absDecimal < 0.1)  fixedPrecision = 2;
    else if (absDecimal < 10)   fixedPrecision = 1;
    else                        fixedPrecision = 0;
    
    return originalSign + absDecimal.toFixed(fixedPrecision);
}

export function formatCoordinateValue(value, decimalPlaces) {
    if (typeof value !== 'number' || isNaN(value)) {
        return '...';
    }
    const sign = value < 0 ? "-" : KATEX_MINUS_PHANTOM;
    const fixedValue = Math.abs(value).toFixed(decimalPlaces);
    return sign + fixedValue;
}

export function normalize(v) {
    const mag = Math.hypot(v.x, v.y);
    if (mag === 0) return { x: 0, y: 0 };
    return { x: v.x / mag, y: v.y / mag };
}

export function getClosestPointOnLineSegment(p, a, b) {
    const abx = b.x - a.x;
    const aby = b.y - a.y;
    const acx = p.x - a.x;
    const acy = p.y - a.y;
    const lenSqAB = abx * abx + aby * aby;

    if (lenSqAB === 0) {
        return { x: a.x, y: a.y, distance: distance(p, a), onSegmentStrict: true, t: 0 };
    }
    let t = (acx * abx + acy * aby) / lenSqAB;
    const onSegmentStrict = t > ON_SEGMENT_STRICT_T_MIN && t < ON_SEGMENT_STRICT_T_MAX;
    const clampedT = Math.max(0, Math.min(1, t));
    const closestX = a.x + clampedT * abx;
    const closestY = a.y + clampedT * aby;
    const dist = distance(p, { x: closestX, y: closestY });
    return { x: closestX, y: closestY, distance: dist, onSegmentStrict: onSegmentStrict, t: clampedT };
}

export function getMousePosOnCanvas(event, canvasElement) {
    const rect = canvasElement.getBoundingClientRect();
    return { x: event.clientX - rect.left, y: event.clientY - rect.top };
}

export function snapToAngle(targetAngleRad, offsetAngleRad, angleSnapFractionsArray, baseReferenceAngleRad, forceSnap = false) {
    if (isNaN(targetAngleRad) || isNaN(offsetAngleRad) || Math.abs(baseReferenceAngleRad) < GEOMETRY_CALCULATION_EPSILON) {
        const defaultAngle = isNaN(offsetAngleRad) ? 0 : offsetAngleRad;
        return { angle: defaultAngle, turn: 0, factor: null };
    }
    let bestSnappedAngleRad = targetAngleRad;
    let minAngleDifference = Infinity;
    let bestTurn = normalizeAngleToPi(targetAngleRad - offsetAngleRad);
    let bestFactor = null;

    const maxAllowedFactor = (Math.PI + 0.0001) / Math.abs(baseReferenceAngleRad);

    for (const fraction of angleSnapFractionsArray) {
        if (fraction > maxAllowedFactor) {
            continue;
        }

        const snapIncrementRad = baseReferenceAngleRad * fraction;

        const potentialSnapAngleCCW = normalizeAngle(offsetAngleRad + snapIncrementRad);
        let diffCCW = Math.abs(normalizeAngleToPi(targetAngleRad - potentialSnapAngleCCW));
        if (diffCCW < minAngleDifference) {
            minAngleDifference = diffCCW;
            bestSnappedAngleRad = potentialSnapAngleCCW;
            bestTurn = snapIncrementRad;
            bestFactor = fraction;
        }

        if (fraction !== 0) {
            const potentialSnapAngleCW = normalizeAngle(offsetAngleRad - snapIncrementRad);
            let diffCW = Math.abs(normalizeAngleToPi(targetAngleRad - potentialSnapAngleCW));
            if (diffCW < minAngleDifference) {
                minAngleDifference = diffCW;
                bestSnappedAngleRad = potentialSnapAngleCW;
                bestTurn = -snapIncrementRad;
                bestFactor = -fraction;
            }
        }
    }

    if (forceSnap || minAngleDifference < ANGLE_SNAP_THRESHOLD_RAD) {
        return { angle: bestSnappedAngleRad, turn: bestTurn, factor: bestFactor };
    }

    return { angle: targetAngleRad, turn: normalizeAngleToPi(targetAngleRad - offsetAngleRad), factor: null };
}

export function hslToRgb(h, s, l) {
    let r, g, b;

    if (s === 0) {
        r = g = b = l;
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (6 * (2 / 3 - t));
            return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

export function formatSnapFactor(factor, symbol) {
    const fractionStr = formatFraction(factor, 0.001);
    const newSymbol = symbol === 'A' ? '\\theta' : (symbol === 'D' ? '\\delta' : symbol);
    
    if (fractionStr === "0") return `0${newSymbol}`;
    if (fractionStr === "1") return newSymbol;
    if (fractionStr === "-1") return `-${newSymbol}`;

    if (fractionStr.endsWith("/1")) {
        return `${fractionStr.slice(0, -2)}${newSymbol}`;
    }

    if (fractionStr.includes('/')) {
        let sign = '';
        let workStr = fractionStr;
        if (workStr.startsWith('-')) {
            sign = '-';
            workStr = workStr.substring(1);
        }

        const parts = workStr.split('/');
        const num = parts[0];
        const den = parts[1];
        
        if (num === "1") return `${sign}\\frac{1}{${den}}${newSymbol}`;
        return `${sign}\\frac{${num}}{${den}}${newSymbol}`;
    }
    return `${fractionStr}${newSymbol}`;
}

=== write_content_to_file.py ===
--- CONTENT EXCLUDED (listed in exclude_files) ---


