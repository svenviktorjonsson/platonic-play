=== Project Directory Structure ===
Root: C:\Users\viktor.jonsson\OneDrive - CellMax Technologies AB\Documents\Repositories\svenviktorjonsson\platonic-play
Relevant files and folders (excluding specified patterns):

.
├── constants.js
├── index.html
├── package.json
├── readme.md
├── renderer.js
├── script.js
├── style.css
├── utils.js
├── vite.config.js


=== File Contents ===

=== constants.js ===
// constants.js

export const BASE_THEME = {
    background: '#1a1a1a',
    htmlBody: '#1e1e1e',
    grid: [136, 136, 136],
    axis: 'rgba(255, 255, 255, 1)',
    axisTickLabel: [255, 255, 255],
    defaultStroke: 'white',
    vertex: '#ffffff',
    edge: '#BFC5D0',
    face: '#808080',
    frozenReference: 'rgba(240, 240, 130, 0.95)',
    feedbackDefault: [230, 230, 230],
    feedbackSnapped: 'rgba(240, 240, 130, 0.95)',
    geometryInfoText: 'rgba(255, 255, 255, 0.95)',
    geometryInfoTextSnapped: 'rgba(240, 240, 130, 0.95)',
    mouseCoords: 'rgba(255, 255, 255, 0.7)',
    uiIcon: 'white',
    uiIconDefault: '#9CA3AF',
    uiIconSelected: '#F9FAFB',
    uiTextSelected: '#E0F2FE',
    uiTextDefault: '#D1D5DB',
    uiDefault: 'rgba(255, 255, 255, 0.8)',
    selectionGlow: '#4da6ff',
    activeCenterGlow: '#00ffff',
    helperLine: 'rgba(200, 200, 200, 0.6)'
};

export const CONTEXT_MENU_INSET = 5;
export const COORD_SYSTEM_EDGE_FRACTION_LABEL_OFFSET = 25;
export const COORD_SYSTEM_EDGE_FRACTION_FONT_SIZE = 20;
export const INSCRIBED_CIRCLE_ITERATIONS = 20;
export const INSCRIBED_CIRCLE_STEP_FACTOR = 0.1;
// --- GEOMETRY & DRAWING ---
export const UI_FACE_ICON_FILL_COLOR = '#808080';
export const VERTEX_RADIUS = 5;
export const CENTER_POINT_VISUAL_RADIUS = VERTEX_RADIUS * 2;
export const VERTEX_SELECT_RADIUS = 10;
export const LINE_WIDTH = 2;
export const GRID_LINEWIDTH = 1;
export const DASH_PATTERN = [6, 6];
export const DASH_PATTERN_SMALL = [3, 3];
export const SELECTED_INDICATOR_OFFSET = 3;
export const DEGREES_IN_CIRCLE = 360;
export const DEGREES_IN_HALF_CIRCLE = 180;
export const DEGREES_IN_QUADRANT = 90;
export const RADIANS_IN_CIRCLE = 2 * Math.PI;
export const MIN_ALPHA_FOR_DRAWING = 0.01;
export const TRIANGULAR_GRID_Y_STEP_FACTOR = Math.sqrt(3) / 2;
export const POLAR_TO_LINE_TRANSITION_RADIUS_FACTOR = 400;
export const ORIGIN_TICK_ANGLE_RAD = Math.PI / 3;
export const AXIS_MAJOR_TICK_SCALE_FACTOR = 1.5;
export const AXIS_ARROW_ANGLE_RAD = Math.PI / 6;
export const MAJOR_TICK_LINE_WIDTH = 1.5;
export const HELPER_LINE_DASH_PATTERN = [2, 3];
export const REF_LINE_DASH_PATTERN = [1, 3];

// --- INTERACTION ---
export const EDGE_ID_DELIMITER = '_EDGE_';
export const DOUBLE_CLICK_MS = 300;
export const DRAG_THRESHOLD = 3;
export const EDGE_CLICK_THRESHOLD = 7;
export const MIN_SCALE_VALUE = 1e-15;
export const MAX_SCALE_VALUE = 1e13;
export const ZOOM_FACTOR = 1.15;
export const KEYBOARD_ZOOM_FACTOR = 1.15;
export const ANGLE_SNAP_THRESHOLD_RAD = Math.PI / 48;
export const SCALE_SNAP_THRESHOLD = 0.05
export const ON_SEGMENT_STRICT_T_MIN = 1e-5;
export const ON_SEGMENT_STRICT_T_MAX = 1 - 1e-5;
export const MIN_TRANSFORM_ACTION_THRESHOLD = 0.001;
export const BISECTOR_LINE_EXTENSION_FACTOR = 100000;
export const GRID_SNAP_THRESHOLD_FACTOR = 0.8;

// --- AXES & TICKS ---
export const AXIS_LINE_WIDTH = 1.5;
export const AXIS_TICK_SIZE = 4;
export const AXIS_TICK_LABEL_ALPHA = 0.9;
export const AXIS_NAME_FONT_SIZE = 24;
export const AXIS_TICK_FONT_SIZE = 10;
export const AXIS_LABEL_OFFSET = 8;
export const AXIS_LABEL_PADDING = 20;
export const AXIS_ARROW_SIZE = 12;
export const INITIAL_POLAR_REL_RADIUS = 0.309;
export const X_AXIS_LABEL_DISTANCE = 5;
export const X_AXIS_LABEL_ARROW_DIST = 20;
export const Y_AXIS_LABEL_DISTANCE = 10;
export const Y_AXIS_LABEL_ARROW_DIST = 5;
export const POLAR_THETA_LABEL_DISTANCE = 20;
export const POLAR_THETA_LABEL_ARROW_DIST = 12;
export const ANGLE_PRECISION_FACTOR = 1e6;
export const BOUNDARY_ANGLE_PRECISION = 7;
export const LABEL_ID_PRECISION_FACTOR = 1e15;
export const ORIGIN_LABEL_TEXT = '\\phantom{-}0';
export const POLAR_AXIS_RADIUS_BUFFER_FACTOR = 1.1;
export const TICK_LABEL_SIGFIG_THRESH_1 = 80;
export const TICK_LABEL_SIGFIG_THRESH_2 = 40;
export const TICK_LABEL_SIGFIG_THRESH_3 = 20;
export const FINE_TICK_ANGLE_THRESHOLD_DEG = 5;
export const IMAGINARY_UNIT_SYMBOL = 'i';
export const POLAR_RADIUS_SYMBOL = 'r';
export const COMPLEX_REAL_LABEL = '\\mathrm{Re}';
export const COMPLEX_IMAGINARY_LABEL = '\\mathrm{Im}';

// --- DEFAULTS ---
export const DEFAULT_CALIBRATION_VIEW_SCALE = 80.0;
export const DEFAULT_REFERENCE_DISTANCE = 1.0;
export const DEFAULT_REFERENCE_ANGLE_RAD = Math.PI / 2;
export const DEFAULT_POLAR_ANGLE_DIFF = 30;

// --- UI & TOOLBAR ---
export const UI_BUTTON_PADDING = 10;
export const UI_TOOLBAR_WIDTH = 56;
export const UI_SWATCH_SIZE = 30;
export const UI_PADDING = 10;
export const MENU_BUTTON_WIDTH = 36;
export const MENU_BUTTON_HEIGHT = 30;
export const TOOL_BUTTON_HEIGHT = 40;
export const TOOLBAR_SECTION_GAP = 20;
export const UI_ICON_BASE_SIZE = 32;
export const UI_ICON_LINE_WIDTH = 2;
export const UI_ICON_LINE_WIDTH_SMALL = 1.5;
export const UI_ICON_DASH_PATTERN = [2, 4];
export const UI_ICON_VERTEX_RADIUS = 1.5;
export const UI_ICON_LABEL_FONT_SIZE = 10;
export const UI_MENU_ICON_LINE_WIDTH = 3;
export const TRANSFORM_ICON_SIZE = 30;
export const TRANSFORM_ICON_PADDING = 15;
export const TRANSFORM_ICON_Y_OFFSET = 5;
export const UI_TRANSFORM_TOOL_LABEL_FONT_SIZE = 24;
export const UI_TRANSFORM_TOOL_LABEL_TEXT = 'T';
export const UI_SYMMETRY_TOOL_LABEL_FONT_SIZE = 24;
export const UI_SYMMETRY_TOOL_LABEL_TEXT = 'S';
export const DISPLAY_ICON_SIZE = 40;
export const DISPLAY_ICON_PADDING = 15;
export const UI_DISPLAY_ICON_BAR_WIDTH_PADDING = 12;
export const UI_DISPLAY_ICON_Y_OFFSET = 10;
export const UI_DISPLAY_ICON_Y_SPACING = 10;
export const UI_DISPLAY_ICON_KNOB_RADIUS = 3;
export const UI_SWATCH_SELECTED_BORDER_WIDTH = 3;
export const UI_BUTTON_BORDER_WIDTH = 2;
export const UI_BUTTON_ICON_PADDING = 7;
export const UI_GHOST_ICON_SIZE = 30;
export const COLOR_PALETTE_Y_OFFSET = 5;
export const COLOR_WHEEL_FADE_START_RADIUS_FACTOR = 0.75;
export const DEFAULT_RECENT_COLORS = ['#ffffff', '#BFC5D0', '#808080', '#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff']

// --- FEEDBACK LABELS & TEXT ---
export const FEEDBACK_LABEL_FONT_SIZE = 12;
export const FEEDBACK_ARC_RADIUS_SCREEN = 30;
export const FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN = 18;
export const FEEDBACK_LINE_VISUAL_WIDTH = 1;
export const REF_TEXT_SCREEN_PIXEL_THRESHOLD = 1.5;
export const REF_TEXT_KATEX_FONT_SIZE = 11;
export const REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN = 18;
export const REF_TEXT_ANGLE_LABEL_OFFSET_SCREEN = 50;
export const ANGLE_LABEL_RADIUS_SCREEN = 75;
export const REF_CIRCLE_MIN_DISPLAY_RADIUS = 20;
export const REF_CIRCLE_MIN_TICK_SPACING = 8;
export const REF_CIRCLE_THETA_LABEL_OFFSET = 30;
export const REF_ARC_RADIUS_SCREEN = 35;
export const SNAP_ANGLE_LABEL_OFFSET = 60;
export const TRANSFORM_ANGLE_LABEL_OFFSET = 20;
export const TRANSFORM_SCALE_LABEL_OFFSET = 18;
export const SCIENTIFIC_NOTATION_UPPER_BOUND = 1000000;
export const SCIENTIFIC_NOTATION_LOWER_BOUND = 0.000001;
export const ZERO_TOLERANCE = 0.00001;
export const FRACTION_FORMAT_TOLERANCE = 0.015;
export const FRACTION_FORMAT_MAX_DENOMINATOR = 32;
export const FRACTION_FORMAT_MAX_DENOMINATOR_TRANSFORM = 10;
export const COORD_PRECISION_FACTOR = 0.999;
export const MAX_COORD_DECIMAL_PLACES = 16;
export const MAX_ANGLE_DECIMAL_PLACES = 12;
export const MOUSE_COORD_FONT_SIZE = 14;
export const KATEX_MINUS_PHANTOM = '\\hphantom{-}';
export const PI_SYMBOL_KATEX = '\\pi';
export const DELTA_SYMBOL_KATEX = '\\delta';
export const DELTA_EQUALS_KATEX = '\\delta = ';
export const THETA_EQUALS_KATEX = '\\theta = ';
export const SELECTION_GLOW_BLUR_RADIUS = 15;
export const SELECTION_GLOW_ALPHA = 0.8;
export const SELECTION_GLOW_RADIUS_OFFSET = 3;
export const SELECTION_GLOW_LINE_WIDTH = 2;
export const EDGE_SELECTION_GLOW_WIDTH_OFFSET = 4;
export const MAX_VERTICES_FOR_ANGLES = 1;
export const MAX_EDGES_FOR_LABELS = 3;
export const MAX_FACES_FOR_COORDS = 1;

// --- GRID CALCULATIONS ---
export const GRID_TARGET_SPACING = 140;
export const GRID_ALPHA_TRANSITION_START = 0.4;
export const GRID_ALPHA_TRANSITION_END = 0.9;
export const GRID_ALPHA_CLAMP_THRESHOLD = 0.05;
export const GRID_POLAR_CIRCLE_MIN_SPACING = 10;
export const GRID_POLAR_SPOKE_MIN_SPACING = 10;
export const GRID_POLAR_SPOKE_MIN_RADIUS = 50;
export const GRID_POINT_RADIUS = 1.5;
export const ANGULAR_GRID_PREDEFINED_LEVELS = [15, 5, 1];
export const ANGULAR_GRID_TARGET_SPACING = 80;
export const ANGULAR_GRID_FADE_IN_THRESHOLD = 0.01;

// --- SNAPPING PARAMETERS ---
export const GEOMETRY_CALCULATION_EPSILON = 1e-9;
export const FLOATING_POINT_PRECISION_LIMIT = 1e-15;
export const VERTICAL_LINE_COS_THRESHOLD = 0.1;
export const SNAP_STICKINESS_RADIUS_SCREEN = 30;
export const LINE_TO_SNAP_RADIUS_SCREEN = 10;
export const VERTEX_ON_LINE_SNAP_RADIUS_SCREEN = 15;
export const DRAG_SNAP_GEOMETRIC_DISTANCE_FACTORS = [0.5, 1, 1.5, 2, 3, 4, 5];
export const DRAW_SNAP_CANDIDATE_COUNT_PER_SIDE = 2;
export const DRAW_SNAP_DISTANCE_FACTOR_STEP = 0.5;
export const DRAW_SNAP_DISTANCE_FACTOR_LIMIT = 50;
export const GHOST_SNAP_RADIUS_SCREEN = 30;
export const MAX_HISTORY_SIZE = 50;

// --- SNAP GENERATION PARAMETERS ---
export const MAX_FRACTION_DENOMINATOR_FOR_ANGLE_SNAPS = 6;
export const MAX_BASE_ANGLE_MULTIPLIER_FOR_SNAPS = 2;
export const MAX_INITIAL_METER_SNAP_MULTIPLIER = 10;
export const MAX_SNAP_DENOMINATOR = 6;
export const MAX_SNAP_INTEGER = 10;

export const MERGE_RADIUS_SCREEN = 5;

export const NINETY_DEG_ANGLE_SNAP_FRACTIONS = (() => {
    const uniqueFractions = new Set();
    const denominators = [1, 2, 3, 4, 5, 6];
    for (const q of denominators) {
        for (let p = 1; p <= q * 4; p++) {
            uniqueFractions.add(p / q);
        }
    }
    return Array.from(uniqueFractions).sort((a, b) => a - b);
})();


function generateSnapFactors(maxDenominator, maxInteger) {
    const fractionsSet = new Set();
    fractionsSet.add(0);
    for (let q = 1; q <= maxDenominator; q++) {
        for (let p = 1; p <= q * maxInteger; p++) {
            fractionsSet.add(p / q);
        }
    }
    return Array.from(fractionsSet).sort((a, b) => a - b);
}

export const SNAP_FACTORS = generateSnapFactors(MAX_SNAP_DENOMINATOR, MAX_SNAP_INTEGER);

// --- ENUMS & LITERALS ---
export const VERTEX_TYPE_REGULAR = 'regular';
export const TRANSFORMATION_TYPE_ROTATION = ' transformation_rotation';
export const TRANSFORMATION_TYPE_SCALE = ' transformation_scale';
export const TRANSFORMATION_TYPE_DIRECTIONAL_SCALE = 'transformation_directional_scale';
export const COORDS_DISPLAY_MODE_NONE = 'none';
export const COORDS_DISPLAY_MODE_REGULAR = 'regular';
export const COORDS_DISPLAY_MODE_COMPLEX = 'complex';
export const COORDS_DISPLAY_MODE_POLAR = 'polar';
export const GRID_DISPLAY_MODE_NONE = 'none';
export const GRID_DISPLAY_MODE_LINES = 'lines';
export const GRID_DISPLAY_MODE_POINTS = 'points';
export const GRID_DISPLAY_MODE_TRIANGULAR = 'triangular';
export const GRID_DISPLAY_MODE_POLAR = 'polar';
export const ANGLE_DISPLAY_MODE_DEGREES = 'degrees';
export const ANGLE_DISPLAY_MODE_RADIANS = 'radians';
export const ANGLE_DISPLAY_MODE_NONE = 'none';
export const DISTANCE_DISPLAY_MODE_ON = 'on';
export const DISTANCE_DISPLAY_MODE_NONE = 'none';
export const KEY_SPACE = ' ';
export const KEY_ESCAPE = 'Escape';
export const KEY_DELETE = 'Delete';
export const KEY_BACKSPACE = 'Backspace';
export const KEY_REPEAT = 'r';
export const KEY_ZOOM_IN = '=';
export const KEY_ZOOM_IN_PLUS = '+';
export const KEY_ZOOM_OUT = '-';
export const KEY_COPY = 'c';
export const KEY_PASTE = 'v';
export const KEY_CUT = 'x';
export const KEY_UNDO = 'z';
export const KEY_REDO = 'y';
export const KEY_SELECT_ALL = 'a';
export const COLOR_TARGET_VERTEX = 'vertex';
export const COLOR_TARGET_EDGE = 'edge';
export const COLOR_TARGET_FACE = 'face';


=== index.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Platonic Play</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <link rel="stylesheet" href="./style.css">
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <div class="canvas-wrapper-relative">
                <canvas id="drawingCanvas"></canvas>
                <div id="html-overlay"></div>
            </div>
        </div>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script type="module" src="./script.js"></script>
    
    <div id="context-menu" class="context-menu"></div>
</body>
</html>

=== package.json ===
{
  "name": "platonic-play",
  "version": "1.0.0",
  "description": "",
  "main": "script.js",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "vite": "^7.0.6"
  },
  "dependencies": {
    "colormap-selector": "github:svenviktorjonsson/colormap-selector"
  }
}


=== readme.md ===
readme




=== renderer.js ===
import * as U from './utils.js';
import * as C from './constants.js';

let colorWheelIcon = null
const patternCache = new Map();

export function calculateGridIntervals(viewTransformScale) {
    const effectiveDataInterval = C.GRID_TARGET_SPACING / viewTransformScale;

    let lowerPowerOf10 = Math.pow(10, Math.floor(Math.log10(effectiveDataInterval)));
    let higherPowerOf10 = Math.pow(10, Math.ceil(Math.log10(effectiveDataInterval)));

    if (Math.abs(lowerPowerOf10 - higherPowerOf10) < C.GEOMETRY_CALCULATION_EPSILON || lowerPowerOf10 === 0) {
        higherPowerOf10 = lowerPowerOf10 === 0 ? 0.001 : lowerPowerOf10 * 10;
        if (lowerPowerOf10 === 0) lowerPowerOf10 = 0.0001;
    }

    const grid1Interval = lowerPowerOf10;
    const grid2Interval = higherPowerOf10;

    let logInterpFactor = 0;
    if (grid2Interval > grid1Interval && grid1Interval > 0) {
        logInterpFactor = (Math.log10(effectiveDataInterval) - Math.log10(grid1Interval)) / (Math.log10(grid2Interval) - Math.log10(grid1Interval));
    }

    let interpValue = (logInterpFactor - C.GRID_ALPHA_TRANSITION_START) / (C.GRID_ALPHA_TRANSITION_END - C.GRID_ALPHA_TRANSITION_START);
    interpValue = Math.max(0, Math.min(1, interpValue));
    interpValue = interpValue * interpValue * (3 - 2 * interpValue);

    let alpha1 = 1 - interpValue;
    let alpha2 = interpValue;

    if (alpha1 < C.GRID_ALPHA_CLAMP_THRESHOLD) alpha1 = 0; else if (alpha1 > 1 - C.GRID_ALPHA_CLAMP_THRESHOLD) alpha1 = 1;
    if (alpha2 < C.GRID_ALPHA_CLAMP_THRESHOLD) alpha2 = 0; else if (alpha2 > 1 - C.GRID_ALPHA_CLAMP_THRESHOLD) alpha2 = 1;

    const totalAlpha = alpha1 + alpha2;
    if (totalAlpha > 0 && totalAlpha !== 2) {
        alpha1 /= totalAlpha;
        alpha2 /= totalAlpha;
    }

    return { grid1Interval, grid2Interval, alpha1, alpha2 };
}

export function getDynamicAngularIntervals(viewTransform, canvasWidth, canvasHeight, dataToScreen) {
    const originScreen = dataToScreen({ x: 0, y: 0 });
    const screenCenter = { x: canvasWidth / 2, y: canvasHeight / 2 };

    const radiusToCenterScreen = U.distance(originScreen, screenCenter);
    let targetAngleDeg;

    if (radiusToCenterScreen < 1e-6) {
        targetAngleDeg = C.ANGULAR_GRID_TARGET_SPACING;
    } else {
        const targetAngleRad = C.ANGULAR_GRID_TARGET_SPACING / radiusToCenterScreen;
        targetAngleDeg = targetAngleRad * (180 / Math.PI);
    }

    if (isNaN(targetAngleDeg) || targetAngleDeg <= C.GEOMETRY_CALCULATION_EPSILON) {
        targetAngleDeg = C.GEOMETRY_CALCULATION_EPSILON;
    }

    const results = [];
    let allLevels = [...C.ANGULAR_GRID_PREDEFINED_LEVELS];

    let lastGeneratedLevel = allLevels[allLevels.length - 1];
    
    const absoluteMinimum = 1e-15;
    
    while (lastGeneratedLevel > absoluteMinimum) {
        lastGeneratedLevel /= 10;
        if (!allLevels.includes(lastGeneratedLevel)) {
            allLevels.push(lastGeneratedLevel);
        }
    }

    allLevels.sort((a, b) => b - a);

    let primaryLevel = null;
    let secondaryLevel = null;

    for (let i = allLevels.length - 1; i >= 0; i--) {
        const currentLevel = allLevels[i];

        if (targetAngleDeg < currentLevel) {
            primaryLevel = { angle: currentLevel, alpha: 1.0 };
            if (i + 1 < allLevels.length) {
                secondaryLevel = { angle: allLevels[i + 1], alpha: 0 };
            }
            break;
        }
    }

    if (!primaryLevel && allLevels.length > 0) {
        primaryLevel = { angle: allLevels[0], alpha: 1.0 };
        if (allLevels.length > 1) {
            secondaryLevel = { angle: allLevels[1], alpha: 0 };
        }
    } else if (!primaryLevel && allLevels.length === 0) {
        primaryLevel = { angle: C.ANGULAR_GRID_PREDEFINED_LEVELS[0], alpha: 1.0 };
    }

    results.push(primaryLevel);

    if (secondaryLevel) {
        const logPrimary = Math.log10(primaryLevel.angle);
        const logSecondary = Math.log10(secondaryLevel.angle);
        const logTarget = Math.log10(targetAngleDeg);

        let interpValue;
        if (logSecondary === logPrimary) {
            interpValue = 0;
        } else {
            interpValue = (logTarget - logPrimary) / (logSecondary - logPrimary);
        }

        interpValue = Math.max(0, Math.min(1, interpValue));

        const fadeInAlpha = interpValue * interpValue * (3 - 2 * interpValue);

        if (fadeInAlpha > C.ANGULAR_GRID_FADE_IN_THRESHOLD) {
            secondaryLevel.alpha = fadeInAlpha;
            results.push(secondaryLevel);
        }
    }

    const uniqueResults = [];
    const seenAngles = new Set();
    results.sort((a, b) => b.angle - a.angle);

    for (const res of results) {
        if (!seenAngles.has(res.angle)) {
            uniqueResults.push(res);
            seenAngles.add(res.angle);
        }
    }

    if (uniqueResults.length === 0) {
        uniqueResults.push({ angle: C.ANGULAR_GRID_PREDEFINED_LEVELS[0], alpha: 1.0 });
    }

    return uniqueResults;
}

export function drawFaceGlows(ctx, { allFaces, hoveredFaceId, selectedFaceIds, colors, isDragConfirmed, dragPreviewVertices }, dataToScreen, findVertexById, getFaceId) {
    if (!hoveredFaceId && selectedFaceIds.length === 0) return;

    const getLiveVertex = (vertexId) => {
        if (isDragConfirmed && dragPreviewVertices) {
            const previewVertex = dragPreviewVertices.find(p => p && p.id === vertexId);
            if (previewVertex) {
                return previewVertex;
            }
        }
        return findVertexById(vertexId);
    };

    allFaces.forEach(face => {
        const faceId = getFaceId(face);
        const isSelected = selectedFaceIds.includes(faceId);
        const isHovered = faceId === hoveredFaceId;

        if (isSelected || isHovered) {
            const vertices = face.vertexIds.map(id => getLiveVertex(id)).filter(p => p && p.type === 'regular');
            if (vertices.length < 3) return;

            const screenVertices = vertices.map(v => dataToScreen(v));

            ctx.save();
            ctx.fillStyle = colors.selectionGlow;
            ctx.globalAlpha = 0.25;
            
            ctx.beginPath();
            screenVertices.forEach((vertex, index) => {
                if (index === 0) {
                    ctx.moveTo(vertex.x, vertex.y);
                } else {
                    ctx.lineTo(vertex.x, vertex.y);
                }
            });
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
    });
}

function calculateVisibleAngleRange(originScreen, screenRadius, canvasWidth, canvasHeight) {
    // If origin is inside the viewport, we can see the full circle
    if (originScreen.x >= 0 && originScreen.x <= canvasWidth && 
        originScreen.y >= 0 && originScreen.y <= canvasHeight) {
        return { ranges: [[0, 360]], isFullCircle: true };
    }

    const rect = {
        left: 0,
        right: canvasWidth,
        top: 0,
        bottom: canvasHeight
    };

    // If circle doesn't intersect the viewport at all
    if (originScreen.x + screenRadius < rect.left || 
        originScreen.x - screenRadius > rect.right ||
        originScreen.y + screenRadius < rect.top || 
        originScreen.y - screenRadius > rect.bottom) {
        return null;
    }

    const corners = [
        { x: rect.left, y: rect.top },
        { x: rect.right, y: rect.top },
        { x: rect.right, y: rect.bottom },
        { x: rect.left, y: rect.bottom }
    ];

    // If all corners are inside the circle, we see the full circle
    const allCornersInside = corners.every(corner => {
        const distSq = (corner.x - originScreen.x) ** 2 + (corner.y - originScreen.y) ** 2;
        return distSq <= screenRadius ** 2;
    });

    if (allCornersInside) {
        return { ranges: [[0, 360]], isFullCircle: true };
    }

    // Find all intersection points and angles
    const intersectionAngles = [];

    // Check corners that are outside the circle
    corners.forEach(corner => {
        const distSq = (corner.x - originScreen.x) ** 2 + (corner.y - originScreen.y) ** 2;
        if (distSq > screenRadius ** 2) {
            const dx = corner.x - originScreen.x;
            const dy = corner.y - originScreen.y;
            const angle = Math.atan2(-dy, dx);
            const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle;
            intersectionAngles.push(normalizedAngle * 180 / Math.PI);
        }
    });

    // Check intersections with rectangle edges
    const edges = [
        { x1: rect.left, y1: rect.top, x2: rect.right, y2: rect.top },
        { x1: rect.right, y1: rect.top, x2: rect.right, y2: rect.bottom },
        { x1: rect.right, y1: rect.bottom, x2: rect.left, y2: rect.bottom },
        { x1: rect.left, y1: rect.bottom, x2: rect.left, y2: rect.top }
    ];

    edges.forEach(edge => {
        const intersections = U.getLineCircleIntersection(
            {p1: {x: edge.x1, y: edge.y1}, p2: {x: edge.x2, y: edge.y2}},
            {center: {x: originScreen.x, y: originScreen.y}, radius: screenRadius}
        );
        
        intersections.forEach(vertex => {
            const dx = vertex.x - originScreen.x;
            const dy = vertex.y - originScreen.y;
            const angle = Math.atan2(-dy, dx);
            const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle;
            intersectionAngles.push(normalizedAngle * 180 / Math.PI);
        });
    });

    if (intersectionAngles.length === 0) {
        return { ranges: [[0, 360]], isFullCircle: true };
    }

    // Remove duplicates and sort
    const uniqueAngles = [...new Set(intersectionAngles.map(a => Math.round(a * 1e6) / 1e6))].sort((a, b) => a - b);

    if (uniqueAngles.length < 2) {
        return { ranges: [[0, 360]], isFullCircle: true };
    }

    // Find the largest gap between consecutive angles (this is the invisible range)
    let maxGap = 0;
    let maxGapStartAngle = 0;
    let maxGapEndAngle = 0;

    for (let i = 0; i < uniqueAngles.length; i++) {
        const currentAngle = uniqueAngles[i];
        const nextAngle = uniqueAngles[(i + 1) % uniqueAngles.length];
        
        let gap;
        if (i === uniqueAngles.length - 1) {
            // Wrap around gap
            gap = (360 - currentAngle) + nextAngle;
        } else {
            gap = nextAngle - currentAngle;
        }

        if (gap > maxGap) {
            maxGap = gap;
            maxGapStartAngle = currentAngle;
            maxGapEndAngle = nextAngle;
        }
    }

    // The visible range is everything EXCEPT the largest gap
    // So we need to return the complement of the gap
    if (maxGapEndAngle > maxGapStartAngle) {
        // Simple case: gap doesn't wrap around
        return {
            ranges: [[maxGapEndAngle, maxGapStartAngle + 360]],
            isFullCircle: false
        };
    } else {
        // Gap wraps around 0/360
        return {
            ranges: [[maxGapEndAngle, maxGapStartAngle]],
            isFullCircle: false
        };
    }
}

export function clearCanvas(ctx, { canvas, dpr, colors }) {
    const actualCanvasWidth = canvas.width / dpr;
    const actualCanvasHeight = canvas.height / dpr;
    ctx.resetTransform();
    ctx.scale(dpr, dpr);
    ctx.fillStyle = colors.background;
    ctx.fillRect(0, 0, actualCanvasWidth, actualCanvasHeight);
}

export function drawFaces(ctx, { allFaces, facesVisible, isDragConfirmed, dragPreviewVertices, transformIndicatorData, initialDragVertexStates, colors, initialCoordSystemStates }, dataToScreen, findVertexById) {
    if (!facesVisible || !allFaces || !colors || !ctx) return;

    const getLiveVertex = (vertexId) => {
        if (isDragConfirmed && dragPreviewVertices) {
            const previewVertex = dragPreviewVertices.find(p => p && p.id === vertexId);
            if (previewVertex) return previewVertex;
        }
        return findVertexById(vertexId);
    };

    allFaces.forEach((face) => {
        if (!face || !face.vertexIds || face.vertexIds.length < 3) return;
        
        const liveVertices = face.vertexIds.map(id => getLiveVertex(id)).filter(p => p && p.type === 'regular');
        if (liveVertices.length < 3) return;

        const screenVertices = liveVertices.map(v => dataToScreen(v));

        let faceToDraw = face;
        if (isDragConfirmed && face.localCoordSystem && face.vertexIds.some(vid => dragPreviewVertices.some(pv => pv.id === vid))) {
            const initialSystem = initialCoordSystemStates.get(face.id);
            const previewSystem = calculatePreviewCoordSystem(face, { initialSystem, dragPreviewVertices, initialDragVertexStates, findVertexById, transformIndicatorData });
            faceToDraw = { ...face, localCoordSystem: previewSystem };
        }
        
        if (screenVertices.every(v => v && typeof v.x === 'number' && typeof v.y === 'number')) {
            drawFace(ctx, screenVertices, faceToDraw, colors, dataToScreen, findVertexById);
        }
    });
}

function calculatePreviewCoordSystem(face, { initialSystem, dragPreviewVertices, initialDragVertexStates, findVertexById, transformIndicatorData }) {
    if (!initialSystem) return face.localCoordSystem;

    const liveVertices = face.vertexIds
        .map(id => dragPreviewVertices.find(p => p && p.id === id) || findVertexById(id))
        .filter(p => p && p.type === 'regular');

    if (!initialSystem.isCustom) {
        const incircle = U.calculateIncenter(liveVertices);
        if (incircle) {
            const rotation = transformIndicatorData ? transformIndicatorData.rotation : 0;
            const scale = transformIndicatorData ? transformIndicatorData.scale : 1;
            return {
                ...initialSystem,
                origin: incircle.center,
                scale: initialSystem.scale * scale,
                angle: U.normalizeAngle(initialSystem.angle + rotation)
            };
        }
        return initialSystem;
    }

    const previewSystem = JSON.parse(JSON.stringify(initialSystem));

    if (transformIndicatorData) {
        const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
        const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };

        previewSystem.origin = U.applyTransformToVertex(initialSystem.origin, center, rotation, scale, directionalScale, startVector);

        if (!directionalScale) {
            previewSystem.angle = U.normalizeAngle(initialSystem.angle + rotation);
            previewSystem.scale = initialSystem.scale * scale;
        }
    }

    const draggedVertexIds = new Set(initialDragVertexStates.map(v => v.id));
    let newOrigin = { ...previewSystem.origin };
    let newAngle = previewSystem.angle;
    let newScale = previewSystem.scale;

    if (previewSystem.attachedToVertex) {
        if (draggedVertexIds.has(previewSystem.attachedToVertex)) {
            const draggedVertex = dragPreviewVertices.find(p => p.id === previewSystem.attachedToVertex);
            if (draggedVertex) newOrigin = { ...draggedVertex };
        }
    } else if (previewSystem.attachedToEdge) {
        if (draggedVertexIds.has(previewSystem.attachedToEdge.v1) || draggedVertexIds.has(previewSystem.attachedToEdge.v2)) {
            const v1 = dragPreviewVertices.find(p => p.id === previewSystem.attachedToEdge.v1) || findVertexById(previewSystem.attachedToEdge.v1);
            const v2 = dragPreviewVertices.find(p => p.id === previewSystem.attachedToEdge.v2) || findVertexById(previewSystem.attachedToEdge.v2);
            if (v1 && v2) {
                newOrigin = {
                    x: v1.x + previewSystem.attachedToEdge.t * (v2.x - v1.x),
                    y: v1.y + previewSystem.attachedToEdge.t * (v2.y - v1.y)
                };
            }
        }
    }

    if (previewSystem.rotationAlignedToEdge) {
        if (draggedVertexIds.has(previewSystem.rotationAlignedToEdge.v1) || draggedVertexIds.has(previewSystem.rotationAlignedToEdge.v2)) {
            const v1 = dragPreviewVertices.find(p => p.id === previewSystem.rotationAlignedToEdge.v1) || findVertexById(previewSystem.rotationAlignedToEdge.v1);
            const v2 = dragPreviewVertices.find(p => p.id === previewSystem.rotationAlignedToEdge.v2) || findVertexById(previewSystem.rotationAlignedToEdge.v2);
            if (v1 && v2) {
                const currentEdgeAngle = Math.atan2(v2.y - v1.y, v2.x - v1.x);
                const { originalAngle, originalSystemAngle } = previewSystem.rotationAlignedToEdge;
                const angleOffset = originalSystemAngle - originalAngle;
                newAngle = U.normalizeAngle(currentEdgeAngle + angleOffset);
            }
        }
    }

    if (previewSystem.scaleAttachedToEdge) {
        if (draggedVertexIds.has(previewSystem.scaleAttachedToEdge.v1) || draggedVertexIds.has(previewSystem.scaleAttachedToEdge.v2)) {
            const v1 = dragPreviewVertices.find(p => p.id === previewSystem.scaleAttachedToEdge.v1) || findVertexById(previewSystem.scaleAttachedToEdge.v1);
            const v2 = dragPreviewVertices.find(p => p.id === previewSystem.scaleAttachedToEdge.v2) || findVertexById(previewSystem.scaleAttachedToEdge.v2);
            if (v1 && v2) {
                newScale = U.distance(v1, v2) * previewSystem.scaleAttachedToEdge.scaleRatio;
            }
        }
    }

    if (liveVertices.length >= 3) {
        previewSystem.origin = U.clampPointToPolygon(newOrigin, liveVertices);
    } else {
        previewSystem.origin = newOrigin;
    }
    previewSystem.angle = newAngle;
    previewSystem.scale = Math.max(0.01, newScale);

    return previewSystem;
}

export function drawCopyPreviews(ctx, { copyCount, isDragConfirmed, initialDragVertexStates, dragPreviewVertices, transformIndicatorData, allEdges, allFaces, findVertexById, findNeighbors, colors }, dataToScreen) {
    const verticesToCopy = initialDragVertexStates.filter(p => p.type === 'regular');
    const vertexIdsToCopy = new Set(verticesToCopy.map(p => p.id));
    const incidentEdges = allEdges.filter(edge =>
        vertexIdsToCopy.has(edge.id1) && vertexIdsToCopy.has(edge.id2)
    );
    
    const affectedFaces = allFaces.filter(face => 
        face.vertexIds && face.vertexIds.some(vId => vertexIdsToCopy.has(vId))
    );

    const isRigidBodyMotion = affectedFaces.every(face => 
        face.vertexIds.every(vId => vertexIdsToCopy.has(vId))
    );

    ctx.save();
    ctx.globalAlpha = 1.0;

    for (let i = 0; i < copyCount; i++) {
        let previewVerticesForThisCopy;

        if (i === 0) {
            previewVerticesForThisCopy = initialDragVertexStates.filter(p => p.type === 'regular');
        } else if (transformIndicatorData) {
            const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
            const effectiveRotation = rotation * i;
            const effectiveScale = Math.pow(scale, i);
            const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
            previewVerticesForThisCopy = verticesToCopy.map(p => {
                const newPos = U.applyTransformToVertex(p, center, effectiveRotation, effectiveScale, directionalScale, startVector);
                return { ...p, id: `preview_${p.id}_${i}`, x: newPos.x, y: newPos.y };
            });
        } else {
            const deltaX = dragPreviewVertices[0].x - initialDragVertexStates[0].x;
            const deltaY = dragPreviewVertices[0].y - initialDragVertexStates[0].y;
            const effectiveDeltaX = deltaX * i;
            const effectiveDeltaY = deltaY * i;
            previewVerticesForThisCopy = verticesToCopy.map(p => ({
                ...p, id: `preview_${p.id}_${i}`, x: p.x + effectiveDeltaX, y: p.y + effectiveDeltaY
            }));
        }

        const newIdMapForThisCopy = new Map();
        previewVerticesForThisCopy.forEach((previewVertex, index) => {
            const originalVertex = verticesToCopy[index];
            newIdMapForThisCopy.set(originalVertex.id, previewVertex);
        });

        affectedFaces.forEach(originalFace => {
            const faceVerticesForThisCopy = originalFace.vertexIds.map(originalVertexId => {
                if (vertexIdsToCopy.has(originalVertexId)) {
                    return newIdMapForThisCopy.get(originalVertexId);
                }
                const staticVertex = findVertexById(originalVertexId);
                return (staticVertex && staticVertex.type === 'regular') ? staticVertex : null;
            }).filter(Boolean);

            if (faceVerticesForThisCopy.length >= 3) {
                const screenVertices = faceVerticesForThisCopy.map(v => dataToScreen(v));
                if (screenVertices.every(v => v && typeof v.x === 'number' && typeof v.y === 'number')) {
                    let faceToDraw = originalFace;
                    if (originalFace.localCoordSystem) {
                        const previewSystem = JSON.parse(JSON.stringify(originalFace.localCoordSystem));
                        if (previewSystem.isCustom) {
                            if (transformIndicatorData && i > 0) {
                                const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
                                const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
                                previewSystem.origin = U.applyTransformToVertex(previewSystem.origin, center, rotation * i, Math.pow(scale, i), directionalScale, startVector);
                                previewSystem.angle = U.normalizeAngle(previewSystem.angle + (rotation * i));
                                if(!directionalScale) previewSystem.scale *= Math.pow(scale, i);
                            } else if (i > 0) {
                                const deltaX = dragPreviewVertices[0].x - initialDragVertexStates[0].x;
                                const deltaY = dragPreviewVertices[0].y - initialDragVertexStates[0].y;
                                previewSystem.origin.x += deltaX * i;
                                previewSystem.origin.y += deltaY * i;
                            }
                        } else {
                            const incircle = U.calculateIncenter(faceVerticesForThisCopy);
                            if(incircle) {
                                previewSystem.origin = incircle.center;
                                previewSystem.scale = incircle.radius;
                            }
                        }
                        faceToDraw = {...originalFace, localCoordSystem: previewSystem};
                    }
                    drawFace(ctx, screenVertices, faceToDraw, colors, dataToScreen, findVertexById);
                }
            }
        });

        if (isRigidBodyMotion) {
            ctx.setLineDash([]);
            incidentEdges.forEach(originalEdge => {
                const p1 = newIdMapForThisCopy.get(originalEdge.id1);
                const p2 = newIdMapForThisCopy.get(originalEdge.id2);
                if (p1 && p2) {
                    const p1Screen = dataToScreen(p1);
                    const p2Screen = dataToScreen(p2);
                    ctx.beginPath();
                    ctx.moveTo(p1Screen.x, p1Screen.y);
                    ctx.lineTo(p2Screen.x, p2Screen.y);
                    ctx.strokeStyle = originalEdge.color || colors.defaultStroke;
                    ctx.lineWidth = C.LINE_WIDTH;
                    ctx.stroke();
                }
            });
        }

        ctx.setLineDash(isRigidBodyMotion ? [] : C.DASH_PATTERN);
        verticesToCopy.forEach(originalVertex => {
            const correspondingPreviewVertex = newIdMapForThisCopy.get(originalVertex.id);
            if (!correspondingPreviewVertex) return;
            
            const neighbors = findNeighbors(originalVertex.id);
            neighbors.forEach(neighborId => {
                if (!vertexIdsToCopy.has(neighborId)) {
                    const neighborVertex = findVertexById(neighborId);
                    if (neighborVertex && neighborVertex.type === 'regular') {
                        const previewScreen = dataToScreen(correspondingPreviewVertex);
                        const neighborScreen = dataToScreen(neighborVertex);
                        ctx.beginPath();
                        ctx.moveTo(previewScreen.x, previewScreen.y);
                        ctx.lineTo(neighborScreen.x, neighborScreen.y);
                        ctx.strokeStyle = colors.defaultStroke;
                        ctx.lineWidth = C.LINE_WIDTH;
                        ctx.stroke();
                    }
                }
            });
        });

        previewVerticesForThisCopy.forEach(vertex => {
            drawVertex(ctx, vertex, { 
                selectedVertexIds: [], 
                selectedCenterIds: [], 
                activeCenterId: null, 
                currentColor: vertex.color, 
                colors, 
                verticesVisible: true 
            }, dataToScreen, () => {});
        });
    }

    ctx.restore();
}

export function drawDrawingPreview(ctx, { startVertex, snappedData, isShiftPressed, currentColor, nextCreationColor, nextEdgeColor, colors, edgeColormapInfo }, dataToScreen) {
    const startScreen = dataToScreen(startVertex);
    const targetScreen = dataToScreen(snappedData);

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(startScreen.x, startScreen.y);
    ctx.lineTo(targetScreen.x, targetScreen.y);
    ctx.setLineDash(C.DASH_PATTERN);
    
    if (edgeColormapInfo && edgeColormapInfo.colormapItem) {
        const gradient = ctx.createLinearGradient(startScreen.x, startScreen.y, targetScreen.x, targetScreen.y);
        const startColor = U.sampleColormap(edgeColormapInfo.colormapItem, edgeColormapInfo.startT);
        const endColor = U.sampleColormap(edgeColormapInfo.colormapItem, edgeColormapInfo.endT);
        gradient.addColorStop(0, startColor);
        gradient.addColorStop(1, endColor);
        ctx.strokeStyle = gradient;
    } else if (snappedData.snapped) {
        ctx.strokeStyle = colors.feedbackSnapped;
    } else if (isShiftPressed) {
        ctx.strokeStyle = colors.feedbackSnapped;
    } else {
        ctx.strokeStyle = nextEdgeColor;
    }
    
    ctx.lineWidth = C.LINE_WIDTH;
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.beginPath();
    ctx.arc(targetScreen.x, targetScreen.y, C.VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
    
    if (snappedData.snapped) {
        ctx.fillStyle = colors.feedbackSnapped;
    } else {
        ctx.fillStyle = nextCreationColor;
    }
    
    ctx.fill();
    ctx.restore();
}

export function drawMergePreviews(ctx, { allVertices, dragPreviewVertices, viewTransform, colors, transformIndicatorData, copyCount, initialDragVertexStates }, dataToScreen) {
    if (!dragPreviewVertices || dragPreviewVertices.length === 0 || !initialDragVertexStates || initialDragVertexStates.length === 0) {
        return;
    }

    const indicatorMergeThreshold = C.GEOMETRY_CALCULATION_EPSILON;
    const drawnMergeIndicators = new Set();
    const draggedIds = new Set(initialDragVertexStates.map(p => p.id));
    const verticesToTransform = initialDragVertexStates.filter(p => p.type === 'regular');

    const staticVertices = allVertices.filter(p => p.type === 'regular' && !draggedIds.has(p.id));

    const multipliers = copyCount === 1 ? [1] : Array.from({ length: copyCount }, (_, k) => k);

    const copies = [];
    if (verticesToTransform.length > 0) {
        if (transformIndicatorData) {
            const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
            const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
            multipliers.forEach(k => {
                const effectiveRotation = rotation * k;
                const effectiveScale = Math.pow(scale, k);
                const transformedVertices = verticesToTransform.map(p_orig => {
                    const newPos = U.applyTransformToVertex(p_orig, center, effectiveRotation, effectiveScale, directionalScale, startVector);
                    return { ...p_orig, ...newPos };
                });
                copies.push(transformedVertices);
            });
        } else {
            const deltaX = dragPreviewVertices[0].x - initialDragVertexStates[0].x;
            const deltaY = dragPreviewVertices[0].y - initialDragVertexStates[0].y;
            multipliers.forEach(k => {
                const effectiveDeltaX = deltaX * k;
                const effectiveDeltaY = deltaY * k;
                const transformedVertices = verticesToTransform.map(p_orig => ({
                    ...p_orig,
                    x: p_orig.x + effectiveDeltaX,
                    y: p_orig.y + effectiveDeltaY,
                }));
                copies.push(transformedVertices);
            });
        }
    }

    const drawIndicator = (p1, p2) => {
        if (p1.id === p2.id) return;
        if (U.distance(p1, p2) < indicatorMergeThreshold) {
            const mergePos = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            const screenPos = dataToScreen(mergePos);
            const key = `${Math.round(screenPos.x)},${Math.round(screenPos.y)}`;
            if (!drawnMergeIndicators.has(key)) {
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, C.VERTEX_RADIUS, 0, 2 * Math.PI);
                ctx.fill();
                drawnMergeIndicators.add(key);
            }
        }
    };

    ctx.fillStyle = colors.feedbackSnapped;

    for (const copy of copies) {
        for (const p_copy of copy) {
            for (const p_static of staticVertices) {
                drawIndicator(p_copy, p_static);
            }
        }
    }

    for (let i = 0; i < copies.length; i++) {
        for (let j = i + 1; j < copies.length; j++) {
            for (const pA of copies[i]) {
                for (const pB of copies[j]) {
                    drawIndicator(pA, pB);
                }
            }
        }
    }
}

function generateOptimizedAngleSequence(angleStep, minAngle, maxAngle) {
    const angles = [];
    
    const isWraparound = maxAngle > 360;
    
    if (isWraparound) {
        const actualMaxAngle = maxAngle - 360;
        
        const startAngle1 = Math.floor(minAngle / angleStep) * angleStep;
        for (let angle = startAngle1; angle < 360; angle += angleStep) {
            if (angle >= minAngle) {
                angles.push(angle);
            }
        }
        
        for (let angle = 0; angle <= actualMaxAngle + angleStep; angle += angleStep) {
            if (angle <= actualMaxAngle) {
                angles.push(angle);
            }
        }
    } else {
        const startAngle = Math.floor(minAngle / angleStep) * angleStep;
        for (let angle = startAngle; angle <= maxAngle + angleStep; angle += angleStep) {
            if (angle >= minAngle && angle <= maxAngle && angle >= 0 && angle < 360) {
                angles.push(angle);
            }
        }
    }
    
    return [...new Set(angles)].sort((a, b) => a - b);
}

function isTickVisible(tickEnd, canvasWidth, canvasHeight) {
    return tickEnd.x >= -C.AXIS_LABEL_PADDING && 
           tickEnd.x <= canvasWidth + C.AXIS_LABEL_PADDING && 
           tickEnd.y >= -C.AXIS_LABEL_PADDING && 
           tickEnd.y <= canvasHeight + C.AXIS_LABEL_PADDING;
}

export function drawPolarReferenceCircle(ctx, htmlOverlay, updateHtmlLabel, radius, alpha, { canvas, dpr, viewTransform, angleDisplayMode, colors }, dataToScreen, lastAngularGridState) {
    if (typeof dataToScreen !== 'function' || typeof updateHtmlLabel !== 'function') {
        return;
    }

    const originScreen = dataToScreen({ x: 0, y: 0 });
    const canvasWidthCSS = canvas.width / dpr;
    const canvasHeightCSS = canvas.height / dpr;
    const screenCenter = { x: canvasWidthCSS / 2, y: canvasHeightCSS / 2 };
    const baseRadius = Math.min(canvasWidthCSS, canvasHeightCSS) / 4;
    const panDistance = U.distance(originScreen, screenCenter);
    const screenRadius = baseRadius + panDistance;

    if (screenRadius < C.REF_CIRCLE_MIN_DISPLAY_RADIUS || !isCircleInView(originScreen.x, originScreen.y, screenRadius, canvasWidthCSS, canvasHeightCSS)) {
        return;
    }

    ctx.save();
    ctx.strokeStyle = `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;

    const transitionRadius = Math.min(canvasWidthCSS, canvasHeightCSS) * 400;
    const isLineMode = screenRadius > transitionRadius;

    let visibleAngleRange = null;

    if (isLineMode) {
        const screenRect = { x: 0, y: 0, w: canvasWidthCSS, h: canvasHeightCSS };
        const circle = { x: originScreen.x, y: originScreen.y, r: screenRadius };
        const intersections = getCircleRectIntersections(circle, screenRect);

        if (intersections.length >= 2) {
            let p1 = intersections[0], p2 = intersections[1];
            let maxDistSq = 0;
            for (let i = 0; i < intersections.length; i++) {
                for (let j = i + 1; j < intersections.length; j++) {
                    const dSq = (intersections[i].x - intersections[j].x)**2 + (intersections[i].y - intersections[j].y)**2;
                    if (dSq > maxDistSq) {
                        maxDistSq = dSq;
                        p1 = intersections[i];
                        p2 = intersections[j];
                    }
                }
            }
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            const angle1 = (Math.atan2(originScreen.y - p1.y, p1.x - originScreen.x) * 180 / Math.PI + 360) % 360;
            const angle2 = (Math.atan2(originScreen.y - p2.y, p2.x - originScreen.x) * 180 / Math.PI + 360) % 360;
            visibleAngleRange = { minAngle: Math.min(angle1, angle2), maxAngle: Math.max(angle1, angle2), isFullCircle: false };
            if (Math.abs(angle1 - angle2) > 180) {
                 visibleAngleRange = { minAngle: Math.max(angle1, angle2), maxAngle: Math.min(angle1, angle2) + 360, isFullCircle: false };
            }
        }
    } else {
        ctx.beginPath();
        ctx.arc(originScreen.x, originScreen.y, screenRadius, 0, 2 * Math.PI);
        ctx.stroke();
        visibleAngleRange = calculateVisibleAngleRange(originScreen, screenRadius, canvasWidthCSS, canvasHeightCSS);
    }
    
    ctx.restore();
    
    if (!visibleAngleRange) return;

    const dataRadius = screenRadius / (viewTransform.scale / dpr);
    const drawnAnglesSimple = new Set();
    const drawnAnglesComplex = new Map();

    lastAngularGridState.forEach(level => {
        const tickAlpha = level.alpha;
        if (tickAlpha < 0.01) return;

        const screenSeparation = screenRadius * (level.angle * Math.PI / 180);
        
        if (screenSeparation < C.REF_CIRCLE_MIN_TICK_SPACING * 0.5) return;

        const finalColor = `rgba(${colors.feedbackDefault.join(',')}, ${tickAlpha * 0.95})`;

        let anglesToProcess;
        if (visibleAngleRange.isFullCircle) {
            anglesToProcess = [];
            for (let deg = 0; deg < 360; deg += level.angle) {
                anglesToProcess.push(deg);
            }
        } else {
            anglesToProcess = [];
            if (visibleAngleRange.ranges && Array.isArray(visibleAngleRange.ranges)) {
                visibleAngleRange.ranges.forEach(range => {
                    const [minAngle, maxAngle] = range;
                    const rangeAngles = generateOptimizedAngleSequence(level.angle, minAngle, maxAngle);
                    anglesToProcess.push(...rangeAngles);
                });
            } else if (visibleAngleRange.minAngle !== undefined && visibleAngleRange.maxAngle !== undefined) {
                anglesToProcess = generateOptimizedAngleSequence(level.angle, visibleAngleRange.minAngle, visibleAngleRange.maxAngle);
            }
            anglesToProcess = [...new Set(anglesToProcess)];
        }

        anglesToProcess.forEach(deg => {
            deg = Math.round(deg * 1e10) / 1e10;
            
            if (angleDisplayMode === 'degrees') {
                if (drawnAnglesSimple.has(deg)) return;
            }
            else if (angleDisplayMode === 'radians') {
                const levelKey = `${deg}-${level.angle}`;
                if (drawnAnglesComplex.has(levelKey)) return;
            }

            const angleRad = deg * Math.PI / 180;
            
            const labelPos = { 
                x: originScreen.x + (screenRadius + C.REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN) * Math.cos(angleRad), 
                y: originScreen.y - (screenRadius + C.REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN) * Math.sin(angleRad) 
            };
            
            const labelMargin = 100;
            const isLabelVisible = labelPos.x > -labelMargin && labelPos.x < canvasWidthCSS + labelMargin && 
                                   labelPos.y > -labelMargin && labelPos.y < canvasHeightCSS + labelMargin;
            
            if (!isLabelVisible) {
                return;
            }
            
            let labelOptions = { textAlign: 'center', textBaseline: 'middle' };
            
            if (angleDisplayMode === 'radians') {
                labelOptions = { textAlign: 'left', textBaseline: 'middle' };
            }

            ctx.save();
            ctx.strokeStyle = finalColor;
            ctx.lineWidth = C.GRID_LINEWIDTH;

            if (deg % 90 === 0 && deg < 360) {
                const vertexOnCircle = { 
                    x: originScreen.x + screenRadius * Math.cos(angleRad), 
                    y: originScreen.y - screenRadius * Math.sin(angleRad) 
                };

                let tickVec;
                const tickLength = C.AXIS_TICK_SIZE * 1.5;
                
                switch (deg) {
                    case 0:
                        tickVec = { x: Math.SQRT1_2, y: -Math.SQRT1_2 };
                        labelOptions = { textAlign: 'left', textBaseline: 'bottom' };
                        break;
                    case 90:
                        tickVec = { x: Math.SQRT1_2, y: -Math.SQRT1_2 };
                        labelOptions = { textAlign: 'left', textBaseline: 'bottom' };
                        break;
                    case 180:
                        tickVec = { x: -Math.SQRT1_2, y: -Math.SQRT1_2 };
                        labelOptions = { textAlign: 'right', textBaseline: 'bottom' };
                        break;
                    case 270:
                        tickVec = { x: Math.SQRT1_2, y: Math.SQRT1_2 };
                        labelOptions = { textAlign: 'left', textBaseline: 'top' };
                        break;
                }
                
                const tickEnd = {
                    x: vertexOnCircle.x + tickVec.x * tickLength,
                    y: vertexOnCircle.y + tickVec.y * tickLength
                };

                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(vertexOnCircle.x, vertexOnCircle.y);
                ctx.lineTo(tickEnd.x, tickEnd.y);
                ctx.stroke();
                
                labelPos.x = tickEnd.x;
                labelPos.y = tickEnd.y;

            } else {
                const tickStart = { 
                    x: originScreen.x + (screenRadius - C.VERTEX_RADIUS) * Math.cos(angleRad), 
                    y: originScreen.y - (screenRadius - C.VERTEX_RADIUS) * Math.sin(angleRad) 
                };
                const tickEnd = { 
                    x: originScreen.x + (screenRadius + C.VERTEX_RADIUS) * Math.cos(angleRad), 
                    y: originScreen.y - (screenRadius + C.VERTEX_RADIUS) * Math.sin(angleRad) 
                };
                if (isTickVisible(tickEnd, canvasWidthCSS, canvasHeightCSS)) {
                    ctx.beginPath();
                    ctx.moveTo(tickStart.x, tickStart.y);
                    ctx.lineTo(tickEnd.x, tickEnd.y);
                    ctx.stroke();
                }
            }
            
            ctx.restore();
            
            let angleText = '';
            if (angleDisplayMode === 'degrees') {
                let precision = Math.max(0, (level.angle.toString().split('.')[1] || '').length);
                
                if (level.angle < 1) {
                    precision = Math.max(precision, Math.ceil(-Math.log10(level.angle)) + 1);
                }
                
                const cleanDeg = Math.round(deg * Math.pow(10, precision)) / Math.pow(10, precision);
                const formattedDeg = parseFloat(cleanDeg.toFixed(precision));
                
                const displayValue = Math.round(formattedDeg * 1e10) / 1e10;
                angleText = `${displayValue}^{\\circ}`;
            } else {
                if (deg === 0 && angleDisplayMode === 'radians') {
                    angleText = '0';
                } else if (deg !== 0) {
                    const isFineTick = level.angle <= 5;
                    
                    if (isFineTick) {
                        const radianValue = deg * Math.PI / 180;
                        
                        const levelAnglePrecision = Math.max(0, (level.angle.toString().split('.')[1] || '').length);
                        const radianPrecision = Math.max(3, levelAnglePrecision + 2);
                        
                        let formattedRadian = radianValue.toFixed(radianPrecision);
                        formattedRadian = parseFloat(formattedRadian).toString();
                        
                        if (parseFloat(formattedRadian) !== 0) {
                            angleText = formattedRadian;
                        }
                    } else {
                        const numerator = deg;
                        const denominator = 180;
                        
                        const gcdValue = U.gcd(numerator, denominator);
                        const simplifiedNum = numerator / gcdValue;
                        const simplifiedDen = denominator / gcdValue;
                        
                        if (simplifiedDen === 1) {
                            if (simplifiedNum === 1) angleText = '\\pi';
                            else if (simplifiedNum === -1) angleText = '-\\pi';
                            else angleText = `${simplifiedNum}\\pi`;
                        } else {
                            if (simplifiedNum === 1) angleText = `\\frac{\\pi}{${simplifiedDen}}`;
                            else if (simplifiedNum === -1) angleText = `-\\frac{\\pi}{${simplifiedDen}}`;
                            else if (simplifiedNum < 0) angleText = `-\\frac{${Math.abs(simplifiedNum)}\\pi}{${simplifiedDen}}`;
                            else angleText = `\\frac{${simplifiedNum}\\pi}{${simplifiedDen}}`;
                        }
                    }
                }
            }

            if (angleText) {
                const labelId = angleDisplayMode === 'radians' 
                    ? `circ-label-${deg}-${level.angle}-${dataRadius.toExponential(15)}`
                    : `circ-label-${deg}-${dataRadius.toExponential(15)}`;
                    
                updateHtmlLabel({ 
                    id: labelId, 
                    content: angleText, 
                    x: labelPos.x, 
                    y: labelPos.y, 
                    color: finalColor, 
                    fontSize: C.REF_TEXT_KATEX_FONT_SIZE, 
                    options: labelOptions
                });
                
                if (angleDisplayMode === 'degrees') {
                    drawnAnglesSimple.add(deg);
                } else {
                    const levelKey = `${deg}-${level.angle}`;
                    drawnAnglesComplex.set(levelKey, { 
                        levelAngle: level.angle, 
                        alpha: tickAlpha,
                        labelId: labelId 
                    });
                }
            }
        });
    });

    const arrowColor = colors.feedbackDefault;
    let stickyArrowAngle = -Infinity;
    const zeroDegVertex = { x: originScreen.x + screenRadius, y: originScreen.y };
    if (zeroDegVertex.x > -C.AXIS_LABEL_PADDING && zeroDegVertex.x < canvasWidthCSS + C.AXIS_LABEL_PADDING && zeroDegVertex.y > -C.AXIS_LABEL_PADDING && zeroDegVertex.y < canvasHeightCSS + C.AXIS_LABEL_PADDING) {
        stickyArrowAngle = 0;
    } else {
        const screenRect = { x: 0, y: 0, w: canvasWidthCSS, h: canvasHeightCSS };
        const circle = { x: originScreen.x, y: originScreen.y, r: screenRadius };
        const intersections = getCircleRectIntersections(circle, screenRect);
        
        if (intersections.length > 0) {
            let largestVisibleAngle = -Infinity;
            
            intersections.forEach(p => {
                const angle = Math.atan2(originScreen.y - p.y, p.x - originScreen.x);
                const normalizedAngle = angle >= 0 ? angle : angle + 2 * Math.PI;
                
                const testPoint = { 
                    x: originScreen.x + screenRadius * Math.cos(normalizedAngle), 
                    y: originScreen.y - screenRadius * Math.sin(normalizedAngle) 
                };
                
                const margin = C.AXIS_LABEL_PADDING;
                const isVisible = testPoint.x > -margin && testPoint.x < canvasWidthCSS + margin && 
                                 testPoint.y > -margin && testPoint.y < canvasHeightCSS + margin;
                
                if (isVisible && normalizedAngle > largestVisibleAngle) {
                    largestVisibleAngle = normalizedAngle;
                }
            });
            
            const corners = [{x:0,y:0}, {x:screenRect.w,y:0}, {x:screenRect.w,y:screenRect.h}, {x:0,y:screenRect.h}];
            corners.forEach(c => {
                if (U.distance(c, originScreen) < circle.r) {
                    const angle = Math.atan2(originScreen.y - c.y, c.x - originScreen.x);
                    const normalizedAngle = angle >= 0 ? angle : angle + 2 * Math.PI;
                    
                    const testPoint = { 
                        x: originScreen.x + screenRadius * Math.cos(normalizedAngle), 
                        y: originScreen.y - screenRadius * Math.sin(normalizedAngle) 
                    };
                    
                    const margin = C.AXIS_LABEL_PADDING;
                    const isVisible = testPoint.x > -margin && testPoint.x < canvasWidthCSS + margin && 
                                     testPoint.y > -margin && testPoint.y < canvasHeightCSS + margin;
                    
                    if (isVisible && normalizedAngle > largestVisibleAngle) {
                        largestVisibleAngle = normalizedAngle;
                    }
                }
            });
            
            if (largestVisibleAngle > -Infinity) {
                stickyArrowAngle = largestVisibleAngle;
            }
        }
    }

    if (stickyArrowAngle > -Infinity) {
        const arrowAngle = stickyArrowAngle;
        const tipPos = { x: originScreen.x + screenRadius * Math.cos(arrowAngle), y: originScreen.y - screenRadius * Math.sin(arrowAngle) };
        const tangentVec = { x: -Math.sin(arrowAngle), y: -Math.cos(arrowAngle) };
        const radialVec = { x: Math.cos(arrowAngle), y: -Math.sin(arrowAngle) };
        const p1 = { x: tipPos.x - C.AXIS_ARROW_SIZE * tangentVec.x + (C.AXIS_ARROW_SIZE / 2) * radialVec.x, y: tipPos.y - C.AXIS_ARROW_SIZE * tangentVec.y + (C.AXIS_ARROW_SIZE / 2) * radialVec.y };
        const p2 = { x: tipPos.x - C.AXIS_ARROW_SIZE * tangentVec.x - (C.AXIS_ARROW_SIZE / 2) * radialVec.x, y: tipPos.y - C.AXIS_ARROW_SIZE * tangentVec.y - (C.AXIS_ARROW_SIZE / 2) * radialVec.y };
        ctx.save();
        ctx.fillStyle = `rgba(${arrowColor.join(',')}, 1.0)`;
        ctx.beginPath();
        ctx.moveTo(tipPos.x, tipPos.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        let labelPos;
        if (arrowAngle === 0) {
            labelPos = {
                x: tipPos.x - C.POLAR_THETA_LABEL_DISTANCE,
                y: tipPos.y + C.POLAR_THETA_LABEL_ARROW_DIST + C.AXIS_ARROW_SIZE
            };
        } else {
            const radialVecInward = { x: -Math.cos(arrowAngle), y: Math.sin(arrowAngle) };
            labelPos = {
                x: tipPos.x + radialVecInward.x * (C.POLAR_THETA_LABEL_ARROW_DIST + C.AXIS_ARROW_SIZE) + tangentVec.x * C.POLAR_THETA_LABEL_DISTANCE,
                y: tipPos.y + radialVecInward.y * (C.POLAR_THETA_LABEL_ARROW_DIST + C.AXIS_ARROW_SIZE) + tangentVec.y * C.POLAR_THETA_LABEL_DISTANCE
            };
        }
        updateHtmlLabel({ id: `theta-label-sticky`, content: '\\theta', x: labelPos.x, y: labelPos.y, color: `rgba(${arrowColor.join(',')}, 1.0)`, fontSize: C.AXIS_NAME_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } });
    }
}

function getCircleRectIntersections(circle, rect) {
    const { x: cx, y: cy, r } = circle;
    const { x: rx, y: ry, w: rw, h: rh } = rect;
    const intersections = [];
    
    const circleForUtils = { center: { x: cx, y: cy }, radius: r };
    
    const checkLine = (x1, y1, x2, y2) => {
        const line = { p1: { x: x1, y: y1 }, p2: { x: x2, y: y2 } };
        const points = U.getLineCircleIntersection(line, circleForUtils);
        
        points.forEach(point => {
            const dx = x2 - x1;
            const dy = y2 - y1;
            
            let t;
            if (Math.abs(dx) > Math.abs(dy)) {
                t = (point.x - x1) / dx;
            } else {
                t = (point.y - y1) / dy;
            }
            
            if (t >= 0 && t <= 1) {
                intersections.push({ x: point.x, y: point.y });
            }
        });
    };
    
    checkLine(rx, ry, rx + rw, ry);
    checkLine(rx + rw, ry, rx + rw, ry + rh);
    checkLine(rx + rw, ry + rh, rx, ry + rh);
    checkLine(rx, ry + rh, rx, ry);
    
    return intersections;
}

export function isCircleInView(circleX, circleY, circleRadius, canvasWidth, canvasHeight) {
    if (circleX + circleRadius < 0 ||
        circleX - circleRadius > canvasWidth ||
        circleY + circleRadius < 0 ||
        circleY - circleRadius > canvasHeight) {
        return false;
    }
    return true;
}

function drawZeroTickAndTickLabel(ctx, origin, canvasWidth, canvasHeight, coordsDisplayMode, updateHtmlLabel, colors) {
    const tickColor = `rgba(${colors.axisTickLabel.join(',')}, ${C.AXIS_TICK_LABEL_ALPHA})`;
    const longTickSize = C.AXIS_TICK_SIZE * C.AXIS_MAJOR_TICK_SCALE_FACTOR;
    
    ctx.save();
    ctx.strokeStyle = tickColor;
    ctx.lineWidth = C.MAJOR_TICK_LINE_WIDTH;
    ctx.setLineDash([]);
    
    const yLength = longTickSize;
    const xLength = yLength / Math.tan(C.ORIGIN_TICK_ANGLE_RAD);
    
    const endX = origin.x - xLength;
    const endY = origin.y + yLength;
    
    ctx.beginPath();
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
    ctx.restore();
    
    updateHtmlLabel({
        id: 'tick-label-origin',
        content: C.ORIGIN_LABEL_TEXT,
        x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET,
        y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET,
        color: tickColor,
        fontSize: C.AXIS_TICK_FONT_SIZE,
        options: { textAlign: 'right', textBaseline: 'top' }
    });
}

export function drawAxes(ctx, htmlOverlay, { canvas, dpr, coordsDisplayMode, viewTransform, angleDisplayMode, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState, updateHtmlLabel) {
    ctx.save();
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;
    const origin = dataToScreen({ x: 0, y: 0 });

    const drawAxisWithArrows = (x1, y1, x2, y2) => {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        const angle = Math.atan2(y2 - y1, x2 - x1);
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - C.AXIS_ARROW_SIZE * Math.cos(angle - C.AXIS_ARROW_ANGLE_RAD), y2 - C.AXIS_ARROW_SIZE * Math.sin(angle - C.AXIS_ARROW_ANGLE_RAD));
        ctx.lineTo(x2 - C.AXIS_ARROW_SIZE * Math.cos(angle + C.AXIS_ARROW_ANGLE_RAD), y2 - C.AXIS_ARROW_SIZE * Math.sin(angle + C.AXIS_ARROW_ANGLE_RAD));
        ctx.closePath();
        ctx.fill();
    };

    const drawTicksAndLabels = (interval1, alpha1, interval2, alpha2, isPolar) => {
        const drawnXPositions = new Map();
        const drawnYPositions = new Map();
        
        const addTicksForInterval = (interval, alpha, isCoarser) => {
            if (!interval || alpha < C.MIN_ALPHA_FOR_DRAWING) return;
            const topLeftData = screenToData({ x: 0, y: 0 });
            const bottomRightData = screenToData({ x: canvasWidth, y: canvasHeight });
            const localZeroThreshold = interval * C.GEOMETRY_CALCULATION_EPSILON;
            
            if (isPolar) {
                const maxRadiusData = Math.hypot(Math.max(Math.abs(topLeftData.x), Math.abs(bottomRightData.x)), Math.max(Math.abs(topLeftData.y), Math.abs(bottomRightData.y))) * C.POLAR_AXIS_RADIUS_BUFFER_FACTOR;
                const startMultiplier = 1;
                const endMultiplier = Math.ceil(maxRadiusData / interval);
                
                for (let i = startMultiplier; i <= endMultiplier; i++) {
                    const r_data = i * interval;
                    const existing = drawnXPositions.get(r_data);
                    if (!existing) {
                        drawnXPositions.set(r_data, { alpha, isCoarser });
                    } else if (isCoarser) {
                        drawnXPositions.set(r_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                    } else {
                        if (!existing.isCoarser) {
                            drawnXPositions.set(r_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                        }
                    }
                }
            } else {
                const startMultiplierX = Math.floor(topLeftData.x / interval);
                const endMultiplierX = Math.ceil(bottomRightData.x / interval);
                const startMultiplierY = Math.floor(bottomRightData.y / interval);
                const endMultiplierY = Math.ceil(topLeftData.y / interval);
                
                for (let i = startMultiplierX; i <= endMultiplierX; i++) {
                    const x_data = i * interval;
                    if (Math.abs(x_data) < localZeroThreshold) continue;
                    const existing = drawnXPositions.get(x_data);
                    if (!existing) {
                        drawnXPositions.set(x_data, { alpha, isCoarser });
                    } else if (isCoarser) {
                        drawnXPositions.set(x_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                    } else {
                        if (!existing.isCoarser) {
                            drawnXPositions.set(x_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                        }
                    }
                }
                
                for (let i = startMultiplierY; i <= endMultiplierY; i++) {
                    const y_data = i * interval;
                    if (Math.abs(y_data) < localZeroThreshold) continue;
                    const existing = drawnYPositions.get(y_data);
                    if (!existing) {
                        drawnYPositions.set(y_data, { alpha, isCoarser });
                    } else if (isCoarser) {
                        drawnYPositions.set(y_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                    } else {
                        if (!existing.isCoarser) {
                            drawnYPositions.set(y_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                        }
                    }
                }
            }
        };
        
        const interval1IsCoarser = !interval2 || interval1 >= interval2;
        
        addTicksForInterval(interval1, alpha1, interval1IsCoarser);
        addTicksForInterval(interval2, alpha2, !interval1IsCoarser);

        // Check if scientific notation should be used for ANY visible value
        let useScientific = false;
        const checkScientific = (val) => {
            const absValue = Math.abs(val);
            if (absValue >= C.SCIENTIFIC_NOTATION_UPPER_BOUND || (absValue > 0 && absValue < C.SCIENTIFIC_NOTATION_LOWER_BOUND)) {
                useScientific = true;
            }
        };
        
        // Check all axis tick values
        drawnXPositions.forEach((_, x_data) => checkScientific(x_data));
        drawnYPositions.forEach((_, y_data) => checkScientific(y_data));
        
        // Also check the current viewport bounds to ensure mouse coordinates will be consistent
        const topLeftData = screenToData({ x: 0, y: 0 });
        const bottomRightData = screenToData({ x: canvasWidth, y: canvasHeight });
        checkScientific(topLeftData.x);
        checkScientific(topLeftData.y);
        checkScientific(bottomRightData.x);
        checkScientific(bottomRightData.y);
        
        // Calculate decimal places based on the primary interval
        const primaryInterval = interval1 || interval2 || 1;
        const decimalPlaces = primaryInterval > 0 ? Math.max(0, -Math.floor(Math.log10(primaryInterval))) : 0;
        
        drawnXPositions.forEach((tickInfo, x_data) => {
            const effectiveAlpha = tickInfo.isCoarser ? 1.0 : tickInfo.alpha;
            const tickLabelColor = `rgba(${colors.axisTickLabel.join(',')}, ${C.AXIS_TICK_LABEL_ALPHA * effectiveAlpha})`;
            ctx.strokeStyle = tickLabelColor;
            ctx.lineWidth = C.GRID_LINEWIDTH;
            
            if (isPolar) {
                let labelText;
                if (useScientific) {
                    // Calculate how many decimal places needed in scientific notation coefficient
                    // to distinguish between consecutive tick values
                    const logValue = Math.log10(Math.abs(x_data));
                    const exponent = Math.floor(logValue);
                    const coefficient = x_data / Math.pow(10, exponent);
                    
                    // Determine precision needed based on tick interval
                    const intervalInSameScale = primaryInterval / Math.pow(10, exponent);
                    const decimalPlacesNeeded = Math.max(0, -Math.floor(Math.log10(intervalInSameScale)) + 1);
                    
                    const expStr = Math.abs(x_data).toExponential(decimalPlacesNeeded);
                    const parts = expStr.split('e');
                    let coefficientStr = parts[0];
                    let exp = parseInt(parts[1], 10);
                    const sign = x_data < 0 ? "-" : "";
                    labelText = `${sign}${coefficientStr} \\cdot 10^{${exp}}`;
                } else {
                    labelText = x_data.toFixed(decimalPlaces).replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
                }
                const stableIdPart = x_data.toExponential(15);
                
                const isYAxisOnScreen = origin.y > -C.AXIS_LABEL_PADDING && origin.y < canvasHeight + C.AXIS_LABEL_PADDING;
                const isXAxisOnScreen = origin.x > -C.AXIS_LABEL_PADDING && origin.x < canvasWidth + C.AXIS_LABEL_PADDING;

                const pX = dataToScreen({ x: x_data, y: 0 });
                if (isYAxisOnScreen && pX.x > -C.AXIS_LABEL_PADDING && pX.x < canvasWidth + C.AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(pX.x, origin.y - C.AXIS_TICK_SIZE / 2); 
                    ctx.lineTo(pX.x, origin.y + C.AXIS_TICK_SIZE / 2); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-x-${stableIdPart}`, 
                        content: labelText, 
                        x: pX.x, 
                        y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET, 
                        color: tickLabelColor, 
                        fontSize: C.AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'center', textBaseline: 'top' } 
                    });
                }
                
                const pNegX = dataToScreen({ x: -x_data, y: 0 });
                if (isYAxisOnScreen && pNegX.x > -C.AXIS_LABEL_PADDING && pNegX.x < canvasWidth + C.AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(pNegX.x, origin.y - C.AXIS_TICK_SIZE / 2); 
                    ctx.lineTo(pNegX.x, origin.y + C.AXIS_TICK_SIZE / 2); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-negx-${stableIdPart}`, 
                        content: labelText, 
                        x: pNegX.x, 
                        y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET, 
                        color: tickLabelColor, 
                        fontSize: C.AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'center', textBaseline: 'top' } 
                    });
                }
                
                const pPosY = dataToScreen({ x: 0, y: x_data });
                if (isXAxisOnScreen && pPosY.y > -C.AXIS_LABEL_PADDING && pPosY.y < canvasHeight + C.AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(origin.x - C.AXIS_TICK_SIZE / 2, pPosY.y); 
                    ctx.lineTo(origin.x + C.AXIS_TICK_SIZE / 2, pPosY.y); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-posy-${stableIdPart}`, 
                        content: labelText, 
                        x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET, 
                        y: pPosY.y, 
                        color: tickLabelColor, 
                        fontSize: C.AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'right', textBaseline: 'middle' } 
                    });
                }
                
                const pNegY = dataToScreen({ x: 0, y: -x_data });
                if (isXAxisOnScreen && pNegY.y > -C.AXIS_LABEL_PADDING && pNegY.y < canvasHeight + C.AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(origin.x - C.AXIS_TICK_SIZE / 2, pNegY.y); 
                    ctx.lineTo(origin.x + C.AXIS_TICK_SIZE / 2, pNegY.y); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-negy-${stableIdPart}`, 
                        content: labelText, 
                        x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET, 
                        y: pNegY.y, 
                        color: tickLabelColor, 
                        fontSize: C.AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'right', textBaseline: 'middle' } 
                    });
                }
            } else {
                const screenX = dataToScreen({ x: x_data, y: 0 }).x;
                ctx.beginPath(); 
                ctx.moveTo(screenX, origin.y); 
                ctx.lineTo(screenX, origin.y + C.AXIS_TICK_SIZE); 
                ctx.stroke();
                
                let tickLabel;
                if (useScientific) {
                    // Calculate precision needed for scientific notation
                    const logValue = Math.log10(Math.abs(x_data));
                    const exponent = Math.floor(logValue);
                    
                    // Determine precision needed based on tick interval
                    const intervalInSameScale = primaryInterval / Math.pow(10, exponent);
                    const decimalPlacesNeeded = Math.max(0, -Math.floor(Math.log10(intervalInSameScale)) + 1);
                    
                    const expStr = Math.abs(x_data).toExponential(decimalPlacesNeeded);
                    const parts = expStr.split('e');
                    let coefficientStr = parts[0];
                    // Remove trailing zeros from coefficient
                    coefficientStr = coefficientStr.replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
                    let exp = parseInt(parts[1], 10);
                    const sign = x_data < 0 ? "-" : "";
                    tickLabel = `${sign}${coefficientStr} \\cdot 10^{${exp}}`;
                } else {
                    tickLabel = x_data.toFixed(decimalPlaces).replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
                }
                
                const getStableId = (prefix, num) => `${prefix}-${num.toExponential(15)}`;
                updateHtmlLabel({ 
                    id: getStableId('tick-label-x', x_data), 
                    content: tickLabel, 
                    x: screenX, 
                    y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'center', textBaseline: 'top' } 
                });
            }
        });
        
        if (!isPolar) {
            drawnYPositions.forEach((tickInfo, y_data) => {
                const effectiveAlpha = tickInfo.isCoarser ? 1.0 : tickInfo.alpha;
                const tickLabelColor = `rgba(${colors.axisTickLabel.join(',')}, ${C.AXIS_TICK_LABEL_ALPHA * effectiveAlpha})`;
                ctx.strokeStyle = tickLabelColor;
                ctx.lineWidth = C.GRID_LINEWIDTH;
                
                const screenY = dataToScreen({ x: 0, y: y_data }).y;
                let yLabelContent;
                if (useScientific) {
                    // Calculate precision needed for scientific notation
                    const logValue = Math.log10(Math.abs(y_data));
                    const exponent = Math.floor(logValue);
                    
                    // Determine precision needed based on tick interval
                    const intervalInSameScale = primaryInterval / Math.pow(10, exponent);
                    const decimalPlacesNeeded = Math.max(0, -Math.floor(Math.log10(intervalInSameScale)) + 1);
                    
                    const expStr = Math.abs(y_data).toExponential(decimalPlacesNeeded);
                    const parts = expStr.split('e');
                    let coefficientStr = parts[0];
                    // Remove trailing zeros from coefficient
                    coefficientStr = coefficientStr.replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
                    let exp = parseInt(parts[1], 10);
                    const sign = y_data < 0 ? "-" : "";
                    yLabelContent = `${sign}${coefficientStr} \\cdot 10^{${exp}}`;
                } else {
                    yLabelContent = y_data.toFixed(decimalPlaces).replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
                }
                
                if (coordsDisplayMode === C.COORDS_DISPLAY_MODE_COMPLEX && Math.abs(y_data) > C.GEOMETRY_CALCULATION_EPSILON) {
                    if (yLabelContent === '1') yLabelContent = C.IMAGINARY_UNIT_SYMBOL;
                    else if (yLabelContent === '-1') yLabelContent = `-${C.IMAGINARY_UNIT_SYMBOL}`;
                    else yLabelContent += C.IMAGINARY_UNIT_SYMBOL;
                }
                
                ctx.beginPath(); 
                ctx.moveTo(origin.x, screenY); 
                ctx.lineTo(origin.x - C.AXIS_TICK_SIZE, screenY); 
                ctx.stroke();
                
                const getStableId = (prefix, num) => `${prefix}-${num.toExponential(15)}`;
                updateHtmlLabel({ 
                    id: getStableId('tick-label-y', y_data), 
                    content: yLabelContent, 
                    x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET, 
                    y: screenY, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'right', textBaseline: 'middle' } 
                });
            });
        }
        return { useScientific };
    };

    ctx.lineWidth = C.AXIS_LINE_WIDTH;
    ctx.strokeStyle = colors.axis;
    ctx.fillStyle = colors.axis;

    let formatInfo = { useScientific: false };
    if (coordsDisplayMode === C.COORDS_DISPLAY_MODE_POLAR) {
        const { interval1, interval2, alpha1, alpha2 } = lastGridState;
        
        // Draw polar axis lines with arrows and labels
        drawPolarAxisLines(ctx, htmlOverlay, { canvas, dpr, colors }, dataToScreen, updateHtmlLabel);
        
        // Calculate scientific notation decision for consistency
        let useScientific = false;
        const checkScientific = (val) => {
            const absValue = Math.abs(val);
            if (absValue >= C.SCIENTIFIC_NOTATION_UPPER_BOUND || (absValue > 0 && absValue < C.SCIENTIFIC_NOTATION_LOWER_BOUND)) {
                useScientific = true;
            }
        };
        
        // Check viewport bounds for scientific notation decision
        const topLeftData = screenToData({ x: 0, y: 0 });
        const bottomRightData = screenToData({ x: canvasWidth, y: canvasHeight });
        checkScientific(topLeftData.x);
        checkScientific(topLeftData.y);
        checkScientific(bottomRightData.x);
        checkScientific(bottomRightData.y);
        
        // Draw polar radius ticks and labels
        drawPolarRadiusTicks(ctx, htmlOverlay, { canvas, dpr, colors }, dataToScreen, screenToData, lastGridState, updateHtmlLabel, useScientific);
        
        // Draw polar reference circles (angle ticks)
        drawPolarReferenceCircle(ctx, htmlOverlay, updateHtmlLabel, 0, 0, { canvas, dpr, coordsDisplayMode, viewTransform, angleDisplayMode, colors }, dataToScreen, lastAngularGridState);
        
        formatInfo = { useScientific };
    } else {
        if (origin.y > 0 && origin.y < canvasHeight) drawAxisWithArrows(0, origin.y, canvasWidth, origin.y);
        if (origin.x > 0 && origin.x < canvasWidth) drawAxisWithArrows(origin.x, canvasHeight, origin.x, 0);
        
        let xLabel = 'x';
        let yLabel = 'y';
        if (coordsDisplayMode === C.COORDS_DISPLAY_MODE_COMPLEX) {
            xLabel = C.COMPLEX_REAL_LABEL;
            yLabel = C.COMPLEX_IMAGINARY_LABEL;
        }
        
        updateHtmlLabel({ 
            id: 'axis-label-x', 
            content: xLabel, 
            x: canvasWidth - C.AXIS_ARROW_SIZE - C.X_AXIS_LABEL_ARROW_DIST, 
            y: origin.y - C.X_AXIS_LABEL_DISTANCE, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'center', textBaseline: 'bottom' } 
        });
        
        updateHtmlLabel({ 
            id: 'axis-label-y', 
            content: yLabel, 
            x: origin.x + C.Y_AXIS_LABEL_DISTANCE, 
            y: C.AXIS_ARROW_SIZE + C.Y_AXIS_LABEL_ARROW_DIST, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'left', textBaseline: 'middle' } 
        });
        
        formatInfo = drawTicksAndLabels(lastGridState.interval1, lastGridState.alpha1, lastGridState.interval2, lastGridState.alpha2, false);
    }

    drawZeroTickAndTickLabel(ctx, origin, canvasWidth, canvasHeight, coordsDisplayMode, updateHtmlLabel, colors);

    ctx.restore();
    return formatInfo;
}

// Optimized function for drawing polar radius ticks and labels
export function drawPolarRadiusTicks(ctx, htmlOverlay, { canvas, dpr, colors }, dataToScreen, screenToData, lastGridState, updateHtmlLabel, useScientific) {
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;
    const origin = dataToScreen({ x: 0, y: 0 });
    
    // Check if origin axes are visible on screen
    const isYAxisOnScreen = origin.y > -C.AXIS_LABEL_PADDING && origin.y < canvasHeight + C.AXIS_LABEL_PADDING;
    const isXAxisOnScreen = origin.x > -C.AXIS_LABEL_PADDING && origin.x < canvasWidth + C.AXIS_LABEL_PADDING;
    
    // Early exit if no axes are visible
    if (!isYAxisOnScreen && !isXAxisOnScreen) {
        return;
    }
    
    const { interval1, interval2, alpha1, alpha2 } = lastGridState;
    const drawnRadiusPositions = new Map();
    
    // Calculate decimal places based on the primary interval
    const primaryInterval = interval1 || interval2 || 1;
    const decimalPlaces = primaryInterval > 0 ? Math.max(0, -Math.floor(Math.log10(primaryInterval))) : 0;
    
    const addTicksForInterval = (interval, alpha, isCoarser) => {
        if (!interval || alpha < C.MIN_ALPHA_FOR_DRAWING) return;
        
        // Calculate only the radius range that could be visible on the current axes
        let maxRadius = 0;
        
        if (isYAxisOnScreen) {
            // Check X-axis visibility range
            const leftData = screenToData({ x: 0, y: origin.y });
            const rightData = screenToData({ x: canvasWidth, y: origin.y });
            maxRadius = Math.max(maxRadius, Math.abs(leftData.x), Math.abs(rightData.x));
        }
        
        if (isXAxisOnScreen) {
            // Check Y-axis visibility range  
            const topData = screenToData({ x: origin.x, y: 0 });
            const bottomData = screenToData({ x: origin.x, y: canvasHeight });
            maxRadius = Math.max(maxRadius, Math.abs(topData.y), Math.abs(bottomData.y));
        }
        
        // Add small buffer
        maxRadius *= 1.1;
        
        const startMultiplier = 1;
        const endMultiplier = Math.ceil(maxRadius / interval);
        
        // Limit calculations to prevent performance issues
        const maxCalculations = 1000;
        const actualEndMultiplier = Math.min(endMultiplier, startMultiplier + maxCalculations);
        
        for (let i = startMultiplier; i <= actualEndMultiplier; i++) {
            const r_data = i * interval;
            
            // Check if any tick for this radius will be visible
            let willBeVisible = false;
            
            if (isYAxisOnScreen) {
                const xPos = dataToScreen({ x: r_data, y: 0 }).x;
                const xNegPos = dataToScreen({ x: -r_data, y: 0 }).x;
                if ((xPos >= -C.AXIS_LABEL_PADDING && xPos <= canvasWidth + C.AXIS_LABEL_PADDING) ||
                    (xNegPos >= -C.AXIS_LABEL_PADDING && xNegPos <= canvasWidth + C.AXIS_LABEL_PADDING)) {
                    willBeVisible = true;
                }
            }
            
            if (!willBeVisible && isXAxisOnScreen) {
                const yPos = dataToScreen({ x: 0, y: r_data }).y;
                const yNegPos = dataToScreen({ x: 0, y: -r_data }).y;
                if ((yPos >= -C.AXIS_LABEL_PADDING && yPos <= canvasHeight + C.AXIS_LABEL_PADDING) ||
                    (yNegPos >= -C.AXIS_LABEL_PADDING && yNegPos <= canvasHeight + C.AXIS_LABEL_PADDING)) {
                    willBeVisible = true;
                }
            }
            
            // Only add if it will be visible
            if (willBeVisible) {
                const existing = drawnRadiusPositions.get(r_data);
                if (!existing) {
                    drawnRadiusPositions.set(r_data, { alpha, isCoarser });
                } else if (isCoarser) {
                    drawnRadiusPositions.set(r_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                } else {
                    if (!existing.isCoarser) {
                        drawnRadiusPositions.set(r_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                    }
                }
            }
        }
    };
    
    const interval1IsCoarser = !interval2 || interval1 >= interval2;
    addTicksForInterval(interval1, alpha1, interval1IsCoarser);
    addTicksForInterval(interval2, alpha2, !interval1IsCoarser);
    
    // Draw radius ticks and labels
    drawnRadiusPositions.forEach((tickInfo, r_data) => {
        const effectiveAlpha = tickInfo.isCoarser ? 1.0 : tickInfo.alpha;
        const tickLabelColor = `rgba(${colors.axisTickLabel.join(',')}, ${C.AXIS_TICK_LABEL_ALPHA * effectiveAlpha})`;
        ctx.strokeStyle = tickLabelColor;
        ctx.lineWidth = C.GRID_LINEWIDTH;
        
        // Format the label text
        let labelText;
        if (useScientific) {
            const logValue = Math.log10(Math.abs(r_data));
            const exponent = Math.floor(logValue);
            const intervalInSameScale = primaryInterval / Math.pow(10, exponent);
            const decimalPlacesNeeded = Math.max(0, -Math.floor(Math.log10(intervalInSameScale)) + 1);
            
            const expStr = Math.abs(r_data).toExponential(decimalPlacesNeeded);
            const parts = expStr.split('e');
            let coefficientStr = parts[0];
            coefficientStr = coefficientStr.replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
            let exp = parseInt(parts[1], 10);
            const sign = r_data < 0 ? "-" : "";
            labelText = `${sign}${coefficientStr} \\cdot 10^{${exp}}`;
        } else {
            labelText = r_data.toFixed(decimalPlaces).replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
        }
        
        const stableIdPart = r_data.toExponential(15);

        // Draw ticks on X-axis (only if Y axis is visible)
        if (isYAxisOnScreen) {
            const pX = dataToScreen({ x: r_data, y: 0 });
            if (pX.x > -C.AXIS_LABEL_PADDING && pX.x < canvasWidth + C.AXIS_LABEL_PADDING) {
                ctx.beginPath(); 
                ctx.moveTo(pX.x, origin.y - C.AXIS_TICK_SIZE / 2); 
                ctx.lineTo(pX.x, origin.y + C.AXIS_TICK_SIZE / 2); 
                ctx.stroke();
                updateHtmlLabel({ 
                    id: `polartick-r-x-${stableIdPart}`, 
                    content: labelText, 
                    x: pX.x, 
                    y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'center', textBaseline: 'top' } 
                });
            }
            
            const pNegX = dataToScreen({ x: -r_data, y: 0 });
            if (pNegX.x > -C.AXIS_LABEL_PADDING && pNegX.x < canvasWidth + C.AXIS_LABEL_PADDING) {
                ctx.beginPath(); 
                ctx.moveTo(pNegX.x, origin.y - C.AXIS_TICK_SIZE / 2); 
                ctx.lineTo(pNegX.x, origin.y + C.AXIS_TICK_SIZE / 2); 
                ctx.stroke();
                updateHtmlLabel({ 
                    id: `polartick-r-negx-${stableIdPart}`, 
                    content: labelText, 
                    x: pNegX.x, 
                    y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'center', textBaseline: 'top' } 
                });
            }
        }
        
        // Draw ticks on Y-axis (only if X axis is visible)
        if (isXAxisOnScreen) {
            const pPosY = dataToScreen({ x: 0, y: r_data });
            if (pPosY.y > -C.AXIS_LABEL_PADDING && pPosY.y < canvasHeight + C.AXIS_LABEL_PADDING) {
                ctx.beginPath(); 
                ctx.moveTo(origin.x - C.AXIS_TICK_SIZE / 2, pPosY.y); 
                ctx.lineTo(origin.x + C.AXIS_TICK_SIZE / 2, pPosY.y); 
                ctx.stroke();
                updateHtmlLabel({ 
                    id: `polartick-r-posy-${stableIdPart}`, 
                    content: labelText, 
                    x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET, 
                    y: pPosY.y, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'right', textBaseline: 'middle' } 
                });
            }
            
            const pNegY = dataToScreen({ x: 0, y: -r_data });
            if (pNegY.y > -C.AXIS_LABEL_PADDING && pNegY.y < canvasHeight + C.AXIS_LABEL_PADDING) {
                ctx.beginPath(); 
                ctx.moveTo(origin.x - C.AXIS_TICK_SIZE / 2, pNegY.y); 
                ctx.lineTo(origin.x + C.AXIS_TICK_SIZE / 2, pNegY.y); 
                ctx.stroke();
                updateHtmlLabel({ 
                    id: `polartick-r-negy-${stableIdPart}`, 
                    content: labelText, 
                    x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET, 
                    y: pNegY.y, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'right', textBaseline: 'middle' } 
                });
            }
        }
    });
}

export function drawPolarAxisLines(ctx, htmlOverlay, { canvas, dpr, colors }, dataToScreen, updateHtmlLabel) {
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;
    const origin = dataToScreen({ x: 0, y: 0 });
    
    const drawAxisWithArrows = (x1, y1, x2, y2) => {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        const angle = Math.atan2(y2 - y1, x2 - x1);
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - C.AXIS_ARROW_SIZE * Math.cos(angle - C.AXIS_ARROW_ANGLE_RAD), y2 - C.AXIS_ARROW_SIZE * Math.sin(angle - C.AXIS_ARROW_ANGLE_RAD));
        ctx.lineTo(x2 - C.AXIS_ARROW_SIZE * Math.cos(angle + C.AXIS_ARROW_ANGLE_RAD), y2 - C.AXIS_ARROW_SIZE * Math.sin(angle + C.AXIS_ARROW_ANGLE_RAD));
        ctx.closePath();
        ctx.fill();
    };
    
    ctx.lineWidth = C.GRID_LINEWIDTH;
    
    const posXVisible = canvasWidth > origin.x;
    const negXVisible = 0 < origin.x;
    const posYVisible = 0 < origin.y;
    const negYVisible = canvasHeight > origin.y;
    
    if (posXVisible) {
        drawAxisWithArrows(origin.x, origin.y, canvasWidth, origin.y);
        updateHtmlLabel({ 
            id: 'axis-label-r-posx', 
            content: C.POLAR_RADIUS_SYMBOL, 
            x: canvasWidth - C.AXIS_ARROW_SIZE - C.X_AXIS_LABEL_ARROW_DIST, 
            y: origin.y - C.X_AXIS_LABEL_DISTANCE, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'center', textBaseline: 'bottom' } 
        });
    }
    
    if (negXVisible) {
        drawAxisWithArrows(origin.x, origin.y, 0, origin.y);
        updateHtmlLabel({ 
            id: 'axis-label-r-negx', 
            content: C.POLAR_RADIUS_SYMBOL, 
            x: C.AXIS_ARROW_SIZE + C.X_AXIS_LABEL_ARROW_DIST, 
            y: origin.y - C.X_AXIS_LABEL_DISTANCE, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'center', textBaseline: 'bottom' } 
        });
    }
    
    if (posYVisible) {
        drawAxisWithArrows(origin.x, origin.y, origin.x, 0);
        updateHtmlLabel({ 
            id: 'axis-label-r-posy', 
            content: C.POLAR_RADIUS_SYMBOL, 
            x: origin.x + C.Y_AXIS_LABEL_DISTANCE, 
            y: C.AXIS_ARROW_SIZE + C.Y_AXIS_LABEL_ARROW_DIST, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'left', textBaseline: 'middle' } 
        });
    }
    
    if (negYVisible) {
        drawAxisWithArrows(origin.x, origin.y, origin.x, canvasHeight);
        updateHtmlLabel({ 
            id: 'axis-label-r-negy', 
            content: C.POLAR_RADIUS_SYMBOL, 
            x: origin.x + C.Y_AXIS_LABEL_DISTANCE, 
            y: canvasHeight - C.AXIS_ARROW_SIZE - C.Y_AXIS_LABEL_ARROW_DIST, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'left', textBaseline: 'middle' } 
        });
    }
}

export function drawPolarGrid(ctx, { canvas, dpr, colors, gridAlpha }, origin, maxDataRadius, viewTransform, lastGridState, lastAngularGridState) {
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;
    const transitionRadius = Math.min(canvasWidth, canvasHeight) * C.POLAR_TO_LINE_TRANSITION_RADIUS_FACTOR;

    let minViewRadius, maxViewRadius;
    if (origin.x >= 0 && origin.x <= canvasWidth && origin.y >= 0 && origin.y <= canvasHeight) {
        minViewRadius = 0;
    } else {
        const distances = [
            U.distanceToSegment(origin.x, origin.y, 0, 0, canvasWidth, 0),
            U.distanceToSegment(origin.x, origin.y, canvasWidth, 0, canvasWidth, canvasHeight),
            U.distanceToSegment(origin.x, origin.y, canvasWidth, canvasHeight, 0, canvasHeight),
            U.distanceToSegment(origin.x, origin.y, 0, canvasHeight, 0, 0)
        ];
        minViewRadius = Math.min(...distances);
    }
    
    const corners = [
        { x: 0, y: 0 },
        { x: canvasWidth, y: 0 },
        { x: canvasWidth, y: canvasHeight },
        { x: 0, y: canvasHeight }
    ];
    
    const cornerDistances = corners.map(corner => 
        Math.sqrt((corner.x - origin.x) ** 2 + (corner.y - origin.y) ** 2)
    );
    
    maxViewRadius = Math.max(...cornerDistances);

    const minViewRadiusData = minViewRadius * dpr / viewTransform.scale;
    const maxViewRadiusData = maxViewRadius * dpr / viewTransform.scale;

    const drawPolarCircles = (interval, alpha) => {
        if (!interval || alpha < C.MIN_ALPHA_FOR_DRAWING) return;
        
        const screenSpacing = interval * viewTransform.scale / dpr;
        if (screenSpacing < C.GRID_POLAR_CIRCLE_MIN_SPACING) return;

        ctx.strokeStyle = `rgba(${colors.grid.join(',')}, ${alpha * gridAlpha})`;
        ctx.lineWidth = C.GRID_LINEWIDTH;
        
        const startMultiplier = minViewRadiusData === 0 ? 1 : Math.ceil(minViewRadiusData / interval);
        const endMultiplier = Math.floor(maxViewRadiusData / interval);
        
        for (let i = startMultiplier; i <= endMultiplier; i++) {
            const r = i * interval;
            const screenRadius = r * viewTransform.scale / dpr;
            
            if (screenRadius > transitionRadius) {
                const intersections = [];
                const circle = { center: { x: origin.x, y: origin.y }, radius: screenRadius };
                
                const edges = [
                    { p1: { x: 0, y: 0 }, p2: { x: canvasWidth, y: 0 } },
                    { p1: { x: canvasWidth, y: 0 }, p2: { x: canvasWidth, y: canvasHeight } },
                    { p1: { x: canvasWidth, y: canvasHeight }, p2: { x: 0, y: canvasHeight } },
                    { p1: { x: 0, y: canvasHeight }, p2: { x: 0, y: 0 } }
                ];
                
                edges.forEach(edge => {
                    const edgeIntersections = U.getLineCircleIntersection(edge, circle);
                    edgeIntersections.forEach(point => {
                        if (point.x >= 0 && point.x <= canvasWidth && point.y >= 0 && point.y <= canvasHeight) {
                            intersections.push(point);
                        }
                    });
                });
                
                if (intersections.length >= 2) {
                    let p1 = intersections[0], p2 = intersections[1], maxDistSq = 0;
                    for (let j = 0; j < intersections.length; j++) {
                        for (let k = j + 1; k < intersections.length; k++) {
                            const dSq = (intersections[j].x - intersections[k].x)**2 + (intersections[j].y - intersections[k].y)**2;
                            if (dSq > maxDistSq) {
                                maxDistSq = dSq;
                                p1 = intersections[j];
                                p2 = intersections[k];
                            }
                        }
                    }
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            } else {
                ctx.beginPath();
                ctx.arc(origin.x, origin.y, screenRadius, 0, C.RADIANS_IN_CIRCLE);
                ctx.stroke();
            }
        }
    };

    drawPolarCircles(lastGridState.interval1, lastGridState.alpha1);
    drawPolarCircles(lastGridState.interval2, lastGridState.alpha2);

    if (!lastAngularGridState || !Array.isArray(lastAngularGridState)) {
        return;
    }

    const screenCenter = { x: canvasWidth / 2, y: canvasHeight / 2 };
    const baseRadius = Math.min(canvasWidth, canvasHeight) / 4;
    const panDistance = Math.sqrt((origin.x - screenCenter.x) ** 2 + (origin.y - screenCenter.y) ** 2);
    const spokeReferenceRadius = baseRadius + panDistance;

    if (spokeReferenceRadius < C.REF_CIRCLE_MIN_DISPLAY_RADIUS || !isCircleInView(origin.x, origin.y, spokeReferenceRadius, canvasWidth, canvasHeight)) {
        return;
    }

    const isLineMode = spokeReferenceRadius > transitionRadius;
    let visibleAngleRange = null;

    if (isLineMode) {
        const screenRect = { x: 0, y: 0, w: canvasWidth, h: canvasHeight };
        const circle = { x: origin.x, y: origin.y, r: spokeReferenceRadius };
        const intersections = getCircleRectIntersections(circle, screenRect);

        if (intersections.length >= 2) {
            let p1 = intersections[0], p2 = intersections[1];
            let maxDistSq = 0;
            for (let i = 0; i < intersections.length; i++) {
                for (let j = i + 1; j < intersections.length; j++) {
                    const dSq = (intersections[i].x - intersections[j].x)**2 + (intersections[i].y - intersections[j].y)**2;
                    if (dSq > maxDistSq) {
                        maxDistSq = dSq;
                        p1 = intersections[i];
                        p2 = intersections[j];
                    }
                }
            }
            const angle1 = (Math.atan2(origin.y - p1.y, p1.x - origin.x) * 180 / Math.PI + 360) % 360;
            const angle2 = (Math.atan2(origin.y - p2.y, p2.x - origin.x) * 180 / Math.PI + 360) % 360;
            visibleAngleRange = { minAngle: Math.min(angle1, angle2), maxAngle: Math.max(angle1, angle2), isFullCircle: false };
            if (Math.abs(angle1 - angle2) > 180) {
                visibleAngleRange = { minAngle: Math.max(angle1, angle2), maxAngle: Math.min(angle1, angle2) + 360, isFullCircle: false };
            }
        }
    } else {
        visibleAngleRange = calculateVisibleAngleRange(origin, spokeReferenceRadius, canvasWidth, canvasHeight);
    }
    
    if (!visibleAngleRange) return;

    const drawnAngles = new Set();

    lastAngularGridState.forEach(level => {
        const tickAlpha = level.alpha;
        if (tickAlpha < 0.01) return;

        const screenSeparation = spokeReferenceRadius * (level.angle * Math.PI / 180);
        if (screenSeparation < C.REF_CIRCLE_MIN_TICK_SPACING * 0.5) return;

        ctx.strokeStyle = `rgba(${colors.grid.join(',')}, ${tickAlpha * gridAlpha})`;
        ctx.lineWidth = C.GRID_LINEWIDTH * 0.5;

        let anglesToProcess;
        if (visibleAngleRange.isFullCircle) {
            anglesToProcess = [];
            for (let deg = 0; deg < 360; deg += level.angle) {
                anglesToProcess.push(deg);
            }
        } else {
            anglesToProcess = [];
            if (visibleAngleRange.ranges && Array.isArray(visibleAngleRange.ranges)) {
                visibleAngleRange.ranges.forEach(range => {
                    let [minAngle, maxAngle] = range;
                    
                    if (isLineMode) {
                        const corners = [
                            { x: 0, y: 0 },
                            { x: canvasWidth, y: 0 },
                            { x: canvasWidth, y: canvasHeight },
                            { x: 0, y: canvasHeight }
                        ];
                        
                        const cornerAngles = corners.map(corner => {
                            return (Math.atan2(origin.y - corner.y, corner.x - origin.x) * 180 / Math.PI + 360) % 360;
                        });
                        
                        const allAngles = [...cornerAngles, minAngle, maxAngle].sort((a, b) => a - b);
                        const extendedMinAngle = Math.min(...allAngles) - level.angle * 2;
                        const extendedMaxAngle = Math.max(...allAngles) + level.angle * 2;
                        
                        minAngle = extendedMinAngle;
                        maxAngle = extendedMaxAngle;
                    }
                    
                    const rangeAngles = generateOptimizedAngleSequence(level.angle, minAngle, maxAngle);
                    anglesToProcess.push(...rangeAngles);
                });
            } else if (visibleAngleRange.minAngle !== undefined && visibleAngleRange.maxAngle !== undefined) {
                let minAngle = visibleAngleRange.minAngle;
                let maxAngle = visibleAngleRange.maxAngle;
                
                if (isLineMode) {
                    const corners = [
                        { x: 0, y: 0 },
                        { x: canvasWidth, y: 0 },
                        { x: canvasWidth, y: canvasHeight },
                        { x: 0, y: canvasHeight }
                    ];
                    
                    const cornerAngles = corners.map(corner => {
                        return (Math.atan2(origin.y - corner.y, corner.x - origin.x) * 180 / Math.PI + 360) % 360;
                    });
                    
                    const allAngles = [...cornerAngles, minAngle, maxAngle].sort((a, b) => a - b);
                    const extendedMinAngle = Math.min(...allAngles) - level.angle * 2;
                    const extendedMaxAngle = Math.max(...allAngles) + level.angle * 2;
                    
                    minAngle = extendedMinAngle;
                    maxAngle = extendedMaxAngle;
                }
                
                anglesToProcess = generateOptimizedAngleSequence(level.angle, minAngle, maxAngle);
            }
            anglesToProcess = [...new Set(anglesToProcess)];
        }

        anglesToProcess.forEach(deg => {
            deg = Math.round(deg * 1e10) / 1e10;
            if (drawnAngles.has(deg)) return;

            const angleRad = deg * Math.PI / 180;
            
            const tickStart = {
                x: origin.x + (minViewRadiusData * viewTransform.scale / dpr) * Math.cos(angleRad),
                y: origin.y - (minViewRadiusData * viewTransform.scale / dpr) * Math.sin(angleRad)
            };
            const tickEnd = {
                x: origin.x + (maxViewRadiusData * viewTransform.scale / dpr) * Math.cos(angleRad),
                y: origin.y - (maxViewRadiusData * viewTransform.scale / dpr) * Math.sin(angleRad)
            };

            ctx.beginPath();
            ctx.moveTo(tickStart.x, tickStart.y);
            ctx.lineTo(tickEnd.x, tickEnd.y);
            ctx.stroke();
            
            drawnAngles.add(deg);
        });
    });
}

export function drawGrid(ctx, { gridDisplayMode, canvas, dpr, viewTransform, gridAlpha, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState) {
    
    if (gridDisplayMode === C.GRID_DISPLAY_MODE_NONE) return;

    ctx.save();

    const origin = dataToScreen({ x: 0, y: 0 });
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;

    if (gridDisplayMode === C.GRID_DISPLAY_MODE_POLAR) {
        const topLeftData = screenToData({ x: 0, y: 0 });
        const bottomRightData = screenToData({ x: canvasWidth, y: canvasHeight });
        const maxDataRadius = Math.hypot(Math.max(Math.abs(topLeftData.x), Math.abs(bottomRightData.x)), Math.max(Math.abs(topLeftData.y), Math.abs(bottomRightData.y)));

        // Call the new unified polar grid drawing function
        drawPolarGrid(ctx, { canvas, dpr, colors, gridAlpha }, origin, maxDataRadius, viewTransform, lastGridState, lastAngularGridState);

    } else {
        // Rectangular grid modes (lines, points, triangular)
        const drawGridElements = (interval, alpha) => {
            if (!interval || alpha < C.MIN_ALPHA_FOR_DRAWING) return;
            const gridElementColor = `rgba(${colors.grid.join(',')}, ${alpha * gridAlpha})`;

            const start = screenToData({ x: 0, y: canvasHeight });
            const end = screenToData({ x: canvasWidth, y: 0 });
            
            const startMultiplierX = Math.floor(start.x / interval);
            const endMultiplierX = Math.ceil(end.x / interval);
            const startMultiplierY = Math.floor(start.y / interval);
            const endMultiplierY = Math.ceil(end.y / interval);

            if (gridDisplayMode === C.GRID_DISPLAY_MODE_LINES) {
                ctx.strokeStyle = gridElementColor;
                ctx.lineWidth = C.GRID_LINEWIDTH;
                for (let i = startMultiplierX; i <= endMultiplierX; i++) {
                    const x = i * interval;
                    const screenX = dataToScreen({ x: x, y: 0 }).x;
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, canvasHeight);
                    ctx.stroke();
                }
                for (let i = startMultiplierY; i <= endMultiplierY; i++) {
                    const y = i * interval;
                    const screenY = dataToScreen({ x: 0, y: y }).y;
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(canvasWidth, screenY);
                    ctx.stroke();
                }
            } else if (gridDisplayMode === C.GRID_DISPLAY_MODE_POINTS) {
                ctx.fillStyle = gridElementColor;
                const vertexRadius = C.GRID_POINT_RADIUS * dpr;
                for (let i = startMultiplierX; i <= endMultiplierX; i++) {
                    const x = i * interval;
                    for (let j = startMultiplierY; j <= endMultiplierY; j++) {
                        const y = j * interval;
                        const screenPos = dataToScreen({ x: x, y: y });
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, vertexRadius, 0, C.RADIANS_IN_CIRCLE);
                        ctx.fill();
                    }
                }
            } else if (gridDisplayMode === C.GRID_DISPLAY_MODE_TRIANGULAR) {
                ctx.fillStyle = gridElementColor;
                const vertexRadius = C.GRID_POINT_RADIUS * dpr;
                const y_step = interval * C.TRIANGULAR_GRID_Y_STEP_FACTOR;
                
                const startMultiplierY_tri = Math.floor(start.y / y_step);
                const endMultiplierY_tri = Math.ceil(end.y / y_step);
                
                for (let j = startMultiplierY_tri; j <= endMultiplierY_tri; j++) {
                    const y = j * y_step;
                    const rowIndex = j;
                    const x_offset = (rowIndex % 2 !== 0) ? interval / 2 : 0;
                    for (let i = startMultiplierX; i <= endMultiplierX; i++) {
                        const x = i * interval;
                        const finalX = x + x_offset;
                        const screenPos = dataToScreen({ x: finalX, y: y });
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, vertexRadius, 0, C.RADIANS_IN_CIRCLE);
                        ctx.fill();
                    }
                }
            }
        };
        
        drawGridElements(lastGridState.interval1, lastGridState.alpha1);
        drawGridElements(lastGridState.interval2, lastGridState.alpha2);
    }
    
    ctx.restore();
}

export function drawAngleArc(ctx, centerScreen, dataStartAngleRad, dataEndAngleRad, radius, color, isDashed = false) {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = C.GRID_LINEWIDTH;
    ctx.setLineDash(isDashed ? C.DASH_PATTERN_SMALL : []);
    const canvasStartAngle = -dataStartAngleRad;
    const canvasEndAngle = -dataEndAngleRad;
    let signedAngleDiffData = U.normalizeAngleToPi(dataEndAngleRad - dataStartAngleRad);
    ctx.beginPath();
    ctx.arc(centerScreen.x, centerScreen.y, radius, canvasStartAngle, canvasEndAngle, signedAngleDiffData > 0);
    ctx.stroke();
    ctx.restore();
}

export function drawVertex(ctx, vertex, { selectedVertexIds, selectedCenterIds, activeCenterId, colors, verticesVisible = true, isHovered = false }, dataToScreen, updateHtmlLabel) {
    let isSelected;
    if (vertex.type === C.VERTEX_TYPE_REGULAR) {
        isSelected = selectedVertexIds.includes(vertex.id);
        
        if (!verticesVisible && !isSelected && !isHovered) {
            return;
        }
    } else {
        isSelected = selectedCenterIds.includes(vertex.id);
    }

    const vertexColor = vertex.color || colors.vertex;
    const screenPos = dataToScreen(vertex);

    switch (vertex.type) {
        case C.VERTEX_TYPE_REGULAR:
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, C.VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            ctx.fillStyle = vertexColor;
            ctx.fill();
            break;
        case C.TRANSFORMATION_TYPE_ROTATION:
        case C.TRANSFORMATION_TYPE_SCALE:
        case C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE:
            const onCanvasIconSize = C.CENTER_POINT_VISUAL_RADIUS * 2;
            const icon = {
                type: vertex.type,
                x: screenPos.x - onCanvasIconSize / 2,
                y: screenPos.y - onCanvasIconSize / 2,
                width: onCanvasIconSize,
                height: onCanvasIconSize
            };
            drawUITransformationSymbols(ctx, icon, colors);
            break;
    }

    const shouldGlow = isSelected || isHovered;
    if (shouldGlow) {
        ctx.save();
        ctx.shadowColor = vertex.id === activeCenterId ? colors.activeCenterGlow : colors.selectionGlow;
        ctx.shadowBlur = C.SELECTION_GLOW_BLUR_RADIUS;
        ctx.globalAlpha = C.SELECTION_GLOW_ALPHA;

        ctx.beginPath();
        let glowRadius;
        if (vertex.type === C.VERTEX_TYPE_REGULAR) {
            glowRadius = C.VERTEX_RADIUS + C.SELECTION_GLOW_RADIUS_OFFSET;
        } else {
            glowRadius = C.CENTER_POINT_VISUAL_RADIUS + C.SELECTION_GLOW_RADIUS_OFFSET;
        }
        ctx.arc(screenPos.x, screenPos.y, glowRadius, 0, C.RADIANS_IN_CIRCLE);
        ctx.strokeStyle = vertex.id === activeCenterId ? colors.activeCenterGlow : colors.selectionGlow;
        ctx.lineWidth = C.SELECTION_GLOW_LINE_WIDTH;
        ctx.stroke();

        ctx.restore();
    }
}

export function drawAllEdges(ctx, { allEdges, selectedEdgeIds, isDragConfirmed, dragPreviewVertices, colors, edgesVisible }, dataToScreen, findVertexById, getEdgeId) {
    ctx.lineWidth = C.LINE_WIDTH;
    allEdges.forEach(edge => {
        const p1_orig = findVertexById(edge.id1);
        const p2_orig = findVertexById(edge.id2);
        if (!p1_orig || !p2_orig || p1_orig.type !== C.VERTEX_TYPE_REGULAR || p2_orig.type !== C.VERTEX_TYPE_REGULAR) return;

        const edgeId = getEdgeId(edge);
        const isSelected = selectedEdgeIds.includes(edgeId);
        
        if (!edgesVisible && !isSelected) return;

        let p1_render = { ...p1_orig };
        let p2_render = { ...p2_orig };
        let shouldBeDashed = false;

        if (isDragConfirmed && dragPreviewVertices.length > 0) {
            const p1Preview = dragPreviewVertices.find(dp => dp.id === p1_orig.id);
            const p2Preview = dragPreviewVertices.find(dp => dp.id === p2_orig.id);
            
            const p1BeingDragged = !!p1Preview;
            const p2BeingDragged = !!p2Preview;
            shouldBeDashed = p1BeingDragged !== p2BeingDragged;
            
            if (p1Preview) { p1_render.x = p1Preview.x; p1_render.y = p1Preview.y; }
            if (p2Preview) { p2_render.x = p2Preview.x; p2_render.y = p2Preview.y; }
        }

        const p1Screen = dataToScreen(p1_render);
        const p2Screen = dataToScreen(p2_render);

        ctx.beginPath();
        ctx.moveTo(p1Screen.x, p1Screen.y);
        ctx.lineTo(p2Screen.x, p2Screen.y);

        if (edge.colormapItem) {
            const gradient = ctx.createLinearGradient(p1Screen.x, p1Screen.y, p2Screen.x, p2Screen.y);
            const startColor = U.sampleColormap(edge.colormapItem, edge.gradientStart);
            const endColor = U.sampleColormap(edge.colormapItem, edge.gradientEnd);
            gradient.addColorStop(0, startColor);
            gradient.addColorStop(1, endColor);
            ctx.strokeStyle = gradient;
        } else {
            ctx.strokeStyle = edge.color || colors.defaultStroke;
        }

        ctx.setLineDash(shouldBeDashed ? C.DASH_PATTERN : []);
        ctx.lineWidth = C.LINE_WIDTH;
        ctx.stroke();
        ctx.setLineDash([]);

        if (isSelected) {
            ctx.beginPath();
            ctx.moveTo(p1Screen.x, p1Screen.y);
            ctx.lineTo(p2Screen.x, p2Screen.y);
            ctx.strokeStyle = colors.selectionGlow;
            ctx.globalAlpha = C.SELECTION_GLOW_ALPHA;
            ctx.lineWidth = C.LINE_WIDTH + C.EDGE_SELECTION_GLOW_WIDTH_OFFSET;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }
    });
    ctx.setLineDash([]);
    ctx.strokeStyle = colors.defaultStroke;
}

export function drawTransformIndicators(ctx, htmlOverlay, { transformIndicatorData, angleSigFigs, distanceSigFigs, colors, coordSystemTransformIndicatorData }, dataToScreen, updateHtmlLabel) {
    if (transformIndicatorData) {
        const { center, startPos, currentPos, rotation, scale, isSnapping, snappedScaleValue, gridToGridInfo, transformType, directionalScale } = transformIndicatorData;

        const centerScreen = dataToScreen(center);
        const startScreen = dataToScreen(startPos);
        const color = isSnapping ? colors.feedbackSnapped : `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;

        ctx.save();
        ctx.setLineDash(C.DASH_PATTERN);
        ctx.strokeStyle = color;
        ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;

        if (transformType === C.TRANSFORMATION_TYPE_ROTATION) {
            const currentScreen = dataToScreen(currentPos);
            const startVecScreen = { x: startScreen.x - centerScreen.x, y: startScreen.y - centerScreen.y };
            const arcRadius = Math.hypot(startVecScreen.x, startVecScreen.y);
            const startAngleScreen = Math.atan2(startVecScreen.y, startVecScreen.x);

            ctx.beginPath();
            ctx.moveTo(centerScreen.x, centerScreen.y);
            ctx.lineTo(startScreen.x, startScreen.y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(centerScreen.x, centerScreen.y);
            ctx.lineTo(currentScreen.x, currentScreen.y);
            ctx.stroke();

            if (Math.abs(rotation) > C.MIN_TRANSFORM_ACTION_THRESHOLD) {
                const screenRotation = -rotation;
                const anticlockwise = rotation > 0;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.arc(centerScreen.x, centerScreen.y, arcRadius, startAngleScreen, startAngleScreen + screenRotation, anticlockwise);
                ctx.stroke();
            }
        } else if (transformType === C.TRANSFORMATION_TYPE_SCALE || transformType === C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE) {
            const scaledPos = {
                x: center.x + (startPos.x - center.x) * scale,
                y: center.y + (startPos.y - center.y) * scale
            };
            const scaledScreen = dataToScreen(scaledPos);

            ctx.beginPath();
            ctx.moveTo(centerScreen.x, centerScreen.y);
            ctx.lineTo(startScreen.x, startScreen.y);
            ctx.stroke();

            if (Math.abs(scale - 1) > C.MIN_TRANSFORM_ACTION_THRESHOLD) {
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(centerScreen.x, centerScreen.y);
                ctx.lineTo(scaledScreen.x, scaledScreen.y);
                ctx.stroke();
            }
        }

        ctx.setLineDash([]);
        ctx.restore();

        if (transformType === C.TRANSFORMATION_TYPE_ROTATION && Math.abs(rotation) > C.MIN_TRANSFORM_ACTION_THRESHOLD) {
            const angleDeg = rotation * (180 / Math.PI);
            const angleText = `${parseFloat(angleDeg.toFixed(4)).toString()}^{\\circ}`;
            const startVecScreen = { x: startScreen.x - centerScreen.x, y: startScreen.y - centerScreen.y };
            
            const bisectorAngle = Math.atan2(startVecScreen.y, startVecScreen.x) + (-rotation) / 2;
            const arcRadius = Math.hypot(startVecScreen.x, startVecScreen.y);
            const labelRadius = arcRadius + C.TRANSFORM_ANGLE_LABEL_OFFSET;
            const angleTextX = centerScreen.x + labelRadius * Math.cos(bisectorAngle);
            const angleTextY = centerScreen.y + labelRadius * Math.sin(bisectorAngle);

            updateHtmlLabel({ id: 'transform-angle-indicator', content: angleText, x: angleTextX, y: angleTextY, color: color, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } });
        } else {
            updateHtmlLabel({ id: 'transform-angle-indicator', content: '', x: 0, y: 0, color: color, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
        }

        if ((transformType === C.TRANSFORMATION_TYPE_SCALE || transformType === C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE) && Math.abs(scale - 1) > C.MIN_TRANSFORM_ACTION_THRESHOLD) {
            let scaleText;
            const effectiveScale = isSnapping && snappedScaleValue !== null ? snappedScaleValue : scale;
            
            if (Math.abs(effectiveScale - 1) < 0.001) {
                scaleText = `\\times 1`;
            } else if (isSnapping && gridToGridInfo) {
                const { startSquaredSum, snapSquaredSum } = gridToGridInfo;
                const [startCoeff, startRadicand] = U.simplifySquareRoot(startSquaredSum);
                const [snapCoeff, snapRadicand] = U.simplifySquareRoot(snapSquaredSum);
                
                if (startRadicand === 1 && snapRadicand === 1) {
                    scaleText = `\\times \\frac{${snapCoeff}}{${startCoeff}}`;
                } else if (startRadicand === snapRadicand) {
                    scaleText = `\\times \\frac{${snapCoeff}}{${startCoeff}}`;
                } else {
                    const numerator = U.formatSimplifiedRoot(snapCoeff, snapRadicand);
                    const denominator = U.formatSimplifiedRoot(startCoeff, startRadicand);
                    scaleText = `\\times \\frac{${numerator}}{${denominator}}`;
                }
            } else if (isSnapping && snappedScaleValue !== null) {
                scaleText = `\\times ${U.formatFraction(snappedScaleValue, C.FRACTION_FORMAT_TOLERANCE, C.FRACTION_FORMAT_MAX_DENOMINATOR_TRANSFORM)}`;
            } else {
                const formattedScale = parseFloat(effectiveScale.toFixed(4)).toString();
                scaleText = `\\times ${formattedScale}`;
            }

            const midX = (centerScreen.x + startScreen.x) / 2;
            const midY = (centerScreen.y + startScreen.y) / 2;
            const lineAngle = Math.atan2(startScreen.y - centerScreen.y, startScreen.x - centerScreen.x);
            let textPerpAngle = lineAngle - Math.PI / 2;
            const scaleTextX = midX + Math.cos(textPerpAngle) * C.TRANSFORM_SCALE_LABEL_OFFSET;
            const scaleTextY = midY + Math.sin(textPerpAngle) * C.TRANSFORM_SCALE_LABEL_OFFSET;

            let rotationDeg = lineAngle * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
            if (rotationDeg > C.DEGREES_IN_QUADRANT || rotationDeg < -C.DEGREES_IN_QUADRANT) {
                rotationDeg += C.DEGREES_IN_HALF_CIRCLE;
            }

            updateHtmlLabel({ id: 'transform-scale-indicator', content: scaleText, x: scaleTextX, y: scaleTextY, color: color, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'bottom', rotation: rotationDeg } }, htmlOverlay);
        } else {
            updateHtmlLabel({ id: 'transform-scale-indicator', content: '', x: 0, y: 0, color: color, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'bottom' } }, htmlOverlay);
        }
    }

    if (coordSystemTransformIndicatorData) {
        const { edgeFraction, orthogonalDistanceFraction, v1, v2, snapPosition } = coordSystemTransformIndicatorData;
        
        let labelText = '';
        let labelPos = { x: 0, y: 0 };
        
        if (orthogonalDistanceFraction !== undefined) {
            labelText = U.formatFraction(orthogonalDistanceFraction, 0.001, 8);
            const originScreen = dataToScreen(snapPosition.origin);
            const snapScreen = dataToScreen(snapPosition.closest);
            
            const midX = (originScreen.x + snapScreen.x) / 2;
            const midY = (originScreen.y + snapScreen.y) / 2;
            const angle = Math.atan2(snapScreen.y - originScreen.y, snapScreen.x - originScreen.x);
            
            labelPos.x = midX + Math.cos(angle + Math.PI/2) * C.COORD_SYSTEM_EDGE_FRACTION_LABEL_OFFSET;
            labelPos.y = midY + Math.sin(angle + Math.PI/2) * C.COORD_SYSTEM_EDGE_FRACTION_LABEL_OFFSET;
        } else if (edgeFraction !== undefined) {
            const v1Screen = dataToScreen(v1);
            const v2Screen = dataToScreen(v2);
            const snapScreen = dataToScreen(snapPosition);
            const edgeAngle = Math.atan2(v2Screen.y - v1Screen.y, v2Screen.x - v1Screen.x);
            
            const offsetX = Math.cos(edgeAngle + Math.PI/2) * C.COORD_SYSTEM_EDGE_FRACTION_LABEL_OFFSET;
            const offsetY = Math.sin(edgeAngle + Math.PI/2) * C.COORD_SYSTEM_EDGE_FRACTION_LABEL_OFFSET;
            
            labelPos.x = snapScreen.x + offsetX;
            labelPos.y = snapScreen.y + offsetY;
            
            labelText = U.formatFraction(edgeFraction, 0.001, 8);
        }
        
        if (labelText) {
             updateHtmlLabel({ 
                id: 'coord-system-edge-fraction', 
                content: labelText, 
                x: labelPos.x, 
                y: labelPos.y, 
                color: colors.feedbackSnapped, 
                fontSize: C.COORD_SYSTEM_EDGE_FRACTION_FONT_SIZE, 
                options: { textAlign: 'center', textBaseline: 'middle' } 
            });
        }
    }
}

export function drawReferenceElementsGeometry(ctx, context, dataToScreen, screenToData, { showAngles, showDistances, viewTransform, mousePos, colors }) {
    if ((!showAngles && !showDistances) || !context.frozen_Origin_Data_to_display) return;
    
    const startVertexData = context.frozen_Origin_Data_to_display;
    const mouseDataPos = screenToData(mousePos);
    const previewDistance = U.distance(startVertexData, mouseDataPos);
    
    if (previewDistance < C.GEOMETRY_CALCULATION_EPSILON) return;

    const refElementColor = colors.frozenReference;

    const turnAngleData = context.displayAngleA_valueRad_for_A_equals_label;
    const baseAngleData = context.frozen_A_baseRad_to_display !== null ? context.frozen_A_baseRad_to_display : 0;
    const distanceData = context.frozen_D_du_to_display;

    if (!startVertexData) return;

    const frozenOriginScreen = dataToScreen(startVertexData);
    const absoluteAngleForRefLine = baseAngleData + turnAngleData;

    ctx.save();
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
    ctx.strokeStyle = refElementColor;

    if (showAngles && context.displayAngleA_valueRad_for_A_equals_label !== null && Math.abs(context.displayAngleA_valueRad_for_A_equals_label) > C.GEOMETRY_CALCULATION_EPSILON) {
        const effectiveRadiusForLine = C.REF_ARC_RADIUS_SCREEN + ctx.lineWidth / 2;

        const dottedLineEndVertexData = {
            x: startVertexData.x + Math.cos(baseAngleData) * (effectiveRadiusForLine / viewTransform.scale),
            y: startVertexData.y + Math.sin(baseAngleData) * (effectiveRadiusForLine / viewTransform.scale)
        };
        const dottedLineEndVertexScreen = dataToScreen(dottedLineEndVertexData);

        ctx.beginPath();
        ctx.moveTo(frozenOriginScreen.x, frozenOriginScreen.y);
        ctx.lineTo(dottedLineEndVertexScreen.x, dottedLineEndVertexScreen.y);
        ctx.setLineDash(C.REF_LINE_DASH_PATTERN);
        ctx.stroke();

        drawAngleArc(ctx, frozenOriginScreen, baseAngleData, absoluteAngleForRefLine, C.REF_ARC_RADIUS_SCREEN, refElementColor, false);
    }
    ctx.restore();
}

export function prepareSnapInfoTexts(ctx, htmlOverlay, startVertexData, targetDataPos, snappedOutput, { showDistances, showAngles, currentShiftPressed, distanceSigFigs, angleSigFigs, angleDisplayMode, viewTransform, frozenReference_D_du, gridDisplayMode, frozenReference_A_rad, colors }, dataToScreen, drawingContext, updateHtmlLabel) {
    if ((!showAngles && !showDistances) || snappedOutput.distance < C.GEOMETRY_CALCULATION_EPSILON) {
        return;
    }

    const startScreen = dataToScreen(startVertexData);
    const { angle: snappedAbsoluteAngleDeg, distance: snappedDistanceData, lengthSnapFactor, angleSnapFactor, angleTurn, gridToGridSquaredSum, gridInterval } = snappedOutput;
    const { offsetAngleRad, isFirstSegmentBeingDrawn } = drawingContext;
    const currentElementColor = currentShiftPressed ? colors.feedbackSnapped : colors.geometryInfoText;
    const currentLineAbsoluteAngle = Math.atan2(targetDataPos.y - startVertexData.y, targetDataPos.x - startVertexData.x);

    if (snappedDistanceData * viewTransform.scale / window.devicePixelRatio < C.VERTEX_RADIUS) {
        return;
    }

    const isAngleFeedbackActive = showAngles && snappedDistanceData > C.GEOMETRY_CALCULATION_EPSILON && Math.abs(angleTurn) > C.GEOMETRY_CALCULATION_EPSILON;

    if (showDistances) {
        let distanceText = '';

        if (currentShiftPressed && !isFirstSegmentBeingDrawn && frozenReference_D_du !== null) {
            const currentExactDistance = snappedDistanceData;

            if (gridToGridSquaredSum !== null && gridInterval) {
                const actualGridDistance = gridInterval * Math.sqrt(gridToGridSquaredSum);
                if (Math.abs(actualGridDistance - frozenReference_D_du) < C.GEOMETRY_CALCULATION_EPSILON) {
                    distanceText = C.DELTA_SYMBOL_KATEX;
                } else {
                    let foundFraction = false;
                    for (const factor of C.SNAP_FACTORS) {
                        if (Math.abs(currentExactDistance / frozenReference_D_du - factor) < C.GEOMETRY_CALCULATION_EPSILON) {
                            distanceText = U.formatSnapFactor(factor, 'D');
                            foundFraction = true;
                            break;
                        }
                    }
                    if (!foundFraction) {
                        const [coeff, radicand] = U.simplifySquareRoot(gridToGridSquaredSum);
                        const finalCoeff = gridInterval * coeff;
                        const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                        distanceText = U.formatSimplifiedRoot(roundedFinalCoeff, radicand);
                    }
                }
            } else if (frozenReference_D_du > C.GEOMETRY_CALCULATION_EPSILON) {
                const ratio = currentExactDistance / frozenReference_D_du;
                let foundFraction = false;
                for (const factor of C.SNAP_FACTORS) {
                    if (Math.abs(ratio - factor) < C.GEOMETRY_CALCULATION_EPSILON) {
                        distanceText = U.formatSnapFactor(factor, 'D');
                        foundFraction = true;
                        break;
                    }
                }
                if (!foundFraction) {
                    distanceText = U.formatNumber(snappedDistanceData, distanceSigFigs);
                }
            } else {
                distanceText = U.formatNumber(snappedDistanceData, distanceSigFigs);
            }
        } else if (currentShiftPressed && isFirstSegmentBeingDrawn && gridDisplayMode !== C.GRID_DISPLAY_MODE_NONE && gridInterval) {
            if (gridToGridSquaredSum !== null && gridInterval) {
                if (gridToGridSquaredSum >= 0) {
                    const [coeff, radicand] = U.simplifySquareRoot(gridToGridSquaredSum);
                    const finalCoeff = gridInterval * coeff;
                    const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                    distanceText = U.formatSimplifiedRoot(roundedFinalCoeff, radicand);
                }
            } else {
                distanceText = U.formatNumber(snappedDistanceData, distanceSigFigs);
            }
        } else {
            distanceText = U.formatNumber(snappedDistanceData, distanceSigFigs);
        }

        if (distanceText) {
            const startScreenPos = dataToScreen(startVertexData);
            const endScreenPos = dataToScreen(targetDataPos);
            const edgeAngleScreen = Math.atan2(endScreenPos.y - startScreenPos.y, endScreenPos.x - startScreenPos.x);
            const midX = (startScreenPos.x + endScreenPos.x) / 2;
            const midY = (startScreenPos.y + endScreenPos.y) / 2;

            let textPerpAngle;

            if (isAngleFeedbackActive) {
                if (angleTurn > C.GEOMETRY_CALCULATION_EPSILON) {
                    textPerpAngle = edgeAngleScreen - Math.PI / 2;
                } else if (angleTurn < -C.GEOMETRY_CALCULATION_EPSILON) {
                    textPerpAngle = edgeAngleScreen + Math.PI / 2;
                } else {
                    textPerpAngle = edgeAngleScreen - Math.PI / 2;
                }
            } else {
                if (Math.abs(Math.sin(edgeAngleScreen)) < C.VERTICAL_LINE_COS_THRESHOLD) {
                    textPerpAngle = edgeAngleScreen - Math.PI / 2;
                } else if (Math.abs(Math.cos(edgeAngleScreen)) < C.VERTICAL_LINE_COS_THRESHOLD) {
                    textPerpAngle = edgeAngleScreen;
                    if (Math.sin(edgeAngleScreen) < 0) {
                        textPerpAngle += Math.PI / 2;
                    } else {
                        textPerpAngle -= Math.PI / 2;
                    }
                } else {
                    textPerpAngle = edgeAngleScreen - Math.PI / 2;
                    if (Math.sin(textPerpAngle) > 0) {
                        textPerpAngle += Math.PI;
                    }
                }
            }
            
            const distanceTextX = midX + Math.cos(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
            const distanceTextY = midY + Math.sin(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
            let rotationDeg = edgeAngleScreen * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
            if (rotationDeg > C.DEGREES_IN_QUADRANT || rotationDeg < -C.DEGREES_IN_QUADRANT) {
                rotationDeg += C.DEGREES_IN_HALF_CIRCLE;
            }
            updateHtmlLabel({ id: 'snap-dist', content: distanceText, x: distanceTextX, y: distanceTextY, color: currentElementColor, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle', rotation: rotationDeg } }, htmlOverlay);
        }
    }

    if (isAngleFeedbackActive) {
        const baseAngleForArc = isFirstSegmentBeingDrawn ? 0 : offsetAngleRad;

        drawAngleArc(ctx, startScreen, baseAngleForArc, currentLineAbsoluteAngle, C.FEEDBACK_ARC_RADIUS_SCREEN, currentElementColor);

        ctx.save();
        ctx.beginPath();
        const effectiveRadiusForLine = C.FEEDBACK_ARC_RADIUS_SCREEN + ctx.lineWidth / 2;
        const baseLineEndData = {
            x: startVertexData.x + (effectiveRadiusForLine / viewTransform.scale) * Math.cos(baseAngleForArc),
            y: startVertexData.y + (effectiveRadiusForLine / viewTransform.scale) * Math.sin(baseAngleForArc)
        };
        const baseLineEndScreen = dataToScreen(baseLineEndData);
        ctx.moveTo(startScreen.x, startScreen.y);
        ctx.lineTo(baseLineEndScreen.x, baseLineEndScreen.y);
        ctx.strokeStyle = currentElementColor;
        ctx.setLineDash(C.HELPER_LINE_DASH_PATTERN);
        ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
        ctx.stroke();
        ctx.restore();

        let angleText = '';
        const canReferToTheta = !isFirstSegmentBeingDrawn && frozenReference_A_rad !== null && Math.abs(frozenReference_A_rad) > C.GEOMETRY_CALCULATION_EPSILON;

        if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
            if (currentShiftPressed && canReferToTheta) {
                const referenceAngleRad = Math.abs(drawingContext.currentSegmentReferenceA_for_display);
                let potentialFactor = null;

                if (typeof angleSnapFactor === 'number') {
                    potentialFactor = angleSnapFactor;
                } else if (angleTurn !== null) {
                    if (Math.abs(referenceAngleRad) > C.GEOMETRY_CALCULATION_EPSILON) {
                        const calculatedFactor = angleTurn / referenceAngleRad;
                        for (const frac of C.NINETY_DEG_ANGLE_SNAP_FRACTIONS) {
                            if (Math.abs(Math.abs(calculatedFactor) - frac) < C.GEOMETRY_CALCULATION_EPSILON) {
                                potentialFactor = calculatedFactor < 0 ? -frac : frac;
                                break;
                            }
                        }
                    }
                }
                if (potentialFactor !== null && Math.abs(potentialFactor) > C.GEOMETRY_CALCULATION_EPSILON) {
                    angleText = U.formatSnapFactor(potentialFactor, 'A');
                } else {
                    let degrees = angleTurn * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
                    if (Math.abs(degrees) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = `${U.formatNumber(degrees, angleSigFigs)}^{\\circ}`;
                    }
                }
            } else {
                let angleToFormatRad = isFirstSegmentBeingDrawn ? currentLineAbsoluteAngle : angleTurn;
                if (currentShiftPressed && !isFirstSegmentBeingDrawn) {
                    let angleToFormatDeg = angleToFormatRad * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
                    if (Math.abs(angleToFormatDeg) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = `${U.formatNumber(angleToFormatDeg, angleSigFigs)}^{\\circ}`;
                    }
                } else {
                    let angleToFormatDeg = U.normalizeAngleToPi(angleToFormatRad) * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
                    if (Math.abs(angleToFormatDeg) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = `${U.formatNumber(angleToFormatDeg, angleSigFigs)}^{\\circ}`;
                    }
                }
            }
        } else if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_RADIANS) {
            if (currentShiftPressed && canReferToTheta) {
                const referenceAngleRad = Math.abs(drawingContext.currentSegmentReferenceA_for_display);
                let potentialFactor = null;

                if (typeof angleSnapFactor === 'number') {
                    potentialFactor = angleSnapFactor;
                } else if (angleTurn !== null) {
                    if (Math.abs(referenceAngleRad) > C.GEOMETRY_CALCULATION_EPSILON) {
                        const calculatedFactor = angleTurn / referenceAngleRad;
                        for (const frac of C.NINETY_DEG_ANGLE_SNAP_FRACTIONS) {
                            if (Math.abs(Math.abs(calculatedFactor) - frac) < C.GEOMETRY_CALCULATION_EPSILON) {
                                potentialFactor = calculatedFactor < 0 ? -frac : frac;
                                break;
                            }
                        }
                    }
                }
                if (potentialFactor !== null && Math.abs(potentialFactor) > C.GEOMETRY_CALCULATION_EPSILON) {
                    const fracStr = U.formatSnapFactor(potentialFactor, null);
                    angleText = `${fracStr === '0' ? '0' : fracStr + C.PI_SYMBOL_KATEX}`;
                    if (angleText.startsWith(`1${C.PI_SYMBOL_KATEX}`)) angleText = C.PI_SYMBOL_KATEX;
                    if (angleText.startsWith(`-1${C.PI_SYMBOL_KATEX}`)) angleText = `-${C.PI_SYMBOL_KATEX}`;
                    if (angleText === `0${C.PI_SYMBOL_KATEX}`) angleText = "0";
                } else {
                    let radians = angleTurn;
                    if (Math.abs(radians) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = U.formatNumber(radians, angleSigFigs);
                    }
                }
            } else {
                let angleToFormatRad = isFirstSegmentBeingDrawn ? currentLineAbsoluteAngle : angleTurn;
                if (currentShiftPressed && !isFirstSegmentBeingDrawn) {
                    let radians = angleToFormatRad;
                    if (Math.abs(radians) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = U.formatNumber(radians, angleSigFigs);
                    }
                } else {
                    let radians = U.normalizeAngleToPi(angleToFormatRad);
                    if (Math.abs(radians) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = U.formatNumber(radians, angleSigFigs);
                    }
                }
            }
        }

        if (angleText) {
            const canvasStartAngle = -baseAngleForArc;
            const canvasEndAngle = -currentLineAbsoluteAngle;
            const sumCos = Math.cos(canvasStartAngle) + Math.cos(canvasEndAngle);
            const sumSin = Math.sin(canvasStartAngle) + Math.sin(canvasEndAngle);
            let bisectorCanvasAngle = Math.atan2(sumSin, sumCos);
            const angleTextX = startScreen.x + Math.cos(bisectorCanvasAngle) * C.SNAP_ANGLE_LABEL_OFFSET;
            const angleTextY = startScreen.y + Math.sin(bisectorCanvasAngle) * C.SNAP_ANGLE_LABEL_OFFSET;
            updateHtmlLabel({ id: 'snap-angle', content: angleText, x: angleTextX, y: angleTextY, color: currentElementColor, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
        }
    }
}

export function prepareReferenceElementsTexts(htmlOverlay, context, { showAngles, showDistances, viewTransform, mousePos, frozenReference_D_du, distanceSigFigs, angleSigFigs, angleDisplayMode, colors }, screenToData, dataToScreen, updateHtmlLabel) {
    const dataThreshold = C.REF_TEXT_SCREEN_PIXEL_THRESHOLD / viewTransform.scale;

    let previewDistance = -1;
    if (context.frozen_Origin_Data_to_display) {
        const startVertexData = context.frozen_Origin_Data_to_display;
        const mouseDataPos = screenToData(mousePos);
        previewDistance = U.distance(startVertexData, mouseDataPos);
    }

    if ((!showAngles && !showDistances) || !context.frozen_Origin_Data_to_display || previewDistance < dataThreshold) {
        return;
    }

    const refElementColor = colors.frozenReference;

    const startVertexData = context.frozen_Origin_Data_to_display;
    const turnAngleData = context.displayAngleA_valueRad_for_A_equals_label;
    const baseAngleData = context.frozen_A_baseRad_to_display !== null ? context.frozen_A_baseRad_to_display : 0;
    const distanceData = context.frozen_D_du_to_display;
    const frozenG2GSquaredSum = context.frozen_D_g2g_to_display ? context.frozen_D_g2g_to_display.g2gSquaredSum : null;
    const frozenG2GInterval = context.frozen_D_g2g_to_display ? context.frozen_D_g2g_to_display.interval : null;

    if (!startVertexData) {
        return;
    }

    const absoluteAngleForRefLine = baseAngleData + turnAngleData;
    const endVertexData = {
        x: startVertexData.x + distanceData * Math.cos(absoluteAngleForRefLine),
        y: startVertexData.y + distanceData * Math.sin(absoluteAngleForRefLine)
    };

    const startVertexScreen = dataToScreen(startVertexData);
    const endVertexScreen = dataToScreen(endVertexData);

    if (showDistances && distanceData !== null && distanceData > dataThreshold && frozenReference_D_du !== null) {
        let distanceText = '';

        if (frozenG2GSquaredSum !== null && frozenG2GSquaredSum > 0 && frozenG2GInterval) {
            const [coeff, radicand] = U.simplifySquareRoot(frozenG2GSquaredSum);
            const finalCoeff = frozenG2GInterval * coeff;
            const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
            distanceText = `${C.DELTA_EQUALS_KATEX}${U.formatSimplifiedRoot(roundedFinalCoeff, radicand)}`;
        } else {
            const platonicValue = distanceData / C.DEFAULT_REFERENCE_DISTANCE;
            distanceText = `${C.DELTA_EQUALS_KATEX}${U.formatNumber(platonicValue, distanceSigFigs)}`;
        }

        const edgeAngleScreen = Math.atan2(endVertexScreen.y - startVertexScreen.y, endVertexScreen.x - startVertexScreen.x);
        const midX_screen = (startVertexScreen.x + endVertexScreen.x) / 2;
        const midY_screen = (startVertexScreen.y + endVertexScreen.y) / 2;
        
        let rotationDeg = edgeAngleScreen * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
        if (rotationDeg > C.DEGREES_IN_QUADRANT || rotationDeg < -C.DEGREES_IN_QUADRANT) {
            rotationDeg += C.DEGREES_IN_HALF_CIRCLE;
        }
        let textPerpAngle;

        if (showAngles && turnAngleData !== null && Math.abs(turnAngleData) > C.GEOMETRY_CALCULATION_EPSILON) {
            const canvasStartAngle = -baseAngleData;
            const canvasEndAngle = -(baseAngleData + turnAngleData);
            const sumCos = Math.cos(canvasStartAngle) + Math.cos(canvasEndAngle);
            const sumSin = Math.sin(canvasStartAngle) + Math.sin(canvasEndAngle);
            const angleLabelBisectorRad = Math.atan2(sumSin, sumCos);
            const perp1 = edgeAngleScreen - Math.PI / 2;
            const perp2 = edgeAngleScreen + Math.PI / 2;
            const diff1 = Math.abs(U.normalizeAngleToPi(perp1 - angleLabelBisectorRad));
            const diff2 = Math.abs(U.normalizeAngleToPi(perp2 - angleLabelBisectorRad));
            textPerpAngle = diff1 > diff2 ? perp1 : perp2;
        } else {
            textPerpAngle = edgeAngleScreen - Math.PI / 2;
            if (Math.sin(textPerpAngle) > 0) {
                textPerpAngle += Math.PI;
            }
        }
        const textDistLabelX_D = midX_screen + Math.cos(textPerpAngle) * C.REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN;
        const textDistLabelY_D = midY_screen + Math.sin(textPerpAngle) * C.REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN;

        updateHtmlLabel({ id: 'ref-dist', content: distanceText, x: textDistLabelX_D, y: textDistLabelY_D, color: refElementColor, fontSize: C.REF_TEXT_KATEX_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle', rotation: rotationDeg } }, htmlOverlay);
    }

    if (showAngles && turnAngleData !== null && Math.abs(turnAngleData) > C.GEOMETRY_CALCULATION_EPSILON) {
        const startAngleCanvas = -baseAngleData;
        const endAngleCanvas = -(baseAngleData + turnAngleData);

        const sumCos = Math.cos(startAngleCanvas) + Math.cos(endAngleCanvas);
        const sumSin = Math.sin(startAngleCanvas) + Math.sin(endAngleCanvas);
        let bisectorCanvasAngle = Math.atan2(sumSin, sumCos);
        const angleLabelOffsetDistance = C.REF_TEXT_ANGLE_LABEL_OFFSET_SCREEN;

        const textAngleLabelX_A = startVertexScreen.x + Math.cos(bisectorCanvasAngle) * angleLabelOffsetDistance;
        const textAngleLabelY_A = startVertexScreen.y + Math.sin(bisectorCanvasAngle) * angleLabelOffsetDistance;

        let aKatexText = '';
        if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
            let aValueDeg = turnAngleData * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
            aKatexText = `${C.THETA_EQUALS_KATEX}${U.formatNumber(aValueDeg, angleSigFigs)}^{\\circ}`;
        } else if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_RADIANS) {
            let aValueRad = turnAngleData;
            aKatexText = `${C.THETA_EQUALS_KATEX}${U.formatFraction(aValueRad / Math.PI, C.FRACTION_FORMAT_TOLERANCE, C.FRACTION_FORMAT_MAX_DENOMINATOR)}${C.PI_SYMBOL_KATEX}`;
            if (aKatexText === `${C.THETA_EQUALS_KATEX}1${C.PI_SYMBOL_KATEX}`) aKatexText = C.PI_SYMBOL_KATEX;
            if (aKatexText === `${C.THETA_EQUALS_KATEX}-1${C.PI_SYMBOL_KATEX}`) aKatexText = `-${C.PI_SYMBOL_KATEX}`;
            if (aKatexText === `${C.THETA_EQUALS_KATEX}0${C.PI_SYMBOL_KATEX}`) aKatexText = "0";
        }

        updateHtmlLabel({ id: 'ref-angle', content: aKatexText, x: textAngleLabelX_A, y: textAngleLabelY_A, color: refElementColor, fontSize: C.REF_TEXT_KATEX_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function updateMouseCoordinates(htmlOverlay, { coordsDisplayMode, isMouseOverCanvas, currentShiftPressed, ghostVertexPosition, gridDisplayMode, lastGridState, angleDisplayMode, canvas, dpr, mousePos, colors, useScientific }, screenToData, updateHtmlLabel) {
    
    if (coordsDisplayMode === C.COORDS_DISPLAY_MODE_NONE || !mousePos || !isMouseOverCanvas) {
        return;
    }

    let displayPos;
    if (currentShiftPressed && ghostVertexPosition) {
        displayPos = ghostVertexPosition;
    } else {
        displayPos = screenToData(mousePos);
    }

    let effectiveGridInterval = 1;
    if (gridDisplayMode !== C.GRID_DISPLAY_MODE_NONE && lastGridState && lastGridState.interval1) {
        effectiveGridInterval = lastGridState.interval1;
    }

    // Mouse coordinates should be 1 decimal place more precise than the finest tick spacing
    let finestInterval = effectiveGridInterval;
    if (lastGridState && lastGridState.interval2 && lastGridState.interval2 < finestInterval) {
        finestInterval = lastGridState.interval2;
    }
    
    // Mouse coordinates precision based on tick interval:
    // - 10000+ → round to nearest 100 (2 fewer sig figs)
    // - 1000 → round to nearest 10 (1 fewer sig fig)  
    // - 100 → round to nearest 1 (0 decimals)
    // - 10 → 1 decimal place
    // - 1 → 2 decimal places
    // - 0.1 → 3 decimal places, etc.
    
    let mouseDecimalPlaces;
    let roundingFactor = 1;
    
    if (finestInterval >= 10000) {
        // Round to nearest 100, show as integers
        roundingFactor = 100;
        mouseDecimalPlaces = 0;
    } else if (finestInterval >= 1000) {
        // Round to nearest 10, show as integers  
        roundingFactor = 10;
        mouseDecimalPlaces = 0;
    } else if (finestInterval >= 100) {
        // Round to nearest 1, show as integers
        roundingFactor = 1;
        mouseDecimalPlaces = 0;
    } else if (finestInterval >= 10) {
        // Show 1 decimal place
        mouseDecimalPlaces = 1;
    } else {
        // For smaller intervals, add 2 more decimal places than tick precision
        const tickDecimalPlaces = Math.max(0, -Math.floor(Math.log10(finestInterval)));
        mouseDecimalPlaces = tickDecimalPlaces + 2;
    }
    
    // Calculate how many significant figures the tick interval has
    const getSignificantFigures = (value) => {
        if (value === 0) return 1;
        // For tick intervals like 100000, 10000, 1000, 100, 10, 1, 0.1, 0.01 etc.
        // These are typically 1 significant figure
        return 1;
    };
    
    const tickSigFigs = getSignificantFigures(finestInterval);
    const mouseSigFigs = tickSigFigs + 2; // Always 2 more sig figs than ticks
    
    // Format coordinates with consistent precision
    const formatCoordinate = (value) => {
        if (useScientific) {
            // For scientific notation, ensure both x and y have same decimal places in coefficient
            // Always use mouseSigFigs - 1 decimal places (since first digit is before decimal)
            const decimalPlacesInCoeff = mouseSigFigs - 1;
            const expStr = Math.abs(value).toExponential(decimalPlacesInCoeff);
            const parts = expStr.split('e');
            let coefficient = parts[0];
            let exponent = parseInt(parts[1], 10);
            const sign = value < 0 ? "-" : "";
            return `${sign}${coefficient} \\cdot 10^{${exponent}}`;
        } else {
            if (roundingFactor > 1) {
                // Only round for large intervals (≥100)
                const roundedValue = Math.round(value / roundingFactor) * roundingFactor;
                return roundedValue.toFixed(mouseDecimalPlaces);
            } else {
                // For smaller intervals, just use fixed decimal places without rounding
                return value.toFixed(mouseDecimalPlaces);
            }
        }
    };

    const angleDecimalPlaces = Math.min(mouseDecimalPlaces, C.MAX_ANGLE_DECIMAL_PLACES);
    
    let textContent = '';

    switch (coordsDisplayMode) {
        case C.COORDS_DISPLAY_MODE_REGULAR: {
            // Both x and y use the same decimal places
            let xText = formatCoordinate(displayPos.x);
            if (displayPos.x >= 0 && !xText.includes('cdot')) xText = `${C.KATEX_MINUS_PHANTOM}${xText}`;
            let yText = formatCoordinate(displayPos.y);
            if (displayPos.y >= 0 && !yText.includes('cdot')) yText = `${C.KATEX_MINUS_PHANTOM}${yText}`;
            textContent = `\\begin{pmatrix*}[r] x \\\\ y \\end{pmatrix*} = \\begin{pmatrix*}[r] ${xText} \\\\ ${yText} \\end{pmatrix*}`;
            break;
        }
        case C.COORDS_DISPLAY_MODE_COMPLEX: {
            // Both real and imaginary parts use the same decimal places
            let rePart = formatCoordinate(displayPos.x);
            if (displayPos.x >= 0 && !rePart.includes('cdot')) rePart = `${C.KATEX_MINUS_PHANTOM}${rePart}`;
            const imAbs = Math.abs(displayPos.y);
            let imPartAbs = formatCoordinate(imAbs);
            const sign = displayPos.y < 0 ? '-' : '+';
            textContent = `z = ${rePart} ${sign} ${imPartAbs}${C.IMAGINARY_UNIT_SYMBOL}`;
            break;
        }
        case C.COORDS_DISPLAY_MODE_POLAR: {
            const rValue = Math.hypot(displayPos.x, displayPos.y);
            const thetaRaw = Math.atan2(displayPos.y, displayPos.x);
            
            let rText = formatCoordinate(rValue);
            if (rValue >= 0 && !rText.includes('cdot')) rText = `${C.KATEX_MINUS_PHANTOM}${rText}`;
            let angleStr;
            if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
                let thetaDeg = U.normalizeAngleDegrees(thetaRaw * 180 / Math.PI);
                angleStr = thetaDeg.toFixed(angleDecimalPlaces);
                if (thetaDeg >= 0) angleStr = `${C.KATEX_MINUS_PHANTOM}${angleStr}`;
                angleStr += `^{\\circ}`;
            } else {
                let thetaRad = U.normalizeAngleToPi(thetaRaw);
                angleStr = thetaRad.toFixed(angleDecimalPlaces);
                if (thetaRad >= 0) angleStr = `${C.KATEX_MINUS_PHANTOM}${angleStr}`;
            }
            textContent = `\\begin{pmatrix*}[r] r \\\\ \\theta \\end{pmatrix*} = \\begin{pmatrix*}[r] ${rText} \\\\ ${angleStr} \\end{pmatrix*}`;
            break;
        }
    }

    const canvasWidth = canvas.width / dpr;
    updateHtmlLabel({ 
        id: 'mouse-coord-text', 
        content: textContent, 
        x: canvasWidth - C.UI_PADDING, 
        y: C.UI_PADDING, 
        color: colors.mouseCoords, 
        fontSize: C.MOUSE_COORD_FONT_SIZE, 
        options: { textAlign: 'right', textBaseline: 'top' } 
    });
}

export function createColorWheelIcon(size, dpr) {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = size * dpr;
    tempCanvas.height = size * dpr;
    const tempCtx = tempCanvas.getContext('2d');
    const imageData = tempCtx.createImageData(tempCanvas.width, tempCanvas.height);
    const pixels = imageData.data;
    const centerX = tempCanvas.width / 2;
    const centerY = tempCanvas.height / 2;
    const radius = tempCanvas.width / 2;
    for (let y = 0; y < tempCanvas.height; y++) {
        for (let x = 0; x < tempCanvas.width; x++) {
            const i = (y * tempCanvas.width + x) * 4;
            const dx = x - centerX;
            const dy = y - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > radius) continue;
            const hue = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
            const saturation = 100;
            const lightness = 50;
            let alpha;
            const fadeStartRadius = radius * C.COLOR_WHEEL_FADE_START_RADIUS_FACTOR;
            if (dist < fadeStartRadius) {
                alpha = 1.0;
            } else {
                const fadeDistance = radius - fadeStartRadius;
                alpha = 1.0 - ((dist - fadeStartRadius) / fadeDistance);
            }
            const [R, G, B] = U.hslToRgb(hue / 360, saturation / 100, lightness / 100);
            pixels[i] = R;
            pixels[i + 1] = G;
            pixels[i + 2] = B;
            pixels[i + 3] = Math.round(Math.max(0, alpha) * 255);
        }
    }
    tempCtx.putImageData(imageData, 0, 0);
    return tempCanvas;
}

function drawThemeIcon(ctx, rect, activeThemeName, colors) {
    ctx.save();
    const centerX = rect.x + rect.width / 2;
    const centerY = rect.y + rect.height / 2;
    const radius = rect.width / 2 * 0.6;

    ctx.strokeStyle = colors.uiIcon;
    ctx.fillStyle = colors.uiIcon;
    ctx.lineWidth = 2;

    if (activeThemeName === 'dark') {
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 0.7, 0, 2 * Math.PI);
        ctx.fill();
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * 2 * Math.PI;
            const startX = centerX + Math.cos(angle) * (radius * 0.85);
            const startY = centerY + Math.sin(angle) * (radius * 0.85);
            const endX = centerX + Math.cos(angle) * (radius * 1.1);
            const endY = centerY + Math.sin(angle) * (radius * 1.1);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
    } else {
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(centerX - 5, centerY - 3, radius, 0, 2 * Math.PI);
        ctx.fillStyle = colors.background;
        ctx.fill();
    }
    ctx.restore();
}

export function drawCoordsIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    const x_offset = 1;
    ctx.strokeStyle = colorStrong;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(2 + x_offset, 30); ctx.lineTo(30 + x_offset, 30);
    ctx.moveTo(2 + x_offset, 30); ctx.lineTo(2 + x_offset, 2);
    ctx.stroke();
    ctx.fillStyle = colorStrong;
    const vertex = { x: 16 + x_offset, y: 16 };
    let labelPos = { x: 17 + x_offset, y: 8 };
    let label = '';
    switch (mode) {
        case C.COORDS_DISPLAY_MODE_REGULAR:
            ctx.setLineDash(C.UI_ICON_DASH_PATTERN);
            ctx.beginPath();
            ctx.moveTo(vertex.x, vertex.y); ctx.lineTo(vertex.x, 30);
            ctx.moveTo(vertex.x, vertex.y); ctx.lineTo(2 + x_offset, vertex.y);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            ctx.fill();
            label = '(x,y)';
            break;
        case C.COORDS_DISPLAY_MODE_COMPLEX:
            ctx.setLineDash(C.UI_ICON_DASH_PATTERN);
            ctx.beginPath();
            ctx.moveTo(2 + x_offset, 30); ctx.lineTo(vertex.x, vertex.y);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            ctx.fill();
            label = 'x+iy';
            break;
        case C.COORDS_DISPLAY_MODE_POLAR:
            ctx.setLineDash(C.UI_ICON_DASH_PATTERN);
            ctx.beginPath();
            ctx.moveTo(2 + x_offset, 30); ctx.lineTo(vertex.x, vertex.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(2 + x_offset, 30, 8, -Math.atan2(30 - vertex.y, vertex.x - (2 + x_offset)), 0);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            ctx.fill();
            label = '(r,\\theta)';
            break;
        case C.COORDS_DISPLAY_MODE_NONE:
            break;
    }
    ctx.restore();
    if (label) {
        const labelId = 'icon-label-coords';
        const labelColor = isSelected ? colors.uiTextSelected : colors.uiTextDefault;
        updateHtmlLabel({ id: labelId, content: label, x: center.x + (labelPos.x - 16) * scale, y: center.y + (labelPos.y - 16) * scale, color: labelColor, fontSize: C.UI_ICON_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function drawAngleIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    let sizeIncrease = 0;
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    ctx.strokeStyle = colorStrong;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    const p1 = { x: 28, y: 30 };
    const p2 = { x: 4, y: 30 };
    const p3 = { x: 16, y: 8 };
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.lineTo(p3.x, p3.y);
    ctx.stroke();
    let label = '';
    let labelPos = { x: 20, y: 22 };
    if (mode !== C.ANGLE_DISPLAY_MODE_NONE) {
        ctx.beginPath();
        const angle = Math.atan2(p3.y - p2.y, p3.x - p2.x);
        ctx.arc(p2.x, p2.y, 8, angle, 0);
        ctx.stroke();
        if (mode === C.ANGLE_DISPLAY_MODE_DEGREES) {
            label = '60^\\circ';
        } else if (mode === C.ANGLE_DISPLAY_MODE_RADIANS) {
            label = '\\frac{\\pi}{3}';
            sizeIncrease = 2
        }
    }
    ctx.restore();
    if (label) {
        const labelId = 'icon-label-angles';
        const labelColor = isSelected ? colors.uiTextSelected : colors.uiTextDefault;
        updateHtmlLabel({ id: labelId, content: label, x: center.x + (labelPos.x - 16) * scale, y: center.y + (labelPos.y - 20) * scale, color: labelColor, fontSize: C.UI_ICON_LABEL_FONT_SIZE+sizeIncrease, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function drawDistanceIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    ctx.strokeStyle = colorStrong;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    ctx.beginPath();
    ctx.moveTo(2, 30);
    ctx.lineTo(30, 30);
    ctx.stroke();
    let label = '';
    let labelPos = { x: 16, y: 22 };
    if (mode === C.DISTANCE_DISPLAY_MODE_ON) {
        label = '3.14';
    }
    ctx.restore();
    if (label) {
        const labelId = 'icon-label-distances';
        const labelColor = isSelected ? colors.uiTextSelected : colors.uiTextDefault;
        updateHtmlLabel({ id: labelId, content: label, x: center.x + (labelPos.x - 16) * scale, y: center.y + (labelPos.y - 16) * scale, color: labelColor, fontSize: 12, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function drawGridIcon(ctx, rect, mode, isSelected, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    ctx.strokeStyle = colorStrong;
    ctx.fillStyle = colorStrong;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    switch (mode) {
        case C.GRID_DISPLAY_MODE_LINES:
            ctx.strokeRect(2, 2, 28, 28);
            ctx.beginPath();
            ctx.moveTo(2, 16); ctx.lineTo(30, 16);
            ctx.moveTo(16, 2); ctx.lineTo(16, 30);
            ctx.stroke();
            break;
        case C.GRID_DISPLAY_MODE_POINTS:
            ctx.strokeRect(2, 2, 28, 28);
            ctx.beginPath();
            [8, 16, 24].forEach(x => {
                [8, 16, 24].forEach(y => {
                    ctx.moveTo(x, y);
                    ctx.arc(x, y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
                });
            });
            ctx.fill();
            break;
        case C.GRID_DISPLAY_MODE_TRIANGULAR:
            ctx.strokeRect(2, 2, 28, 28);
            const triRadius = 8;
            const triCenterX = 16;
            const triCenterY = 16;
            ctx.beginPath();
            ctx.arc(triCenterX, triCenterY, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const x = triCenterX + triRadius * Math.cos(angle);
                const y = triCenterY + triRadius * Math.sin(angle);
                ctx.moveTo(x, y);
                ctx.arc(x, y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            }
            ctx.fill();
            break;
        case C.GRID_DISPLAY_MODE_POLAR:
            ctx.beginPath();
            ctx.arc(16, 16, 14, 0, C.RADIANS_IN_CIRCLE);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(16, 16, 7, 0, C.RADIANS_IN_CIRCLE);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(2, 16); ctx.lineTo(30, 16);
            ctx.moveTo(16, 2); ctx.lineTo(16, 30);
            ctx.stroke();
            break;
        case C.GRID_DISPLAY_MODE_NONE:
            ctx.strokeRect(2, 2, 28, 28);
            break;
    }
    ctx.restore();
}

export function drawDisplayIcon(ctx, icon, state, htmlOverlay, updateHtmlLabel) {
    const { coordsDisplayMode, gridDisplayMode, angleDisplayMode, distanceDisplayMode, colors } = state;
    let isSelected = false;
    switch (icon.group) {
        case 'coords':
            isSelected = coordsDisplayMode !== C.COORDS_DISPLAY_MODE_NONE;
            break;
        case 'grid':
            isSelected = gridDisplayMode !== C.GRID_DISPLAY_MODE_NONE;
            break;
        case 'angles':
            isSelected = angleDisplayMode !== C.ANGLE_DISPLAY_MODE_NONE;
            break;
        case 'distances':
            isSelected = distanceDisplayMode === C.DISTANCE_DISPLAY_MODE_ON;
            break;
    }
    const rect = { x: icon.x, y: icon.y, width: icon.width, height: icon.height };
    switch (icon.group) {
        case 'coords':
            drawCoordsIcon(ctx, rect, coordsDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);
            break;
        case 'grid':
            drawGridIcon(ctx, rect, gridDisplayMode, isSelected, colors);
            break;
        case 'angles':
            drawAngleIcon(ctx, rect, angleDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);
            break;
        case 'distances':
            drawDistanceIcon(ctx, rect, distanceDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);
            break;
    }
}

function drawUITransformationSymbols(ctx, icon, colors) {
    const screenPos = { x: icon.x + icon.width / 2, y: icon.y + icon.height / 2 };
    const radius = icon.width / 2;
    ctx.strokeStyle = colors.uiIcon;
    ctx.fillStyle = colors.uiIcon;
    ctx.setLineDash([]);
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    ctx.save();
    ctx.translate(screenPos.x, screenPos.y);

    switch (icon.type) {
        case C.TRANSFORMATION_TYPE_ROTATION: {
            const arcAngle = -Math.PI / 4;
            
            ctx.beginPath();
            ctx.arc(0, 0, radius,  arcAngle,-arcAngle);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(0, 0, radius, Math.PI+arcAngle, Math.PI-arcAngle);
            ctx.stroke();
            
            const arrowSize = radius * 0.25;
            
            const arrow1X = radius * Math.cos(arcAngle);
            const arrow1Y = radius * Math.sin(arcAngle);
            
            ctx.save();
            ctx.translate(arrow1X, arrow1Y);
            ctx.rotate(arcAngle-Math.PI/2);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, -arrowSize * 0.5);
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, arrowSize * 0.5);
            ctx.stroke();
            ctx.restore();
            
            const arrow2X = radius * Math.cos(Math.PI + arcAngle);
            const arrow2Y = radius * Math.sin(Math.PI + arcAngle);
            
            ctx.save();
            ctx.translate(arrow2X, arrow2Y);
            ctx.rotate(arcAngle+Math.PI/2);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, -arrowSize * 0.5);
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, arrowSize * 0.5);
            ctx.stroke();
            ctx.restore();
            break;
        }

        case C.TRANSFORMATION_TYPE_SCALE: {
            const lineLength = radius * 0.8;
            const arrowSize = radius * 0.25;
            
            ctx.beginPath();
            ctx.moveTo(-lineLength, 0);
            ctx.lineTo(lineLength, 0);
            ctx.moveTo(0, -lineLength);
            ctx.lineTo(0, lineLength);
            ctx.stroke();
            
            const arrowPositions = [
                { x: lineLength, y: 0, dirX: 1, dirY: 0 },
                { x: -lineLength, y: 0, dirX: -1, dirY: 0 },
                { x: 0, y: -lineLength, dirX: 0, dirY: -1 },
                { x: 0, y: lineLength, dirX: 0, dirY: 1 }
            ];
            
            arrowPositions.forEach(pos => {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize + pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize - pos.dirX * arrowSize * 0.5);
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize - pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize + pos.dirX * arrowSize * 0.5);
                ctx.stroke();
            });
            break;
        }

        case C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE: {
            const lineLength = radius * 0.8;
            const arrowSize = radius * 0.25;
            
            ctx.beginPath();
            ctx.moveTo(-lineLength / Math.sqrt(2), -lineLength / Math.sqrt(2));
            ctx.lineTo(lineLength / Math.sqrt(2), lineLength / Math.sqrt(2));
            ctx.moveTo(lineLength / Math.sqrt(2), -lineLength / Math.sqrt(2));
            ctx.lineTo(-lineLength / Math.sqrt(2), lineLength / Math.sqrt(2));
            ctx.stroke();
            
            const arrowPositions = [
                { 
                    x: lineLength / Math.sqrt(2), 
                    y: -lineLength / Math.sqrt(2), 
                    dirX: 1/Math.sqrt(2), 
                    dirY: -1/Math.sqrt(2)
                },
                { 
                    x: -lineLength / Math.sqrt(2), 
                    y: lineLength / Math.sqrt(2), 
                    dirX: -1/Math.sqrt(2), 
                    dirY: 1/Math.sqrt(2)
                }
            ];
            
            arrowPositions.forEach(pos => {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize + pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize - pos.dirX * arrowSize * 0.5);
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize - pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize + pos.dirX * arrowSize * 0.5);
                ctx.stroke();
            });
            break;
        }
    }
    ctx.restore();
}

export function drawVisibilityIcon(ctx, rect, colors) {
    const centerX = rect.x + rect.width / 2;
    const centerY = rect.y + rect.height / 2;
    const eyeWidth = rect.width * 0.6;
    const eyeHeight = rect.height * 0.3;
    
    ctx.save();
    ctx.strokeStyle = colors.uiIcon;
    ctx.fillStyle = colors.uiIcon;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    ctx.lineCap = 'round';
    
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, eyeWidth / 2, eyeHeight / 2, 0, 0, 2 * Math.PI);
    ctx.stroke();
    
    const pupilRadius = eyeHeight * 0.3;
    ctx.beginPath();
    ctx.arc(centerX, centerY, pupilRadius, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.restore();
}

function drawColorPalette(ctx, htmlOverlay, state, updateHtmlLabel) {
    const { canvasUI, colors, allColors, namedColors, colorAssignments, activeColorTargets, verticesVisible, edgesVisible, facesVisible, isDraggingColorTarget, draggedColorTargetInfo, mousePos } = state;

    const checkerboardColor1 = '#808080';
    const checkerboardColor2 = '#c0c0c0';
    
    function drawCheckerboard(rect) {
        const tileSize = rect.height / 3;
        const numCols = Math.ceil(rect.width / tileSize);
        for (let row = 0; row < 3; row++) {
            for (let col = 0; col < numCols; col++) {
                ctx.fillStyle = (row + col) % 2 === 0 ? checkerboardColor1 : checkerboardColor2;
                const tileX = rect.x + col * tileSize;
                const tileY = rect.y + row * tileSize;
                const tileWidth = Math.min(tileSize, rect.x + rect.width - tileX);
                const tileHeight = Math.min(tileSize, rect.y + rect.height - tileY);
                if (tileWidth > 0 && tileHeight > 0) ctx.fillRect(tileX, tileY, tileWidth, tileHeight);
            }
        }
    }
    
    const randomBtn = canvasUI.randomColorButton;
    if (randomBtn) {
        ctx.fillStyle = '#000000';
        ctx.fillRect(randomBtn.x, randomBtn.y, randomBtn.width, randomBtn.height);
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = C.UI_BUTTON_BORDER_WIDTH;
        ctx.strokeRect(randomBtn.x, randomBtn.y, randomBtn.width, randomBtn.height);
        const centerX = randomBtn.x + randomBtn.width / 2;
        const centerY = randomBtn.y + randomBtn.height / 2;
        const wheelRadius = randomBtn.width * 0.35;
        const segments = 8;
        for (let i = 0; i < segments; i++) {
            const angle1 = (i / segments) * 2 * Math.PI;
            const angle2 = ((i + 1) / segments) * 2 * Math.PI;
            const hue = (i / segments) * 360;
            ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, wheelRadius, angle1, angle2);
            ctx.closePath();
            ctx.fill();
        }
        ctx.fillStyle = colors.background;
        ctx.beginPath();
        ctx.arc(centerX, centerY, wheelRadius * 0.4, 0, 2 * Math.PI);
        ctx.fill();
    }

    const removeBtn = canvasUI.removeColorButton;
    if (removeBtn) {
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = C.UI_BUTTON_BORDER_WIDTH;
        ctx.strokeRect(removeBtn.x, removeBtn.y, removeBtn.width, removeBtn.height);
        ctx.beginPath();
        ctx.moveTo(removeBtn.x + C.UI_BUTTON_ICON_PADDING, removeBtn.y + removeBtn.height / 2);
        ctx.lineTo(removeBtn.x + removeBtn.width - C.UI_BUTTON_ICON_PADDING, removeBtn.y + removeBtn.height / 2);
        ctx.stroke();
    }

    canvasUI.colorSwatches.forEach((swatch) => {
        const colorItem = swatch.item;
        let hasAlpha = false;
        if (colorItem && colorItem.type === 'color') {
            const parsedColor = U.parseColor(colorItem.value);
            if (parsedColor && parsedColor.a < 1.0) hasAlpha = true;
        } else if (colorItem && colorItem.type === 'colormap') {
            if (colorItem.vertices.some(p => p.alpha !== undefined && p.alpha < 1.0)) hasAlpha = true;
        }
        if (hasAlpha) drawCheckerboard(swatch);
        if (colorItem && colorItem.type === 'colormap') {
            const gradient = ctx.createLinearGradient(swatch.x, swatch.y, swatch.x + swatch.width, swatch.y);
            colorItem.vertices.forEach(vertex => {
                let colorValue = vertex.color;
                if (typeof colorValue === 'string') colorValue = namedColors[colorValue] || [0, 0, 0];
                gradient.addColorStop(vertex.pos, `rgba(${colorValue.join(',')},${vertex.alpha || 1.0})`);
            });
            ctx.fillStyle = gradient;
        } else if (colorItem) {
            ctx.fillStyle = colorItem.value;
        }
        ctx.fillRect(swatch.x, swatch.y, swatch.width, swatch.height);
    });

    const addBtn = canvasUI.addColorButton;
    if (addBtn) {
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = C.UI_BUTTON_BORDER_WIDTH;
        ctx.strokeRect(addBtn.x, addBtn.y, addBtn.width, addBtn.height);
        ctx.beginPath();
        ctx.moveTo(addBtn.x + addBtn.width / 2, addBtn.y + C.UI_BUTTON_ICON_PADDING);
        ctx.lineTo(addBtn.x + addBtn.width / 2, addBtn.y + addBtn.height - C.UI_BUTTON_ICON_PADDING);
        ctx.moveTo(addBtn.x + C.UI_BUTTON_ICON_PADDING, addBtn.y + addBtn.height / 2);
        ctx.lineTo(addBtn.x + addBtn.width - C.UI_BUTTON_ICON_PADDING, addBtn.y + addBtn.height / 2);
        ctx.stroke();
    }

    if (canvasUI.colorTargetIcons) {
        const getIconOptions = (target) => {
            let targetColorIndex = colorAssignments[target];
            if (isDraggingColorTarget && draggedColorTargetInfo && draggedColorTargetInfo.target === target && draggedColorTargetInfo.previewColorIndex !== undefined) {
                targetColorIndex = draggedColorTargetInfo.previewColorIndex;
            }

            const colorItem = (targetColorIndex === -1) ? null : allColors[targetColorIndex];

            const options = {};
            if (target === C.COLOR_TARGET_VERTEX) {
                options.vertexState = verticesVisible ? 'filled' : 'disabled';
                if (targetColorIndex === -1) {
                    options.vertexColor = 'rgba(128, 128, 128, 1)';
                } else if (colorItem && colorItem.type === 'color') {
                    options.vertexColor = colorItem.value;
                } else if (colorItem && colorItem.type === 'colormap') {
                    options.vertexColormapItem = colorItem;
                }
            } else if (target === C.COLOR_TARGET_EDGE) {
                options.edgeState = edgesVisible ? 'solid' : 'disabled';
                if (targetColorIndex === -1) {
                    options.edgeColor = 'rgba(128, 128, 128, 1)';
                } else if (colorItem && colorItem.type === 'color') {
                    options.edgeColor = colorItem.value;
                } else if (colorItem && colorItem.type === 'colormap') {
                    options.edgeColormapItem = colorItem;
                }
            } else if (target === C.COLOR_TARGET_FACE) {
                options.faceState = facesVisible ? 'filled' : 'disabled';
                if (targetColorIndex === -1) {
                    options.faceColor = 'rgba(128, 128, 128, 1)';
                } else if (colorItem && colorItem.type === 'color') {
                    options.faceColor = colorItem.value;
                } else if (colorItem && colorItem.type === 'colormap') {
                    options.faceColormapItem = colorItem;
                }
            }
            return options;
        };

        const drawOrder = [C.COLOR_TARGET_FACE, C.COLOR_TARGET_EDGE, C.COLOR_TARGET_VERTEX];
        drawOrder.forEach(targetToDraw => {
            const icon = canvasUI.colorTargetIcons.find(i => i.target === targetToDraw);
            if (icon) {
                const isActive = activeColorTargets.includes(targetToDraw);
                const iconOptions = getIconOptions(targetToDraw);

                if (isDraggingColorTarget && draggedColorTargetInfo && draggedColorTargetInfo.target === C.COLOR_TARGET_FACE && targetToDraw === C.COLOR_TARGET_FACE) {
                    const swatchUnderMouse = canvasUI.colorSwatches.find(swatch =>
                        mousePos.x >= swatch.x && mousePos.x <= swatch.x + swatch.width &&
                        mousePos.y >= swatch.y && mousePos.y <= swatch.y + swatch.height
                    );

                    if (swatchUnderMouse && swatchUnderMouse.item.type === 'colormap') {
                        const t = U.clamp((mousePos.x - swatchUnderMouse.x) / swatchUnderMouse.width, 0, 1);
                        iconOptions.faceColor = U.sampleColormap(swatchUnderMouse.item, t);
                        iconOptions.faceState = 'filled';
                    }
                }

                drawTriangleIcon(ctx, icon, iconOptions, colors, isActive);
            }
        });
    }

    const drawnBoxesForSwatches = new Set();
    activeColorTargets.forEach(target => {
        let targetColorIndex = colorAssignments[target];
        if (isDraggingColorTarget && draggedColorTargetInfo && draggedColorTargetInfo.target === target && draggedColorTargetInfo.previewColorIndex !== undefined) {
            targetColorIndex = draggedColorTargetInfo.previewColorIndex;
        }
        
        if (targetColorIndex === -1 || drawnBoxesForSwatches.has(targetColorIndex)) return;

        const swatch = canvasUI.colorSwatches.find(s => s.index === targetColorIndex);
        if (swatch) {
            const targetsForThisSwatch = Object.keys(colorAssignments).filter(t => {
                let checkIndex = colorAssignments[t];
                if (isDraggingColorTarget && draggedColorTargetInfo && draggedColorTargetInfo.target === t && draggedColorTargetInfo.previewColorIndex !== undefined) {
                    checkIndex = draggedColorTargetInfo.previewColorIndex;
                }
                return checkIndex === swatch.index && activeColorTargets.includes(t);
            });
            const iconsForThisSwatch = canvasUI.colorTargetIcons.filter(icon => targetsForThisSwatch.includes(icon.target));

            if (iconsForThisSwatch.length > 0) {
                const minY = Math.min(...iconsForThisSwatch.map(i => i.y));
                
                ctx.strokeStyle = colors.selectionGlow;
                ctx.lineWidth = C.UI_BUTTON_BORDER_WIDTH;
                const padding = 2;
                const boxX = swatch.x - padding;
                const boxY = minY - padding;
                const boxWidth = swatch.width + (padding * 2);
                const boxHeight = (swatch.y + swatch.height) - boxY + padding;
                
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                drawnBoxesForSwatches.add(targetColorIndex);
            }
        }
    });
}

function drawColorToolbarPreview(ctx, rect, { verticesVisible, edgesVisible, facesVisible, colorAssignments, allColors }, colors) {
    const allDisabled = !verticesVisible && !edgesVisible && !facesVisible;

    const options = {
        vertexState: (verticesVisible || allDisabled) ? 'filled' : 'hidden',
        edgeState: (edgesVisible || allDisabled) ? 'solid' : 'hidden',
        faceState: (facesVisible || allDisabled) ? 'filled' : 'hidden',
        showAllDisabled: allDisabled
    };
    
    const vertexColorIndex = colorAssignments[C.COLOR_TARGET_VERTEX];
    if (vertexColorIndex !== -1) {
        const vertexColorItem = allColors[vertexColorIndex];
        if (vertexColorItem && vertexColorItem.type === 'colormap') {
            options.vertexColormapItem = vertexColorItem;
        } else if (vertexColorItem && vertexColorItem.type === 'color') {
            options.vertexColor = vertexColorItem.value;
        }
    } else {
        options.vertexColor = colors.vertex;
    }
    
    const edgeColorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
    if (edgeColorIndex !== -1) {
        const edgeColorItem = allColors[edgeColorIndex];
        if (edgeColorItem && edgeColorItem.type === 'colormap') {
            options.edgeColormapItem = edgeColorItem;
        } else if (edgeColorItem && edgeColorItem.type === 'color') {
            options.edgeColor = edgeColorItem.value;
        }
    } else {
        options.edgeColor = colors.edge;
    }
    
    const faceColorIndex = colorAssignments[C.COLOR_TARGET_FACE];
    if (faceColorIndex !== -1) {
        const faceColorItem = allColors[faceColorIndex];
        if (faceColorItem && faceColorItem.type === 'color') {
            options.faceColor = faceColorItem.value;
        } else if (faceColorItem && faceColorItem.type === 'colormap') {
            options.faceColormapItem = faceColorItem;
        }
    } else {
        options.faceColor = colors.face;
    }
    
    drawTriangleIcon(ctx, rect, options, colors);
}

function drawTriangleIcon(ctx, rect, options, colors, isActive = false) {
    const { vertexState = 'none', edgeState = 'none', faceState = 'none', faceColor, edgeColor, vertexColor: optionsVertexColor, faceColormapItem, showAllDisabled = false } = options;
    
    ctx.save();
    
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    
    const triangleSize = 26;
    const height = triangleSize * Math.sqrt(3) / 2;
    
    const vertices = [
        { x: 16, y: 16 - height / 1.5 },
        { x: 16 - triangleSize / 2, y: 16 + height / 3 },
        { x: 16 + triangleSize / 2, y: 16 + height / 3 }
    ];

    const facePath = new Path2D();
    facePath.moveTo(vertices[0].x, vertices[0].y);
    facePath.lineTo(vertices[1].x, vertices[1].y);
    facePath.lineTo(vertices[2].x, vertices[2].y);
    facePath.closePath();
    
    if (faceState === 'filled') {
        if (faceColormapItem && faceColormapItem.type === 'colormap') {
            const gradient = ctx.createLinearGradient(vertices[1].x, 0, vertices[2].x, 0);
            faceColormapItem.vertices.forEach(vertex => {
                const colorValue = vertex.color;
                const alpha = vertex.alpha !== undefined ? vertex.alpha : 1.0;
                const colorString = `rgba(${colorValue.join(',')},${alpha})`;
                gradient.addColorStop(vertex.pos, colorString);
            });
            ctx.fillStyle = gradient;
        } else {
            ctx.fillStyle = faceColor || colors.face;
        }
        ctx.fill(facePath);
    } else if (faceState === 'disabled') {
        ctx.fillStyle = '#808080';
        ctx.fill(facePath);
    }
    
    if (edgeState === 'solid' || edgeState === 'disabled') {
        ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
        ctx.setLineDash([]);
        
        const edges = [
            [vertices[0], vertices[1]],
            [vertices[1], vertices[2]],
            [vertices[2], vertices[0]]
        ];
        
        edges.forEach((edge, edgeIndex) => {
            const [start, end] = edge;
            if (options.edgeColormapItem && options.edgeColormapItem.type === 'colormap' && edgeState === 'solid') {
                const gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
                const edgeOffset = edges.length > 1 ? edgeIndex / (edges.length - 1) : 0.5;
                const startT = Math.max(0, Math.min(1, edgeOffset));
                const endT = Math.max(0, Math.min(1, edgeOffset + 0.3));
                const startColor = U.sampleColormap(options.edgeColormapItem, startT);
                const endColor = U.sampleColormap(options.edgeColormapItem, endT);
                gradient.addColorStop(0, startColor);
                gradient.addColorStop(1, endColor);
                ctx.strokeStyle = gradient;
            } else if (edgeState === 'disabled') {
                ctx.strokeStyle = '#808080';
            } else {
                ctx.strokeStyle = edgeColor || colors.edge;
            }
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
        });
    }
    
    if (vertexState === 'filled' || vertexState === 'disabled') {
        ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
        vertices.forEach((vertex, index) => {
            let currentVertexColor = optionsVertexColor || colors.vertex;
            if (options.vertexColormapItem && options.vertexColormapItem.type === 'colormap' && vertexState === 'filled') {
                const t = vertices.length > 1 ? index / (vertices.length - 1) : 0.5;
                currentVertexColor = U.sampleColormap(options.vertexColormapItem, t);
            }
            if (vertexState === 'disabled') {
                currentVertexColor = '#808080';
            }
            const vertexPath = new Path2D();
            vertexPath.moveTo(vertex.x + C.UI_ICON_VERTEX_RADIUS * 2, vertex.y);
            vertexPath.arc(vertex.x, vertex.y, C.UI_ICON_VERTEX_RADIUS * 2, 0, 2 * Math.PI);
            ctx.fillStyle = currentVertexColor;
            ctx.setLineDash([]);
            ctx.fill(vertexPath);
        });
    }

    const hasDisabledElements = vertexState === 'disabled' || edgeState === 'disabled' || faceState === 'disabled';
    
    if (showAllDisabled) {
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(2, 2);
        ctx.lineTo(30, 30);
        ctx.stroke();
    } else if (hasDisabledElements) {
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 2;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(2, 2);
        ctx.lineTo(30, 30);
        ctx.stroke();
    }
    
    ctx.restore();
}

export function drawFace(ctx, screenVertices, face, colors, dataToScreen, findVertexById) {
    if (!screenVertices || screenVertices.length < 3) return;

    ctx.save();

    // Create the path for the face first.
    ctx.beginPath();
    screenVertices.forEach((vertex, index) => {
        if (index === 0) {
            ctx.moveTo(vertex.x, vertex.y);
        } else {
            ctx.lineTo(vertex.x, vertex.y);
        }
    });
    ctx.closePath();

    if (face && face.colormapItem && face.localCoordSystem) {
        const isCycled = face.colormapItem.isCyclic === true;

        if (isCycled) {
            // --- Logic for REPEATING (Cycled) Colormaps ---
            const cacheKey = JSON.stringify(face.colormapItem.vertices);
            let patternCanvas = patternCache.get(cacheKey);

            if (!patternCanvas) {
                patternCanvas = document.createElement('canvas');
                patternCanvas.width = 256;
                patternCanvas.height = 1;
                const patternCtx = patternCanvas.getContext('2d');
                const grad = patternCtx.createLinearGradient(0, 0, 256, 0);
                
                face.colormapItem.vertices.forEach(vertex => {
                    const colorValue = vertex.color;
                    const alpha = vertex.alpha !== undefined ? vertex.alpha : 1.0;
                    let colorString = `rgba(255,255,255,${alpha})`;
                    if (typeof colorValue === 'string') {
                        colorString = colorValue;
                    } else if (Array.isArray(colorValue)) {
                        colorString = `rgba(${colorValue.join(',')},${alpha})`;
                    }
                    grad.addColorStop(vertex.pos, colorString);
                });
                
                patternCtx.fillStyle = grad;
                patternCtx.fillRect(0, 0, 256, 1);
                patternCache.set(cacheKey, patternCanvas);
            }
            
            const pattern = ctx.createPattern(patternCanvas, 'repeat');
            const origin_s = dataToScreen(face.localCoordSystem.origin);
            const unit_vec_global = U.localToGlobal({x: 1, y: 0}, face.localCoordSystem);
            const unit_vec_s = dataToScreen(unit_vec_global);
            
            const dx = unit_vec_s.x - origin_s.x;
            const dy = unit_vec_s.y - origin_s.y;
            
            const screen_dist = Math.hypot(dx, dy);
            const scale = screen_dist > 0 ? screen_dist / 256 : 0;
            
            const matrix = new DOMMatrix();
            matrix.translateSelf(origin_s.x, origin_s.y);
            matrix.rotateSelf(0, 0, -face.localCoordSystem.angle * 180 / Math.PI);
            matrix.scaleSelf(scale, scale);
            
            pattern.setTransform(matrix);
            
            ctx.fillStyle = pattern;
            ctx.fill();

        } else {
            // --- Logic for SATURATING (Regular) Colormaps ---
            const localStart = { x: 0, y: 0 };
            const localEnd = { x: 1, y: 0 };
            const globalStart = U.localToGlobal(localStart, face.localCoordSystem);
            const globalEnd = U.localToGlobal(localEnd, face.localCoordSystem);
            const screenStart = dataToScreen(globalStart);
            const screenEnd = dataToScreen(globalEnd);
            
            const gradient = ctx.createLinearGradient(screenStart.x, screenStart.y, screenEnd.x, screenEnd.y);
            face.colormapItem.vertices.forEach(vertex => {
                let colorValue = vertex.color;
                if (typeof colorValue === 'string') {
                    gradient.addColorStop(vertex.pos, colorValue);
                } else {
                    const alpha = vertex.alpha !== undefined ? vertex.alpha : 1.0;
                    gradient.addColorStop(vertex.pos, `rgba(${colorValue.join(',')},${alpha})`);
                }
            });
            ctx.fillStyle = gradient;
            ctx.fill();
        }
    } else {
        // Default solid color fill
        ctx.fillStyle = face?.color || colors.face;
        ctx.fill();
    }
    
    ctx.restore();
}



function drawVisibilityPanelIcon(ctx, icon, state, htmlOverlay, updateHtmlLabel, iconColors) {
    const {angleDisplayMode, distanceDisplayMode, colors } = state;
    
    const rect = { x: icon.x, y: icon.y, width: icon.width, height: icon.height };
    switch (icon.group) {
        case 'angles':
            drawAngleIcon(ctx, rect, angleDisplayMode, angleDisplayMode !== C.ANGLE_DISPLAY_MODE_NONE, htmlOverlay, updateHtmlLabel, colors);
            break;
        case 'distances':
            drawDistanceIcon(ctx, rect, distanceDisplayMode, distanceDisplayMode === C.DISTANCE_DISPLAY_MODE_ON, htmlOverlay, updateHtmlLabel, colors);
            break;
    }
}

function drawVisibilityPanel(ctx, htmlOverlay, state, updateHtmlLabel) {
    const { canvasUI, colorAssignments, allColors, colors } = state;

    const getColor = (target) => {
        if (!colorAssignments || !allColors) return colors.uiIcon;
        const colorIndex = colorAssignments[target];
        if (colorIndex === -1) return 'rgba(128, 128, 128, 1)';
        const item = allColors[colorIndex];
        if (!item) return colors.uiIcon;
        if (item.type === 'color') return item.value;
        return colors.uiIcon; 
    };

    const iconColors = {
        vertexColor: getColor(C.COLOR_TARGET_VERTEX),
        edgeColor: getColor(C.COLOR_TARGET_EDGE),
        faceColor: getColor(C.COLOR_TARGET_FACE)
    };

    canvasUI.visibilityIcons.forEach(icon => {
        drawVisibilityPanelIcon(ctx, icon, state, htmlOverlay, updateHtmlLabel, iconColors);
    });
}

function drawMainToolbar(ctx, htmlOverlay, state, updateHtmlLabel) {
   const { canvasUI, colors, activeThemeName, colorAssignments, allColors, verticesVisible, edgesVisible, facesVisible } = state;

   const btn = canvasUI.toolbarButton;
   ctx.strokeStyle = colors.uiDefault;
   ctx.lineWidth = C.UI_MENU_ICON_LINE_WIDTH;
   ctx.beginPath();
   for (let i = 0; i < 3; i++) {
       const lineY = btn.y + 5 + i * 10;
       ctx.moveTo(btn.x + 4, lineY);
       ctx.lineTo(btn.x + btn.width - 4, lineY);
   }
   ctx.stroke();

   const ctb = canvasUI.colorToolButton;
   if (ctb) {
       drawColorToolbarPreview(ctx, ctb, {
           verticesVisible,
           edgesVisible,
           facesVisible,
           colorAssignments,
           allColors
       }, colors);
   }

   const ttb = canvasUI.transformToolButton;
   if (ttb) {
       updateHtmlLabel({ id: 'transform-tool-label', content: C.UI_TRANSFORM_TOOL_LABEL_TEXT, x: ttb.x + ttb.width / 2, y: ttb.y + ttb.height / 2, color: colors.uiIcon, fontSize: C.UI_TRANSFORM_TOOL_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
   }

   const dtb = canvasUI.displayToolButton;
   if (dtb) {
       ctx.strokeStyle = colors.uiDefault;
       ctx.fillStyle = colors.uiDefault;
       ctx.lineWidth = C.UI_ICON_LINE_WIDTH;
       const barWidth = dtb.width - C.UI_DISPLAY_ICON_BAR_WIDTH_PADDING;
       for (let i = 0; i < 3; i++) {
           const y = dtb.y + C.UI_DISPLAY_ICON_Y_OFFSET + i * C.UI_DISPLAY_ICON_Y_SPACING;
           ctx.beginPath();
           ctx.moveTo(dtb.x + 6, y);
           ctx.lineTo(dtb.x + 6 + barWidth, y);
           ctx.stroke();
           ctx.beginPath();
           ctx.arc(dtb.x + 6 + barWidth * (i / 2), y, C.UI_DISPLAY_ICON_KNOB_RADIUS, 0, 2 * Math.PI);
           ctx.fill();
       }
   }

   const vtb = canvasUI.visibilityToolButton;
   if (vtb) {
       drawVisibilityIcon(ctx, vtb, colors);
   }

   const themeBtn = canvasUI.themeToggleButton;
   if (themeBtn) {
       drawThemeIcon(ctx, themeBtn, activeThemeName, colors);
   }
}



function drawTransformPanel(ctx, state) {
    const { canvasUI, colors } = state;
    canvasUI.transformIcons.forEach(icon => {
        drawUITransformationSymbols(ctx, icon, colors);
    });
}

function drawDisplayPanel(ctx, htmlOverlay, state, updateHtmlLabel) {
    const { canvasUI, colors, coordsDisplayMode, gridDisplayMode, angleDisplayMode, distanceDisplayMode, activeThemeName } = state;
    
    canvasUI.displayIcons.forEach(icon => {
        const rect = { x: icon.x, y: icon.y, width: icon.width, height: icon.height };
        switch (icon.group) {
            case 'coords':
                drawCoordsIcon(ctx, rect, coordsDisplayMode, coordsDisplayMode !== C.COORDS_DISPLAY_MODE_NONE, htmlOverlay, updateHtmlLabel, colors);
                break;
            case 'grid':
                drawGridIcon(ctx, rect, gridDisplayMode, gridDisplayMode !== C.GRID_DISPLAY_MODE_NONE, colors);
                break;
            case 'angles':
                drawAngleIcon(ctx, rect, angleDisplayMode, angleDisplayMode !== C.ANGLE_DISPLAY_MODE_NONE, htmlOverlay, updateHtmlLabel, colors);
                break;
            case 'distances':
                drawDistanceIcon(ctx, rect, distanceDisplayMode, distanceDisplayMode === C.DISTANCE_DISPLAY_MODE_ON, htmlOverlay, updateHtmlLabel, colors);
                break;
            case 'theme':
                drawThemeIcon(ctx, rect, activeThemeName, colors);
                break;
        }
    });
}
export function drawCanvasUI(ctx, htmlOverlay, state, updateHtmlLabel) {
    const { dpr, isToolbarExpanded, isColorPaletteExpanded, isTransformPanelExpanded, isDisplayPanelExpanded, isVisibilityPanelExpanded,
        isPlacingTransform, placingTransformType, placingSnapPos, mousePos, colors } = state;

    ctx.save();
    ctx.resetTransform();
    ctx.scale(dpr, dpr);

    if (isToolbarExpanded) {
        drawMainToolbar(ctx, htmlOverlay, state, updateHtmlLabel);
    } else {
        const btn = state.canvasUI.toolbarButton;
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = C.UI_MENU_ICON_LINE_WIDTH;
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
            const lineY = btn.y + 5 + i * 10;
            ctx.moveTo(btn.x + 4, lineY);
            ctx.lineTo(btn.x + btn.width - 4, lineY);
        }
        ctx.stroke();
    }

    if (isColorPaletteExpanded) {
        drawColorPalette(ctx, htmlOverlay, state, updateHtmlLabel);
    }
    if (isTransformPanelExpanded) {
        drawTransformPanel(ctx, state);
    }
    if (isDisplayPanelExpanded) {
        drawDisplayPanel(ctx, htmlOverlay, state, updateHtmlLabel);
    }
    if (isVisibilityPanelExpanded) {
        drawVisibilityPanel(ctx, htmlOverlay, state, updateHtmlLabel);
    }

    if (isPlacingTransform) {
        const finalDrawPos = placingSnapPos || mousePos;
        if (finalDrawPos) {
            const iconHalfSize = C.UI_GHOST_ICON_SIZE / 2;
            const ghostIcon = { type: placingTransformType, x: finalDrawPos.x - iconHalfSize, y: finalDrawPos.y - iconHalfSize, width: C.UI_GHOST_ICON_SIZE, height: C.UI_GHOST_ICON_SIZE };
            drawUITransformationSymbols(ctx, ghostIcon, colors);
        }
    }

    ctx.restore();
}

export function getIconPreviewColor(target, draggedColorTargetInfo, allColors, colors) {
    if (draggedColorTargetInfo && draggedColorTargetInfo.target === target && draggedColorTargetInfo.previewColorIndex !== undefined) {
        const colorIndex = draggedColorTargetInfo.previewColorIndex;
        if (colorIndex === -1) {
            return generateRandomColor();
        }
        const item = allColors[colorIndex];
        if (item?.type === 'color') {
            return item.value;
        } else if (item?.type === 'colormap') {
            return sampleColormap(item, 0.5);
        }
    }
    
    // Fallback to current assignment
    const colorIndex = colorAssignments[target];
    if (colorIndex === -1) {
        return 'rgba(128, 128, 128, 1)';
    }
    const item = allColors[colorIndex];
    if (!item) return colors.uiIcon;
    if (item.type === 'color') return item.value;
    return colors.uiIcon;
}

export function drawSelectedEdgeDistances(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showDistances, distanceSigFigs, colors, lastGridState, currentShiftPressed }, findVertexById, getEdgeId, dataToScreen, updateHtmlLabel, currentVertexStates = null, initialDragVertexStates = null, transformIndicatorData = null) {
    if (!showDistances || selectedEdgeIds.length === 0) return;
    
    selectedEdgeIds.forEach(edgeId => {
        const edge = allEdges.find(e => getEdgeId(e) === edgeId);
        if (edge) {
            let p1 = findVertexById(edge.id1);
            let p2 = findVertexById(edge.id2);
            
            if (currentVertexStates) {
                const p1State = currentVertexStates.find(p => p.id === edge.id1);
                const p2State = currentVertexStates.find(p => p.id === edge.id2);
                if (p1State) p1 = p1State;
                if (p2State) p2 = p2State;
            }
            
            if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
                let distanceText;
                const isTransforming = currentVertexStates && transformIndicatorData;

                if (edge.labelMode === 'exact' && edge.exactValue) {
                    const [coeff, radicand] = U.simplifySquareRoot(edge.exactValue.g2gSquaredSum);
                    let finalCoeff = edge.exactValue.gridInterval * coeff;
                    
                    // Only apply scale during a live transform preview
                    if (isTransforming && transformIndicatorData.transformType !== C.TRANSFORMATION_TYPE_ROTATION) {
                        const scale = transformIndicatorData.snappedScaleValue !== null ? transformIndicatorData.snappedScaleValue : transformIndicatorData.scale;
                        finalCoeff *= scale;
                    }
                    
                    distanceText = U.formatSimplifiedRoot(parseFloat(finalCoeff.toFixed(10)), radicand);
                } else {
                    // For 'decimal' mode or if data is missing, calculate the length
                    distanceText = U.formatNumber(U.distance(p1, p2), distanceSigFigs);
                }
                
                const p1Screen = dataToScreen(p1);
                const p2Screen = dataToScreen(p2);
                const midX = (p1Screen.x + p2Screen.x) / 2;
                const midY = (p1Screen.y + p2Screen.y) / 2;
                const edgeAngleScreen = Math.atan2(p2Screen.y - p1Screen.y, p2Screen.x - p1Screen.x);
                
                let textPerpAngle = edgeAngleScreen - Math.PI / 2;
                if (Math.sin(textPerpAngle) > 0) {
                    textPerpAngle += Math.PI;
                }
                
                const distanceTextX = midX + Math.cos(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                const distanceTextY = midY + Math.sin(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                
                let rotationDeg = edgeAngleScreen * (180 / Math.PI);
                if (rotationDeg > 90 || rotationDeg < -90) {
                    rotationDeg += 180;
                }
                
                updateHtmlLabel({ 
                    id: `selected-edge-dist-${edgeId}`, 
                    content: distanceText, 
                    x: distanceTextX, 
                    y: distanceTextY, 
                    color: `rgba(${colors.feedbackDefault.join(',')}, 1.0)`, 
                    fontSize: C.FEEDBACK_LABEL_FONT_SIZE, 
                    options: { textAlign: 'center', textBaseline: 'middle', rotation: rotationDeg } 
                });
            }
        }
    });
}

export function drawSelectionRectangle(ctx, startPos, currentPos, colors) {
    ctx.save();
    ctx.strokeStyle = colors.mouseCoords;
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
    ctx.setLineDash(C.DASH_PATTERN);

    const rX = Math.min(startPos.x, currentPos.x);
    const rY = Math.min(startPos.y, currentPos.y);
    const rW = Math.abs(startPos.x - currentPos.x);
    const rH = Math.abs(startPos.y - currentPos.y);

    ctx.strokeRect(rX, rY, rW, rH);
    ctx.restore();
}

export function drawDragFeedback(ctx, htmlOverlay, targetVertexId, currentVertexStates, { lastGridState, showDistances, showAngles, distanceSigFigs, angleDisplayMode, angleSigFigs, currentShiftPressed, viewTransform, colors }, dataToScreen, findNeighbors, getEdgeId, isSnapping = false, excludedEdgeId = null, updateHtmlLabel = null, selectedVertexIds = [], isDragging = false, initialDragVertexStates = [], activeCenterId = null) {
    const feedbackColor = isSnapping ? colors.feedbackSnapped : `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;

    const liveVertices = new Map(currentVertexStates.map(p => [p.id, { ...p }]));
    const getLiveVertex = (id) => liveVertices.get(id);

    const vertex = getLiveVertex(targetVertexId);
    if (!vertex) return;

    const neighbors = findNeighbors(vertex.id).map(getLiveVertex).filter(Boolean);
    const vertexScreen = dataToScreen(vertex);
    const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

    const isVertexOnGrid = (vertex, interval) => {
        if (!vertex || !interval || interval <= 0) return false;
        const epsilon = interval * 1e-6;
        const isOnGridX = Math.abs(vertex.x / interval - Math.round(vertex.x / interval)) < epsilon;
        const isOnGridY = Math.abs(vertex.y / interval - Math.round(vertex.y / interval)) < epsilon;
        return isOnGridX && isOnGridY;
    };

    const allNeighborsAreDragged = neighbors.every(n => selectedVertexIds.includes(n.id));
    const originalVertexState = initialDragVertexStates.find(p => p.id === targetVertexId);

    if (!activeCenterId && isDragging && currentShiftPressed && allNeighborsAreDragged && originalVertexState && U.distance(originalVertexState, vertex) > C.GEOMETRY_CALCULATION_EPSILON) {
        const p1Screen = dataToScreen(originalVertexState);
        const p2Screen = vertexScreen;
        const dragVectorAngle = Math.atan2(p2Screen.y - p1Screen.y, p2Screen.x - p1Screen.x);

        if (showDistances) {
            let distText;
            const dragStartedOnGrid = gridInterval && isVertexOnGrid(originalVertexState, gridInterval);
            const dragEndedOnGrid = gridInterval && isVertexOnGrid(vertex, gridInterval);
            if (dragStartedOnGrid && dragEndedOnGrid) {
                const deltaX = vertex.x - originalVertexState.x;
                const deltaY = vertex.y - originalVertexState.y;
                const dx_grid = Math.round(deltaX / gridInterval);
                const dy_grid = Math.round(deltaY / gridInterval);
                const g2gSquaredSumForDisplay = dx_grid * dx_grid + dy_grid * dy_grid;
                if (g2gSquaredSumForDisplay === 0) {
                    distText = '0';
                } else {
                    const [coeff, radicand] = U.simplifySquareRoot(g2gSquaredSumForDisplay);
                    const finalCoeff = gridInterval * coeff;
                    const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                    distText = U.formatSimplifiedRoot(roundedFinalCoeff, radicand);
                }
            } else {
                distText = U.formatNumber(U.distance(originalVertexState, vertex), distanceSigFigs);
            }
            const midX = (p1Screen.x + p2Screen.x) / 2;
            const midY = (p1Screen.y + p2Screen.y) / 2;
            let textPerpAngle = dragVectorAngle - Math.PI / 2;
            if (Math.sin(textPerpAngle) > 0) {
                textPerpAngle += Math.PI;
            }
            const distanceTextX = midX + Math.cos(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
            const distanceTextY = midY + Math.sin(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
            let rotationDeg = dragVectorAngle * (180 / Math.PI);
            if (rotationDeg > 90 || rotationDeg < -90) {
                rotationDeg += 180;
            }
            updateHtmlLabel({ id: `drag-dist-vector-${vertex.id}`, content: distText, x: distanceTextX, y: distanceTextY, color: feedbackColor, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle', rotation: rotationDeg } }, htmlOverlay);
        }

        ctx.save();
        ctx.setLineDash(C.DASH_PATTERN);
        ctx.strokeStyle = feedbackColor;
        ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
        ctx.beginPath();
        ctx.moveTo(p1Screen.x, p1Screen.y);
        ctx.lineTo(p2Screen.x, p2Screen.y);
        ctx.stroke();
        ctx.restore();
        
        if (showAngles && Math.abs(dragVectorAngle) > C.GEOMETRY_CALCULATION_EPSILON) {
            const dataAngle = Math.atan2(vertex.y - originalVertexState.y, vertex.x - originalVertexState.x);
            drawAngleArc(ctx, p1Screen, 0, dataAngle, C.FEEDBACK_ARC_RADIUS_SCREEN, feedbackColor);
            
            let angleText;
            if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
                angleText = `${U.formatNumber(dataAngle * (180 / Math.PI), angleSigFigs)}^{\\circ}`;
            } else {
                angleText = U.formatNumber(dataAngle, angleSigFigs);
            }

            if (angleText) {
                const bisectorAngle = -dataAngle / 2.0;
                const angleLabelScreenPos = {
                    x: p1Screen.x + C.ANGLE_LABEL_RADIUS_SCREEN * Math.cos(bisectorAngle),
                    y: p1Screen.y + C.ANGLE_LABEL_RADIUS_SCREEN * Math.sin(bisectorAngle)
                };
                updateHtmlLabel({ id: `drag-angle-vector-${vertex.id}`, content: angleText, x: angleLabelScreenPos.x, y: angleLabelScreenPos.y, color: feedbackColor, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
            }
        }
    }
    
    if (showDistances) {
        neighbors.forEach(neighbor => {
            const isNeighborSelected = selectedVertexIds.includes(neighbor.id);
            if (!isDragging || !isNeighborSelected) {
                const p1 = vertex;
                const p2 = neighbor;
                const edgeId = getEdgeId({ id1: p1.id, id2: p2.id });
                let distanceText;
                const areBothVerticesOnGrid = gridInterval && isVertexOnGrid(p1, gridInterval) && isVertexOnGrid(p2, gridInterval);

                if (areBothVerticesOnGrid) {
                    const deltaX = p1.x - p2.x;
                    const deltaY = p1.y - p2.y;
                    const dx_grid = Math.round(deltaX / gridInterval);
                    const dy_grid = Math.round(deltaY / gridInterval);
                    const g2gSquaredSumForDisplay = dx_grid * dx_grid + dy_grid * dy_grid;
                    if (g2gSquaredSumForDisplay === 0) {
                        distanceText = '0';
                    } else {
                        const [coeff, radicand] = U.simplifySquareRoot(g2gSquaredSumForDisplay);
                        const finalCoeff = gridInterval * coeff;
                        const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                        distanceText = U.formatSimplifiedRoot(roundedFinalCoeff, radicand);
                    }
                } else {
                    const edgeLength = U.distance(p1, p2);
                    distanceText = U.formatNumber(edgeLength, distanceSigFigs);
                }
                
                const p1Screen = dataToScreen(p1);
                const p2Screen = dataToScreen(p2);
                const midX = (p1Screen.x + p2Screen.x) / 2;
                const midY = (p1Screen.y + p2Screen.y) / 2;
                const edgeAngleScreen = Math.atan2(p2Screen.y - p1Screen.y, p2Screen.x - p1Screen.x);
                
                let textPerpAngle = edgeAngleScreen - Math.PI / 2;
                if (Math.sin(textPerpAngle) > 0) {
                    textPerpAngle += Math.PI;
                }
                
                const distanceTextX = midX + Math.cos(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                const distanceTextY = midY + Math.sin(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                
                let rotationDeg = edgeAngleScreen * (180 / Math.PI);
                if (rotationDeg > 90 || rotationDeg < -90) {
                    rotationDeg += 180;
                }
                
                updateHtmlLabel({ 
                    id: `drag-dist-${edgeId}`, 
                    content: distanceText, 
                    x: distanceTextX, 
                    y: distanceTextY, 
                    color: feedbackColor, 
                    fontSize: C.FEEDBACK_LABEL_FONT_SIZE, 
                    options: { textAlign: 'center', textBaseline: 'middle', rotation: rotationDeg } 
                });
            }
        });
    }
    
    if (showAngles && neighbors.length >= 2 && (!isDragging || neighbors.some(n => !selectedVertexIds.includes(n.id)))) {
        const sortedNeighbors = [...neighbors].sort((a, b) => {
            const angleA = Math.atan2(a.y - vertex.y, a.x - vertex.x);
            const angleB = Math.atan2(b.y - vertex.y, b.x - vertex.x);
            return angleA - angleB;
        });

        for (let i = 0; i < sortedNeighbors.length; i++) {
            const p1 = sortedNeighbors[i];
            const p2 = sortedNeighbors[(i + 1) % sortedNeighbors.length];
            
            const p1IsSelected = selectedVertexIds.includes(p1.id);
            const p2IsSelected = selectedVertexIds.includes(p2.id);
            const angleIsChanging = !isDragging || !p1IsSelected || !p2IsSelected;
            
            if (!angleIsChanging) continue;
            
            const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };
            const v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };
            const angle1_data = Math.atan2(v1.y, v1.x);
            const angle2_data = Math.atan2(v2.y, v2.x);
            let angleToDisplayRad = angle2_data - angle1_data;
            if (angleToDisplayRad < 0) {
                angleToDisplayRad += 2 * Math.PI;
            }
            if (angleToDisplayRad < C.GEOMETRY_CALCULATION_EPSILON) continue;
            
            const bisectorAngle = angle1_data + (angleToDisplayRad / 2);
            ctx.save();
            ctx.strokeStyle = feedbackColor;
            ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
            ctx.beginPath();
            ctx.arc(vertexScreen.x, vertexScreen.y, C.FEEDBACK_ARC_RADIUS_SCREEN, -angle1_data, -angle2_data, false);
            ctx.stroke();
            ctx.restore();

            let angleText;
            if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
                angleText = `${U.formatNumber(angleToDisplayRad * (180 / Math.PI), angleSigFigs)}^{\\circ}`;
            } else if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_RADIANS) {
                if (currentShiftPressed) {
                    angleText = U.formatFraction(angleToDisplayRad / Math.PI, 0.015, 32) + "\\pi";
                    if (angleText.startsWith(`1\\pi`)) angleText = "\\pi";
                    if (angleText.startsWith(`-1\\pi`)) angleText = `-\\pi`;
                    if (angleText === `0\\pi`) angleText = "0";
                } else {
                    angleText = U.formatNumber(angleToDisplayRad, angleSigFigs);
                }
            }

            if (angleText) {
                const angleLabelDataPos = {
                    x: vertex.x + (C.ANGLE_LABEL_RADIUS_SCREEN / viewTransform.scale) * Math.cos(bisectorAngle),
                    y: vertex.y + (C.ANGLE_LABEL_RADIUS_SCREEN / viewTransform.scale) * Math.sin(bisectorAngle)
                };
                const angleLabelScreenPos = dataToScreen(angleLabelDataPos);
                const labelId = `drag-angle-${vertex.id}-${p1.id}-${p2.id}`;
                updateHtmlLabel({ id: labelId, content: angleText, x: angleLabelScreenPos.x, y: angleLabelScreenPos.y, color: feedbackColor, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
            }
        }
    }
}

export function drawSelectedEdgeAngles(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showAngles, angleSigFigs, angleDisplayMode, currentShiftPressed, distanceSigFigs, viewTransform, lastGridState, colors }, findVertexById, getEdgeId, dataToScreen, findNeighbors, updateHtmlLabel) {
    if (!showAngles || selectedEdgeIds.length === 0) return;
    
    selectedEdgeIds.forEach(edgeId => {
        const edge = allEdges.find(e => getEdgeId(e) === edgeId);
        if (edge) {
            const p1 = findVertexById(edge.id1);
            const p2 = findVertexById(edge.id2);
            if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
                const feedbackState = {
                    lastGridState,
                    showDistances: false,
                    showAngles: true,
                    distanceSigFigs,
                    angleDisplayMode,
                    angleSigFigs,
                    currentShiftPressed,
                    viewTransform,
                    colors
                };
                
                drawDragFeedback(ctx, htmlOverlay, p1.id, [p1, p2], feedbackState, dataToScreen, findNeighbors, getEdgeId, false, null, updateHtmlLabel);
                drawDragFeedback(ctx, htmlOverlay, p2.id, [p1, p2], feedbackState, dataToScreen, findNeighbors, getEdgeId, false, null, updateHtmlLabel);
            }
        }
    });
}

export function drawFaceCoordinateSystems(ctx, { allFaces, selectedFaceIds, colors, isDragConfirmed, dragPreviewVertices, initialDragVertexStates, transformIndicatorData, highlightedEdgeForSnap, draggedFaceId, coordSystemSnapAngle, coordSystemSnapType, coordSystemSnapScale, initialCoordSystemStates }, dataToScreen, findVertexById) {
    if (selectedFaceIds.length > C.MAX_FACES_FOR_COORDS) return;

    const facesToDraw = new Set(selectedFaceIds);
    if (facesToDraw.size === 0) return;

    facesToDraw.forEach(faceId => {
        const face = allFaces.find(f => f.id === faceId);
        if (!face || !face.localCoordSystem) return;

        let systemToDraw = face.localCoordSystem;

        if (isDragConfirmed && face.vertexIds.some(vid => dragPreviewVertices.some(pv => pv.id === vid))) {
            const initialSystem = initialCoordSystemStates.get(face.id);
            systemToDraw = calculatePreviewCoordSystem(face, { initialSystem, dragPreviewVertices, initialDragVertexStates, findVertexById, transformIndicatorData });
        }
        
        if (draggedFaceId === faceId && coordSystemSnapAngle !== null) {
            const getLiveVertex = (vertexId) => {
                if (isDragConfirmed && dragPreviewVertices) {
                    const previewVertex = dragPreviewVertices.find(p => p && p.id === vertexId);
                    if (previewVertex) return previewVertex;
                }
                return findVertexById(vertexId);
            };

            const originScreen = dataToScreen(systemToDraw.origin);
            
            if (coordSystemSnapType === 'edge' && highlightedEdgeForSnap !== null) {
                const faceVertices = face.vertexIds.map(id => getLiveVertex(id)).filter(p => p && p.type === 'regular');
                if (highlightedEdgeForSnap < faceVertices.length) {
                    const edgeStart = faceVertices[highlightedEdgeForSnap];
                    const edgeEnd = faceVertices[(highlightedEdgeForSnap + 1) % faceVertices.length];
                    const startScreen = dataToScreen(edgeStart);
                    const endScreen = dataToScreen(edgeEnd);
                    
                    ctx.save();
                    ctx.strokeStyle = colors.feedbackSnapped;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(startScreen.x, startScreen.y);
                    ctx.lineTo(endScreen.x, endScreen.y);
                    ctx.stroke();
                    ctx.restore();
                }
            } else if (coordSystemSnapType === 'cardinal') {
                const lineLength = 100;
                const lineEndX = originScreen.x + Math.cos(-coordSystemSnapAngle) * lineLength;
                const lineEndY = originScreen.y + Math.sin(-coordSystemSnapAngle) * lineLength;
                const lineStartX = originScreen.x - Math.cos(-coordSystemSnapAngle) * lineLength;
                const lineStartY = originScreen.y - Math.sin(-coordSystemSnapAngle) * lineLength;
                
                ctx.save();
                ctx.strokeStyle = colors.feedbackSnapped;
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(lineStartX, lineStartY);
                ctx.lineTo(lineEndX, lineEndY);
                ctx.stroke();
                ctx.restore();
            }
        }

        drawCoordinateSystemCross(ctx, systemToDraw, colors, dataToScreen, coordSystemSnapScale);
    });
}

function drawCoordinateSystemCross(ctx, coordSystem, colors, dataToScreen, coordSystemSnapScale = null) {
    const centerScreen = dataToScreen(coordSystem.origin);

    const xAxisEndGlobal = U.localToGlobal({ x: 1, y: 0 }, coordSystem);
    const yAxisEndGlobal = U.localToGlobal({ x: 0, y: 1 }, coordSystem);
    const xAxisScreenEnd = dataToScreen(xAxisEndGlobal);
    const yAxisScreenEnd = dataToScreen(yAxisEndGlobal);

    ctx.save();
    ctx.lineWidth = C.SELECTION_GLOW_LINE_WIDTH;
    ctx.lineCap = 'round';

    const drawArrow = (p1, p2, lineColor, arrowColor) => {
        // Draw line
        ctx.strokeStyle = lineColor;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();

        // Draw arrowhead
        ctx.fillStyle = arrowColor;
        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
        ctx.beginPath();
        ctx.moveTo(p2.x, p2.y);
        ctx.lineTo(p2.x - C.AXIS_ARROW_SIZE * Math.cos(angle - C.AXIS_ARROW_ANGLE_RAD), p2.y - C.AXIS_ARROW_SIZE * Math.sin(angle - C.AXIS_ARROW_ANGLE_RAD));
        ctx.lineTo(p2.x - C.AXIS_ARROW_SIZE * Math.cos(angle + C.AXIS_ARROW_ANGLE_RAD), p2.y - C.AXIS_ARROW_SIZE * Math.sin(angle + C.AXIS_ARROW_ANGLE_RAD));
        ctx.closePath();
        ctx.fill();
    };

    // Determine arrow colors based on snap state
    const xArrowColor = coordSystemSnapScale !== null ? colors.feedbackSnapped : '#ff0000'; // Red for x-axis
    const yArrowColor = coordSystemSnapScale !== null ? colors.feedbackSnapped : '#00ff00'; // Green for y-axis

    drawArrow(centerScreen, xAxisScreenEnd, '#ff0000', xArrowColor);
    drawArrow(centerScreen, yAxisScreenEnd, '#00ff00', yArrowColor);

    // The center vertex for grabbing (blue dot)
    ctx.fillStyle = '#0000ff';
    ctx.beginPath();
    ctx.arc(centerScreen.x, centerScreen.y, 4, 0, 2 * Math.PI);
    ctx.fill();

    ctx.restore();
}


=== script.js ===
import ColormapSelector from './node_modules/colormap-selector/ColormapSelector.js';
import './node_modules/colormap-selector/styles.css';

console.log('🚀 Script.js loaded at:', new Date().toLocaleTimeString());

import * as C from './constants.js';
import * as U from './utils.js';
import * as R from './renderer.js';

const canvas = document.getElementById('drawingCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const htmlOverlay = document.getElementById('html-overlay');
const dpr = window.devicePixelRatio || 1;
const activeHtmlLabels = new Map();
let colorEditor;
const canvasUI = {
    toolbarButton: null,
    mainToolbar: null,
    colorToolButton: null,
    colorSwatches: [],
    addColorButton: null,
    transformToolButton: null,
    transformIcons: [],
    displayToolButton: null,
    displayIcons: [],
    themeToggleButton: null,
    symmetryToolButton: null,
    symmetryIcons: []
};

let contextMenu;
let contextMenuVertexId = null;
let contextMenuEdgeId = null;
let contextMenuFaceId = null;


let initialCoordSystemStateOnDrag = null;
let initialCoordSystemStates = new Map();
let coordSystemTransformIndicatorData = null;
let highlightedEdgeForSnap = null;
let coordSystemSnapAngle = null;
let draggedFaceId = null;
let coordSystemSnapType = null;
let coordSystemSnapScale = null;

let isDraggingColorTarget = false;
let draggedColorTargetInfo = null;

let currentDrawingPath = [];
let frozenReference_A_rad = null;
let frozenReference_A_baseRad = null;
let frozenReference_D_du = null;
let frozenReference_Origin_Data = null;
let isMouseOverCanvas = false;
let placingSnapPos = null;
let isDisplayPanelExpanded = false;
let isVisibilityPanelExpanded = false;
let coordsDisplayMode = 'regular';
let gridDisplayMode = 'lines';
let angleDisplayMode = 'degrees';
let distanceDisplayMode = 'on';
let verticesVisible = true;
let edgesVisible = true;
let facesVisible = true;

let hoveredVertexId = null;
let hoveredEdgeId = null;
let hoveredFaceId = null;
let isEdgeTransformDrag = false;
let isDraggingCenter = false;
let allVertices = [];
let allEdges = [];
let allFaces = [];
let selectedVertexIds = [];
let selectedEdgeIds = [];
let selectedFaceIds = [];
let activeCenterId = null;
let mousePos = { x: 0, y: 0 };

let frozenReference_D_g2g = null;
let isToolbarExpanded = false;
let isColorPaletteExpanded = false;
let isEditingColor = false;
let editingColorIndex = null;
let isTransformPanelExpanded = false;
let isPlacingTransform = false;
let placingTransformType = null;
let drawingSequence = [];
let currentSequenceIndex = 0;
let showAngles = true;
let showDistances = true;
let angleSigFigs = 4;
let distanceSigFigs = 3;
let gridAlpha = 0.5;
let transformIndicatorData = null;
let isActionInProgress = false;
let isDragConfirmed = false;
let isPanningBackground = false;
let isRectangleSelecting = false;
let currentMouseButton = -1;
let actionStartPos = { x: 0, y: 0 };
let backgroundPanStartOffset = { x: 0, y: 0 };
let initialDragVertexStates = [];
let rectangleSelectStartPos = { x: 0, y: 0 };
let actionContext = null;
let allColors = C.DEFAULT_RECENT_COLORS;
let isDrawingMode = false;
let previewLineStartVertexId = null;
let actionTargetVertex = null;
let dragPreviewVertices = [];
let currentShiftPressed = false;
let clipboard = { vertices: [], edges: [], faces: [], referenceVertex: null };
let clickData = { targetId: null, type: null, count: 0, timestamp: 0 };
let undoStack = [];

function setupUndoStackDebugging() {
    const originalPop = Array.prototype.pop;
    const originalPush = Array.prototype.push;
    const originalShift = Array.prototype.shift;
    const originalSplice = Array.prototype.splice;

    undoStack.pop = function() {
        const result = originalPop.call(this);
        return result;
    };

    undoStack.push = function(...args) {
        const result = originalPush.call(this, ...args);
        return result;
    };

    undoStack.shift = function() {
        const result = originalShift.call(this);
        return result;
    };

    undoStack.splice = function(...args) {
        const result = originalSplice.call(this, ...args);
        return result;
    };
}

// In script.js (near the other state variables)

let isMouseOverColorEditor = false;
let redoStack = [];
let ghostVertexPosition = null;
let selectedCenterIds = [];
let copyCountInput = '';
let copyCountTimer = null;
let ghostVertices = [];
let currentAccumulatedRotation = 0;
let lastGridState = {
    interval1: null,
    interval2: null,
    alpha1: 0,
    alpha2: 0,
    scale: null
};
let viewTransform = {
    scale: C.DEFAULT_CALIBRATION_VIEW_SCALE,
    offsetX: 0,
    offsetY: 0
};
let lastAngularGridState = {
    angle1: 30,
    angle2: 15,
    alpha1: 1,
    alpha2: 0,
};
let labelsToKeepThisFrame = new Set();
let activeThemeName = 'dark';

let activeColorTargets = [];
let isDraggingColorSwatch = false;
let draggedSwatchInfo = null;

let colorAssignments = {
    [C.COLOR_TARGET_VERTEX]: 0,
    [C.COLOR_TARGET_EDGE]: 1,
    [C.COLOR_TARGET_FACE]: 2,
};

let isDraggingCoordSystem = false;
let draggedCoordSystemElement = null;
let coordSystemSnapTargets = null;

let deletedFaceIds = new Set(); // Track explicitly deleted faces
let draggedSwatchTemporarilyRemoved = false;


function ensureFaceCoordinateSystems() {
    U.updateFaceLocalCoordinateSystems(allFaces, findVertexById);
}

function createFaceWithCoordinateSystem(vertexIds) {
    const newFace = {
        id: U.getFaceId({ vertexIds }),
        vertexIds: vertexIds,
        localCoordSystem: null,
        color: getColorForTarget(C.COLOR_TARGET_FACE)
    };

    if (!allFaces.some(f => f.id === newFace.id)) {
        allFaces.push(newFace);
    }

    ensureFaceCoordinateSystems();
    return newFace;
}

function getColors() {
    const theme = U.getCurrentTheme(activeThemeName, C.BASE_THEME);
    return theme;
}

function generateRandomColor() {
    const r = Math.floor(Math.random() * 256);
    const g = Math.floor(Math.random() * 256);
    const b = Math.floor(Math.random() * 256);
    const a = Math.random() * 0.8 + 0.2;
    return `rgba(${r}, ${g}, ${b}, ${a.toFixed(2)})`;
}

function getColorForTarget(targetType, index = 0, total = 1) {
    const colorIndex = colorAssignments[targetType];
    if (colorIndex === -1) {
        return generateRandomColor();
    }
    const item = allColors[colorIndex];
    if (item?.type === 'color') {
        return item.value;
    } else if (item?.type === 'colormap') {
        const t = total > 1 ? index / (total - 1) : 0.5;
        return U.sampleColormap(item, t);
    }
    
    const colors = getColors();
    if (targetType === C.COLOR_TARGET_VERTEX) return colors.vertex;
    if (targetType === C.COLOR_TARGET_EDGE) return colors.edge;
    if (targetType === C.COLOR_TARGET_FACE) return colors.face;
    
    return colors.vertex;
}

function applyColormapToEdge(edge, index = 0, total = 1) {
    const colorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
    if (colorIndex === -1) {
        edge.color = generateRandomColor();
        return;
    }
    
    const colorItem = allColors[colorIndex];
    if (colorItem && colorItem.type === 'colormap') {
        const startT = total > 1 ? index / total : 0;
        const endT = total > 1 ? (index + 1) / total : 1;
        edge.gradientStart = startT;
        edge.gradientEnd = endT;
        edge.colormapItem = colorItem;
        delete edge.colormapOffset;
        delete edge.color;
    } else if (colorItem && colorItem.type === 'color') {
        edge.color = colorItem.value;
        delete edge.gradientStart;
        delete edge.gradientEnd;
        delete edge.colormapItem;
        delete edge.colormapOffset;
    } else {
        edge.color = getColors().edge;
        delete edge.gradientStart;
        delete edge.gradientEnd;
        delete edge.colormapItem;
        delete edge.colormapOffset;
    }
}

function applyColorsToSelection() {

    activeColorTargets.forEach(target => {
        const colorIndex = colorAssignments[target];
        if (colorIndex === -1 && target !== C.COLOR_TARGET_VERTEX) {
            return;
        }

        if (target === C.COLOR_TARGET_VERTEX) {
            const colorItem = allColors[colorIndex];
            if (colorItem && colorItem.type === 'colormap') {
                const verticesToColor = selectedVertexIds.map(id => findVertexById(id)).filter(p => p && p.type === 'regular');
                verticesToColor.forEach((vertex, index) => {
                    const t = verticesToColor.length > 1 ? index / (verticesToColor.length - 1) : 0.5;
                    vertex.color = U.sampleColormap(colorItem, t);
                });
            } else {
                selectedVertexIds.forEach(id => {
                    const vertex = findVertexById(id);
                    if (vertex && vertex.type === 'regular') {
                        vertex.color = getColorForTarget(C.COLOR_TARGET_VERTEX);
                    }
                });
            }
        } else if (target === C.COLOR_TARGET_EDGE) {
            const colorItem = allColors[colorIndex];
            if (colorItem && colorItem.type === 'colormap') {
                selectedEdgeIds.forEach((edgeId, index) => {
                    const edge = allEdges.find(e => U.getEdgeId(e) === edgeId);
                    if (edge) {
                        const totalEdges = selectedEdgeIds.length;
                        const startT = totalEdges > 1 ? index / totalEdges : 0;
                        const endT = totalEdges > 1 ? (index + 1) / totalEdges : 1;
                        edge.gradientStart = startT;
                        edge.gradientEnd = endT;
                        edge.colormapItem = colorItem;
                        delete edge.color;
                    }
                });
            } else {
                const color = getColorForTarget(C.COLOR_TARGET_EDGE);
                allEdges.forEach(edge => {
                    if (selectedEdgeIds.includes(U.getEdgeId(edge))) {
                        edge.color = color;
                        delete edge.gradientStart;
                        delete edge.gradientEnd;
                        delete edge.colormapItem;
                    }
                });
            }
        } else if (target === C.COLOR_TARGET_FACE) {
            const colorIndex = colorAssignments[target];
            if (colorIndex === -1) {
                const color = getColorForTarget(C.COLOR_TARGET_FACE);
                allFaces.forEach(face => {
                    if (selectedFaceIds.includes(U.getFaceId(face))) {
                        face.color = color;
                        delete face.colormapItem;
                        delete face.colormapDistribution;
                    }
                });
            } else {
                const colorItem = allColors[colorIndex];
                if (colorItem && colorItem.type === 'colormap') {
                    allFaces.forEach(face => {
                        if (selectedFaceIds.includes(U.getFaceId(face))) {
                            face.colormapItem = colorItem;
                            face.colormapDistribution = 'x'; // Default to x-direction
                            delete face.color;
                        }
                    });
                } else {
                    const color = getColorForTarget(C.COLOR_TARGET_FACE);
                    allFaces.forEach(face => {
                        if (selectedFaceIds.includes(U.getFaceId(face))) {
                            face.color = color;
                            delete face.colormapItem;
                            delete face.colormapDistribution;
                        }
                    });
                }
            }
        }
    });
}

function invertVertexColors() {
    allVertices.forEach(vertex => {
        if (vertex.type === C.VERTEX_TYPE_REGULAR) {
            if (vertex.color) {
                vertex.color = U.invertGrayscaleValue(vertex.color);
            } else {
                vertex.color = getColors().vertex;
            }
        }
    });
}

function updateHtmlLabel({ id, content, x, y, color, fontSize, options = {} }) {
    labelsToKeepThisFrame.add(id);
    let el = activeHtmlLabels.get(id);

    if (!el) {
        el = document.createElement('div');
        el.style.position = 'absolute';
        el.style.fontFamily = 'KaTeX_Main, Times New Roman, serif';
        el.style.whiteSpace = 'nowrap';
        htmlOverlay.appendChild(el);
        activeHtmlLabels.set(id, el);
    }

    let transform = '';
    if (options.textAlign === 'center') {
        transform += ' translateX(-50%)';
    } else if (options.textAlign === 'right') {
        transform += ' translateX(-100%)';
    }

    if (options.textBaseline === 'middle') {
        transform += ' translateY(-50%)';
    } else if (options.textBaseline === 'bottom') {
        transform += ' translateY(-100%)';
    }

    if (options.rotation !== undefined) {
        transform += ` rotate(${options.rotation}deg)`;
    }

    el.style.transform = transform.trim();
    el.style.left = `${x}px`;
    el.style.top = `${y}px`;
    el.style.color = color;
    el.style.fontSize = `${fontSize}px`;

    if (el.katexContent !== content) {
        if (typeof window.katex !== 'undefined') {
            katex.render(content, el, {
                throwOnError: false,
                displayMode: false
            });
        } else {
            el.textContent = content.replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, "$1/$2").replace(/[\\{}]/g, "");
        }
        el.katexContent = content;
    }
}

function cleanupHtmlLabels() {
    for (const [id, el] of activeHtmlLabels.entries()) {
        if (!labelsToKeepThisFrame.has(id)) {
            el.remove();
            activeHtmlLabels.delete(id);
        }
    }
}

function handleCenterSelection(centerId, shiftKey, ctrlKey) {
    if (ctrlKey) {
        const index = selectedCenterIds.indexOf(centerId);
        if (index > -1) {
            selectedCenterIds.splice(index, 1);
            if (activeCenterId === centerId) {
                activeCenterId = selectedCenterIds.length > 0 ? selectedCenterIds[selectedCenterIds.length - 1] : null;
            }
        } else {
            selectedCenterIds.push(centerId);
            activeCenterId = centerId;
        }
    } else if (shiftKey) {
        if (!selectedCenterIds.includes(centerId)) {
            selectedCenterIds.push(centerId);
            activeCenterId = centerId;
        }
    } else {
        selectedCenterIds = [centerId];
        activeCenterId = centerId;
    }
}

function getDeformingSnapPosition(dragOrigin, mouseDataPos, selectedVertexIds) {
    const snapStickinessData = C.SNAP_STICKINESS_RADIUS_SCREEN / viewTransform.scale;
    const unselectedNeighbors = U.findNeighbors(dragOrigin.id, allEdges)
        .map(id => findVertexById(id))
        .filter(p => p && !selectedVertexIds.includes(p.id));

    const candidates = [];
    const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

    const pointGeometries = [];
    const pathGeometries = [];

    if (gridInterval) {
        U.getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true).forEach(p => pointGeometries.push(p));
    }
    allVertices.forEach(p => {
        if (p.id !== dragOrigin.id && p.type === 'regular' && !unselectedNeighbors.some(n => n.id === p.id)) {
            pointGeometries.push(p);
        }
    });

    if (unselectedNeighbors.length === 2) {
        const n1 = unselectedNeighbors[0];
        const n2 = unselectedNeighbors[1];
        
        pathGeometries.push({ type: 'line', data: U.getPerpendicularBisector(n1, n2), snapType: 'isosceles' });

        const originalAngle = U.computeAngle(n1, dragOrigin, n2);
        const anglePreservingCircle = U.findCircleFromPointsAndAngle(n1, n2, originalAngle, dragOrigin);
        if (anglePreservingCircle) pathGeometries.push({ type: 'circle', data: anglePreservingCircle, snapType: 'angle_preservation' });
        
        const allSnapAngles = new Set();
        C.NINETY_DEG_ANGLE_SNAP_FRACTIONS.forEach(f => {
            for (let i = 1; i <= 24; i++) {
                const angle = U.normalizeAngle((f * Math.PI / 2) * i);
                if (angle > C.GEOMETRY_CALCULATION_EPSILON && angle < C.RADIANS_IN_CIRCLE - C.GEOMETRY_CALCULATION_EPSILON) {
                    allSnapAngles.add(parseFloat(angle.toFixed(7)));
                }
            }
        });
        allSnapAngles.forEach(angle => {
            const circle = U.findCircleFromPointsAndAngle(n1, n2, angle, dragOrigin);
            if (circle) pathGeometries.push({ type: 'circle', data: circle, snapType: 'fixed_angle' });
        });
        
        const sideLength = U.distance(n1, n2);
        pathGeometries.push({ type: 'circle', data: { center: n1, radius: sideLength }, snapType: 'equal_distance' });
        pathGeometries.push({ type: 'circle', data: { center: n2, radius: sideLength }, snapType: 'equal_distance' });

        if (gridInterval) {
            for (let i = 1; i <= 30; i++) {
                const radius = i * gridInterval * 0.5;
                pathGeometries.push({ type: 'circle', data: { center: n1, radius }, snapType: 'grid_distance' });
                pathGeometries.push({ type: 'circle', data: { center: n2, radius }, snapType: 'grid_distance' });
            }
        }
    }

    pointGeometries.forEach(p => {
        candidates.push({ type: 'point', pos: p, dist: U.distance(mouseDataPos, p), source: p });
    });
    
    pathGeometries.forEach(geom => {
        let closestPointOnPath, distToMouse;
        if (geom.type === 'line') {
            const closest = U.getClosestPointOnLine(mouseDataPos, geom.data.p1, geom.data.p2);
            closestPointOnPath = { x: closest.x, y: closest.y };
            distToMouse = closest.distance;
        } else {
            const vectorToMouse = { x: mouseDataPos.x - geom.data.center.x, y: mouseDataPos.y - geom.data.center.y };
            const mag = Math.hypot(vectorToMouse.x, vectorToMouse.y);
            if (mag < C.GEOMETRY_CALCULATION_EPSILON) {
                closestPointOnPath = { x: geom.data.center.x + geom.data.radius, y: geom.data.center.y };
            } else {
                closestPointOnPath = {
                    x: geom.data.center.x + vectorToMouse.x / mag * geom.data.radius,
                    y: geom.data.center.y + vectorToMouse.y / mag * geom.data.radius
                };
            }
            distToMouse = U.distance(mouseDataPos, closestPointOnPath);
        }
        candidates.push({ type: geom.type, pos: closestPointOnPath, dist: distToMouse, source: geom.data, snapType: geom.snapType });
    });

    if (candidates.length === 0) return { pos: mouseDataPos, snapped: false };
    
    candidates.sort((a, b) => a.dist - b.dist);
    const bestPrimaryCandidate = candidates[0];

    if (bestPrimaryCandidate.dist > snapStickinessData) {
        return { pos: mouseDataPos, snapped: false };
    }
    
    let finalSnapPos = bestPrimaryCandidate.pos;
    
    if ((bestPrimaryCandidate.type === 'line' || bestPrimaryCandidate.type === 'circle') && unselectedNeighbors.length === 2) {
        const primaryPath = bestPrimaryCandidate.source;
        const secondarySnapPoints = [];

        pathGeometries.forEach(otherGeom => {
            if (otherGeom.data === primaryPath) return;
            
            if (bestPrimaryCandidate.type === 'line') {
                if (otherGeom.type === 'line') {
                    const int = U.getLineLineIntersection(primaryPath, otherGeom.data);
                    if (int) secondarySnapPoints.push(int);
                } else {
                    secondarySnapPoints.push(...U.getLineCircleIntersection(primaryPath, otherGeom.data));
                }
            } else {
                if (otherGeom.type === 'line') {
                    secondarySnapPoints.push(...U.getLineCircleIntersection(otherGeom.data, primaryPath));
                } else {
                    secondarySnapPoints.push(...U.getCircleCircleIntersection(primaryPath, otherGeom.data));
                }
            }
        });
        
        pointGeometries.forEach(p => {
            if (U.distance(p, finalSnapPos) < snapStickinessData * 2) {
                if(bestPrimaryCandidate.type === 'line') {
                    secondarySnapPoints.push(U.getClosestPointOnLine(p, primaryPath.p1, primaryPath.p2));
                } else {
                    const vec = { x: p.x - primaryPath.center.x, y: p.y - primaryPath.center.y };
                    const mag = Math.hypot(vec.x, vec.y);
                    if (mag > C.GEOMETRY_CALCULATION_EPSILON) {
                        secondarySnapPoints.push({
                            x: primaryPath.center.x + vec.x / mag * primaryPath.radius,
                            y: primaryPath.center.y + vec.y / mag * primaryPath.radius
                        });
                    }
                }
            }
        });

        if (secondarySnapPoints.length > 0) {
            let minSecondaryDist = Infinity;
            let bestSecondarySnap = null;
            secondarySnapPoints.forEach(candidate => {
                const dist = U.distance(finalSnapPos, candidate);
                if (dist < minSecondaryDist) {
                    minSecondaryDist = dist;
                    bestSecondarySnap = candidate;
                }
            });

            if (bestSecondarySnap && minSecondaryDist < (snapStickinessData / 2.0)) {
                finalSnapPos = bestSecondarySnap;
            }
        }
    }

    return { pos: finalSnapPos, snapped: true, snapType: bestPrimaryCandidate.snapType || bestPrimaryCandidate.type };
}

function getBestSnapPosition(mouseDataPos) {
    const candidates = U.getGridSnapCandidates(mouseDataPos, gridDisplayMode, lastGridState.interval1, lastAngularGridState, true);

    allVertices.forEach(p => {
        if (p.type === 'regular') {
            candidates.push({ x: p.x, y: p.y, isGridVertex: false });
        }
    });

    allEdges.forEach(edge => {
        const p1 = findVertexById(edge.id1);
        const p2 = findVertexById(edge.id2);
        if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
            const midvertex = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2, isGridVertex: false };
            candidates.push(midvertex);
        }
    });

    if (candidates.length === 0) {
        return null;
    }

    const distanceSq = (p1, p2) => (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;

    return candidates.reduce((best, current) => {
        const bestDist = distanceSq(mouseDataPos, best);
        const currentDist = distanceSq(mouseDataPos, current);
        return currentDist < bestDist ? current : best;
    });
}

export function getSnappedPosition(startVertex, mouseScreenPos, shiftPressed, isDragContext = false, overrideContext = null) {
    const mouseDataPos = screenToData(mouseScreenPos);
    const drawingContext = overrideContext || getDrawingContext(startVertex.id);

    if (!shiftPressed) {
        const candidates = [];
        const vertexSelectRadiusData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;
        for (const p of allVertices) {
            if (p.id !== startVertex.id && p.type === "regular" && U.distance(mouseDataPos, p) < vertexSelectRadiusData) {
                candidates.push({ priority: 1, dist: U.distance(mouseDataPos, p), pos: { x: p.x, y: p.y }, snapType: 'vertex', targetVertex: p });
            }
        }
        const edgeClickThresholdData = C.EDGE_CLICK_THRESHOLD / viewTransform.scale;
        for (const edge of allEdges) {
            const p1 = findVertexById(edge.id1);
            const p2 = findVertexById(edge.id2);
            if (p1 && p2 && p1.type === "regular" && p2.type === "regular") {
                const closest = U.getClosestPointOnLineSegment(mouseDataPos, p1, p2);
                if (closest.distance < edgeClickThresholdData && closest.onSegmentStrict) {
                    candidates.push({ priority: 2, dist: closest.distance, pos: { x: closest.x, y: closest.y }, snapType: 'edge', targetEdge: edge });
                }
            }
        }

        if (candidates.length > 0) {
            candidates.sort((a, b) => {
                if (a.priority !== b.priority) return a.priority - b.priority;
                return a.dist - b.dist;
            });
            const bestCandidate = candidates[0];
            const finalAngleRad = Math.atan2(bestCandidate.pos.y - startVertex.y, bestCandidate.pos.x - startVertex.x) || 0;
            return {
                ...bestCandidate.pos,
                angle: finalAngleRad * (180 / Math.PI),
                distance: U.distance(startVertex, bestCandidate.pos),
                snapped: true,
                snapType: bestCandidate.snapType,
                targetEdge: bestCandidate.targetEdge,
                targetVertex: bestCandidate.targetVertex,
                gridSnapped: false,
                lengthSnapFactor: null,
                angleSnapFactor: null,
                angleTurn: U.normalizeAngleToPi(finalAngleRad - drawingContext.offsetAngleRad),
                gridToGridSquaredSum: null,
                gridInterval: null
            };
        }

        const finalAngleRad = Math.atan2(mouseDataPos.y - startVertex.y, mouseDataPos.x - startVertex.x) || 0;
        return {
            x: mouseDataPos.x, y: mouseDataPos.y,
            angle: finalAngleRad * (180 / Math.PI),
            distance: U.distance(startVertex, mouseDataPos),
            snapped: false, gridSnapped: false, lengthSnapFactor: null, angleSnapFactor: null,
            angleTurn: U.normalizeAngleToPi(finalAngleRad - drawingContext.offsetAngleRad),
            gridToGridSquaredSum: null, gridInterval: null
        };
    }

    const highPriorityCandidates = [];
    const vertexSelectRadiusData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;
    for (const p of allVertices) {
        if (p.id !== startVertex.id && p.type === "regular" && U.distance(mouseDataPos, p) < vertexSelectRadiusData) {
            highPriorityCandidates.push({ priority: 1, dist: U.distance(mouseDataPos, p), pos: { x: p.x, y: p.y }, snapType: 'vertex', targetVertex: p });
        }
    }
    const edgeClickThresholdData = C.EDGE_CLICK_THRESHOLD / viewTransform.scale;
    for (const edge of allEdges) {
        const p1 = findVertexById(edge.id1);
        const p2 = findVertexById(edge.id2);
        if (p1 && p2 && p1.type === "regular" && p2.type === "regular") {
            const closest = U.getClosestPointOnLineSegment(mouseDataPos, p1, p2);
            if (closest.distance < edgeClickThresholdData && closest.onSegmentStrict) {
                highPriorityCandidates.push({ priority: 2, dist: closest.distance, pos: { x: closest.x, y: closest.y }, snapType: 'edge', targetEdge: edge });
            }
        }
    }

    if (highPriorityCandidates.length > 0) {
        highPriorityCandidates.sort((a, b) => {
            if (a.priority !== b.priority) return a.priority - b.priority;
            return a.dist - b.dist;
        });
        const bestCandidate = highPriorityCandidates[0];
        const finalAngleRad = Math.atan2(bestCandidate.pos.y - startVertex.y, bestCandidate.pos.x - startVertex.x) || 0;
        return {
            ...bestCandidate.pos,
            angle: finalAngleRad * (180 / Math.PI),
            distance: U.distance(startVertex, bestCandidate.pos),
            snapped: true,
            snapType: bestCandidate.snapType,
            targetEdge: bestCandidate.targetEdge,
            targetVertex: bestCandidate.targetVertex,
            gridSnapped: false,
            lengthSnapFactor: null,
            angleSnapFactor: null,
            angleTurn: U.normalizeAngleToPi(finalAngleRad - drawingContext.offsetAngleRad),
            gridToGridSquaredSum: null,
            gridInterval: null
        };
    }

    const unselectedNeighbors = U.findNeighbors(startVertex.id, allEdges)
        .map(id => findVertexById(id))
        .filter(p => p && p.type === 'regular' && !selectedVertexIds.includes(p.id));

    const isDeformingDrag = isDragContext && unselectedNeighbors.length > 0;

    if (isDeformingDrag) {
        const allSnapVertices = [];

        const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        if (gridDisplayMode !== 'none' && gridInterval) {
            const gridVertices = U.getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true);
            gridVertices.forEach(p => allSnapVertices.push({ pos: p, type: 'grid' }));
        }

        allVertices.forEach(p => {
            if (p.id !== startVertex.id && p.type === 'regular') {
                allSnapVertices.push({ pos: p, type: 'vertex' });
            }
        });

        const getPerpendicularBisector = (p1, p2) => {
            const midVertex = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            const perpVector = { x: -(p2.y - p1.y), y: p2.x - p1.x };
            return { p1: midVertex, p2: { x: midVertex.x + perpVector.x * C.BISECTOR_LINE_EXTENSION_FACTOR, y: midVertex.y + perpVector.y * C.BISECTOR_LINE_EXTENSION_FACTOR } };
        };

        for (let i = 0; i < unselectedNeighbors.length; i++) {
            for (let j = i + 1; j < unselectedNeighbors.length; j++) {
                const n1 = unselectedNeighbors[i];
                const n2 = unselectedNeighbors[j];
                const bisector = getPerpendicularBisector(n1, n2);

                if (gridInterval) {
                    const maxDist = U.distance(startVertex, mouseDataPos) + gridInterval * 10;
                    for (let d = gridInterval * 0.5; d < maxDist; d += gridInterval * 0.5) {
                        const intersections = U.getLineCircleIntersection(bisector, { center: n1, radius: d });
                        intersections.forEach(p => allSnapVertices.push({ pos: p, type: 'equidistant_grid_dist' }));
                    }
                }

                const distN1N2 = U.distance(n1, n2);
                if (distN1N2 > C.GEOMETRY_CALCULATION_EPSILON) {
                    const midvertex = { x: (n1.x + n2.x) / 2, y: (n1.y + n2.y) / 2 };
                    const bisectorDir = U.normalize({ x: -(n2.y - n1.y), y: n2.x - p1.x });

                    const snapAnglesRad = C.NINETY_DEG_ANGLE_SNAP_FRACTIONS.map(f => f * Math.PI / 2);
                    snapAnglesRad.forEach(alpha => {
                        if (alpha > 0 && alpha < Math.PI) {
                            const h = (distN1N2 / 2) / Math.tan(alpha / 2);
                            const p1 = { x: midvertex.x + h * bisectorDir.x, y: midvertex.y + h * bisectorDir.y };
                            const p2 = { x: midvertex.x - h * bisectorDir.x, y: midvertex.y - h * bisectorDir.y };
                            allSnapVertices.push({ pos: p1, type: 'equidistant_angle' });
                            allSnapVertices.push({ pos: p2, type: 'equidistant_angle' });
                        }
                    });
                }
            }
        }

        if (unselectedNeighbors.length >= 3) {
            for (let i = 0; i < unselectedNeighbors.length; i++) {
                for (let j = i + 1; j < unselectedNeighbors.length; j++) {
                    for (let k = j + 1; k < unselectedNeighbors.length; k++) {
                        const n1 = unselectedNeighbors[i];
                        const n2 = unselectedNeighbors[j];
                        const n3 = unselectedNeighbors[k];
                        const bisector1 = getPerpendicularBisector(n1, n2);
                        const bisector2 = getPerpendicularBisector(n2, n3);
                        const circumcenter = U.getLineLineIntersection(bisector1, bisector2);
                        if (circumcenter) {
                            allSnapVertices.push({ pos: circumcenter, type: 'circumcenter' });
                        }
                    }
                }
            }
        }

        if (allSnapVertices.length === 0) {
            const finalAngleRad = Math.atan2(mouseDataPos.y - startVertex.y, mouseDataPos.x - startVertex.x) || 0;
            return {
                x: mouseDataPos.x, y: mouseDataPos.y,
                angle: finalAngleRad * (180 / Math.PI), distance: U.distance(startVertex, mouseDataPos),
                snapped: false
            };
        }

        const bestCandidate = allSnapVertices.reduce((best, current) => {
            const currentDist = U.distance(mouseDataPos, current.pos);
            const bestDist = best.pos ? U.distance(mouseDataPos, best.pos) : Infinity;
            return currentDist < bestDist ? current : best;
        }, { pos: null });

        const finalPos = bestCandidate.pos;
        const finalAngle = Math.atan2(finalPos.y - startVertex.y, finalPos.x - startVertex.x) || 0;
        return {
            x: finalPos.x,
            y: finalPos.y,
            angle: finalAngle * (180 / Math.PI),
            distance: U.distance(startVertex, finalPos),
            snapped: true,
            snapType: bestCandidate.type,
            gridSnapped: bestCandidate.type === 'grid',
            lengthSnapFactor: null,
            angleSnapFactor: null,
            angleTurn: U.normalizeAngleToPi(finalAngle - drawingContext.offsetAngleRad),
            gridToGridSquaredSum: null,
            gridInterval: null,
        };

    } else {
        const allShiftCandidates = [];

        const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        if (gridDisplayMode !== 'none' && gridInterval) {
            const gridVertices = U.getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true);
            gridVertices.forEach(p => allShiftCandidates.push({ pos: p, isGridVertexSnap: true, type: 'grid' }));
        }

        const referenceAngleForSnapping = drawingContext.currentSegmentReferenceA_for_display;
        const baseUnitDistance = drawingContext.currentSegmentReferenceD;
        const symmetricalAngleFractions = new Set([0, ...C.NINETY_DEG_ANGLE_SNAP_FRACTIONS.flatMap(f => [f, -f])]);
        const sortedSymmetricalFractions = Array.from(symmetricalAngleFractions).sort((a, b) => a - b);
        const allSnapAngles = sortedSymmetricalFractions.map(f => ({ factor: f, angle: U.normalizeAngleToPi(drawingContext.offsetAngleRad + (f * referenceAngleForSnapping)), turn: U.normalizeAngleToPi(f * referenceAngleForSnapping) }));
        const allSnapDistances = [];
        for (let i = 0; i <= C.DRAW_SNAP_DISTANCE_FACTOR_LIMIT / C.DRAW_SNAP_DISTANCE_FACTOR_STEP; i++) {
            const factor = i * C.DRAW_SNAP_DISTANCE_FACTOR_STEP;
            allSnapDistances.push({ factor: factor, dist: factor * baseUnitDistance });
        }

        if (allSnapAngles.length > 0 && allSnapDistances.length > 0) {
            for (const angleData of allSnapAngles) {
                for (const distData of allSnapDistances) {
                    const pos = { x: startVertex.x + distData.dist * Math.cos(angleData.angle), y: startVertex.y + distData.dist * Math.sin(angleData.angle) };
                    allShiftCandidates.push({
                        pos: pos,
                        isGridVertexSnap: false,
                        type: 'geometric',
                        lengthSnapFactor: distData.factor,
                        angleSnapFactor: angleData.factor,
                        angleTurn: angleData.turn
                    });
                }
            }
        }

        if (allShiftCandidates.length > 0) {
            const bestOverallCandidate = allShiftCandidates.reduce((best, current) => {
                const currentDist = U.distance(mouseDataPos, current.pos);
                const bestDist = best.pos ? U.distance(mouseDataPos, best.pos) : Infinity;
                return currentDist < bestDist ? current : best;
            }, { pos: null });

            const finalAngle = Math.atan2(bestOverallCandidate.pos.y - startVertex.y, bestOverallCandidate.pos.x - startVertex.x) || 0;
            const snappedDistanceOutput = parseFloat(U.distance(startVertex, bestOverallCandidate.pos).toFixed(10));
            let gridToGridSquaredSum = null;
            let finalGridInterval = null;

            if (bestOverallCandidate.isGridVertexSnap && gridDisplayMode !== 'polar') {
                const currentGridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
                const epsilon = currentGridInterval * C.GEOMETRY_CALCULATION_EPSILON;
                const isVertexOnGrid = (vertex, interval) => Math.abs(vertex.x / interval - Math.round(vertex.x / interval)) < epsilon && Math.abs(vertex.y / interval - Math.round(vertex.y / interval)) < epsilon;
                if (isVertexOnGrid(startVertex, currentGridInterval)) {
                    const deltaX = bestOverallCandidate.pos.x - startVertex.x;
                    const deltaY = bestOverallCandidate.pos.y - startVertex.y;
                    const dx_grid = Math.round(deltaX / currentGridInterval);
                    const dy_grid = Math.round(deltaY / currentGridInterval);
                    gridToGridSquaredSum = dx_grid * dx_grid + dy_grid * dy_grid;
                    finalGridInterval = currentGridInterval;
                }
            }

            let finalAngleTurn = bestOverallCandidate.angleTurn != null ? bestOverallCandidate.angleTurn : U.normalizeAngleToPi(finalAngle - drawingContext.offsetAngleRad);

            return {
                x: parseFloat(bestOverallCandidate.pos.x.toFixed(10)),
                y: parseFloat(bestOverallCandidate.pos.y.toFixed(10)),
                angle: finalAngle * (180 / Math.PI),
                distance: snappedDistanceOutput,
                snapped: true,
                gridSnapped: !!bestOverallCandidate.isGridVertexSnap,
                snapType: bestOverallCandidate.isGridVertexSnap ? 'grid' : 'geometric',
                lengthSnapFactor: bestOverallCandidate.lengthSnapFactor || null,
                angleSnapFactor: bestOverallCandidate.angleSnapFactor || null,
                angleTurn: finalAngleTurn,
                gridToGridSquaredSum: gridToGridSquaredSum,
                gridInterval: finalGridInterval,
            };
        }

        const finalAngleRad = Math.atan2(mouseDataPos.y - startVertex.y, mouseDataPos.x - startVertex.x) || 0;
        return {
            x: mouseDataPos.x, y: mouseDataPos.y,
            angle: finalAngleRad * (180 / Math.PI),
            distance: U.distance(startVertex, mouseDataPos),
            snapped: false, gridSnapped: false, lengthSnapFactor: null, angleSnapFactor: null,
            angleTurn: U.normalizeAngleToPi(finalAngleRad - drawingContext.offsetAngleRad),
            gridToGridSquaredSum: null, gridInterval: null
        };
    }
}

function invertColors() {
    allColors = allColors.map(colorItem => {
        if (colorItem.type === 'color') {
            return { ...colorItem, value: U.invertGrayscaleValue(colorItem.value) };
        }
        return colorItem;
    });
}

function initializeCanvasUI() {
    canvasUI.toolbarButton = {
        id: "toolbar-button",
        x: C.UI_BUTTON_PADDING,
        y: C.UI_BUTTON_PADDING,
        width: C.MENU_BUTTON_WIDTH,
        height: C.MENU_BUTTON_HEIGHT,
        type: "menuButton"
    };
}

function buildTransformPanelUI() {
    canvasUI.transformIcons = [];
    const panelX = C.UI_TOOLBAR_WIDTH + C.UI_BUTTON_PADDING;
    const iconY = canvasUI.transformToolButton.y;
    const iconSize = C.TRANSFORM_ICON_SIZE;
    const iconPadding = C.TRANSFORM_ICON_PADDING;
    const transformTypes = [
        C.TRANSFORMATION_TYPE_ROTATION,
        C.TRANSFORMATION_TYPE_SCALE,
        C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE
    ];

    transformTypes.forEach((type, index) => {
        canvasUI.transformIcons.push({
            id: `transform-icon-${type}`,
            type: type,
            x: panelX + index * (iconSize + iconPadding),
            y: iconY + C.TRANSFORM_ICON_Y_OFFSET,
            width: iconSize,
            height: iconSize
        });
    });
}

function buildColorPaletteUI() {
    canvasUI.colorSwatches = [];
    canvasUI.colorTargetIcons = [];
    const paletteY = canvasUI.colorToolButton.y;

    let currentX = C.UI_TOOLBAR_WIDTH + C.UI_BUTTON_PADDING;

    canvasUI.removeColorButton = {
        id: "remove-color-button",
        type: "button",
        x: currentX,
        y: paletteY + C.COLOR_PALETTE_Y_OFFSET,
        width: C.UI_SWATCH_SIZE,
        height: C.UI_SWATCH_SIZE,
    };
    currentX += C.UI_SWATCH_SIZE + C.UI_BUTTON_PADDING;

    allColors.forEach((item, index) => {
        const swatchWidth = (item.type === 'colormap')
            ? (C.UI_SWATCH_SIZE * 3) + (C.UI_BUTTON_PADDING * 2)
            : C.UI_SWATCH_SIZE;

        canvasUI.colorSwatches.push({
            id: `swatch-${index}`,
            type: "colorSwatch",
            x: currentX,
            y: paletteY + C.COLOR_PALETTE_Y_OFFSET,
            width: swatchWidth,
            height: C.UI_SWATCH_SIZE,
            index: index,
            item: item
        });
        currentX += swatchWidth + C.UI_BUTTON_PADDING;
    });

    const addButtonX = currentX;
    canvasUI.addColorButton = {
        id: "add-color-button",
        type: "button",
        x: addButtonX,
        y: paletteY + C.COLOR_PALETTE_Y_OFFSET,
        width: C.UI_SWATCH_SIZE,
        height: C.UI_SWATCH_SIZE,
    };

    Object.entries(colorAssignments).forEach(([target, colorIndex]) => {
        const iconSize = C.UI_SWATCH_SIZE * 0.75;
        let swatch;
        if (colorIndex >= 0 && colorIndex < allColors.length) {
            swatch = canvasUI.colorSwatches.find(s => s.index === colorIndex);
        } else {
            // If color is unassigned (-1), point to the remove/random button area
            swatch = canvasUI.removeColorButton;
        }

        if (swatch) {
            canvasUI.colorTargetIcons.push({
                id: `target-icon-${target}`,
                target: target,
                x: swatch.x + (swatch.width - iconSize) / 2,
                y: swatch.y - iconSize - 5,
                width: iconSize,
                height: iconSize
            });
        }
    });
}

function removeColorAtIndex(indexToRemove) {
    if (indexToRemove < 0 || indexToRemove >= allColors.length || allColors.length <= 1) {
        return;
    }

    allColors.splice(indexToRemove, 1);

    Object.keys(colorAssignments).forEach(target => {
        if (colorAssignments[target] > indexToRemove) {
            colorAssignments[target]--;
        } else if (colorAssignments[target] === indexToRemove) {
            colorAssignments[target] = Math.min(indexToRemove, allColors.length - 1);
        }
    });

    buildColorPaletteUI();
}

function buildVisibilityPanelUI() {
    canvasUI.visibilityIcons = [];
    if (!canvasUI.visibilityToolButton) return;

    const panelX = C.UI_TOOLBAR_WIDTH + C.UI_BUTTON_PADDING;
    const iconY = canvasUI.visibilityToolButton.y;
    const iconSize = C.DISPLAY_ICON_SIZE;
    const iconPadding = C.DISPLAY_ICON_PADDING;

    const iconGroups = ['angles', 'distances'];

    iconGroups.forEach((group, index) => {
        canvasUI.visibilityIcons.push({
            id: `visibility-icon-${group}`,
            group: group,
            x: panelX + index * (iconSize + iconPadding),
            y: iconY,
            width: iconSize,
            height: iconSize
        });
    });
}

function buildMainToolbarUI() {
    const canvasHeight = canvas.height / dpr;
    canvasUI.mainToolbar = {
        id: "main-toolbar-bg",
        x: 0,
        y: 0,
        width: C.UI_TOOLBAR_WIDTH,
        height: canvasHeight,
        type: "toolbar"
    };

    canvasUI.colorToolButton = {
        id: "color-tool-button",
        type: "toolButton",
        x: C.UI_BUTTON_PADDING,
        y: canvasUI.toolbarButton.y + canvasUI.toolbarButton.height + C.TOOLBAR_SECTION_GAP,
        width: C.UI_TOOLBAR_WIDTH - (2 * C.UI_BUTTON_PADDING),
        height: C.TOOL_BUTTON_HEIGHT,
    };

    canvasUI.transformToolButton = {
        id: "transform-tool-button",
        type: "toolButton",
        x: C.UI_BUTTON_PADDING,
        y: canvasUI.colorToolButton.y + canvasUI.colorToolButton.height + C.UI_BUTTON_PADDING,
        width: C.UI_TOOLBAR_WIDTH - (2 * C.UI_BUTTON_PADDING),
        height: C.TOOL_BUTTON_HEIGHT,
    };

    canvasUI.visibilityToolButton = {
        id: "visibility-tool-button",
        type: "toolButton",
        x: C.UI_BUTTON_PADDING,
        y: canvasUI.transformToolButton.y + canvasUI.transformToolButton.height + C.UI_BUTTON_PADDING,
        width: C.UI_TOOLBAR_WIDTH - (2 * C.UI_BUTTON_PADDING),
        height: C.TOOL_BUTTON_HEIGHT,
    };
}

function handleDisplayPanelClick(screenPos) {
    if (isDisplayPanelExpanded) {
        for (const icon of canvasUI.displayIcons) {
            if (screenPos.x >= icon.x && screenPos.x <= icon.x + icon.width &&
                screenPos.y >= icon.y && screenPos.y <= icon.y + icon.height) {
                switch (icon.group) {
                    case 'coords':
                        const coordsModes = [C.COORDS_DISPLAY_MODE_NONE, C.COORDS_DISPLAY_MODE_REGULAR, C.COORDS_DISPLAY_MODE_COMPLEX, C.COORDS_DISPLAY_MODE_POLAR];
                        coordsDisplayMode = coordsModes[(coordsModes.indexOf(coordsDisplayMode) + 1) % coordsModes.length];
                        break;
                    case 'grid':
                        const gridModes = [C.GRID_DISPLAY_MODE_LINES, C.GRID_DISPLAY_MODE_POINTS, C.GRID_DISPLAY_MODE_TRIANGULAR, C.GRID_DISPLAY_MODE_POLAR, C.GRID_DISPLAY_MODE_NONE];
                        gridDisplayMode = gridModes[(gridModes.indexOf(gridDisplayMode) + 1) % gridModes.length];
                        break;
                    case 'angles':
                        const angleModes = [C.ANGLE_DISPLAY_MODE_DEGREES, C.ANGLE_DISPLAY_MODE_RADIANS, C.ANGLE_DISPLAY_MODE_NONE];
                        angleDisplayMode = angleModes[(angleModes.indexOf(angleDisplayMode) + 1) % angleModes.length];
                        showAngles = angleDisplayMode !== C.ANGLE_DISPLAY_MODE_NONE;
                        break;
                    case 'distances':
                        const distModes = [C.DISTANCE_DISPLAY_MODE_ON, C.DISTANCE_DISPLAY_MODE_NONE];
                        distanceDisplayMode = distModes[(distModes.indexOf(distanceDisplayMode) + 1) % distModes.length];
                        showDistances = distanceDisplayMode === C.DISTANCE_DISPLAY_MODE_ON;
                        break;
                    case 'theme':
                        handleThemeToggle();
                        break;
                }
                return true;
            }
        }
    }
    return false;
}


function handleCanvasUIClick(screenPos, shiftKey = false, ctrlKey = false) {
    const btn = canvasUI.toolbarButton;
    if (screenPos.x >= btn.x && screenPos.x <= btn.x + btn.width &&
        screenPos.y >= btn.y && screenPos.y <= btn.y + btn.height) {
        isToolbarExpanded = !isToolbarExpanded;
        if (isToolbarExpanded) {
            buildMainToolbarUI();
        } else {
            isColorPaletteExpanded = false;
            isTransformPanelExpanded = false;
            isDisplayPanelExpanded = false;
            isVisibilityPanelExpanded = false;
            selectedColorIndices = [];
        }
        return true;
    }

    if (isToolbarExpanded) {
        const ctb = canvasUI.colorToolButton;
        if (ctb && screenPos.x >= ctb.x && screenPos.x <= ctb.x + ctb.width &&
            screenPos.y >= ctb.y && screenPos.y <= ctb.y + ctb.height) {
            handleColorToolButtonClick();
            return true;
        }

        const ttb = canvasUI.transformToolButton;
        if (ttb && screenPos.x >= ttb.x && screenPos.x <= ttb.x + ttb.width &&
            screenPos.y >= ttb.y && screenPos.y <= ttb.y + ttb.height) {
            isTransformPanelExpanded = !isTransformPanelExpanded;
            if (isTransformPanelExpanded) buildTransformPanelUI();
            return true;
        }

        const vtb = canvasUI.visibilityToolButton;
        if (vtb && screenPos.x >= vtb.x && screenPos.x <= vtb.x + vtb.width &&
            screenPos.y >= vtb.y && screenPos.y <= vtb.y + vtb.height) {
            isDisplayPanelExpanded = !isDisplayPanelExpanded;
            if (isDisplayPanelExpanded) buildDisplayPanelUI();
            return true;
        }
    }

    if (isColorPaletteExpanded) {
        if (handleColorPaletteClick(screenPos, shiftKey, ctrlKey)) {
            return true;
        }
    }

    if (isTransformPanelExpanded) {
        for (const icon of canvasUI.transformIcons) {
            if (screenPos.x >= icon.x && screenPos.x <= icon.x + icon.width &&
                screenPos.y >= icon.y && screenPos.y <= icon.y + icon.height) {
                isPlacingTransform = true;
                placingTransformType = icon.type;
                canvas.style.cursor = 'none';
                return true;
            }
        }
    }

    if (isDisplayPanelExpanded) {
        if (handleDisplayPanelClick(screenPos, shiftKey, ctrlKey)) {
            return true;
        }
    }

    return false;
}

function buildDisplayPanelUI() {
    canvasUI.displayIcons = [];
    if (!canvasUI.visibilityToolButton) return;

    const panelX = C.UI_TOOLBAR_WIDTH + C.UI_BUTTON_PADDING;
    const iconY = canvasUI.visibilityToolButton.y;
    const iconSize = C.DISPLAY_ICON_SIZE;
    const iconPadding = C.DISPLAY_ICON_PADDING;

    const iconGroups = ['coords', 'grid', 'angles', 'distances', 'theme'];

    iconGroups.forEach((group, index) => {
        canvasUI.displayIcons.push({
            id: `display-icon-${group}`,
            group: group,
            x: panelX + index * (iconSize + iconPadding),
            y: iconY,
            width: iconSize,
            height: iconSize
        });
    });
}

function addToColors(colorObject) {
    if (!colorObject || !colorObject.type) {
        console.error("Invalid color object passed to addToColors:", colorObject);
        return;
    }

    const isDuplicate = allColors.some(item => {
        if (!item || item.type !== colorObject.type) return false;
        if (item.type === 'colormap') {
            return JSON.stringify(item.vertices) === JSON.stringify(colorObject.vertices);
        }
        return item.value === colorObject.value;
    });

    if (isDuplicate) return;

    allColors.push(colorObject);

    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }
}

function getPrecedingSegment(vertexId, edgesToIgnoreIds = []) {
    const currentVertex = findVertexById(vertexId);
    if (!currentVertex) return null;
    for (let i = allEdges.length - 1; i >= 0; i--) {
        const edge = allEdges[i];
        const edgeIdentifier =  U.getEdgeId(edge);
        if (edgesToIgnoreIds.includes(edgeIdentifier)) continue;
        let otherVertexId = null;
        if (edge.id1 === vertexId) otherVertexId = edge.id2;
        else if (edge.id2 === vertexId) otherVertexId = edge.id1;
        if (otherVertexId) {
            const otherVertex = findVertexById(otherVertexId);
            if (otherVertex) {
                const dx = currentVertex.x - otherVertex.x; const dy = currentVertex.y - otherVertex.y;
                return { p1: otherVertex, p2: currentVertex, angleRad: Math.atan2(dy, dx), length: Math.sqrt(dx * dx + dy * dy), edgeId: edgeIdentifier };
            }
        }
    }
    return null;
}

function saveStateForUndo() {
    const state = getCurrentState();
    
    // Create a simple signature of the current state
    const signature = {
        colorCount: allColors.length,
        firstColor: allColors[0]?.value || 'none',
        vertexCount: allVertices.length
    };
    
    
    undoStack.push(state);
    if (undoStack.length > C.MAX_HISTORY_SIZE) undoStack.shift();
    redoStack = [];
    
}

function restoreState(state) {
    allVertices = JSON.parse(JSON.stringify(state.vertices));
    allEdges = JSON.parse(JSON.stringify(state.edges));
    allFaces = JSON.parse(JSON.stringify(state.faces || []));
    selectedVertexIds = JSON.parse(JSON.stringify(state.selectedVertexIds || []));
    selectedEdgeIds = JSON.parse(JSON.stringify(state.selectedEdgeIds || []));
    selectedFaceIds = JSON.parse(JSON.stringify(state.selectedFaceIds || []));
    selectedCenterIds = JSON.parse(JSON.stringify(state.selectedCenterIds || []));
    activeColorTargets = JSON.parse(JSON.stringify(state.activeColorTargets || []));
    allColors = state.allColors ? JSON.parse(JSON.stringify(state.allColors)) : C.DEFAULT_RECENT_COLORS.map(color => {
        if (typeof color === 'string') {
            return { type: 'color', value: color };
        }
        return color;
    });
    colorAssignments = state.colorAssignments ? JSON.parse(JSON.stringify(state.colorAssignments)) : {
        [C.COLOR_TARGET_VERTEX]: 0,
        [C.COLOR_TARGET_EDGE]: 1,
        [C.COLOR_TARGET_FACE]: 2,
    };
    activeCenterId = state.activeCenterId !== undefined ? state.activeCenterId : null;
    isDrawingMode = state.isDrawingMode !== undefined ? state.isDrawingMode : false;
    previewLineStartVertexId = state.previewLineStartVertexId !== undefined ? state.previewLineStartVertexId : null;
    frozenReference_A_rad = state.frozenReference_A_rad !== undefined ? state.frozenReference_A_rad : null;
    frozenReference_A_baseRad = state.frozenReference_A_baseRad !== undefined ? state.frozenReference_A_baseRad : null;
    frozenReference_D_du = state.frozenReference_D_du !== undefined ? state.frozenReference_D_du : null;
    frozenReference_Origin_Data = state.frozenReference_Origin_Data !== undefined ? state.frozenReference_Origin_Data : null;
    frozenReference_D_g2g = state.frozenReference_D_g2g !== undefined ? state.frozenReference_D_g2g : null;
    deletedFaceIds = state.deletedFaceIds !== undefined ? new Set(state.deletedFaceIds) : new Set();
    isActionInProgress = false; isDragConfirmed = false; isRectangleSelecting = false;
    isPanningBackground = false; dragPreviewVertices = [];
    actionTargetVertex = null; currentMouseButton = -1;
    clickData = { targetId: null, type: null, count: 0, timestamp: 0 };
    canvas.style.cursor = 'crosshair';
    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }
    const restoredState = getCurrentState();
    if (undoStack.length === 0) {
        undoStack.push(restoredState);
    }
    // REMOVE THE LINE BELOW:
    // saveStateForUndo();  <-- REMOVE THIS
}

function getCurrentState() {
    return {
        vertices: JSON.parse(JSON.stringify(allVertices)),
        edges: JSON.parse(JSON.stringify(allEdges)),
        faces: JSON.parse(JSON.stringify(allFaces)),
        selectedVertexIds: JSON.parse(JSON.stringify(selectedVertexIds)),
        selectedEdgeIds: JSON.parse(JSON.stringify(selectedEdgeIds)),
        selectedFaceIds: JSON.parse(JSON.stringify(selectedFaceIds)),
        selectedCenterIds: JSON.parse(JSON.stringify(selectedCenterIds)),
        activeColorTargets: JSON.parse(JSON.stringify(activeColorTargets)),
        colorAssignments: JSON.parse(JSON.stringify(colorAssignments)),
        allColors: JSON.parse(JSON.stringify(allColors)),
        activeCenterId: activeCenterId,
        isDrawingMode: isDrawingMode,
        previewLineStartVertexId: previewLineStartVertexId,
        frozenReference_A_rad, frozenReference_A_baseRad, frozenReference_D_du, frozenReference_Origin_Data,
        frozenReference_D_g2g,
        deletedFaceIds: new Set(deletedFaceIds)
    };
}

function handleUndo() {
    if (undoStack.length === 0) return;
    
    
    const currentStateForRedo = getCurrentState();
    const currentSignature = {
        colorCount: allColors.length,
        firstColor: allColors[0]?.value || 'none',
        vertexCount: allVertices.length
    };
    
    redoStack.push(currentStateForRedo);
    if (redoStack.length > C.MAX_HISTORY_SIZE) redoStack.shift();
    
    const prevState = undoStack.pop();
    
    restoreState(prevState);
    
    const restoredSignature = {
        colorCount: allColors.length,
        firstColor: allColors[0]?.value || 'none',
        vertexCount: allVertices.length
    };
}

function handleRedo() {
    if (redoStack.length === 0) return;
    const currentStateForUndo = getCurrentState();
    undoStack.push(currentStateForUndo);
    if (undoStack.length > C.MAX_HISTORY_SIZE) undoStack.shift();
    const nextState = redoStack.pop();
    restoreState(nextState);
}

function screenToData(screenPos_css_pixels) {
    const screenX_physical = screenPos_css_pixels.x * dpr;
    const screenY_physical = screenPos_css_pixels.y * dpr;
    const canvasHeight_physical = canvas.height;
    return {
        x: (screenX_physical - viewTransform.offsetX) / viewTransform.scale,
        y: (canvasHeight_physical - screenY_physical - viewTransform.offsetY) / viewTransform.scale
    };
}

function dataToScreen(dataPos) {
    const canvasHeight_physical = canvas.height;
    const screenX_physical = dataPos.x * viewTransform.scale + viewTransform.offsetX;
    const screenY_physical = canvasHeight_physical - (dataPos.y * viewTransform.scale + viewTransform.offsetY);
    return {
        x: screenX_physical / dpr,
        y: screenY_physical / dpr
    };
}

function resizeCanvas() {
    const canvasContainer = document.querySelector('.canvas-container');
    const canvasWrapper = document.querySelector('.canvas-wrapper-relative');

    if (!canvasContainer || !canvasWrapper) {
        return;
    }

    const cW = canvasWrapper.offsetWidth;
    const cH = canvasWrapper.offsetHeight;

    canvas.width = cW * dpr;
    canvas.height = cH * dpr;
    canvas.style.width = `${cW}px`;
    canvas.style.height = `${cH}px`;

    if (htmlOverlay) {
        htmlOverlay.style.width = `${cW}px`;
        htmlOverlay.style.height = `${cH}px`;
    }
}

function findVertexById(id) { return allVertices.find(p => p.id === id); }

function findClickedVertex(clickPos) {
    const dataPos = screenToData(clickPos);
    const selectRadiusDataRegular = (C.VERTEX_RADIUS * 2) / viewTransform.scale;
    const selectRadiusDataCenter = (C.CENTER_POINT_VISUAL_RADIUS + C.VERTEX_RADIUS) / viewTransform.scale;

    for (let i = allVertices.length - 1; i >= 0; i--) {
        const vertex = allVertices[i];
        if (vertex.type !== 'regular') {
            if (U.distance(dataPos, vertex) < selectRadiusDataCenter) return vertex;
        }
    }

    for (let i = allVertices.length - 1; i >= 0; i--) {
        const vertex = allVertices[i];
        if (vertex.type === 'regular' && U.distance(dataPos, vertex) < selectRadiusDataRegular) return vertex;
    }
    return null;
}

function findClickedEdge(clickPos) {
    const dataPos = screenToData(clickPos);
    const edgeClickThresholdData = C.EDGE_CLICK_THRESHOLD / viewTransform.scale;

    for (let i = allEdges.length - 1; i >= 0; i--) {
        const edge = allEdges[i];
        const p1 = findVertexById(edge.id1);
        const p2 = findVertexById(edge.id2);
        if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
            const closest = U.getClosestPointOnLineSegment(dataPos, p1, p2);
            if (closest.distance < edgeClickThresholdData && closest.onSegmentStrict) {
                return edge;
            }
        }
    }
    return null;
}

function findClickedFace(clickPos) {
    const dataPos = screenToData(clickPos);

    for (let i = allFaces.length - 1; i >= 0; i--) {
        const face = allFaces[i];
        const vertices = face.vertexIds.map(id => findVertexById(id)).filter(p => p && p.type === 'regular');
        if (vertices.length < 3) continue;

        if (U.isVertexInPolygon(dataPos, vertices)) {
            return face;
        }
    }

    return null;
}

function findNeighborEdges(vertexId) {
    return allEdges.filter(e => e.id1 === vertexId || e.id2 === vertexId);
}

function findAllVerticesInSubgraph(startVertexId) {
    if (!findVertexById(startVertexId)) return [];
    const visited = new Set(); const queue = [startVertexId]; const subgraphVertexIds = [];
    visited.add(startVertexId);
    while (queue.length > 0) {
        const currentVertexId = queue.shift(); subgraphVertexIds.push(currentVertexId);
        U.findNeighbors(currentVertexId, allEdges).forEach(neighborId => {
            if (!visited.has(neighborId)) { visited.add(neighborId); queue.push(neighborId); }
        });
    }
    return subgraphVertexIds;
}



function handleCut() {
    if (selectedVertexIds.length === 0 && selectedEdgeIds.length === 0 && selectedCenterIds.length === 0) return;

    saveStateForUndo();
    handleCopy();
    deleteSelectedItems();
}

function handleCopy() {
    const verticesToCopyIds = new Set(selectedVertexIds);
    if (activeCenterId) verticesToCopyIds.add(activeCenterId);

    const facesToCopy = [];
    if (selectedFaceIds.length > 0) {
        selectedFaceIds.forEach(faceId => {
            // FIX: Find face by its canonical ID, not an object property
            const face = allFaces.find(f => U.getFaceId(f) === faceId);
            if (face) {
                facesToCopy.push(face);
                face.vertexIds.forEach(id => verticesToCopyIds.add(id));
            }
        });
    }

    selectedEdgeIds.forEach(edgeId => {
        const [id1, id2] = edgeId.split(C.EDGE_ID_DELIMITER);
        verticesToCopyIds.add(id1);
        verticesToCopyIds.add(id2);
    });

    clipboard.vertices = Array.from(verticesToCopyIds).map(id => {
        const p = findVertexById(id);
        return p ? { ...p } : null;
    }).filter(p => p);

    clipboard.edges = [];
    allEdges.forEach(edge => {
        if (verticesToCopyIds.has(edge.id1) && verticesToCopyIds.has(edge.id2)) {
            clipboard.edges.push({ ...edge });
        }
    });

    clipboard.faces = facesToCopy.map(f => JSON.parse(JSON.stringify(f)));
    clipboard.referenceVertex = screenToData(mousePos);
}

function handlePaste() {
    if (clipboard.vertices.length === 0 || !clipboard.referenceVertex) return;
    saveStateForUndo();

    const pastePosData = screenToData(mousePos);
    const deltaX = pastePosData.x - clipboard.referenceVertex.x;
    const deltaY = pastePosData.y - clipboard.referenceVertex.y;
    const oldToNewIdMap = new Map();
    const newPastedRegularVertexIds = [];
    let newPastedActiveCenterId = null;

    performEscapeAction();

    clipboard.vertices.forEach(cbVertex => {
        const newId = U.generateUniqueId();
        const newVertex = { ...cbVertex, id: newId, x: cbVertex.x + deltaX, y: cbVertex.y + deltaY };
        allVertices.push(newVertex);
        oldToNewIdMap.set(cbVertex.id, newId);
        if (newVertex.type === 'regular') {
            newPastedRegularVertexIds.push(newId);
        } else {
            newPastedActiveCenterId = newId;
        }
    });

    clipboard.edges.forEach(cbEdge => {
        const newP1Id = oldToNewIdMap.get(cbEdge.id1);
        const newP2Id = oldToNewIdMap.get(cbEdge.id2);
        if (newP1Id && newP2Id) {
            allEdges.push({ ...cbEdge, id1: newP1Id, id2: newP2Id });
        }
    });

    const newPastedFaceIds = [];
    clipboard.faces.forEach(cbFace => {
        const newVertexIds = cbFace.vertexIds.map(id => oldToNewIdMap.get(id)).filter(Boolean);
        if (newVertexIds.length === cbFace.vertexIds.length) {
            const newFace = {
                ...cbFace,
                id: U.getFaceId({ vertexIds: newVertexIds }),
                vertexIds: newVertexIds,
            };

            if (newFace.localCoordSystem) {
                // Translate the origin
                newFace.localCoordSystem.origin.x += deltaX;
                newFace.localCoordSystem.origin.y += deltaY;

                // Remap vertex/edge IDs within the coordinate system's constraints
                if (newFace.localCoordSystem.attachedToVertex) {
                    newFace.localCoordSystem.attachedToVertex = oldToNewIdMap.get(newFace.localCoordSystem.attachedToVertex);
                }
                if (newFace.localCoordSystem.attachedToEdge) {
                    newFace.localCoordSystem.attachedToEdge.v1 = oldToNewIdMap.get(newFace.localCoordSystem.attachedToEdge.v1);
                    newFace.localCoordSystem.attachedToEdge.v2 = oldToNewIdMap.get(newFace.localCoordSystem.attachedToEdge.v2);
                }
                if (newFace.localCoordSystem.rotationAlignedToEdge) {
                    newFace.localCoordSystem.rotationAlignedToEdge.v1 = oldToNewIdMap.get(newFace.localCoordSystem.rotationAlignedToEdge.v1);
                    newFace.localCoordSystem.rotationAlignedToEdge.v2 = oldToNewIdMap.get(newFace.localCoordSystem.rotationAlignedToEdge.v2);
                }
                if (newFace.localCoordSystem.scaleAttachedToEdge) {
                    newFace.localCoordSystem.scaleAttachedToEdge.v1 = oldToNewIdMap.get(newFace.localCoordSystem.scaleAttachedToEdge.v1);
                    newFace.localCoordSystem.scaleAttachedToEdge.v2 = oldToNewIdMap.get(newFace.localCoordSystem.scaleAttachedToEdge.v2);
                }
            }
            allFaces.push(newFace);
            newPastedFaceIds.push(newFace.id);
        }
    });
    ensureFaceCoordinateSystems();

    // Select the newly pasted geometry
    selectedVertexIds = newPastedRegularVertexIds;
    selectedEdgeIds = clipboard.edges.map(e => U.getEdgeId({ id1: oldToNewIdMap.get(e.id1), id2: oldToNewIdMap.get(e.id2) }));
    selectedFaceIds = newPastedFaceIds;
    activeCenterId = newPastedActiveCenterId;
}

function deleteSelectedItems() {
    const vertexIdsToDelete = new Set(selectedVertexIds);
    const centerIdsToDelete = new Set(selectedCenterIds);
    const edgeIdsToDelete = new Set(selectedEdgeIds);
    const faceIdsToExplicitlyDelete = new Set(selectedFaceIds);

    if (vertexIdsToDelete.size === 0 && centerIdsToDelete.size === 0 && edgeIdsToDelete.size === 0 && faceIdsToExplicitlyDelete.size === 0) {
        return;
    }
    saveStateForUndo();

    // Around line 1089, replace the face deletion logic:
    if (faceIdsToExplicitlyDelete.size > 0) {
        faceIdsToExplicitlyDelete.forEach(faceId => {
            deletedFaceIds.add(faceId);
        });
        allFaces = allFaces.filter(face => {
            const faceId = face.id || U.getFaceId(face);
            return !faceIdsToExplicitlyDelete.has(faceId);
        });
    }

    const edgesBefore = [...allEdges];

    if (edgeIdsToDelete.size > 0) {
        allEdges = allEdges.filter(edge => !edgeIdsToDelete.has(U.getEdgeId(edge)));
    }
    if (vertexIdsToDelete.size > 0) {
        allVertices = allVertices.filter(p => !vertexIdsToDelete.has(p.id));
        allEdges = allEdges.filter(e => !vertexIdsToDelete.has(e.id1) && !vertexIdsToDelete.has(e.id2));
    }

    updateFaces(edgesBefore, allEdges);

    if (centerIdsToDelete.size > 0) {
        allVertices = allVertices.filter(p => !centerIdsToDelete.has(p.id));
    }

    performEscapeAction();
}

function zoomAt(zoomCenterScreen_css_pixels, scaleFactor) {
    let newScale = viewTransform.scale * scaleFactor;

    if (newScale < C.MIN_SCALE_VALUE) {
        newScale = C.MIN_SCALE_VALUE;
    }
    if (newScale > C.MAX_SCALE_VALUE) {
        newScale = C.MAX_SCALE_VALUE;
    }

    const effectiveScaleFactor = newScale / viewTransform.scale;

    const mouseX_physical = zoomCenterScreen_css_pixels.x * dpr;
    const mouseY_physical = zoomCenterScreen_css_pixels.y * dpr;

    viewTransform.offsetX = mouseX_physical * (1 - effectiveScaleFactor) + viewTransform.offsetX * effectiveScaleFactor;
    viewTransform.offsetY = (canvas.height - mouseY_physical) * (1 - effectiveScaleFactor) + viewTransform.offsetY * effectiveScaleFactor;

    viewTransform.scale = newScale;
}

function getDrawingContext(currentDrawStartVertexId) {
    let offsetAngleRad = 0;
    let currentSegmentReferenceD;
    let currentSegmentReferenceA_for_display = Math.PI / 2;
    let isFirstSegmentBeingDrawn = true;

    const p_current = findVertexById(currentDrawStartVertexId);
    if (!p_current) {
        isFirstSegmentBeingDrawn = true;
        if (gridDisplayMode !== 'none' && lastGridState.interval1) {
            currentSegmentReferenceD = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        } else {
            currentSegmentReferenceD = C.DEFAULT_REFERENCE_DISTANCE;
        }
        if (frozenReference_D_du !== null) {
            currentSegmentReferenceD = frozenReference_D_du;
        }

        return {
            offsetAngleRad,
            currentSegmentReferenceD,
            currentSegmentReferenceA_for_display,
            isFirstSegmentBeingDrawn,
            displayAngleA_valueRad_for_A_equals_label: null,
            displayAngleA_originVertexData_for_A_equals_label: null,
            frozen_A_baseRad_to_display: null,
            frozen_D_du_to_display: null,
            frozen_D_g2g_to_display: null,
            frozen_Origin_Data_to_display: null
        };
    }

    const segment1_prev_to_current = getPrecedingSegment(p_current.id);

    if (segment1_prev_to_current) {
        isFirstSegmentBeingDrawn = false;
        offsetAngleRad = segment1_prev_to_current.angleRad;
        currentSegmentReferenceD = frozenReference_D_du !== null ? frozenReference_D_du : segment1_prev_to_current.length;

        if (frozenReference_A_rad !== null) {
            if (Math.abs(frozenReference_A_rad) < C.GEOMETRY_CALCULATION_EPSILON) {
                currentSegmentReferenceA_for_display = C.DEFAULT_REFERENCE_ANGLE_RAD;
            } else {
                currentSegmentReferenceA_for_display = Math.abs(frozenReference_A_rad);
            }
        } else {
            currentSegmentReferenceA_for_display = C.DEFAULT_REFERENCE_ANGLE_RAD;
        }
    } else {
        isFirstSegmentBeingDrawn = true;
        if (gridDisplayMode !== 'none' && lastGridState.interval1) {
            currentSegmentReferenceD = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        } else {
            currentSegmentReferenceD = C.DEFAULT_REFERENCE_DISTANCE;
        }
        if (frozenReference_D_du !== null) {
            currentSegmentReferenceD = frozenReference_D_du;
        }
        offsetAngleRad = 0;
        currentSegmentReferenceA_for_display = C.DEFAULT_REFERENCE_ANGLE_RAD;
    }

    return {
        offsetAngleRad,
        currentSegmentReferenceD,
        currentSegmentReferenceA_for_display,
        isFirstSegmentBeingDrawn,
        displayAngleA_valueRad_for_A_equals_label: frozenReference_A_rad,
        displayAngleA_originVertexData_for_A_equals_label: frozenReference_Origin_Data,
        frozen_A_baseRad_to_display: frozenReference_A_baseRad,
        frozen_D_du_to_display: frozenReference_D_du,
        frozen_D_g2g_to_display: frozenReference_D_g2g
    };
}

function getCompletedSegmentProperties(startVertex, endVertex, existingEdges) {
    if (!startVertex || !endVertex) return null;

    const angle = Math.atan2(endVertex.y - startVertex.y, endVertex.x - startVertex.x);
    const length = U.distance(startVertex, endVertex);

    let precedingSegmentAngle = 0;
    let isFirstSegmentOfLine = true;

    for (let i = existingEdges.length - 1; i >= 0; i--) {
        const edge = existingEdges[i];
        let otherVertexId = null;
        if (edge.id1 === startVertex.id && findVertexById(edge.id2)?.type === 'regular') otherVertexId = edge.id2;
        else if (edge.id2 === startVertex.id && findVertexById(edge.id1)?.type === 'regular') otherVertexId = edge.id1;

        if (otherVertexId && otherVertexId !== endVertex.id) {
            const prevVertex = findVertexById(otherVertexId);
            if (prevVertex) {
                precedingSegmentAngle = Math.atan2(startVertex.y - prevVertex.y, startVertex.x - prevVertex.x);
                isFirstSegmentOfLine = false;
                break;
            }
        }
    }

    const angleTurn = U.normalizeAngleToPi(angle - precedingSegmentAngle);

    return {
        startVertex,
        endVertex,
        absoluteAngleRad: angle,
        length: length,
        precedingSegmentAbsoluteAngleRad: precedingSegmentAngle,
        turnAngleRad: angleTurn,
        isFirstSegmentOfLine: isFirstSegmentOfLine
    };
}

function completeGraphOnSelectedVertices() {
    const regularVertexIds = selectedVertexIds.filter(id => {
        const vertex = findVertexById(id);
        return vertex && vertex.type === 'regular';
    });

    if (regularVertexIds.length < 2) return;

    saveStateForUndo();

    const edgesBefore = JSON.parse(JSON.stringify(allEdges));
    let edgesWereAdded = false;
    const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

    for (let i = 0; i < regularVertexIds.length; i++) {
        for (let j = i + 1; j < regularVertexIds.length; j++) {
            const id1 = regularVertexIds[i];
            const id2 = regularVertexIds[j];

            const edgeExists = allEdges.some(edge =>
                (edge.id1 === id1 && edge.id2 === id2) ||
                (edge.id1 === id2 && edge.id2 === id1)
            );

            if (!edgeExists) {
                const v1 = findVertexById(id1);
                const v2 = findVertexById(id2);
                if (v1 && v2) {
                    const newEdge = U.createEdge(v1, v2, gridInterval, getColorForTarget);
                    allEdges.push(newEdge);
                    edgesWereAdded = true;
                }
            }
        }
    }

    if (edgesWereAdded && facesVisible) {
        updateFaces(edgesBefore, allEdges);
        
        allFaces.forEach(face => {
            if (!face.color) {
                face.color = getColorForTarget(C.COLOR_TARGET_FACE);
            }
        });
        
        ensureFaceCoordinateSystems();
    }
}

function applySelectionLogic(vertexIdsToSelect = [], edgeIdsToSelect = [], faceIdsToSelect = [], wantsShift, wantsCtrl, targetIsCenter = false) {
    if (targetIsCenter) {
        handleCenterSelection(vertexIdsToSelect[0], wantsShift, wantsCtrl);
    } else {
        if (wantsShift) {
            selectedVertexIds = [...new Set([...selectedVertexIds, ...vertexIdsToSelect])];
            selectedEdgeIds = [...new Set([...selectedEdgeIds, ...edgeIdsToSelect])];
            selectedFaceIds = [...new Set([...selectedFaceIds, ...faceIdsToSelect])];
        } else if (wantsCtrl) {
            vertexIdsToSelect.forEach(id => {
                const index = selectedVertexIds.indexOf(id);
                if (index > -1) selectedVertexIds.splice(index, 1);
                else selectedVertexIds.push(id);
            });
            edgeIdsToSelect.forEach(id => {
                const index = selectedEdgeIds.indexOf(id);
                if (index > -1) selectedEdgeIds.splice(index, 1);
                else selectedEdgeIds.push(id);
            });
            faceIdsToSelect.forEach(id => {
                const index = selectedFaceIds.indexOf(id);
                if (index > -1) selectedFaceIds.splice(index, 1);
                else selectedFaceIds.push(id);
            });
        } else {
            selectedVertexIds = [...vertexIdsToSelect];
            selectedEdgeIds = [...edgeIdsToSelect];
            selectedFaceIds = [...faceIdsToSelect];
        }
    }
}



function initializeApp() {
    setupUndoStackDebugging();
    allColors = C.DEFAULT_RECENT_COLORS.map(color => {
        if (typeof color === 'string') {
            return { type: 'color', value: color };
        }
        return color;
    });

    if (typeof window.katex === 'undefined') {
        console.error("KaTeX library failed to load or initialize. Math rendering will be broken.");
    }
    initializeCanvasUI();
    buildMainToolbarUI();
    resizeCanvas();

    colorEditor = new ColormapSelector();
    colorEditor.initialize();
    document.body.appendChild(colorEditor.getElement());

    const colorEditorElement = colorEditor.getElement();
    colorEditorElement.addEventListener('mouseenter', () => {
        isMouseOverColorEditor = true;
    });
    colorEditorElement.addEventListener('mouseleave', () => {
        isMouseOverColorEditor = false;
    });

    colorEditor.getElement().addEventListener('select', (e) => {
        const colormapData = e.detail;
        const newItem = U.convertColorToColormapFormat(colormapData);

        if (!newItem) return;

        if (isEditingColor && editingColorIndex !== null) {
            allColors[editingColorIndex] = newItem;
        } else {
            addToColors(newItem);
            const newColorIndex = allColors.length - 1;
            activeColorTargets.forEach(target => {
                colorAssignments[target] = newColorIndex;
            });
        }

        applyColorsToSelection();

        isEditingColor = false;
        editingColorIndex = null;
        buildColorPaletteUI();
    });

    viewTransform.scale = 70;
    viewTransform.offsetX = canvas.width / 2;
    viewTransform.offsetY = canvas.height / 2;
    coordsDisplayMode = 'regular';

    contextMenu = document.getElementById('context-menu');
    canvas.addEventListener('contextmenu', handleContextMenu);
    window.addEventListener('click', () => {
        if (contextMenu) {
            contextMenu.style.display = 'none';
        }
    });
    contextMenu.addEventListener('mouseleave', () => {
        contextMenu.style.display = 'none';
    });

    saveStateForUndo();
    gameLoop();
}

function calculateTransformFromMouse(center, mouseData, startReferenceVertex, centerType, currentAccumulatedRotation = 0) {
    const startVector = { x: startReferenceVertex.x - center.x, y: startReferenceVertex.y - center.y };
    const currentVector = { x: mouseData.x - center.x, y: mouseData.y - center.y };
    const startDist = Math.hypot(startVector.x, startVector.y);
    const currentDist = Math.hypot(currentVector.x, currentVector.y);
    const startAngle = Math.atan2(startVector.y, startVector.x);
    const currentAngle = Math.atan2(currentVector.y, currentVector.x);

    let rotation = 0;
    let scale = 1;
    let directionalScale = false;

    if (centerType === C.TRANSFORMATION_TYPE_ROTATION) {
        scale = 1.0;
        rotation = U.calculateRotationAngle(startAngle, currentAngle, currentAccumulatedRotation);
    } else if (centerType === C.TRANSFORMATION_TYPE_SCALE) {
        rotation = 0.0;
        if (startDist > C.GEOMETRY_CALCULATION_EPSILON) {
            scale = currentDist / startDist;
        }
    } else if (centerType === C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE) {
        directionalScale = true;
        rotation = 0;
        if (startDist > C.GEOMETRY_CALCULATION_EPSILON) {
            const startNormalized = { x: startVector.x / startDist, y: startVector.y / startDist };
            const projectedDistance = (currentVector.x * startNormalized.x + currentVector.y * startNormalized.y);
            scale = projectedDistance / startDist;
        }
    }

    return { rotation, scale, directionalScale };
}

function updateFaces(edgesBefore, edgesAfter) {
    if (!facesVisible) {
        allFaces = [];
        deletedFaceIds.clear();
        return;
    }

    const edgesBeforeSet = new Set(edgesBefore.map(e => U.getEdgeId(e)));
    const edgesAfterSet = new Set(edgesAfter.map(e => U.getEdgeId(e)));
    
    const addedEdges = edgesAfter.filter(e => !edgesBeforeSet.has(U.getEdgeId(e)));
    const removedEdges = edgesBefore.filter(e => !edgesAfterSet.has(U.getEdgeId(e)));

    if (addedEdges.length === 0 && removedEdges.length === 0) {
        return;
    }

    const dirtyVertices = new Set();
    addedEdges.forEach(e => { dirtyVertices.add(e.id1); dirtyVertices.add(e.id2); });
    removedEdges.forEach(e => { dirtyVertices.add(e.id1); dirtyVertices.add(e.id2); });
    
    const affectedComponentVertices = new Set();
    const processedStartNodes = new Set();
    for (const startId of dirtyVertices) {
        if (!processedStartNodes.has(startId)) {
            const component = findAllVerticesInSubgraph(startId);
            component.forEach(vId => {
                affectedComponentVertices.add(vId);
                processedStartNodes.add(vId);
            });
        }
    }

    const affectedEdges = allEdges.filter(e => affectedComponentVertices.has(e.id1) && affectedComponentVertices.has(e.id2));
    const oldFacesInComponent = allFaces.filter(face =>
        face.vertexIds.every(vId => affectedComponentVertices.has(vId))
    );
    const oldFaceIds = new Set(oldFacesInComponent.map(f => f.id));

    const correctFacesForComponent = U.detectClosedPolygons(affectedEdges, findVertexById);
    const correctFaceIds = new Set(correctFacesForComponent.map(f => f.id));

    const facesToRemove = oldFacesInComponent.filter(f => !correctFaceIds.has(f.id));

    if (facesToRemove.length > 0) {
        const idsToRemove = new Set(facesToRemove.map(f => f.id));
        allFaces = allFaces.filter(f => !idsToRemove.has(f.id));
    }

    const facesToAdd = correctFacesForComponent.filter(f => !oldFaceIds.has(f.id));
    const addedEdgeIds = new Set(addedEdges.map(e => U.getEdgeId(e)));

    facesToAdd.forEach(newFace => {
        let isFormedByNewEdge = false;
        if (addedEdges.length > 0) {
            for (let i = 0; i < newFace.vertexIds.length; i++) {
                const p1 = newFace.vertexIds[i];
                const p2 = newFace.vertexIds[(i + 1) % newFace.vertexIds.length];
                const faceEdgeId = U.getEdgeId({ id1: p1, id2: p2 });
                if (addedEdgeIds.has(faceEdgeId)) {
                    isFormedByNewEdge = true;
                    break;
                }
            }
        }
        
        if (deletedFaceIds.has(newFace.id)) {
            if (isFormedByNewEdge) {
                deletedFaceIds.delete(newFace.id);
            } else {
                return;
            }
        }
        
        const colorIndex = colorAssignments[C.COLOR_TARGET_FACE];
        if (colorIndex !== -1) {
            const colorItem = allColors[colorIndex];
            if (colorItem && colorItem.type === 'colormap') {
                newFace.colormapItem = colorItem;
                newFace.colormapDistribution = 'x';
                delete newFace.color;
            } else {
                newFace.color = getColorForTarget(C.COLOR_TARGET_FACE);
                delete newFace.colormapItem;
                delete newFace.colormapDistribution;
            }
        } else {
            newFace.color = getColorForTarget(C.COLOR_TARGET_FACE);
            delete newFace.colormapItem;
            delete newFace.colormapDistribution;
        }
        
        allFaces.push(newFace);
    });

    ensureFaceCoordinateSystems();
}

function insertVertexOnEdgeWithFaces(targetEdge, insertionVertex, gridInterval, getColorForTarget) {
    const p1 = findVertexById(targetEdge.id1);
    const p2 = findVertexById(targetEdge.id2);

    if (!p1 || !p2) return null;

    const edgesBefore = [...allEdges];

    const newVertex = {
        id: U.generateUniqueId(),
        x: insertionVertex.x,
        y: insertionVertex.y,
        type: 'regular',
        color: getColorForTarget(C.COLOR_TARGET_VERTEX)
    };

    allVertices.push(newVertex);

    allEdges = allEdges.filter(e => U.getEdgeId(e) !== U.getEdgeId(targetEdge));

    allEdges.push(U.createEdge(p1, newVertex, gridInterval, getColorForTarget));
    allEdges.push(U.createEdge(newVertex, p2, gridInterval, getColorForTarget));

    if (facesVisible) {
        updateFaces(edgesBefore, allEdges);
    }

    return newVertex;
}

function getBestTranslationSnap(initialDragVertexStates, rawDelta, copyCount) {
    const snapStickinessData = (2 * C.VERTEX_RADIUS) / viewTransform.scale;
    if (initialDragVertexStates.length === 0) {
        return { delta: rawDelta, snapped: false };
    }

    const handleVertex = initialDragVertexStates[0];
    const mouseDragPos = { x: handleVertex.x + rawDelta.x, y: handleVertex.y + rawDelta.y };
    const allPossibleSnaps = [];

    const verticesToDrag = initialDragVertexStates.filter(p => p.type === 'regular');
    const staticVertices = allVertices.filter(p => p.type === 'regular' && !initialDragVertexStates.some(ip => ip.id === p.id));

    const multipliers = copyCount === 1 ? [1] : Array.from({ length: copyCount }, (_, k) => k);

    if (verticesToDrag.length > 0) {
        multipliers.forEach(k => {
            if (k === 0) return;

            verticesToDrag.forEach(p_orig => {
                staticVertices.forEach(p_target => {
                    const requiredDelta = {
                        x: (p_target.x - p_orig.x) / k,
                        y: (p_target.y - p_orig.y) / k,
                    };
                    allPossibleSnaps.push({ delta: requiredDelta });
                });
            });
        });

        if (copyCount > 1) {
            multipliers.forEach(k1 => {
                multipliers.forEach(k2 => {
                    if (k1 >= k2) return;

                    verticesToDrag.forEach(p1_orig => {
                        verticesToDrag.forEach(p2_orig => {
                            const denominator = k1 - k2;
                            if (Math.abs(denominator) > 0) {
                                const requiredDelta = {
                                    x: (p2_orig.x - p1_orig.x) / denominator,
                                    y: (p2_orig.y - p1_orig.y) / denominator,
                                };
                                allPossibleSnaps.push({ delta: requiredDelta });
                            }
                        });
                    });
                });
            });
        }
    }

    if (allPossibleSnaps.length === 0) {
        return { delta: rawDelta, snapped: false };
    }

    let bestSnap = null;
    let minSnapDist = Infinity;

    allPossibleSnaps.forEach(snap => {
        const handleAtSnapPos = {
            x: handleVertex.x + snap.delta.x,
            y: handleVertex.y + snap.delta.y,
        };
        const dist = U.distance(mouseDragPos, handleAtSnapPos);

        if (dist < minSnapDist) {
            minSnapDist = dist;
            bestSnap = snap;
        }
    });

    if (bestSnap && minSnapDist < snapStickinessData) {
        return {
            delta: bestSnap.delta,
            snapped: true,
            snapType: 'merge'
        };
    }

    return { delta: rawDelta, snapped: false };
}

function getBestRotationSnap(center, initialVertexStates, handleVertex, rawRotation) {
    const copyCount = parseInt(copyCountInput || '1', 10);
    let allPossibleSnaps = [];
    const snapThresholdData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;

    if (copyCount > 1) {
        const staticVertices = allVertices.filter(p => p.type === 'regular' && !initialVertexStates.some(ip => ip.id === p.id));
        const verticesToTransform = initialVertexStates.filter(p => p.type === 'regular');

        for (let i = 0; i < verticesToTransform.length; i++) {
            for (let j = 0; j < verticesToTransform.length; j++) {
                const p1_orig = verticesToTransform[i];
                const p2_orig = verticesToTransform[j];
                const v1 = { x: p1_orig.x - center.x, y: p1_orig.y - center.y };
                const v2 = { x: p2_orig.x - center.x, y: p2_orig.y - center.y };
                const r1 = Math.hypot(v1.x, v1.y);
                const r2 = Math.hypot(v2.x, v2.y);

                if (Math.abs(r1 - r2) < snapThresholdData) {
                    const theta1_orig = Math.atan2(v1.y, v1.x);
                    const theta2_orig = Math.atan2(v2.y, v2.x);

                    for (let c1 = 0; c1 < copyCount; c1++) {
                        for (let c2 = 0; c2 < copyCount; c2++) {
                            if (p1_orig.id === p2_orig.id && c1 === c2) continue;
                            if (c1 === c2) continue;

                            const delta_c = c1 - c2;
                            if (delta_c === 0) continue;

                            let delta_theta = theta2_orig - theta1_orig;
                            const target_delta_theta = rawRotation * delta_c;
                            const k = Math.round((target_delta_theta - delta_theta) / (2 * Math.PI));
                            delta_theta += k * (2 * Math.PI);

                            const exact_rotation = delta_theta / delta_c;
                            allPossibleSnaps.push({ rotation: exact_rotation, priority: Math.abs(exact_rotation - rawRotation) });
                        }
                    }
                }
            }
        }

        verticesToTransform.forEach(p_orig => {
            staticVertices.forEach(p_static => {
                const v_orig = { x: p_orig.x - center.x, y: p_orig.y - center.y };
                const v_static = { x: p_static.x - center.x, y: p_static.y - center.y };
                const r_orig = Math.hypot(v_orig.x, v_orig.y);
                const r_static = Math.hypot(v_static.x, v_static.y);

                if (Math.abs(r_orig - r_static) < snapThresholdData) {
                    const theta_orig = Math.atan2(v_orig.y, v_orig.x);
                    const theta_static = Math.atan2(v_static.y, v_static.y);

                    for (let c = 0; c < copyCount; c++) {
                        if (c === 0) {
                            if (Math.abs(U.normalizeAngleToPi(theta_static - theta_orig)) < C.GEOMETRY_CALCULATION_EPSILON) {
                                allPossibleSnaps.push({ rotation: 0, priority: Math.abs(rawRotation) });
                            }
                            continue;
                        }
                        let delta_theta = theta_static - theta_orig;
                        const target_delta_theta = rawRotation * c;
                        const k = Math.round((target_delta_theta - delta_theta) / (2 * Math.PI));
                        delta_theta += k * (2 * Math.PI);
                        const exact_rotation = delta_theta / c;
                        allPossibleSnaps.push({ rotation: exact_rotation, priority: Math.abs(exact_rotation - rawRotation) });
                    }
                }
            });
        });
    }

    if (Math.abs(rawRotation) < C.ANGLE_SNAP_THRESHOLD_RAD) {
        allPossibleSnaps.push({ rotation: 0, priority: Math.abs(rawRotation) });
    }

    if (currentShiftPressed) {
        for (const factor of C.NINETY_DEG_ANGLE_SNAP_FRACTIONS) {
            const snapAngle = factor * Math.PI / 2;
            if (Math.abs(rawRotation - snapAngle) < C.ANGLE_SNAP_THRESHOLD_RAD) {
                allPossibleSnaps.push({ rotation: snapAngle, priority: Math.abs(rawRotation - snapAngle) });
            }
            if (snapAngle !== 0 && Math.abs(rawRotation - (-snapAngle)) < C.ANGLE_SNAP_THRESHOLD_RAD) {
                allPossibleSnaps.push({ rotation: -snapAngle, priority: Math.abs(rawRotation - (-snapAngle)) });
            }
        }
    }

    if (allPossibleSnaps.length > 0) {
        allPossibleSnaps.sort((a, b) => a.priority - b.priority);
        const bestSnap = allPossibleSnaps[0];

        if (bestSnap.priority < C.ANGLE_SNAP_THRESHOLD_RAD) {
            const finalPos = U.applyTransformToVertex(handleVertex, center, bestSnap.rotation, 1, false, null);
            return {
                rotation: bestSnap.rotation,
                pos: finalPos,
                snapped: true,
                snapType: 'merge'
            };
        }
    }

    const finalPos = U.applyTransformToVertex(handleVertex, center, rawRotation, 1, false, null);
    return { rotation: rawRotation, pos: finalPos, snapped: false, snapType: null };
}

function getBestScaleSnap(center, initialVertexStates, handleVertex, rawScale) {
    const copyCount = parseInt(copyCountInput || '1', 10);
    let allPossibleSnaps = [];
    const snapThresholdData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;
    const angleThreshold = snapThresholdData / 100;

    if (copyCount > 1) {
        const staticVertices = allVertices.filter(p => p.type === 'regular' && !initialVertexStates.some(ip => ip.id === p.id));
        const verticesToTransform = initialVertexStates.filter(p => p.type === 'regular');

        for (let i = 0; i < verticesToTransform.length; i++) {
            for (let j = 0; j < verticesToTransform.length; j++) {
                const p1_orig = verticesToTransform[i];
                const p2_orig = verticesToTransform[j];

                const v1 = { x: p1_orig.x - center.x, y: p1_orig.y - center.y };
                const v2 = { x: p2_orig.x - center.x, y: p2_orig.y - center.y };

                const r1 = Math.hypot(v1.x, v1.y);
                const r2 = Math.hypot(v2.x, v2.y);

                if (r1 < C.GEOMETRY_CALCULATION_EPSILON || r2 < C.GEOMETRY_CALCULATION_EPSILON) continue;

                const theta1 = Math.atan2(v1.y, v1.x);
                const theta2 = Math.atan2(v2.y, v2.x);

                if (Math.abs(U.normalizeAngleToPi(theta1 - theta2)) < angleThreshold) {
                    for (let c1 = 0; c1 < copyCount; c1++) {
                        for (let c2 = 0; c2 < copyCount; c2++) {
                            if (p1_orig.id === p2_orig.id && c1 === c2) continue;
                            if (c1 === c2) continue;

                            const delta_c = c1 - c2;
                            if (delta_c === 0) continue;

                            const ratio = r2 / r1;
                            if (ratio <= 0) continue;

                            const exact_scale = Math.pow(ratio, 1 / delta_c);
                            allPossibleSnaps.push({ scale: exact_scale, priority: Math.abs(exact_scale - rawScale) });
                        }
                    }
                }
            }
        }

        verticesToTransform.forEach(p_orig => {
            staticVertices.forEach(p_static => {
                const v_orig = { x: p_orig.x - center.x, y: p_orig.y - center.y };
                const v_static = { x: p_static.x - center.x, y: p_static.y - center.y };
                const r_orig = Math.hypot(v_orig.x, v_orig.y);
                const r_static = Math.hypot(v_static.x, v_static.y);

                if (r_orig < C.GEOMETRY_CALCULATION_EPSILON || r_static < C.GEOMETRY_CALCULATION_EPSILON) return;

                const theta_orig = Math.atan2(v_orig.y, v_orig.x);
                const theta_static = Math.atan2(v_static.y, v_static.y);

                if (Math.abs(U.normalizeAngleToPi(theta_orig - theta_static)) < angleThreshold) {
                    for (let c = 0; c < copyCount; c++) {
                        if (c === 0) {
                            if (Math.abs(r_static - r_orig) < snapThresholdData) {
                                allPossibleSnaps.push({ scale: 1.0, priority: Math.abs(rawScale - 1.0) });
                            }
                            continue;
                        }
                        const ratio = r_static / r_orig;
                        if (ratio <= 0) continue;
                        const exact_scale = Math.pow(ratio, 1 / c);
                        allPossibleSnaps.push({ scale: exact_scale, priority: Math.abs(exact_scale - rawScale) });
                    }
                }
            });
        });
    }

    if (Math.abs(rawScale - 1.0) < C.SCALE_SNAP_THRESHOLD) {
        allPossibleSnaps.push({ scale: 1.0, priority: Math.abs(rawScale - 1.0) });
    }

    if (currentShiftPressed) {
        for (const factor of C.SNAP_FACTORS) {
            if (factor !== 0 && Math.abs(rawScale - factor) < 0.1) {
                allPossibleSnaps.push({ scale: factor, priority: Math.abs(rawScale - factor) });
            }
        }
    }

    if (allPossibleSnaps.length > 0) {
        allPossibleSnaps.sort((a, b) => a.priority - b.priority);
        const bestSnap = allPossibleSnaps[0];

        if (bestSnap.priority < 0.1) {
            const finalPos = U.applyTransformToVertex(handleVertex, center, 0, bestSnap.scale, false, null);
            return {
                scale: bestSnap.scale,
                pos: finalPos,
                snapped: true,
                snapType: 'merge',
                snappedScaleValue: bestSnap.scale
            };
        }
    }

    const finalPos = U.applyTransformToVertex(handleVertex, center, 0, rawScale, false, null);
    return { scale: rawScale, pos: finalPos, snapped: false, snapType: null };
}

function getBestDirectionalScaleSnap(center, initialVertexStates, handleVertex, rawScale, startVector) {
    const copyCount = parseInt(copyCountInput || '1', 10);
    let allPossibleSnaps = [];
    const snapThresholdData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;

    const axis_dist = Math.hypot(startVector.x, startVector.y);
    if (axis_dist < C.GEOMETRY_CALCULATION_EPSILON) {
        const finalPos = U.applyTransformToVertex(handleVertex, center, 0, rawScale, true, startVector);
        return { scale: rawScale, pos: finalPos, snapped: false, snapType: null };
    }
    const axis_norm = { x: startVector.x / axis_dist, y: startVector.y / axis_dist };
    const getProjectedComponents = (p) => {
        const vec = { x: p.x - center.x, y: p.y - center.y };
        const parallel_dist = vec.x * axis_norm.x + vec.y * axis_norm.y;
        const perp_vec = { x: vec.x - parallel_dist * axis_norm.x, y: vec.y - parallel_dist * axis_norm.y };
        return { parallel_dist, perp_vec };
    };

    if (copyCount > 1) {
        const staticVertices = allVertices.filter(p => p.type === 'regular' && !initialVertexStates.some(ip => ip.id === p.id));
        const verticesToTransform = initialVertexStates.filter(p => p.type === 'regular');

        for (let i = 0; i < verticesToTransform.length; i++) {
            for (let j = 0; j < verticesToTransform.length; j++) {
                const p1_orig = verticesToTransform[i];
                const p2_orig = verticesToTransform[j];
                const proj1 = getProjectedComponents(p1_orig);
                const proj2 = getProjectedComponents(p2_orig);
                if (U.distance(proj1.perp_vec, proj2.perp_vec) < snapThresholdData) {
                    for (let c1 = 0; c1 < copyCount; c1++) {
                        for (let c2 = 0; c2 < copyCount; c2++) {
                            if (p1_orig.id === p2_orig.id && c1 === c2) continue;
                            if (c1 === c2) continue;
                            const delta_c = c1 - c2;
                            if (delta_c === 0 || Math.abs(proj1.parallel_dist) < C.GEOMETRY_CALCULATION_EPSILON) continue;
                            const ratio = proj2.parallel_dist / proj1.parallel_dist;
                            if (ratio >= 0) {
                                const pos_scale = Math.pow(ratio, 1 / delta_c);
                                allPossibleSnaps.push({ scale: pos_scale, priority: Math.abs(pos_scale - rawScale) });
                                if (delta_c % 2 === 0) {
                                    const neg_scale = -pos_scale;
                                    allPossibleSnaps.push({ scale: neg_scale, priority: Math.abs(neg_scale - rawScale) });
                                }
                            } else if (delta_c % 2 !== 0) {
                                const neg_scale = -Math.pow(Math.abs(ratio), 1 / delta_c);
                                allPossibleSnaps.push({ scale: neg_scale, priority: Math.abs(neg_scale - rawScale) });
                            }
                        }
                    }
                }
            }
        }

        verticesToTransform.forEach(p_orig => {
            const proj_orig = getProjectedComponents(p_orig);
            staticVertices.forEach(p_static => {
                const proj_static = getProjectedComponents(p_static);
                if (U.distance(proj_orig.perp_vec, proj_static.perp_vec) < snapThresholdData) {
                    if (Math.abs(proj_orig.parallel_dist) < C.GEOMETRY_CALCULATION_EPSILON) return;
                    for (let c = 0; c < copyCount; c++) {
                        if (c === 0) {
                            if (Math.abs(proj_static.parallel_dist - proj_orig.parallel_dist) < snapThresholdData) {
                                allPossibleSnaps.push({ scale: 1.0, priority: Math.abs(rawScale - 1.0) });
                            }
                            continue;
                        }
                        const ratio = proj_static.parallel_dist / proj_orig.parallel_dist;
                        let exact_scale;
                        if (ratio >= 0) exact_scale = Math.pow(ratio, 1 / c);
                        else if (c % 2 !== 0) exact_scale = -Math.pow(Math.abs(ratio), 1 / c);
                        else continue;
                        allPossibleSnaps.push({ scale: exact_scale, priority: Math.abs(exact_scale - rawScale) });
                    }
                }
            });
        });

        const collapsedPositions = verticesToTransform.map(p => ({ p, collapsed: { x: center.x + getProjectedComponents(p).perp_vec.x, y: center.y + getProjectedComponents(p).perp_vec.y } }));
        for (const item of collapsedPositions) {
            if (staticVertices.some(sp => U.distance(item.collapsed, sp) < snapThresholdData)) {
                allPossibleSnaps.push({ scale: 0, priority: Math.abs(rawScale) });
            }
        }
        for (let i = 0; i < collapsedPositions.length; i++) {
            for (let j = i + 1; j < collapsedPositions.length; j++) {
                if (U.distance(collapsedPositions[i].collapsed, collapsedPositions[j].collapsed) < snapThresholdData) {
                    allPossibleSnaps.push({ scale: 0, priority: Math.abs(rawScale) });
                }
            }
        }
    }

    if (Math.abs(rawScale - 1.0) < 0.1) {
        allPossibleSnaps.push({ scale: 1.0, priority: Math.abs(rawScale - 1.0) });
    }
    if (Math.abs(rawScale) < 0.1) {
        allPossibleSnaps.push({ scale: 0, priority: Math.abs(rawScale) });
    }

    if (currentShiftPressed) {
        const scaleSnapFactors = C.SNAP_FACTORS.filter(f => f !== 0);
        for (const factor of scaleSnapFactors) {
            if (Math.abs(rawScale - factor) < 0.1) {
                allPossibleSnaps.push({ scale: factor, priority: Math.abs(rawScale - factor) });
            }
            if (Math.abs(rawScale - (-factor)) < 0.1) {
                allPossibleSnaps.push({ scale: -factor, priority: Math.abs(rawScale - (-factor)) });
            }
        }
    }

    if (allPossibleSnaps.length > 0) {
        allPossibleSnaps.sort((a, b) => a.priority - b.priority);
        const bestSnap = allPossibleSnaps[0];
        if (bestSnap.priority < 0.1) {
            const finalPos = U.applyTransformToVertex(handleVertex, center, 0, bestSnap.scale, true, startVector);
            return {
                scale: bestSnap.scale,
                pos: finalPos,
                snapped: true,
                snapType: 'merge',
                snappedScaleValue: bestSnap.scale
            };
        }
    }

    const finalPos = U.applyTransformToVertex(handleVertex, center, 0, rawScale, true, startVector);
    return { scale: rawScale, pos: finalPos, snapped: false, snapType: null };
}

function redrawAll() {
    labelsToKeepThisFrame.clear();
    let axisFormatInfo = { useScientific: false };
    const colors = getColors();
    R.clearCanvas(ctx, { canvas, dpr, colors });

    const actualCanvasWidth = canvas.width / dpr;
    const actualCanvasHeight = canvas.height / dpr;

    const { grid1Interval, grid2Interval, alpha1, alpha2 } = R.calculateGridIntervals(viewTransform.scale);
    lastGridState = { interval1: grid1Interval, interval2: grid2Interval, alpha1, alpha2, scale: viewTransform.scale };
    lastAngularGridState = R.getDynamicAngularIntervals(viewTransform, actualCanvasWidth, actualCanvasHeight, dataToScreen);

    R.drawGrid(ctx, { gridDisplayMode, canvas, dpr, viewTransform, gridAlpha, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState);

    if (coordsDisplayMode !== C.COORDS_DISPLAY_MODE_NONE) {
        const stateForAxes = { canvas, dpr, coordsDisplayMode, viewTransform, angleDisplayMode, colors };
        axisFormatInfo = R.drawAxes(ctx, htmlOverlay, stateForAxes, dataToScreen, screenToData, lastGridState, lastAngularGridState, updateHtmlLabel);
    }

    if (facesVisible && allVertices.length > 0) {
        R.drawFaces(ctx, {
            allFaces,
            facesVisible,
            isDragConfirmed,
            dragPreviewVertices,
            transformIndicatorData,
            initialDragVertexStates,
            colors,
            initialCoordSystemStates
        }, dataToScreen, findVertexById);
    }

    const copyCount = parseInt(copyCountInput || '1', 10);
    const isCopyPreviewActive = copyCount > 1 && isDragConfirmed && initialDragVertexStates.length > 0 && initialDragVertexStates.some(p => p.type === 'regular');

    const edgesWithHover = hoveredEdgeId ? [...selectedEdgeIds, hoveredEdgeId] : selectedEdgeIds;
    const stateForEdges = { allEdges, selectedEdgeIds: edgesWithHover, isDragConfirmed, dragPreviewVertices, colors, edgesVisible };
    R.drawAllEdges(ctx, stateForEdges, dataToScreen, findVertexById, U.getEdgeId);

    const originalDraggedVertexIds = isCopyPreviewActive
        ? new Set(initialDragVertexStates.map(v => v.id))
        : new Set();

    allVertices.forEach(vertex => {
        if (isCopyPreviewActive && originalDraggedVertexIds.has(vertex.id)) {
            return;
        }

        let vertexToDraw = { ...vertex };
        if (isDragConfirmed && dragPreviewVertices.length > 0) {
            const preview = dragPreviewVertices.find(dp => dp.id === vertex.id);
            if (preview) vertexToDraw = { ...preview };
        }
        R.drawVertex(ctx, vertexToDraw, { 
            selectedVertexIds, 
            selectedCenterIds, 
            activeCenterId, 
            colors, 
            verticesVisible, 
            isHovered: hoveredVertexId === vertex.id 
        }, dataToScreen, updateHtmlLabel);
    });

    if (isCopyPreviewActive) {
        R.drawCopyPreviews(ctx, { 
            copyCount, 
            isDragConfirmed, 
            initialDragVertexStates, 
            dragPreviewVertices, 
            transformIndicatorData, 
            allEdges, 
            allFaces,
            findVertexById, 
            findNeighbors: (id) => U.findNeighbors(id, allEdges), 
            colors 
        }, dataToScreen);
    }

    if (facesVisible && allVertices.length > 0) {
        R.drawFaceGlows(ctx, {
            allFaces,
            hoveredFaceId,
            selectedFaceIds,
            colors,
            isDragConfirmed,
            dragPreviewVertices
        }, dataToScreen, findVertexById, U.getFaceId);
        
        ensureFaceCoordinateSystems();
        
        if (selectedFaceIds.length > 0) {
            R.drawFaceCoordinateSystems(ctx, { 
                allFaces, 
                selectedFaceIds, 
                colors, 
                isDragConfirmed, 
                dragPreviewVertices, 
                initialDragVertexStates, 
                transformIndicatorData, 
                highlightedEdgeForSnap, 
                draggedFaceId, 
                coordSystemSnapAngle, 
                coordSystemSnapType,
                coordSystemSnapScale,
                initialCoordSystemStates
            }, dataToScreen, findVertexById);
        }
    }

    if (isDrawingMode && currentShiftPressed && frozenReference_Origin_Data) {
        const frozenDisplayContext = {
            frozen_Origin_Data_to_display: frozenReference_Origin_Data,
            displayAngleA_valueRad_for_A_equals_label: frozenReference_A_rad,
            frozen_A_baseRad_to_display: frozenReference_A_baseRad,
            frozen_D_du_to_display: frozenReference_D_du,
            frozen_D_g2g_to_display: frozenReference_D_g2g
        };
        const stateForRefGeo = { showAngles, showDistances, viewTransform, mousePos, colors };
        R.drawReferenceElementsGeometry(ctx, frozenDisplayContext, dataToScreen, screenToData, stateForRefGeo);
        const stateForRefTexts = { showAngles, showDistances, viewTransform, mousePos, frozenReference_D_du, distanceSigFigs, angleDisplayMode, colors };
        R.prepareReferenceElementsTexts(htmlOverlay, frozenDisplayContext, stateForRefTexts, screenToData, dataToScreen, updateHtmlLabel);
    }

    const stateForFeedback = { lastGridState, showDistances, showAngles, distanceSigFigs, angleDisplayMode, angleSigFigs, currentShiftPressed, viewTransform, colors };

    if (isDragConfirmed) {
        if (actionContext && actionContext.dragSnap) {
            const { dragOrigin, snappedData } = actionContext.dragSnap;
            const targetDataPos = { x: snappedData.x, y: snappedData.y };
            const edgeColorIndex = currentDrawingPath ? currentDrawingPath.length - 1 : 0;
            const totalExpectedEdges = currentDrawingPath ? Math.max(currentDrawingPath.length, 2) : 2;
            const nextEdgeColor = getColorForTarget(C.COLOR_TARGET_EDGE, edgeColorIndex, totalExpectedEdges);
            

            let edgeColormapInfo = null;
            const colorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
            if (colorIndex !== -1) {
                const colorItem = allColors[colorIndex];
                if (colorItem && colorItem.type === 'colormap') {
                    edgeColormapInfo = {
                        colormapItem: colorItem,
                        startT: 0,
                        endT: 1
                    };
                }
            }

            R.drawDrawingPreview(ctx, { startVertex: dragOrigin, snappedData, isShiftPressed: true, currentColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextCreationColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextEdgeColor, colors, edgeColormapInfo }, dataToScreen);
            const stateForSnapInfo = { showDistances, showAngles, currentShiftPressed, distanceSigFigs, angleSigFigs, angleDisplayMode, viewTransform, frozenReference_D_du, gridDisplayMode, frozenReference_A_rad, colors };
            R.prepareSnapInfoTexts(ctx, htmlOverlay, dragOrigin, targetDataPos, snappedData, stateForSnapInfo, dataToScreen, getDrawingContext(dragOrigin.id), updateHtmlLabel);
        } else {
            const hybridVertexStates = allVertices.map(p => {
                const draggedVersion = dragPreviewVertices.find(dp => dp.id === p.id);
                return draggedVersion || p;
            });

            if (actionContext && actionContext.targetVertex) {
                R.drawDragFeedback(ctx, htmlOverlay, actionContext.targetVertex.id, hybridVertexStates, stateForFeedback, dataToScreen, (id) => U.findNeighbors(id, allEdges), U.getEdgeId, currentShiftPressed, null, updateHtmlLabel, selectedVertexIds, true, initialDragVertexStates, activeCenterId);
            } else if (actionContext && actionContext.targetEdge) {
                R.drawSelectedEdgeDistances(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showDistances, distanceSigFigs, colors, lastGridState, currentShiftPressed }, findVertexById, U.getEdgeId, dataToScreen, updateHtmlLabel, dragPreviewVertices, initialDragVertexStates, transformIndicatorData);
            }
        }
    } else if ((showDistances || showAngles) && !isDrawingMode && !isCopyPreviewActive && !isPlacingTransform) {
        if (selectedVertexIds.length > 0 && selectedVertexIds.length <= C.MAX_VERTICES_FOR_ANGLES) {
            selectedVertexIds.forEach(vertexId => {
                R.drawDragFeedback(ctx, htmlOverlay, vertexId, allVertices, { ...stateForFeedback, currentShiftPressed: false }, dataToScreen, (id) => U.findNeighbors(id, allEdges), U.getEdgeId, false, null, updateHtmlLabel, selectedVertexIds, false, [], activeCenterId);
            });
        }
        if (selectedEdgeIds.length > 0 && selectedEdgeIds.length <= C.MAX_EDGES_FOR_LABELS) {
            R.drawSelectedEdgeDistances(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showDistances, distanceSigFigs, colors, lastGridState }, findVertexById, U.getEdgeId, dataToScreen, updateHtmlLabel, dragPreviewVertices, initialDragVertexStates, transformIndicatorData);
            R.drawSelectedEdgeAngles(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showAngles, angleSigFigs, angleDisplayMode, currentShiftPressed, distanceSigFigs, viewTransform, lastGridState, colors }, findVertexById, U.getEdgeId, dataToScreen, (id) => U.findNeighbors(id, allEdges), updateHtmlLabel);
        }
    }

    if (isDrawingMode && previewLineStartVertexId) {
        const startVertex = findVertexById(previewLineStartVertexId);
        if (startVertex) {
            const currentPreviewDrawingContext = getDrawingContext(startVertex.id);
            const snappedData = getSnappedPosition(startVertex, mousePos, currentShiftPressed);
            
            let nextEdgeColor = getColorForTarget(C.COLOR_TARGET_EDGE);
            let edgeColormapInfo = null;
            const colorIndex = colorAssignments[C.COLOR_TARGET_EDGE];

            if (colorIndex !== -1) {
                const colorItem = allColors[colorIndex];
                if (colorItem && colorItem.type === 'colormap') {
                    const totalEdges = currentDrawingPath ? Math.max(currentDrawingPath.length, 1) : 1;
                    const nextEdgeIndex = currentDrawingPath ? currentDrawingPath.length - 1 : 0;
                    const startT = totalEdges > 1 ? nextEdgeIndex / totalEdges : 0;
                    const endT = totalEdges > 1 ? (nextEdgeIndex + 1) / totalEdges : 1;
                    
                    edgeColormapInfo = {
                        colormapItem: colorItem,
                        startT: startT,
                        endT: endT
                    };
                }
            }
            
            R.drawDrawingPreview(ctx, { startVertex, snappedData, isShiftPressed: currentShiftPressed, currentColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextCreationColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextEdgeColor, colors, edgeColormapInfo }, dataToScreen);
            
            const targetDataPos = { x: snappedData.x, y: snappedData.y };
            const stateForSnapInfo = { showDistances, showAngles, currentShiftPressed, distanceSigFigs, angleSigFigs, angleDisplayMode, viewTransform, frozenReference_D_du, gridDisplayMode, frozenReference_A_rad, colors };
            R.prepareSnapInfoTexts(ctx, htmlOverlay, startVertex, targetDataPos, snappedData, stateForSnapInfo, dataToScreen, currentPreviewDrawingContext, updateHtmlLabel);
        }
    }

    if (isRectangleSelecting && isDragConfirmed) {
        R.drawSelectionRectangle(ctx, rectangleSelectStartPos, mousePos, colors);
    }

    if (isDragConfirmed) {
        R.drawMergePreviews(ctx, { allVertices, dragPreviewVertices, viewTransform, colors, transformIndicatorData, copyCount: parseInt(copyCountInput || '1', 10), initialDragVertexStates }, dataToScreen);
    }

    if (ghostVertexPosition) {
        const screenPos = dataToScreen(ghostVertexPosition);
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, C.VERTEX_RADIUS, 0, 2 * Math.PI);
        ctx.fillStyle = colors.feedbackSnapped;
        ctx.fill();
    }

    ghostVertices.forEach(ghostVertex => {
        const screenPos = dataToScreen(ghostVertex);
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, C.VERTEX_RADIUS, 0, 2 * Math.PI);
        ctx.fillStyle = colors.feedbackSnapped;
        ctx.fill();
    });

    if (transformIndicatorData || coordSystemTransformIndicatorData) {
        R.drawTransformIndicators(ctx, htmlOverlay, { transformIndicatorData, angleSigFigs, distanceSigFigs, colors, coordSystemTransformIndicatorData }, dataToScreen, updateHtmlLabel);
    }

    R.updateMouseCoordinates(htmlOverlay, { coordsDisplayMode, isMouseOverCanvas, currentShiftPressed, ghostVertexPosition, gridDisplayMode, lastGridState, angleDisplayMode, canvas, dpr, mousePos, colors, useScientific: axisFormatInfo.useScientific }, screenToData, updateHtmlLabel);
    const stateForUI = {
        dpr, canvasUI, isToolbarExpanded, isColorPaletteExpanded, isTransformPanelExpanded, isDisplayPanelExpanded, isVisibilityPanelExpanded,
        isPlacingTransform, placingTransformType, placingSnapPos, mousePos,
        allColors, activeThemeName, colors, verticesVisible, edgesVisible, facesVisible, coordsDisplayMode, gridDisplayMode, angleDisplayMode, distanceDisplayMode,
        namedColors: colorEditor.namedColors,
        colorAssignments, activeColorTargets,
        isDraggingColorTarget, draggedColorTargetInfo
    };
    R.drawCanvasUI(ctx, htmlOverlay, stateForUI, updateHtmlLabel);

    cleanupHtmlLabels();
}

function getBestRigidTranslationSnap(initialDragVertexStates, rawDelta, copyCount) {
    const mergeSnap = getBestTranslationSnap(initialDragVertexStates, rawDelta, copyCount);
    if (mergeSnap.snapped) {
        return mergeSnap;
    }

    const handleVertex = initialDragVertexStates[0];
    const mouseDragPos = { x: handleVertex.x + rawDelta.x, y: handleVertex.y + rawDelta.y };
    const rawDist = Math.hypot(rawDelta.x, rawDelta.y);
    const rawAngle = Math.atan2(rawDelta.y, rawDelta.x);

    let allCandidates = [];
    const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

    if (gridInterval) {
        const distUnit = gridInterval * 0.5;
        const snapDistBefore = Math.floor(rawDist / distUnit) * distUnit;
        const snapDistAfter = snapDistBefore + distUnit;

        const allSnapAngles = C.NINETY_DEG_ANGLE_SNAP_FRACTIONS.flatMap(f => {
            const angle = f * Math.PI / 2;
            return angle === 0 ? [0] : [angle, -angle];
        }).sort((a, b) => a - b);

        let angleBefore = -Infinity;
        let angleAfter = Infinity;

        for (const snapAngle of allSnapAngles) {
            if (snapAngle <= rawAngle) {
                angleBefore = snapAngle;
            }
            if (snapAngle >= rawAngle && angleAfter === Infinity) {
                angleAfter = snapAngle;
            }
        }
        if (angleAfter === Infinity) angleAfter = allSnapAngles[0] + (2 * Math.PI);
        if (angleBefore === -Infinity) angleBefore = allSnapAngles[allSnapAngles.length - 1] - (2 * Math.PI);

        allCandidates.push({ x: snapDistBefore * Math.cos(angleBefore), y: snapDistBefore * Math.sin(angleBefore) });
        allCandidates.push({ x: snapDistBefore * Math.cos(angleAfter), y: snapDistBefore * Math.sin(angleAfter) });
        allCandidates.push({ x: snapDistAfter * Math.cos(angleBefore), y: snapDistAfter * Math.sin(angleBefore) });
        allCandidates.push({ x: snapDistAfter * Math.cos(angleAfter), y: snapDistAfter * Math.sin(angleAfter) });

        const gridVertices = U.getGridSnapCandidates(mouseDragPos, gridDisplayMode, gridInterval, lastAngularGridState, true);
        gridVertices.forEach(p => {
            allCandidates.push({ x: p.x - handleVertex.x, y: p.y - handleVertex.y });
        });
    }

    if (allCandidates.length === 0) {
        return { delta: rawDelta, snapped: false };
    }

    let bestDelta = rawDelta;
    let minSnapDistSq = Infinity;
    allCandidates.forEach(deltaCandidate => {
        const distSq = (deltaCandidate.x - rawDelta.x) ** 2 + (deltaCandidate.y - rawDelta.y) ** 2;
        if (distSq < minSnapDistSq) {
            minSnapDistSq = distSq;
            bestDelta = deltaCandidate;
        }
    });

    const snapStickinessData = C.SNAP_STICKINESS_RADIUS_SCREEN / viewTransform.scale;
    if (Math.sqrt(minSnapDistSq) < snapStickinessData) {
        return { delta: bestDelta, snapped: true, snapType: 'geometric_grid' };
    }

    return { delta: rawDelta, snapped: false };
}

function updateDrawingSequenceColors() {
    if (!currentDrawingPath || currentDrawingPath.length < 2) return;
    
    const colorIndex = colorAssignments[C.COLOR_TARGET_VERTEX];
    if (colorIndex === -1) return;
    
    const colorItem = allColors[colorIndex];
    if (!colorItem || colorItem.type !== 'colormap') return;
    
    const totalVertices = currentDrawingPath.length;
    currentDrawingPath.forEach((vertexId, index) => {
        const vertex = findVertexById(vertexId);
        if (vertex && vertex.type === 'regular') {
            const t = totalVertices > 1 ? index / (totalVertices - 1) : 0.5;
            vertex.color = U.sampleColormap(colorItem, t);
        }
    });
}

function updateDrawingSequenceEdgeColors() {
    if (!currentDrawingPath || currentDrawingPath.length < 2) return;
    
    const colorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
    if (colorIndex === -1) return;
    
    const colorItem = allColors[colorIndex];
    if (!colorItem || colorItem.type !== 'colormap') return;
    
    const totalVertices = currentDrawingPath.length;
    const totalEdges = totalVertices - 1;
    
    for (let i = 0; i < totalEdges; i++) {
        const startVertexId = currentDrawingPath[i];
        const endVertexId = currentDrawingPath[i + 1];
        
        const edge = allEdges.find(e => 
            (e.id1 === startVertexId && e.id2 === endVertexId) ||
            (e.id1 === endVertexId && e.id2 === startVertexId)
        );
        
        if (edge) {
            const startT = i / totalEdges;
            const endT = (i + 1) / totalEdges;
            edge.gradientStart = startT;
            edge.gradientEnd = endT;
            edge.colormapItem = colorItem;
            delete edge.colormapOffset;
            delete edge.color;
        }
    }
}

function handleColorPaletteClick(screenPos, shiftKey, ctrlKey) {
    if (!isColorPaletteExpanded) return false;


    const removeBtn = canvasUI.removeColorButton;
    if (removeBtn && screenPos.x >= removeBtn.x && screenPos.x <= removeBtn.x + removeBtn.width &&
        screenPos.y >= removeBtn.y && screenPos.y <= removeBtn.y + removeBtn.height) {
        if (allColors.length > 1 && activeColorTargets.length > 0) {
            const primaryTarget = activeColorTargets[activeColorTargets.length - 1];
            const colorIndexToRemove = colorAssignments[primaryTarget];
            if (colorIndexToRemove >= 0) {
                saveStateForUndo();
                removeColorAtIndex(colorIndexToRemove);
            }
        }
        return true;
    }

    const addBtn = canvasUI.addColorButton;
    if (addBtn && screenPos.x >= addBtn.x && screenPos.x <= addBtn.x + addBtn.width &&
        screenPos.y >= addBtn.y && screenPos.y <= addBtn.y + addBtn.height) {
        isEditingColor = false;
        editingColorIndex = null;
        colorEditor.show();
        return true;
    }

    return false;
}

function performEscapeAction() {
    if (copyCountTimer) clearTimeout(copyCountTimer);
    copyCountInput = '';
    copyCountTimer = null;

    // Add this new section:
    if (isDraggingColorSwatch) {
        // Restore original state since drag was cancelled
        allColors = draggedSwatchInfo.originalAllColors;
        colorAssignments = draggedSwatchInfo.originalAssignments;
        buildColorPaletteUI();
        
        // Remove the state we saved at drag start since no action was completed
        if (undoStack.length > 0) {
            undoStack.pop();
        }
        
        isDraggingColorSwatch = false;
        draggedSwatchInfo = null;
        draggedSwatchTemporarilyRemoved = false;
    }

    if (isDrawingMode) {
        isDrawingMode = false;
        previewLineStartVertexId = null;
        frozenReference_A_rad = null;
        frozenReference_A_baseRad = null;
        frozenReference_D_du = null;
        frozenReference_D_g2g = null;
        frozenReference_Origin_Data = null;
        drawingSequence = [];
        currentSequenceIndex = 0;
        currentDrawingPath = [];
        return;
    }

    if (isPlacingTransform) {
        isPlacingTransform = false;
        placingTransformType = null;
        placingSnapPos = null;
    }

    selectedVertexIds = [];
    selectedEdgeIds = [];
    selectedFaceIds = [];
    selectedCenterIds = [];
    activeCenterId = null;
    activeColorTargets = [];
    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }

    coordSystemTransformIndicatorData = null;
    isActionInProgress = false;
    isDragConfirmed = false;
    isRectangleSelecting = false;
    isEdgeTransformDrag = false;
    isDraggingCenter = false;
    isPanningBackground = false;
    dragPreviewVertices = [];
    initialDragVertexStates = [];
    actionTargetVertex = null;
    currentMouseButton = -1;
    clickData = { targetId: null, type: null, count: 0, timestamp: 0 };
    canvas.style.cursor = 'crosshair';
    transformIndicatorData = null;
    ghostVertices = [];
    ghostVertexPosition = null;
    highlightedEdgeForSnap = null;
    coordSystemSnapAngle = null;
    draggedFaceId = null;
    coordSystemSnapType = null;
    coordSystemTransformIndicatorData = null;
}

function handleRepeat() {
    if (!isDrawingMode || !previewLineStartVertexId || drawingSequence.length === 0) {
        return;
    }

    saveStateForUndo();

    const lastVertex = findVertexById(previewLineStartVertexId);
    if (!lastVertex) {
        performEscapeAction();
        return;
    }

    const precedingSegmentOfLastVertex = getPrecedingSegment(lastVertex.id);
    if (!precedingSegmentOfLastVertex) {
        performEscapeAction();
        return;
    }
    const currentAbsoluteDirection = precedingSegmentOfLastVertex.angleRad;

    if (drawingSequence.length === 1) {
        return;
    }

    const repeatPatternLength = drawingSequence.length - 1;
    const patternStepIndex = ((currentSequenceIndex - 1) % repeatPatternLength) + 1;
    const patternStep = drawingSequence[patternStepIndex];

    const lengthToDraw = patternStep.length;
    let turnToApplyForNextSegment;
    if (patternStepIndex === drawingSequence.length - 1) {
        const firstRepeatSegmentIndex = drawingSequence.length > 2 ? 1 : 0;
        turnToApplyForNextSegment = drawingSequence[firstRepeatSegmentIndex].turn;
    } else {
        turnToApplyForNextSegment = patternStep.turn;
    }

    let colorForNewVertex;
    let colorForCurrentVertex;

    if (patternStepIndex === drawingSequence.length - 1) {
        const establishedColors = [drawingSequence[0].endVertexColor, drawingSequence[1].endVertexColor];
        const currentColorIndex = (currentSequenceIndex - 1) % establishedColors.length;
        colorForCurrentVertex = establishedColors[currentColorIndex];
        const newColorIndex = currentSequenceIndex % establishedColors.length;
        colorForNewVertex = establishedColors[newColorIndex];
        lastVertex.color = colorForCurrentVertex;
    } else {
        colorForNewVertex = patternStep.endVertexColor;
    }

    const newSegmentAbsoluteAngle = U.normalizeAngle(currentAbsoluteDirection + turnToApplyForNextSegment);

    const targetX = lastVertex.x + lengthToDraw * Math.cos(newSegmentAbsoluteAngle);
    const targetY = lastVertex.y + lengthToDraw * Math.sin(newSegmentAbsoluteAngle);

    let newVertex = null;
    let merged = false;
    const mergeRadiusData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;

    for (const p of allVertices) {
        if (p.type === 'regular' && U.distance({ x: targetX, y: targetY }, p) < mergeRadiusData) {
            newVertex = p;
            merged = true;
            break;
        }
    }

    if (!merged) {
        newVertex = { id: U.generateUniqueId(), x: targetX, y: targetY, type: 'regular', color: colorForNewVertex };
        allVertices.push(newVertex);
    }

    const edgeExists = allEdges.some(e =>
            (e.id1 === lastVertex.id && e.id2 === newVertex.id) ||
            (e.id2 === lastVertex.id && e.id1 === newVertex.id)
        );
        if (!edgeExists) {
            allEdges.push({ id1: lastVertex.id, id2: newVertex.id, color: getColorForTarget(C.COLOR_TARGET_EDGE) });
        }

        if (facesVisible) {
            allFaces = U.detectClosedPolygons(allEdges, findVertexById);
            ensureFaceCoordinateSystems();
        }

        currentDrawingPath.push(newVertex.id);
        window.currentDrawingPath = currentDrawingPath;

        // Update both vertex and edge colors in the drawing sequence
        updateDrawingSequenceColors();
        updateDrawingSequenceEdgeColors();

    previewLineStartVertexId = newVertex.id;

    currentSequenceIndex++;
    if (currentSequenceIndex >= drawingSequence.length) {
        currentSequenceIndex = 1;
    }

    frozenReference_D_du = null;
    frozenReference_D_g2g = null;
    frozenReference_A_rad = null;
    frozenReference_A_baseRad = null;
    frozenReference_Origin_Data = null;
}

function gameLoop() {
    redrawAll();
    requestAnimationFrame(gameLoop);
}


function handleCoordinateSystemMouseDown(event) {
    if (selectedFaceIds.length === 0) return false;

    const mousePos = U.getMousePosOnCanvas(event, canvas);

    for (const faceId of selectedFaceIds) {
        const face = allFaces.find(f => f.id === faceId);
        if (!face || !face.localCoordSystem) continue;

        const element = U.findCoordinateSystemElement(mousePos, face, dataToScreen);
        if (element) {
            isDraggingCoordSystem = true;
            draggedCoordSystemElement = element;
            draggedFaceId = face.id;
            coordSystemSnapTargets = prepareCoordSystemSnapTargets(face);

            if (element.type === 'center') {
                face.localCoordSystem.isCustom = true;
            }

            event.preventDefault();
            return true;
        }
    }

    return false;
}

function prepareCoordSystemSnapTargets(currentFace) {
    const vertices = [];
    const edgeMidvertices = [];
    const edgeVertexIds = [];
    const faceCenters = [];
    const edgeAngles = [];

    currentFace.vertexIds.forEach(id => {
        const vertex = findVertexById(id);
        if (vertex && vertex.type === 'regular') {
            vertices.push({ ...vertex, id: id });
        }
    });

    for (let i = 0; i < vertices.length; i++) {
        const v1 = vertices[i];
        const v2 = vertices[(i + 1) % vertices.length];
        edgeMidvertices.push({
            x: (v1.x + v2.x) / 2,
            y: (v1.y + v2.y) / 2
        });
        
        edgeVertexIds.push(v1.id, v2.id);
        edgeAngles.push(Math.atan2(v2.y - v1.y, v2.x - v1.x));
    }

    allFaces.forEach(face => {
        if (face.id !== currentFace.id && face.localCoordSystem) {
            faceCenters.push(face.localCoordSystem.origin);
        }
    });

    return { vertices, edgeMidvertices, edgeVertexIds, faceCenters, edgeAngles };
}

function handleCoordinateSystemMouseMove(event) {
    if (!isDraggingCoordSystem || !draggedCoordSystemElement) return false;

    const mousePos = U.getMousePosOnCanvas(event, canvas);
    const mouseDataPos = screenToData(mousePos);
    const element = draggedCoordSystemElement;
    const face = element.face;
    const coordSystem = face.localCoordSystem;

    const faceVertices = face.vertexIds.map(id => findVertexById(id)).filter(p => p && p.type === 'regular' && p.x !== undefined && p.y !== undefined);

    if (element.type === 'center') {
        let targetPos;
        let snapResult = { snapped: false };
        
        if (event.shiftKey) {
            snapResult = U.getCoordinateSystemCenterSnap(
                mouseDataPos,
                coordSystemSnapTargets,
                gridDisplayMode,
                lastGridState,
                lastAngularGridState
            );
            
            if (snapResult.snapped) {
                targetPos = snapResult.snapPoint;
                
                if (snapResult.snapType === 'edge') {
                    const edgeInfo = snapResult.edgeInfo;
                    const v1 = findVertexById(edgeInfo.v1);
                    const v2 = findVertexById(edgeInfo.v2);
                    
                    if (v1 && v2) {
                        if (initialCoordSystemStateOnDrag && initialCoordSystemStateOnDrag.attachedToEdge) {
                            const fractions = [0, 0.25, 1/3, 0.5, 2/3, 0.75, 1];
                            let bestFraction = 0.5;
                            let minDist = Infinity;
                            
                            fractions.forEach(frac => {
                                const fracPoint = {
                                    x: v1.x + frac * (v2.x - v1.x),
                                    y: v1.y + frac * (v2.y - v1.y)
                                };
                                const dist = U.distance(mouseDataPos, fracPoint);
                                if (dist < minDist) {
                                    minDist = dist;
                                    bestFraction = frac;
                                }
                            });
                            
                            targetPos = {
                                x: v1.x + bestFraction * (v2.x - v1.x),
                                y: v1.y + bestFraction * (v2.y - v1.y)
                            };
                            
                            snapResult.edgeInfo.t = bestFraction;
                            
                            const currentEdgeLength = U.distance(v1, v2);
                            const originalEdgeLength = coordSystem.attachedToEdge ? coordSystem.attachedToEdge.originalLength : currentEdgeLength;
                            const scaleRatio = coordSystem.scale / originalEdgeLength;
                            
                            snapResult.edgeInfo.originalLength = currentEdgeLength;
                            snapResult.edgeInfo.scaleRatio = scaleRatio;
                            
                            coordSystemTransformIndicatorData = {
                                edgeFraction: bestFraction,
                                v1: v1,
                                v2: v2,
                                snapPosition: targetPos
                            };
                        } else {
                            targetPos = snapResult.snapPoint;
                            coordSystemTransformIndicatorData = null;
                        }
                    }
                }
            } else {
                const incenter = U.calculateIncenter(faceVertices);
                targetPos = incenter ? incenter.center : faceVertices[0];
            }
            
            if (element.type === 'center') {
                ghostVertexPosition = targetPos;
            }
        } else {
            targetPos = mouseDataPos;
            ghostVertexPosition = null;
            coordSystemTransformIndicatorData = null;
        }
        
        if (faceVertices.length > 0 && faceVertices.every(v => v && v.x !== undefined && v.y !== undefined)) {
            targetPos = U.clampPointToPolygon(targetPos, faceVertices);
            
            if (ghostVertexPosition) {
                ghostVertexPosition = U.clampPointToPolygon(ghostVertexPosition, faceVertices);
            }
        }
        
        coordSystem.origin.x = targetPos.x;
        coordSystem.origin.y = targetPos.y;
        coordSystem.isCustom = true;
        
        if (snapResult.snapped) {
            coordSystem.attachedToVertex = snapResult.vertexId || null;
            coordSystem.attachedToEdge = snapResult.edgeInfo || null;
        } else {
            coordSystem.attachedToVertex = null;
            coordSystem.attachedToEdge = null;
        }
    } else if (element.type === 'x_axis' || element.type === 'y_axis') {
        const vectorFromOrigin = {
            x: mouseDataPos.x - coordSystem.origin.x,
            y: mouseDataPos.y - coordSystem.origin.y
        };
        
        let newAngle = Math.atan2(vectorFromOrigin.y, vectorFromOrigin.x);
        let newScale = Math.hypot(vectorFromOrigin.x, vectorFromOrigin.y);

        highlightedEdgeForSnap = null;
        coordSystemSnapAngle = null;
        coordSystemSnapType = null;
        ghostVertices = [];
        ghostVertexPosition = null;
        coordSystemTransformIndicatorData = null;
        coordSystemSnapScale = null;
        
        if (event.shiftKey) {
            const angleSnapResult = U.getAxisSnapAngle(mouseDataPos, coordSystem.origin, true, coordSystemSnapTargets);
            
            if (angleSnapResult.snapped) {
                newAngle = angleSnapResult.angle;
                coordSystemSnapAngle = newAngle;
                coordSystemSnapType = angleSnapResult.snapType;
                
                const snappedAxisDirection = { x: Math.cos(newAngle), y: Math.sin(newAngle) };
                const mouseVector = { x: mouseDataPos.x - coordSystem.origin.x, y: mouseDataPos.y - coordSystem.origin.y };
                const effectiveScale = mouseVector.x * snappedAxisDirection.x + mouseVector.y * snappedAxisDirection.y;

                if (angleSnapResult.snapType === 'vertex_direction') {
                    const targetVertex = findVertexById(angleSnapResult.targetVertexId);
                    if (targetVertex) {
                        newScale = U.distance(coordSystem.origin, targetVertex);
                        coordSystemSnapScale = newScale;
                    }
                } else if (angleSnapResult.edgeIndex !== null) {
                    highlightedEdgeForSnap = angleSnapResult.edgeIndex;
                    const edgeInfo = getAlignedEdgeInfo(face, angleSnapResult.edgeIndex);
                    const isPerpendicular = Math.abs(U.normalizeAngleToPi(newAngle - edgeInfo.edgeAngle)) > Math.PI / 4 && Math.abs(U.normalizeAngleToPi(newAngle - edgeInfo.edgeAngle)) < 3 * Math.PI / 4;

                    if (element.type === 'x_axis' && isPerpendicular) {
                        const v1 = findVertexById(edgeInfo.v1Id);
                        const v2 = findVertexById(edgeInfo.v2Id);
                        if (v1 && v2) {
                            const closestOnEdge = U.getClosestPointOnLine(coordSystem.origin, v1, v2);
                            const referenceOrthogonalDistance = closestOnEdge.distance;

                            const fractions = [0.25, 1/3, 0.5, 2/3, 0.75, 1.0];
                            let bestSnap = { scale: effectiveScale, dist: Infinity, fraction: null };

                            fractions.forEach(frac => {
                                const targetDist = referenceOrthogonalDistance * frac;
                                const diff = Math.abs(effectiveScale - targetDist);
                                if (diff < bestSnap.dist) {
                                    bestSnap = { scale: targetDist, dist: diff, fraction: frac };
                                }
                            });
                            
                            const pixelSnapThreshold = 15 / viewTransform.scale;
                            if (bestSnap.dist < pixelSnapThreshold) {
                                newScale = bestSnap.scale;
                                coordSystemSnapScale = newScale;
                                coordSystemTransformIndicatorData = {
                                    orthogonalDistanceFraction: bestSnap.fraction,
                                    v1: v1,
                                    v2: v2,
                                    snapPosition: { origin: coordSystem.origin, closest: closestOnEdge }
                                };
                            } else {
                                newScale = effectiveScale > 0 ? effectiveScale : 0;
                                coordSystemSnapScale = newScale;
                            }
                        }
                    } else {
                        const scaleSnapResult = U.getAxisScaleSnap(
                            coordSystem.origin, 
                            element.type === 'y_axis' ? newAngle - Math.PI / 2 : newAngle, 
                            { alignedEdgeInfo: edgeInfo }, 
                            face, 
                            findVertexById,
                            effectiveScale,
                            viewTransform,
                            element.type
                        );
                        
                        if (scaleSnapResult.snapped) {
                            newScale = scaleSnapResult.scale;
                            coordSystemSnapScale = newScale;
                            
                            if (scaleSnapResult.edgeFraction !== null) {
                                const arrowHeadPosition = {
                                    x: coordSystem.origin.x + newScale * Math.cos(element.type === 'y_axis' ? newAngle : newAngle),
                                    y: coordSystem.origin.y + newScale * Math.sin(element.type === 'y_axis' ? newAngle : newAngle)
                                };
                                coordSystemTransformIndicatorData = {
                                    edgeFraction: scaleSnapResult.edgeFraction,
                                    v1: findVertexById(edgeInfo.v1Id),
                                    v2: findVertexById(edgeInfo.v2Id),
                                    snapPosition: arrowHeadPosition
                                };
                            }
                        } else {
                             newScale = effectiveScale > 0 ? effectiveScale : 0;
                        }
                    }
                }
            } else {
                newScale = Math.hypot(vectorFromOrigin.x, vectorFromOrigin.y);
            }
        }

        if (element.type === 'y_axis') {
            coordSystem.angle = newAngle - Math.PI / 2;
        } else {
            coordSystem.angle = newAngle;
        }

        if (newScale > 0.01) {
            coordSystem.scale = newScale;
        }

        coordSystem.isCustom = true;
    }

    return true;
}

function handleCoordinateSystemMouseUp() {
    if (isDraggingCoordSystem) {
        const element = draggedCoordSystemElement;
        const face = element.face;
        const coordSystem = face.localCoordSystem;
        
        if (element.type === 'center' && coordSystem) {
            const snapThreshold = 0.01;
            let attachedToVertex = null;
            let attachedToEdge = null;
            
            face.vertexIds.forEach(vertexId => {
                const vertex = findVertexById(vertexId);
                if (vertex && U.distance(coordSystem.origin, vertex) < snapThreshold) {
                    attachedToVertex = vertexId;
                }
            });
            
            if (!attachedToVertex) {
                for (let i = 0; i < face.vertexIds.length; i++) {
                    const v1 = findVertexById(face.vertexIds[i]);
                    const v2 = findVertexById(face.vertexIds[(i + 1) % face.vertexIds.length]);
                    if (v1 && v2) {
                        const closest = U.getClosestPointOnLineSegment(coordSystem.origin, v1, v2);
                        if (closest.distance < snapThreshold && closest.onSegmentStrict) {
                            const currentEdgeLength = U.distance(v1, v2);
                            attachedToEdge = { 
                                v1: v1.id, 
                                v2: v2.id, 
                                t: closest.t,
                                originalAngle: Math.atan2(v2.y - v1.y, v2.x - v1.x),
                                originalLength: currentEdgeLength,
                                scaleRatio: coordSystem.scale / currentEdgeLength
                            };
                            break;
                        }
                    }
                }
            }
            
            coordSystem.attachedToVertex = attachedToVertex;
            coordSystem.attachedToEdge = attachedToEdge;
        }

        if (element.type === 'x_axis' || element.type === 'y_axis') {
            let didSnapRotationToEdge = false;
            let didSnapScaleToEdge = false;

            if (coordSystemSnapType === 'edge' && highlightedEdgeForSnap !== null) {
                const edgeInfo = getAlignedEdgeInfo(face, highlightedEdgeForSnap);
                if (edgeInfo) {
                    if (coordSystemSnapAngle !== null) {
                        coordSystem.rotationAlignedToEdge = {
                            v1: edgeInfo.v1Id,
                            v2: edgeInfo.v2Id,
                            originalAngle: edgeInfo.edgeAngle,
                            originalSystemAngle: coordSystem.angle
                        };
                        didSnapRotationToEdge = true;
                    }

                    if (coordSystemSnapScale !== null) {
                        const v1 = findVertexById(edgeInfo.v1Id);
                        const v2 = findVertexById(edgeInfo.v2Id);
                        if (v1 && v2) {
                            const edgeLength = U.distance(v1, v2);
                            if (edgeLength > C.GEOMETRY_CALCULATION_EPSILON) {
                                coordSystem.scaleAttachedToEdge = {
                                    v1: edgeInfo.v1Id,
                                    v2: edgeInfo.v2Id,
                                    scaleRatio: coordSystem.scale / edgeLength
                                };
                                didSnapScaleToEdge = true;
                            }
                         }
                    }
                }
            }

            if (!didSnapRotationToEdge) {
                coordSystem.rotationAlignedToEdge = null;
            }
            if (!didSnapScaleToEdge) {
                coordSystem.scaleAttachedToEdge = null;
            }
        }
        
        coordSystemSnapScale = null;
        coordSystemTransformIndicatorData = null;
        isDraggingCoordSystem = false;
        draggedCoordSystemElement = null;
        coordSystemSnapTargets = null;
        highlightedEdgeForSnap = null;
        coordSystemSnapAngle = null;
        coordSystemSnapType = null;
        draggedFaceId = null;
        ghostVertexPosition = null;
        ghostVertices = [];
        coordSystemTransformIndicatorData = null;
        return true;
    }
    return false;
}

function handleKeyDown(event) {
    const isCtrlOrCmd = event.ctrlKey || event.metaKey;
    const colors = getColors();

    if (event.key === 'Shift' && !currentShiftPressed) {
        currentShiftPressed = true;
        const mouseDataPos = screenToData(mousePos);
        if (isPlacingTransform) {
            const potentialSnapPos = getBestSnapPosition(mouseDataPos);
            if (potentialSnapPos) {
                placingSnapPos = dataToScreen(potentialSnapPos);
                ghostVertexPosition = potentialSnapPos;
            }
        } else if (isDrawingMode && previewLineStartVertexId) {
            const startVertex = findVertexById(previewLineStartVertexId);
            if (startVertex) {
                const currentPreviewDrawingContext = getDrawingContext(startVertex.id);
                const snappedData = getSnappedPosition(startVertex, mousePos, currentShiftPressed);

                let nextEdgeColor = getColorForTarget(C.COLOR_TARGET_EDGE);
                let edgeColormapInfo = null;

                const colorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
                if (colorIndex !== -1) {
                    const colorItem = allColors[colorIndex];
                    if (colorItem && colorItem.type === 'colormap' && currentDrawingPath && currentDrawingPath.length >= 1) {
                        const totalEdges = currentDrawingPath.length;
                        const nextEdgeIndex = currentDrawingPath.length - 1;
                        const startT = totalEdges > 1 ? nextEdgeIndex / (totalEdges - 1) : 0;
                        const endT = totalEdges > 1 ? (nextEdgeIndex + 1) / totalEdges : 1;
                        edgeColormapInfo = {
                            colormapItem: colorItem,
                            startT: startT,
                            endT: endT
                        };
                    }
                }

                R.drawDrawingPreview(ctx, { startVertex, snappedData, isShiftPressed: currentShiftPressed, currentColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextCreationColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextEdgeColor, colors, edgeColormapInfo }, dataToScreen);
                const stateForSnapInfo = { showDistances, showAngles, currentShiftPressed, distanceSigFigs, angleSigFigs, angleDisplayMode, viewTransform, frozenReference_D_du, gridDisplayMode, frozenReference_A_rad, colors };
                R.prepareSnapInfoTexts(ctx, htmlOverlay, startVertex, snappedData, snappedData, stateForSnapInfo, dataToScreen, currentPreviewDrawingContext, updateHtmlLabel);
            }
        } else if (!isActionInProgress) {
            if (isDraggingCoordSystem && draggedCoordSystemElement && draggedCoordSystemElement.type === 'center') {
                const potentialSnapPos = getBestSnapPosition(mouseDataPos);
                if (potentialSnapPos) {
                    ghostVertexPosition = potentialSnapPos;
                    // Apply the snap to the coordinate system
                    const face = draggedCoordSystemElement.face;
                    const coordSystem = face.localCoordSystem;
                    const faceVertices = face.vertexIds.map(id => findVertexById(id)).filter(p => p && p.type === 'regular');
                    const clampedPos = U.clampPointToPolygon(potentialSnapPos, faceVertices);
                    coordSystem.origin.x = clampedPos.x;
                    coordSystem.origin.y = clampedPos.y;
                    coordSystem.isCustom = true;
                }
            } else {
                const clickedFace = findClickedFace(mousePos);
                if (!clickedFace) {
                    ghostVertexPosition = getBestSnapPosition(mouseDataPos);
                } else {
                    ghostVertexPosition = null;
                }
            }
        }
    }

    if (isActionInProgress && currentMouseButton === 0 && (actionContext?.targetVertex || actionContext?.targetEdge) && event.key >= '0' && event.key <= '9') {
        if (event.repeat) {
            return;
        }
        event.preventDefault();

        clearTimeout(copyCountTimer);

        if (copyCountTimer === null || copyCountInput.length >= 2) {
            copyCountInput = event.key;
        } else {
            copyCountInput += event.key;
        }

        copyCountTimer = setTimeout(() => {
            copyCountTimer = null;
        }, 500);
        return;
    }

    if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_REPEAT) {
        event.preventDefault();
        if (isDrawingMode && previewLineStartVertexId) {
            handleRepeat();
        }
        return;
    }

    const allowedDuringAction = ['Shift', 'Control', 'Meta', 'Alt', 'Escape', 'Delete', 'Backspace'];
    if (isActionInProgress && !allowedDuringAction.includes(event.key) && !(isCtrlOrCmd && [C.KEY_COPY, C.KEY_CUT, C.KEY_PASTE, C.KEY_UNDO, C.KEY_REDO, C.KEY_SELECT_ALL, C.KEY_ZOOM_OUT, C.KEY_ZOOM_IN, C.KEY_ZOOM_IN_PLUS].includes(event.key.toLowerCase()))) return;

    if (isMouseOverCanvas && isCtrlOrCmd && (event.key === C.KEY_ZOOM_IN || event.key === C.KEY_ZOOM_IN_PLUS)) {
        event.preventDefault();
        const centerScreen = { x: (canvas.width / dpr) / 2, y: (canvas.height / dpr) / 2 };
        zoomAt(centerScreen, C.KEYBOARD_ZOOM_FACTOR);
        return;
    }
    if (isMouseOverCanvas && isCtrlOrCmd && event.key === C.KEY_ZOOM_OUT) {
        event.preventDefault();
        const centerScreen = { x: (canvas.width / dpr) / 2, y: (canvas.height / dpr) / 2 };
        zoomAt(centerScreen, 1 / C.KEYBOARD_ZOOM_FACTOR);
        return;
    }

    if (event.key === C.KEY_SPACE) {
        event.preventDefault();
        completeGraphOnSelectedVertices();
    } else if (event.key === C.KEY_ESCAPE) {
        performEscapeAction();
    } else if (event.key === C.KEY_DELETE || event.key === C.KEY_BACKSPACE) {
        deleteSelectedItems();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_COPY) {
        event.preventDefault();
        handleCopy();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_CUT) {
        event.preventDefault();
        handleCut();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_PASTE) {
        event.preventDefault();
        handlePaste();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_UNDO && !event.shiftKey) {
        event.preventDefault();
        handleUndo();
    } else if (isCtrlOrCmd && (event.key.toLowerCase() === C.KEY_REDO || (event.shiftKey && event.key.toLowerCase() === C.KEY_UNDO))) {
        event.preventDefault();
        handleRedo();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_SELECT_ALL && !isMouseOverColorEditor) {
        event.preventDefault();
        saveStateForUndo();
        selectedVertexIds = allVertices.filter(p => p.type === 'regular').map(p => p.id);
        selectedEdgeIds = allEdges.map(edge => U.getEdgeId(edge));
        selectedFaceIds = allFaces.map(face => face.id);
        selectedCenterIds = allVertices.filter(p => p.type !== 'regular').map(p => p.id);
        activeCenterId = null;

        // Update active color targets for select all
        const newActiveTargets = [];
        if (selectedFaceIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_FACE);
        if (selectedEdgeIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_EDGE);
        if (selectedVertexIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_VERTEX);

        if (newActiveTargets.length > 0) {
            activeColorTargets = newActiveTargets;
            if (isColorPaletteExpanded) {
                buildColorPaletteUI();
            }
        }
    }
}

function handleColorToolButtonClick() {
    isColorPaletteExpanded = !isColorPaletteExpanded;
    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }
}

function handleThemeToggle() {
    saveStateForUndo();
    activeThemeName = activeThemeName === 'dark' ? 'light' : 'dark';
    invertVertexColors();
    invertColors();
    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }
}

function getAlignedEdgeInfo(face, edgeIndex) {
    const v1Id = face.vertexIds[edgeIndex];
    const v2Id = face.vertexIds[(edgeIndex + 1) % face.vertexIds.length];
    const v1 = findVertexById(v1Id);
    const v2 = findVertexById(v2Id);
    
    if (v1 && v2) {
        return {
            v1Id,
            v2Id,
            edgeAngle: Math.atan2(v2.y - v1.y, v2.x - v1.x)
        };
    }
    
    return null;
}

function handleMouseMove(event) {
    mousePos = U.getMousePosOnCanvas(event, canvas);
    currentShiftPressed = event.shiftKey;

    if (isDraggingColorTarget && draggedColorTargetInfo) {
        const icon = canvasUI.colorTargetIcons.find(i => i.target === draggedColorTargetInfo.target);
        if (icon) {
            const dropTargets = [...canvasUI.colorSwatches, canvasUI.randomColorButton];
            const closestTarget = U.findClosestUIElement(mousePos, dropTargets);
            if (closestTarget) {
                icon.x = closestTarget.x + (closestTarget.width - icon.width) / 2;
                const newIndex = closestTarget.id === 'random-color-button' ? -1 : closestTarget.index;
                draggedColorTargetInfo.previewColorIndex = newIndex;
            } else {
                icon.x = mousePos.x - draggedColorTargetInfo.offsetX;
                draggedColorTargetInfo.previewColorIndex = draggedColorTargetInfo.originalColorIndex;
            }
        }
        return;
    }

    if (isDraggingColorSwatch) {
        const removeBtn = canvasUI.removeColorButton;
        const isOverRemoveButton = removeBtn && 
            mousePos.x >= removeBtn.x && mousePos.x <= removeBtn.x + removeBtn.width &&
            mousePos.y >= removeBtn.y && mousePos.y <= removeBtn.y + removeBtn.height;

        if (isOverRemoveButton && allColors.length > 1 && !draggedSwatchTemporarilyRemoved) {
            draggedSwatchTemporarilyRemoved = true;
            const indexToRemove = allColors.indexOf(draggedSwatchInfo.item);
            if (indexToRemove >= 0) {
                allColors.splice(indexToRemove, 1);
                
                Object.keys(colorAssignments).forEach(target => {
                    if (colorAssignments[target] > indexToRemove) {
                        colorAssignments[target]--;
                    } else if (colorAssignments[target] === indexToRemove) {
                        colorAssignments[target] = Math.min(indexToRemove, allColors.length - 1);
                    }
                });
                
                buildColorPaletteUI();
            }
            return;
        } else if (!isOverRemoveButton && draggedSwatchTemporarilyRemoved) {
            draggedSwatchTemporarilyRemoved = false;
            allColors.unshift(draggedSwatchInfo.item);
            
            Object.keys(colorAssignments).forEach(target => {
                colorAssignments[target]++;
            });
            
            Object.keys(draggedSwatchInfo.originalAssignments).forEach(target => {
                if (draggedSwatchInfo.originalAssignments[target] === draggedSwatchInfo.originalIndex) {
                    colorAssignments[target] = 0;
                }
            });
            
            buildColorPaletteUI();
            return;
        }

        if (draggedSwatchTemporarilyRemoved) {
            return;
        }

        const fromIndex = allColors.indexOf(draggedSwatchInfo.item);
        
        let targetIndex = fromIndex;
        
        for (let i = 0; i < canvasUI.colorSwatches.length; i++) {
            const swatch = canvasUI.colorSwatches[i];
            const swatchLeft = swatch.x;
            const swatchRight = swatch.x + swatch.width;
            
            if (mousePos.x >= swatchLeft && mousePos.x <= swatchRight) {
                targetIndex = allColors.indexOf(swatch.item);
                break;
            }
        }
        
        if (targetIndex !== fromIndex) {
            const temp = allColors[fromIndex];
            allColors[fromIndex] = allColors[targetIndex];
            allColors[targetIndex] = temp;
            
            Object.keys(colorAssignments).forEach(target => {
                if (colorAssignments[target] === fromIndex) {
                    colorAssignments[target] = targetIndex;
                } else if (colorAssignments[target] === targetIndex) {
                    colorAssignments[target] = fromIndex;
                }
            });
            
            draggedSwatchInfo.item = allColors[targetIndex];
            
            buildColorPaletteUI();
        }
        
        return;
    }
    
    if (handleCoordinateSystemMouseMove(event)) {
        return;
    }

    hoveredVertexId = null;
    hoveredEdgeId = null;
    hoveredFaceId = null;

    if (!isActionInProgress) {
        const p = findClickedVertex(mousePos);
        const e = findClickedEdge(mousePos);
        const f = findClickedFace(mousePos);

        if (p) {
            hoveredVertexId = p.id;
        } else if (e) {
            hoveredEdgeId = U.getEdgeId(e);
        } else if (f) {
            hoveredFaceId = f.id;
        }
    }

    if (currentShiftPressed && !isActionInProgress) {
        const mouseDataPos = screenToData(mousePos);
        if (isPlacingTransform) {
            const potentialSnapPos = getBestSnapPosition(mouseDataPos);
            if (potentialSnapPos) {
                placingSnapPos = dataToScreen(potentialSnapPos);
                ghostVertexPosition = potentialSnapPos;
            }
        } else if (isDrawingMode && previewLineStartVertexId) {
            const startVertex = findVertexById(previewLineStartVertexId);
            if (startVertex) {
                const snappedData = getSnappedPosition(startVertex, mousePos, currentShiftPressed);
                ghostVertexPosition = { x: snappedData.x, y: snappedData.y };
            }
        } else if (isDraggingCoordSystem && draggedCoordSystemElement && draggedCoordSystemElement.type === 'center') {
            ghostVertexPosition = getBestSnapPosition(mouseDataPos);
        } else {
            const clickedFace = findClickedFace(mousePos);
            if (!clickedFace) {
                ghostVertexPosition = getBestSnapPosition(mouseDataPos);
            } else {
                ghostVertexPosition = null;
            }
        }
    } else if (!currentShiftPressed && isDrawingMode && previewLineStartVertexId) {
        const startVertex = findVertexById(previewLineStartVertexId);
        if (startVertex) {
            const snappedData = getSnappedPosition(startVertex, mousePos, false);
            if (snappedData.snapped && (snappedData.snapType === 'vertex' || snappedData.snapType === 'edge')) {
                ghostVertexPosition = { x: snappedData.x, y: snappedData.y };
            } else {
                ghostVertexPosition = null;
            }
        } else {
            ghostVertexPosition = null;
        }
    } else if (!currentShiftPressed) {
        ghostVertexPosition = null;
        placingSnapPos = null;
    }

    if (!isActionInProgress) {
        return;
    }

    if (!isDragConfirmed && U.distance(mousePos, actionStartPos) > C.DRAG_THRESHOLD) {
        isDragConfirmed = true;
        actionTargetVertex = actionContext.dragHandle;
        isEdgeTransformDrag = !!actionContext.isTransformDrag;

        if (actionContext.target === 'ui_icon_click') {
            isDraggingColorTarget = true;
            draggedColorTargetInfo = {
                target: actionContext.element.target,
                offsetX: mousePos.x - actionContext.element.x,
                offsetY: mousePos.y - actionContext.element.y,
                originalColorIndex: colorAssignments[actionContext.element.target],
                previewColorIndex: colorAssignments[actionContext.element.target]
            };
            actionContext.target = 'ui_icon_drag';
            activeColorTargets = [actionContext.element.target];
        } else if (actionContext.target === 'ui_swatch') {
            saveStateForUndo();
            isDraggingColorSwatch = true;
            draggedSwatchInfo = {
                index: actionContext.element.index,
                item: actionContext.element.item,
                offsetX: mousePos.x - actionContext.element.x,
                originalIndex: actionContext.element.index,
                originalAllColors: JSON.parse(JSON.stringify(allColors)),
                originalAssignments: JSON.parse(JSON.stringify(colorAssignments))
            };
        } else if (currentMouseButton === 2) {
            isRectangleSelecting = true;
            return;
        } else if (actionContext.target === 'canvas') {
            isPanningBackground = true;
            backgroundPanStartOffset = { x: viewTransform.offsetX, y: viewTransform.offsetY };
            canvas.style.cursor = 'move';
        } else {
            canvas.style.cursor = 'grabbing';
            isDraggingCenter = actionContext.targetVertex && actionContext.targetVertex.type !== 'regular';

            let verticesToDrag;

            if (isDraggingCenter) {
                verticesToDrag = [actionContext.targetVertex];
            } else {
                let verticesToDragIds = new Set(selectedVertexIds);

                selectedEdgeIds.forEach(edgeId => {
                    const [id1, id2] = edgeId.split(C.EDGE_ID_DELIMITER);
                    verticesToDragIds.add(id1);
                    verticesToDragIds.add(id2);
                });

                selectedFaceIds.forEach(faceId => {
                    const face = allFaces.find(f => U.getFaceId(f) === faceId);
                    if (face) {
                        face.vertexIds.forEach(id => verticesToDragIds.add(id));
                    }
                });

                verticesToDrag = Array.from(verticesToDragIds).map(id => findVertexById(id)).filter(p => p && p.type === 'regular');
            }

            if (isDraggingCenter) {
                if (actionContext.targetVertex.type === C.TRANSFORMATION_TYPE_ROTATION) {
                    const center = actionContext.targetVertex;
                    const startReferenceVertex = screenToData(actionStartPos);
                    const startVector = { x: startReferenceVertex.x - center.x, y: startReferenceVertex.y - center.y };
                    actionContext.initialRotationStartAngle = Math.atan2(startVector.y, startVector.x);
                    currentAccumulatedRotation = 0;
                }
            }

            if (verticesToDrag.length > 0) {
                initialDragVertexStates = JSON.parse(JSON.stringify(verticesToDrag));
                dragPreviewVertices = JSON.parse(JSON.stringify(verticesToDrag));
                
                initialCoordSystemStates.clear();
                const verticesThatMoved = new Set(initialDragVertexStates.map(v => v.id));
                allFaces.forEach(face => {
                    if (face.vertexIds.some(vId => verticesThatMoved.has(vId))) {
                        if (face.localCoordSystem) {
                            initialCoordSystemStates.set(face.id, JSON.parse(JSON.stringify(face.localCoordSystem)));
                        }
                    }
                });
            }
        }
    }

    if (isDragConfirmed) {
        const isTransformingSelection = activeCenterId && (selectedVertexIds.length > 0 || selectedEdgeIds.length > 0 || selectedFaceIds.length > 0) && !isEdgeTransformDrag;
        actionContext.dragSnap = null;
        ghostVertexPosition = null;
        ghostVertices = [];

        if (isPanningBackground) {
            const deltaX_css = mousePos.x - actionStartPos.x;
            const deltaY_css = mousePos.y - actionStartPos.y;
            viewTransform.offsetX = backgroundPanStartOffset.x + (deltaX_css * dpr);
            viewTransform.offsetY = backgroundPanStartOffset.y - (deltaY_css * dpr);
        } else if ((isTransformingSelection || isEdgeTransformDrag) && !isDraggingCenter) {
            const center = findVertexById(activeCenterId);
            let startReferenceVertex = actionTargetVertex;
            
            if (!startReferenceVertex && initialDragVertexStates.length > 0) {
                startReferenceVertex = initialDragVertexStates.find(p => U.distance(p, center) > 1e-6) || initialDragVertexStates[0];
            }

            if (!center || !startReferenceVertex) return;
            const centerType = center.type;
            const mouseData = screenToData(mousePos);
            const rawTransform = calculateTransformFromMouse(center, mouseData, startReferenceVertex, centerType, currentAccumulatedRotation);
            let snapResult = {};
            let finalTransform = {};
            if (centerType === C.TRANSFORMATION_TYPE_ROTATION) {
                snapResult = getBestRotationSnap(center, initialDragVertexStates, startReferenceVertex, rawTransform.rotation);
                finalTransform = { rotation: snapResult.rotation, scale: 1, directionalScale: false };
                currentAccumulatedRotation = snapResult.rotation;
            } else if (centerType === C.TRANSFORMATION_TYPE_SCALE) {
                snapResult = getBestScaleSnap(center, initialDragVertexStates, startReferenceVertex, rawTransform.scale);
                finalTransform = { rotation: 0, scale: snapResult.scale || rawTransform.scale, directionalScale: false };
            } else if (centerType === C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE) {
                const startVector = { x: startReferenceVertex.x - center.x, y: startReferenceVertex.y - center.y };
                snapResult = getBestDirectionalScaleSnap(center, initialDragVertexStates, startReferenceVertex, rawTransform.scale, startVector);
                finalTransform = { rotation: 0, scale: snapResult.scale || rawTransform.scale, directionalScale: true };
            }
            transformIndicatorData = {
                center,
                startPos: startReferenceVertex,
                currentPos: snapResult.pos || mouseData,
                rotation: finalTransform.rotation,
                scale: finalTransform.scale,
                isSnapping: snapResult.snapped || false,
                transformType: centerType,
                directionalScale: finalTransform.directionalScale,
                snappedScaleValue: snapResult.snappedScaleValue || null,
                gridToGridInfo: snapResult.gridToGridInfo || null
            };
            const startVectorForApply = { x: startReferenceVertex.x - center.x, y: startReferenceVertex.y - center.y };
            dragPreviewVertices = initialDragVertexStates.map(p_initial => {
                const newPos = U.applyTransformToVertex(p_initial, center, finalTransform.rotation, finalTransform.scale, finalTransform.directionalScale, startVectorForApply);
                return { ...p_initial, x: newPos.x, y: newPos.y };
            });
            
            if (snapResult.snapped && snapResult.snapType === 'merge' && snapResult.mergingVertex && snapResult.mergeTarget) {
                const sourceVertexInitial = initialDragVertexStates.find(p => p.id === snapResult.mergingVertex.id);
                if (sourceVertexInitial) {
                    const snappedVertexPreview = dragPreviewVertices.find(p => p.id === sourceVertexInitial.id);
                    if (snappedVertexPreview) {
                        const correctionVector = { x: snapResult.mergeTarget.x - snappedVertexPreview.x, y: snapResult.mergeTarget.y - snappedVertexPreview.y };
                        dragPreviewVertices.forEach(p => { p.x += correctionVector.x; p.y += correctionVector.y; });
                        if (transformIndicatorData.currentPos) { transformIndicatorData.currentPos.x += correctionVector.x; transformIndicatorData.currentPos.y += correctionVector.y; }
                    }
                }
            }
            const mergeRadiusData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;
            const staticVerticesForMerge = allVertices.filter(p => p.type === 'regular' && !initialDragVertexStates.some(ip => ip.id === p.id));
            dragPreviewVertices.forEach(previewVertex => {
                if (previewVertex.type === 'regular') {
                    staticVerticesForMerge.forEach(staticVertex => {
                        if (U.distance(previewVertex, staticVertex) < mergeRadiusData) { ghostVertices.push({ x: staticVertex.x, y: staticVertex.y }); }
                    });
                }
            });
            for (let i = 0; i < dragPreviewVertices.length; i++) {
                for (let j = i + 1; j < dragPreviewVertices.length; j++) {
                    const p1 = dragPreviewVertices[i];
                    const p2 = dragPreviewVertices[j];
                    if (p1.type === 'regular' && p2.type === 'regular' && U.distance(p1, p2) < mergeRadiusData) {
                        ghostVertices.push({ x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 });
                    }
                }
            }
        } else if (isDraggingCenter && dragPreviewVertices.length > 0) {
            // Simple translation for dragging centers with placement-style snapping
            const mouseData = screenToData(mousePos);
            
            let finalPos = mouseData;
            if (currentShiftPressed) {
                const potentialSnapPos = getBestSnapPosition(mouseData);
                if (potentialSnapPos) {
                    finalPos = potentialSnapPos;
                    ghostVertexPosition = potentialSnapPos;
                }
            } else {
                ghostVertexPosition = null;
            }
            
            const previewCenterToUpdate = dragPreviewVertices.find(dp => dp && dp.id === initialDragVertexStates[0].id);
            if (previewCenterToUpdate) {
                previewCenterToUpdate.x = finalPos.x;
                previewCenterToUpdate.y = finalPos.y;
            }
        } else if (dragPreviewVertices.length > 0) {
            const mouseData = screenToData(mousePos);
            const startMouseData = screenToData(actionStartPos);
            const rawDelta = { x: mouseData.x - startMouseData.x, y: mouseData.y - startMouseData.y };
            let snapResult = { snapped: false };
            const copyCount = parseInt(copyCountInput || '1', 10);

            const isDeformingDrag = currentShiftPressed &&
                initialDragVertexStates.length === 1 &&
                initialDragVertexStates[0].type === 'regular' &&
                U.findNeighbors(initialDragVertexStates[0].id, allEdges).some(id => !selectedVertexIds.includes(id));

            if (isDeformingDrag) {
                const dragOrigin = initialDragVertexStates[0];
                snapResult = getDeformingSnapPosition(dragOrigin, mouseData, selectedVertexIds);
                const previewVertexToUpdate = dragPreviewVertices.find(dp => dp && dp.id === dragOrigin.id);
                if (previewVertexToUpdate) {
                    previewVertexToUpdate.x = snapResult.pos.x;
                    previewVertexToUpdate.y = snapResult.pos.y;
                }
            } else {
                let finalDelta;
                if (currentShiftPressed) {
                    snapResult = getBestRigidTranslationSnap(initialDragVertexStates, rawDelta, copyCount);
                    finalDelta = snapResult.delta;
                } else {
                    snapResult = getBestTranslationSnap(initialDragVertexStates, rawDelta, copyCount);
                    finalDelta = snapResult.delta;
                }
                initialDragVertexStates.forEach(originalVertexState => {
                    const previewVertexToUpdate = dragPreviewVertices.find(dp => dp && dp.id === originalVertexState.id);
                    if (previewVertexToUpdate) {
                        previewVertexToUpdate.x = originalVertexState.x + finalDelta.x;
                        previewVertexToUpdate.y = originalVertexState.y + finalDelta.y;
                    }
                });
            }
            actionContext.finalSnapResult = snapResult;
            if (snapResult.snapped && snapResult.mergeTarget) {
                ghostVertexPosition = snapResult.mergeTarget;
            }
        }
    }
}

function handleLeftMouseButtonDown(event) {
    if (isPlacingTransform) {
        saveStateForUndo();
        const mouseDataPos = screenToData(mousePos);
        const snappedPos = currentShiftPressed ? getBestSnapPosition(mouseDataPos) : mouseDataPos;

        const newCenter = {
            id: U.generateUniqueId(),
            x: snappedPos.x,
            y: snappedPos.y,
            type: placingTransformType
        };
        allVertices.push(newCenter);

        // Make the new center active and selected
        selectedCenterIds = [newCenter.id];
        activeCenterId = newCenter.id;
        // Clear other selections for clarity
        selectedVertexIds = [];
        selectedEdgeIds = [];
        selectedFaceIds = [];

        // Reset ONLY the placement-related state, keeping the new selection
        isPlacingTransform = false;
        placingTransformType = null;
        placingSnapPos = null;
        canvas.style.cursor = 'crosshair';

        event.preventDefault();
        return;
    }
    isActionInProgress = true;
    isDragConfirmed = false;
    isPanningBackground = false;

    if (isColorPaletteExpanded) {
        const iconsUnderMouse = (canvasUI.colorTargetIcons || []).filter(icon =>
            mousePos.x >= icon.x && mousePos.x <= icon.x + icon.width &&
            mousePos.y >= icon.y && mousePos.y <= icon.y + icon.height
        );

        if (iconsUnderMouse.length > 0) {
            const topIcon = iconsUnderMouse[iconsUnderMouse.length - 1];
            
            const { element, shiftKey, ctrlKey } = { element: topIcon, shiftKey: event.shiftKey, ctrlKey: event.ctrlKey || event.metaKey };
            if (shiftKey) {
                if (!activeColorTargets.includes(element.target)) {
                    activeColorTargets.push(element.target);
                }
            } else if (ctrlKey) {
                if (activeColorTargets.includes(element.target)) {
                    activeColorTargets = activeColorTargets.filter(t => t !== element.target);
                } else {
                    activeColorTargets.push(element.target);
                }
            } else {
                activeColorTargets = [element.target];
            }
            buildColorPaletteUI();

            actionContext = { target: 'ui_icon_click', element: { ...topIcon, type: 'colorTargetIcon' } };
            return;
        }

        for (const swatch of canvasUI.colorSwatches) {
            if (mousePos.x >= swatch.x && mousePos.x <= swatch.x + swatch.width &&
                mousePos.y >= swatch.y && mousePos.y <= swatch.y + swatch.height) {
                actionContext = { target: 'ui_swatch', element: { ...swatch } };
                return;
            }
        }
    }

    if (handleCanvasUIClick(mousePos, event.shiftKey, event.ctrlKey || event.metaKey)) {
        actionContext = { target: 'ui' }; // Set a generic context for UI clicks
        return;
    }

    if (handleCoordinateSystemMouseDown(event)) {
        return;
    }

    if (event.altKey && !isDrawingMode && (findClickedVertex(mousePos) || findClickedEdge(mousePos))) {
        const clickedVertex = findClickedVertex(mousePos);
        const clickedEdge = findClickedEdge(mousePos);
        
        saveStateForUndo();
        performEscapeAction();
        
        if (clickedVertex && clickedVertex.type === 'regular') {
            isDrawingMode = true;
            previewLineStartVertexId = clickedVertex.id;
            drawingSequence = [];
            currentSequenceIndex = 0;
            currentDrawingPath = [clickedVertex.id];
            window.currentDrawingPath = currentDrawingPath;
        } else if (clickedEdge) {
            const p1 = findVertexById(clickedEdge.id1);
            const p2 = findVertexById(clickedEdge.id2);
            if (p1 && p2) {
                const closest = U.getClosestPointOnLineSegment(screenToData(mousePos), p1, p2);
                const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
                const newVertex = insertVertexOnEdgeWithFaces(clickedEdge, closest, gridInterval, getColorForTarget);
                if (newVertex) {
                    isDrawingMode = true;
                    previewLineStartVertexId = newVertex.id;
                    drawingSequence = [];
                    currentSequenceIndex = 0;
                    currentDrawingPath = [newVertex.id];
                    window.currentDrawingPath = currentDrawingPath;
                }
            }
        }
        
        isActionInProgress = false;
        event.preventDefault();
        return;
    }

    let clickedVertex = findClickedVertex(mousePos);
    let clickedEdge = !clickedVertex ? findClickedEdge(mousePos) : null;
    let clickedFace = !clickedVertex && !clickedEdge ? findClickedFace(mousePos) : null;

    const shiftOrCtrl = event.shiftKey || event.ctrlKey || event.metaKey;
    const clickedItem = clickedVertex || clickedEdge || clickedFace;
    let isClickOnSelection = false;
    if (clickedVertex) isClickOnSelection = selectedVertexIds.includes(clickedVertex.id) || selectedCenterIds.includes(clickedVertex.id);
    else if (clickedEdge) isClickOnSelection = selectedEdgeIds.includes(U.getEdgeId(clickedEdge));
    else if (clickedFace) isClickOnSelection = selectedFaceIds.includes(U.getFaceId(clickedFace));
    
    if (!isDrawingMode && !shiftOrCtrl && clickedItem && !isClickOnSelection) {
        if (clickedVertex) applySelectionLogic([clickedVertex.id], [], [], false, false, clickedVertex.type !== 'regular');
        else if (clickedEdge) applySelectionLogic([], [U.getEdgeId(clickedEdge)], [], false, false);
        else if (clickedFace) applySelectionLogic([], [], [U.getFaceId(clickedFace)], false, false);
    }
    
    let dragHandle = null;
    if (clickedVertex) {
        dragHandle = clickedVertex;
    } else if (clickedEdge) {
        const p1 = findVertexById(clickedEdge.id1);
        const p2 = findVertexById(clickedEdge.id2);
        dragHandle = U.getClosestPointOnLineSegment(screenToData(mousePos), p1, p2);
    } else if (clickedFace) {
        dragHandle = screenToData(mousePos);
    }

    const isTransformDrag = activeCenterId && (selectedVertexIds.length > 0 || selectedEdgeIds.length > 0 || selectedFaceIds.length > 0);

    initialDragVertexStates = [];
    dragPreviewVertices = [];

    actionContext = {
        targetVertex: clickedVertex,
        dragHandle: dragHandle,
        targetEdge: clickedEdge,
        targetFace: clickedFace,
        target: clickedItem || 'canvas',
        shiftKey: event.shiftKey,
        ctrlKey: event.ctrlKey || event.metaKey,
        isTransformDrag
    };

    if (clickedVertex && clickedVertex.type !== 'regular') {
        isDraggingCenter = true;
        handleCenterSelection(clickedVertex.id, event.shiftKey, event.ctrlKey || event.metaKey);
    }
}

function handleLeftMouseButtonUp(event) {
    if (isDraggingColorTarget) {
        const icon = canvasUI.colorTargetIcons.find(i => i.target === draggedColorTargetInfo.target);
        if (icon) {
            const dropTargets = [...canvasUI.colorSwatches, canvasUI.randomColorButton];
            const closestTarget = U.findClosestUIElement(mousePos, dropTargets);
            if (closestTarget) {
                const newIndex = closestTarget.id === 'random-color-button' ? -1 : closestTarget.index;
                // Apply to the specific target that was dragged
                colorAssignments[draggedColorTargetInfo.target] = newIndex;
                applyColorsToSelection();
            }
        }
        isDraggingColorTarget = false;
        draggedColorTargetInfo = null;
        buildColorPaletteUI();
        isActionInProgress = false;
        isDragConfirmed = false;
        actionContext = null;
        return;
    }

    if (isDraggingColorSwatch) {
        const removeBtn = canvasUI.removeColorButton;
        const isOverRemoveButton = removeBtn && 
            mousePos.x >= removeBtn.x && mousePos.x <= removeBtn.x + removeBtn.width &&
            mousePos.y >= removeBtn.y && mousePos.y <= removeBtn.y + removeBtn.height;

        if (isOverRemoveButton && allColors.length > 1) {
            const currentIndex = allColors.indexOf(draggedSwatchInfo.item);
            if (currentIndex !== -1) {
                removeColorAtIndex(currentIndex);
            }
        }

        isDraggingColorSwatch = false;
        draggedSwatchInfo = null;
        draggedSwatchTemporarilyRemoved = false;
        
        buildColorPaletteUI();
        
        isActionInProgress = false;
        isDragConfirmed = false;
        actionContext = null;
        return;
    }

    if (!isDragConfirmed && actionContext && actionContext.target === 'ui_icon_click' && actionContext.element.type === 'colorTargetIcon') {
        const { element } = actionContext;
        const now = Date.now();
        
        const iconId = `icon-${element.target}`;
        if (clickData.targetId === iconId && (now - clickData.timestamp) < C.DOUBLE_CLICK_MS) {
            // Double-click: toggle visibility of this geometry type
            saveStateForUndo();
            switch (element.target) {
                case C.COLOR_TARGET_VERTEX:
                    verticesVisible = !verticesVisible;
                    break;
                case C.COLOR_TARGET_EDGE:
                    edgesVisible = !edgesVisible;
                    break;
                case C.COLOR_TARGET_FACE:
                    facesVisible = !facesVisible;
                    break;
            }
            buildColorPaletteUI();
            clickData.count = 0; // Reset for next click
        } else {
            // Single-click was already handled on mousedown
        }
        
        clickData.targetId = iconId;
        clickData.timestamp = now;
        isActionInProgress = false;
        actionContext = null;
        return;
    }


    if (!isDragConfirmed && actionContext && actionContext.target === 'ui_swatch') {
        const { element } = actionContext;
        const now = Date.now();
        
        const swatchId = `swatch-${element.index}`;
        if (clickData.targetId === swatchId && (now - clickData.timestamp) < C.DOUBLE_CLICK_MS) {
            isEditingColor = true;
            editingColorIndex = element.index;
            const colorToEdit = allColors[element.index];
            let initialState;
            if (colorToEdit.type === 'color') {
                const parsedColor = U.parseColor(colorToEdit.value);
                initialState = { type: 'colormap', points: [{ pos: 0.5, alpha: parsedColor.a, color: [parsedColor.r, parsedColor.g, parsedColor.b], order: 1 }] };
            } else if (colorToEdit.type === 'colormap') {
                initialState = { 
                    type: 'colormap', 
                    points: colorToEdit.vertices.map(v => ({ pos: v.pos, alpha: v.alpha !== undefined ? v.alpha : 1.0, color: Array.isArray(v.color) ? [...v.color] : [v.color.r || 0, v.color.g || 0, v.color.b || 0], order: v.order || 1 })),
                    isCyclic: colorToEdit.isCyclic === true
                };
            }
            colorEditor.show(undefined, undefined, initialState);
            clickData.count = 0;
        } else {
            // Single-click re-assigns active targets and colors selection
            if (activeColorTargets.length > 0) {
                saveStateForUndo(); // Save state BEFORE making changes
                activeColorTargets.forEach(target => colorAssignments[target] = element.index);
                applyColorsToSelection();
                buildColorPaletteUI();
            }
        }
        clickData.targetId = swatchId;
        clickData.timestamp = now;
        isActionInProgress = false;
        actionContext = null;
        return;
    }

    if (!isDragConfirmed && isDraggingColorSwatch) {
        const swatchIndex = allColors.indexOf(draggedSwatchInfo.item);
        const swatchId = `swatch-${swatchIndex}`;
        const now = Date.now();
        
        if (clickData.targetId === swatchId && (now - clickData.timestamp) < C.DOUBLE_CLICK_MS) {
            isEditingColor = true;
            editingColorIndex = swatchIndex;
            const colorToEdit = allColors[swatchIndex];
            let initialState;
            if (colorToEdit.type === 'color') {
                const parsedColor = U.parseColor(colorToEdit.value);
                initialState = { type: 'colormap', points: [{ pos: 0.5, alpha: parsedColor.a, color: [parsedColor.r, parsedColor.g, parsedColor.b], order: 1 }] };
            } else if (colorToEdit.type === 'colormap') {
                initialState = { type: 'colormap', points: colorToEdit.vertices.map(v => ({ pos: v.pos, alpha: v.alpha !== undefined ? v.alpha : 1.0, color: Array.isArray(v.color) ? [...v.color] : [v.color.r || 0, v.color.g || 0, v.color.b || 0], order: v.order || 1 })) };
            }
            colorEditor.show(undefined, undefined, initialState);
            clickData.count = 0;
        } else {
            activeColorTargets.forEach(t => colorAssignments[t] = swatchIndex);
            applyColorsToSelection();
            buildColorPaletteUI();
        }
        clickData.targetId = swatchId;
        clickData.timestamp = now;
        
        isDraggingColorSwatch = false;
        draggedSwatchInfo = null;
        saveStateForUndo();
        return;
    }

    if (handleCoordinateSystemMouseUp()) {
        return;
    }

    if (copyCountTimer) clearTimeout(copyCountTimer);
    const copyCount = parseInt(copyCountInput, 10) || 1;
    copyCountInput = '';
    copyCountTimer = null;

    if (!isActionInProgress) return;

    const { shiftKey, ctrlKey, targetVertex, targetEdge, targetFace } = actionContext;

    // Find this line:
if (isDragConfirmed) {

// And replace everything inside it with this:
    saveStateForUndo();
    let lastCopySelectionIds = null;
    if (copyCount > 1) {
        const verticesToCopy = initialDragVertexStates.filter(p => p.type === 'regular');
        const originalIds = new Set(verticesToCopy.map(p => p.id));
        const edgesToCopy = allEdges.filter(e => originalIds.has(e.id1) && originalIds.has(e.id2));
        const facesToCopy = allFaces.filter(f => f.vertexIds.every(id => originalIds.has(id)));
        
        const allNewVertices = [];
        const allNewEdges = [];
        const allNewFaces = [];
        lastCopySelectionIds = { vertices: [], edges: [], faces: [] };

        for (let i = 1; i < copyCount; i++) {
            const newIdMapForThisCopy = new Map();
            const currentCopyVertices = [];
            const currentCopyEdges = [];
            const currentCopyFaces = [];

            verticesToCopy.forEach(p => {
                let newPos;
                if (transformIndicatorData) {
                    const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
                    const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
                    newPos = U.applyTransformToVertex(p, center, rotation * i, Math.pow(scale, i), directionalScale, startVector);
                } else {
                    const delta = { x: dragPreviewVertices[0].x - initialDragVertexStates[0].x, y: dragPreviewVertices[0].y - initialDragVertexStates[0].y };
                    newPos = { x: p.x + delta.x * i, y: p.y + delta.y * i };
                }
                const newVertex = { ...p, ...newPos, id: U.generateUniqueId() };
                allNewVertices.push(newVertex);
                newIdMapForThisCopy.set(p.id, newVertex.id);
                currentCopyVertices.push(newVertex.id);
            });

            edgesToCopy.forEach(edge => {
                const newId1 = newIdMapForThisCopy.get(edge.id1);
                const newId2 = newIdMapForThisCopy.get(edge.id2);
                if (newId1 && newId2) {
                    const newEdge = { ...edge, id1: newId1, id2: newId2 };
                    allNewEdges.push(newEdge);
                    currentCopyEdges.push(U.getEdgeId(newEdge));
                }
            });

            facesToCopy.forEach(originalFace => {
                const initialSystemForCopy = initialCoordSystemStates.get(originalFace.id);
                const newVertexIds = originalFace.vertexIds.map(id => newIdMapForThisCopy.get(id));
                if (newVertexIds.every(Boolean)) {
                    const newFace = JSON.parse(JSON.stringify(originalFace));
                    newFace.id = U.getFaceId({ vertexIds: newVertexIds });
                    newFace.vertexIds = newVertexIds;

                    if (newFace.localCoordSystem && initialSystemForCopy) {
                        if (transformIndicatorData) {
                            const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
                            const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
                            newFace.localCoordSystem.origin = U.applyTransformToVertex(initialSystemForCopy.origin, center, rotation * i, Math.pow(scale, i), directionalScale, startVector);
                            newFace.localCoordSystem.angle = U.normalizeAngle(initialSystemForCopy.angle + (rotation * i));
                            if (!directionalScale) newFace.localCoordSystem.scale = initialSystemForCopy.scale * Math.pow(scale, i);
                        } else {
                            const delta = { x: dragPreviewVertices[0].x - initialDragVertexStates[0].x, y: dragPreviewVertices[0].y - initialDragVertexStates[0].y };
                            newFace.localCoordSystem.origin.x = initialSystemForCopy.origin.x + delta.x * i;
                            newFace.localCoordSystem.origin.y = initialSystemForCopy.origin.y + delta.y * i;
                        }
                        
                        if (newFace.localCoordSystem.attachedToVertex) {
                            newFace.localCoordSystem.attachedToVertex = newIdMapForThisCopy.get(newFace.localCoordSystem.attachedToVertex);
                        }
                        if (newFace.localCoordSystem.attachedToEdge) {
                            newFace.localCoordSystem.attachedToEdge.v1 = newIdMapForThisCopy.get(newFace.localCoordSystem.attachedToEdge.v1);
                            newFace.localCoordSystem.attachedToEdge.v2 = newIdMapForThisCopy.get(newFace.localCoordSystem.attachedToEdge.v2);
                        }
                        if (newFace.localCoordSystem.rotationAlignedToEdge) {
                            newFace.localCoordSystem.rotationAlignedToEdge.v1 = newIdMapForThisCopy.get(newFace.localCoordSystem.rotationAlignedToEdge.v1);
                            newFace.localCoordSystem.rotationAlignedToEdge.v2 = newIdMapForThisCopy.get(newFace.localCoordSystem.rotationAlignedToEdge.v2);
                        }
                        if (newFace.localCoordSystem.scaleAttachedToEdge) {
                            newFace.localCoordSystem.scaleAttachedToEdge.v1 = newIdMapForThisCopy.get(newFace.localCoordSystem.scaleAttachedToEdge.v1);
                            newFace.localCoordSystem.scaleAttachedToEdge.v2 = newIdMapForThisCopy.get(newFace.localCoordSystem.scaleAttachedToEdge.v2);
                        }
                        
                        newFace.localCoordSystem.isCustom = true;
                    }
                    allNewFaces.push(newFace);
                    currentCopyFaces.push(newFace.id);
                }
            });
            
            if (i === copyCount - 1) {
                lastCopySelectionIds = { vertices: currentCopyVertices, edges: currentCopyEdges, faces: currentCopyFaces };
            }
        }
        
        allVertices.push(...allNewVertices);
        allEdges.push(...allNewEdges);
        allFaces.push(...allNewFaces);
        
        selectedVertexIds = lastCopySelectionIds.vertices;
        selectedEdgeIds = lastCopySelectionIds.edges;
        selectedFaceIds = lastCopySelectionIds.faces;
    } else if (dragPreviewVertices.length > 0) {
        dragPreviewVertices.forEach(dp => {
            const originalVertex = allVertices.find(p => p.id === dp.id);
            if (originalVertex) {
                originalVertex.x = dp.x;
                originalVertex.y = dp.y;
            }
        });
        
        const verticesThatMoved = new Set(initialDragVertexStates.map(v => v.id));
        const affectedFaces = new Set();
        allFaces.forEach(face => {
            if (face.vertexIds.some(vId => verticesThatMoved.has(vId))) {
                affectedFaces.add(face);
            }
        });

        if (affectedFaces.size > 0) {
            affectedFaces.forEach(face => {
                const initialSystem = initialCoordSystemStates.get(face.id);
                if (face.localCoordSystem && initialSystem) {
                    if (transformIndicatorData && !transformIndicatorData.directionalScale) {
                        const { center, rotation, scale, startPos } = transformIndicatorData;
                        const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
                        const newOrigin = U.applyTransformToVertex(initialSystem.origin, center, rotation, scale, false, startVector);
                        face.localCoordSystem.origin = newOrigin;
                        face.localCoordSystem.angle = U.normalizeAngle(initialSystem.angle + rotation);
                        face.localCoordSystem.scale = initialSystem.scale * scale;
                    } else {
                        applyCoordinateSystemConstraintsOnDragEnd(face, initialSystem, initialDragVertexStates, dragPreviewVertices, findVertexById);
                    }
                }
            });
        }
    }

    const mergeRadius = C.MERGE_RADIUS_SCREEN / viewTransform.scale;
        const parent = new Map();
        allVertices.forEach(p => parent.set(p.id, p.id));
        const isOriginalDragged = new Set(initialDragVertexStates.map(p => p.id));

        const findRoot = (id) => {
            if (!parent.has(id) || parent.get(id) === id) return id;
            const rootId = findRoot(parent.get(id));
            parent.set(id, rootId);
            return rootId;
        };

        for (let i = 0; i < allVertices.length; i++) {
            for (let j = i + 1; j < allVertices.length; j++) {
                const p1 = allVertices[i];
                const p2 = allVertices[j];
                if (p1.type === 'regular' && p2.type === 'regular' && U.distance(p1, p2) < mergeRadius) {
                    const root1 = findRoot(p1.id);
                    const root2 = findRoot(p2.id);
                    if (root1 !== root2) {
                        const p1_is_orig = isOriginalDragged.has(root1);
                        const p2_is_orig = isOriginalDragged.has(root2);
                        if (p1_is_orig && !p2_is_orig) {
                            parent.set(root1, root2);
                        } else {
                            parent.set(root2, root1);
                        }
                    }
                }
            }
        }

        const verticesToDelete = new Set();
        allVertices.forEach(p => {
            const rootId = findRoot(p.id);
            if (p.id !== rootId) verticesToDelete.add(p.id);
        });

        if (verticesToDelete.size > 0) {
            const edgesBeforeMerge = JSON.parse(JSON.stringify(allEdges));
            
            const faceCoordSystemBackup = backupFaceCoordinateSystemsBeforeMerge(allFaces, findRoot);

            allEdges.forEach(edge => {
                edge.id1 = findRoot(edge.id1);
                edge.id2 = findRoot(edge.id2);
            });

            allFaces.forEach(face => {
                const remappedVertexIds = face.vertexIds.map(vId => findRoot(vId));
                const uniqueVertexIds = remappedVertexIds.filter((vId, index, self) => self.indexOf(vId) === index);
                
                if (uniqueVertexIds.length < 3) {
                    face.vertexIds = [];
                } else {
                    face.vertexIds = uniqueVertexIds;
                    face.id = U.getFaceId({ vertexIds: uniqueVertexIds });
                }
            });

            allVertices = allVertices.filter(p => !verticesToDelete.has(p.id));

            allEdges = allEdges.filter((e, index, self) =>
                e.id1 !== e.id2 &&
                index === self.findIndex(t => U.getEdgeId(t) === U.getEdgeId(e))
            );
            allFaces = allFaces.filter(f => f.vertexIds.length >= 3);
            
            selectedVertexIds = Array.from(new Set(selectedVertexIds.map(id => findRoot(id)).filter(id => !verticesToDelete.has(id))));
            selectedEdgeIds = Array.from(new Set(selectedEdgeIds.map(id => {
                const [id1, id2] = id.split(C.EDGE_ID_DELIMITER);
                const root1 = findRoot(id1);
                const root2 = findRoot(id2);
                return root1 === root2 ? null : U.getEdgeId({id1: root1, id2: root2});
            }).filter(Boolean)));
            selectedFaceIds = Array.from(new Set(selectedFaceIds.map(id => {
                const face = allFaces.find(f => f.id === id);
                return face ? face.id : null;
            }).filter(Boolean)));
            
            updateFaces(edgesBeforeMerge, allEdges);
            
            allFaces.forEach(face => {
                const backupSystem = faceCoordSystemBackup.get(face.id);
                if (backupSystem) {
                    face.localCoordSystem = backupSystem;
                    
                    if (face.localCoordSystem.attachedToVertex) {
                        const mergedVertexId = findRoot(face.localCoordSystem.attachedToVertex);
                        face.localCoordSystem.attachedToVertex = mergedVertexId;
                        
                        const mergedVertex = allVertices.find(v => v.id === mergedVertexId);
                        if (mergedVertex) {
                            face.localCoordSystem.origin.x = mergedVertex.x;
                            face.localCoordSystem.origin.y = mergedVertex.y;
                        }
                    }
                    if (face.localCoordSystem.attachedToEdge) {
                        face.localCoordSystem.attachedToEdge.v1 = findRoot(face.localCoordSystem.attachedToEdge.v1);
                        face.localCoordSystem.attachedToEdge.v2 = findRoot(face.localCoordSystem.attachedToEdge.v2);
                        
                        const v1 = allVertices.find(v => v.id === face.localCoordSystem.attachedToEdge.v1);
                        const v2 = allVertices.find(v => v.id === face.localCoordSystem.attachedToEdge.v2);
                        if (v1 && v2) {
                            const t = face.localCoordSystem.attachedToEdge.t;
                            face.localCoordSystem.origin.x = v1.x + t * (v2.x - v1.x);
                            face.localCoordSystem.origin.y = v1.y + t * (v2.y - v1.y);
                        }
                    }
                    if (face.localCoordSystem.rotationAlignedToEdge) {
                        face.localCoordSystem.rotationAlignedToEdge.v1 = findRoot(face.localCoordSystem.rotationAlignedToEdge.v1);
                        face.localCoordSystem.rotationAlignedToEdge.v2 = findRoot(face.localCoordSystem.rotationAlignedToEdge.v2);
                    }
                    if (face.localCoordSystem.scaleAttachedToEdge) {
                        face.localCoordSystem.scaleAttachedToEdge.v1 = findRoot(face.localCoordSystem.scaleAttachedToEdge.v1);
                        face.localCoordSystem.scaleAttachedToEdge.v2 = findRoot(face.localCoordSystem.scaleAttachedToEdge.v2);
                    }
                }
            });
            
            ensureFaceCoordinateSystems();
        }

        const finalMovedVertexIds = new Set();
        if (copyCount > 1 && lastCopySelectionIds) {
            lastCopySelectionIds.vertices.forEach(id => finalMovedVertexIds.add(id));
        } else if (dragPreviewVertices.length > 0) {
            dragPreviewVertices.forEach(p => finalMovedVertexIds.add(p.id));
        }

        if (verticesToDelete.size > 0) {
            selectedVertexIds.forEach(id => finalMovedVertexIds.add(id));
        }

        if (finalMovedVertexIds.size > 0) {
            updateAffectedEdgeProperties(Array.from(finalMovedVertexIds), transformIndicatorData);
        }

        initialCoordSystemStates.clear();
    } else {
        if (actionContext.target === 'ui-icon') {
            // This was a simple click on an icon, already handled by setting activeColorTarget in mouseDown.
        } else {
            const startVertex = findVertexById(previewLineStartVertexId);
            if (isDrawingMode && startVertex) {
                
                saveStateForUndo();
                const edgesBefore = JSON.parse(JSON.stringify(allEdges));
                const snappedData = getSnappedPosition(startVertex, mousePos, shiftKey);
                let newVertex = null;

                if (snappedData.snapType === 'vertex' && snappedData.targetVertex) {
                    newVertex = snappedData.targetVertex;
                } else if (snappedData.snapType === 'edge' && snappedData.targetEdge) {
                    newVertex = insertVertexOnEdgeWithFaces(snappedData.targetEdge, { x: snappedData.x, y: snappedData.y });
                } else {
                    let newVertexColor = getColorForTarget(C.COLOR_TARGET_VERTEX);
                    const colorIndex = colorAssignments[C.COLOR_TARGET_VERTEX];
                    if (colorIndex !== -1) {
                        const colorItem = allColors[colorIndex];
                        if (colorItem && colorItem.type === 'colormap') {
                            newVertexColor = U.sampleColormap(colorItem, 0.5);
                        }
                    }

                    newVertex = { id: U.generateUniqueId(), x: snappedData.x, y: snappedData.y, type: 'regular', color: newVertexColor };
                    allVertices.push(newVertex);
                }

                if (newVertex) {
                    const edgeExists = allEdges.some(e => (e.id1 === startVertex.id && e.id2 === newVertex.id) || (e.id2 === startVertex.id && e.id1 === newVertex.id));
                    if (!edgeExists) {
                        const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
                        const newEdge = U.createEdge(startVertex, newVertex, gridInterval, getColorForTarget);
                        allEdges.push(newEdge);
                        updateFaces(edgesBefore, allEdges);

                        // Assign colors to any newly created faces
                        allFaces.forEach(face => {
                            if (!face.color) {
                                face.color = getColorForTarget(C.COLOR_TARGET_FACE);
                            }
                        });
                    }
                    
                    const completedSegmentProps = getCompletedSegmentProperties(startVertex, newVertex, allEdges);
                    if (completedSegmentProps) {
                        if (drawingSequence.length > 0) {
                            drawingSequence[drawingSequence.length - 1].turn = completedSegmentProps.turnAngleRad;
                        }
                        drawingSequence.push({ 
                            length: completedSegmentProps.length, 
                            turn: 0, 
                            endVertexColor: newVertex.color 
                        });
                        currentSequenceIndex = drawingSequence.length - 1;
                    }
                    
                    currentDrawingPath.push(newVertex.id);
                    window.currentDrawingPath = currentDrawingPath;

                    // Update both vertex and edge colors in the drawing sequence
                    updateDrawingSequenceColors();
                    updateDrawingSequenceEdgeColors();
                    
                    previewLineStartVertexId = newVertex.id;
                }
                
                if (shiftKey && newVertex && snappedData) {
                    const completedSegmentProps = getCompletedSegmentProperties(startVertex, newVertex, allEdges);
                    if (completedSegmentProps) {
                        frozenReference_Origin_Data = completedSegmentProps.startVertex;
                        
                        if (snappedData.gridToGridSquaredSum > 0 && snappedData.gridInterval) {
                            frozenReference_D_du = snappedData.gridInterval * Math.sqrt(snappedData.gridToGridSquaredSum);
                        } else {
                            frozenReference_D_du = completedSegmentProps.length;
                        }
                        
                        frozenReference_D_g2g = snappedData.gridToGridSquaredSum > 0 ? { 
                            g2gSquaredSum: snappedData.gridToGridSquaredSum, 
                            interval: snappedData.gridInterval 
                        } : null;
                        
                        frozenReference_A_rad = completedSegmentProps.turnAngleRad;
                        frozenReference_A_baseRad = completedSegmentProps.precedingSegmentAbsoluteAngleRad;
                    }
                } else {
                    frozenReference_D_du = null;
                    frozenReference_D_g2g = null;
                    frozenReference_A_rad = null;
                    frozenReference_A_baseRad = null;
                    frozenReference_Origin_Data = null;
                }

                clickData.count = 0;
            } else if (actionContext.target === 'canvas') {
                saveStateForUndo();
                const startCoords = ghostVertexPosition ? ghostVertexPosition : screenToData(mousePos);
                
                // For the first vertex in a new drawing sequence, always use the first color of the colormap
                let newVertexColor = getColorForTarget(C.COLOR_TARGET_VERTEX);
                const colorIndex = colorAssignments[C.COLOR_TARGET_VERTEX];
                if (colorIndex !== -1) {
                    const colorItem = allColors[colorIndex];
                    if (colorItem && colorItem.type === 'colormap') {
                        newVertexColor = U.sampleColormap(colorItem, 0);
                    }
                }

                const newVertex = { id: U.generateUniqueId(), ...startCoords, type: 'regular', color: newVertexColor };
                allVertices.push(newVertex);
                isDrawingMode = true;
                previewLineStartVertexId = newVertex.id;
                drawingSequence = [];
                currentSequenceIndex = 0;
                currentDrawingPath = [newVertex.id];
                window.currentDrawingPath = currentDrawingPath;
            } else {
                if (targetVertex || targetEdge || targetFace) {
                    saveStateForUndo();    
                    const targetId = targetFace ? U.getFaceId(targetFace) : (targetEdge ? U.getEdgeId(targetEdge) : targetVertex.id);
                    let targetType;
                    if (targetFace) targetType = 'face';
                    else if (targetVertex && targetVertex.type !== 'regular') targetType = 'center';
                    else if (targetVertex) targetType = 'vertex';
                    else if (targetEdge) targetType = 'edge';

                    if (targetId && clickData.targetId === targetId && (Date.now() - clickData.timestamp) < C.DOUBLE_CLICK_MS) {
                        clickData.count++;
                    } else {
                        clickData.count = 1;
                    }
                    clickData.targetId = targetId;
                    clickData.type = targetType;
                    clickData.timestamp = Date.now();

                    switch (clickData.count) {
                        case 1:
                            if (clickData.type === 'face') applySelectionLogic([], [], [clickData.targetId], shiftKey, ctrlKey);
                            else if (clickData.type === 'edge') applySelectionLogic([], [clickData.targetId], [], shiftKey, ctrlKey);
                            else if (clickData.type === 'vertex') applySelectionLogic([clickData.targetId], [], [], shiftKey, ctrlKey);
                            else if (clickData.type === 'center') handleCenterSelection(clickData.targetId, shiftKey, ctrlKey);
                            break;
                        case 2:
                            if (clickData.type === 'vertex') {
                                const neighbors = U.findNeighbors(clickData.targetId, allEdges);
                                applySelectionLogic([clickData.targetId, ...neighbors], [], [], shiftKey, ctrlKey);
                            } else if (clickData.type === 'edge') {
                                const edge = allEdges.find(e => U.getEdgeId(e) === clickData.targetId);
                                if (edge) {
                                    const validNeighborEdges = [...findNeighborEdges(edge.id1), ...findNeighborEdges(edge.id2)];
                                    applySelectionLogic([], Array.from(new Set(validNeighborEdges.map(e => U.getEdgeId(e)))), [], shiftKey, ctrlKey);
                                }
                            } else if (clickData.type === 'face') {
                                const face = allFaces.find(f => U.getFaceId(f) === clickData.targetId);
                                if (face) {
                                    const adjacentFaceIds = [];
                                    const faceEdges = new Set();
                                    for (let i = 0; i < face.vertexIds.length; i++) {
                                        const id1 = face.vertexIds[i];
                                        const id2 = face.vertexIds[(i + 1) % face.vertexIds.length];
                                        faceEdges.add(U.getEdgeId({ id1, id2 }));
                                    }
                                    allFaces.forEach(otherFace => {
                                        if (U.getFaceId(otherFace) === U.getFaceId(face)) return;
                                        for (let i = 0; i < otherFace.vertexIds.length; i++) {
                                            const id1 = otherFace.vertexIds[i];
                                            const id2 = otherFace.vertexIds[(i + 1) % otherFace.vertexIds.length];
                                            if (faceEdges.has(U.getEdgeId({ id1, id2 }))) {
                                                adjacentFaceIds.push(U.getFaceId(otherFace));
                                                break;
                                            }
                                        }
                                    });
                                    applySelectionLogic([], [], [U.getFaceId(face), ...adjacentFaceIds], shiftKey, ctrlKey);
                                }
                            }
                            break;
                        case 3:
                            if (clickData.type === 'vertex' || clickData.type === 'edge' || clickData.type === 'face') {
                                let startNode;
                                if (clickData.type === 'vertex') startNode = clickData.targetId;
                                else if (clickData.type === 'edge') startNode = clickData.targetId.split(C.EDGE_ID_DELIMITER)[0];
                                else if (clickData.type === 'face') {
                                    const face = allFaces.find(f => U.getFaceId(f) === clickData.targetId);
                                    if (face) startNode = face.vertexIds[0];
                                }
                                if (startNode) {
                                    const verticesInSubgraph = new Set(findAllVerticesInSubgraph(startNode));
                                    if (clickData.type === 'vertex') applySelectionLogic(Array.from(verticesInSubgraph), [], [], shiftKey, ctrlKey);
                                    else if (clickData.type === 'edge') {
                                        const edgesInSubgraph = allEdges.filter(e => verticesInSubgraph.has(e.id1) && verticesInSubgraph.has(e.id2)).map(e => U.getEdgeId(e));
                                        applySelectionLogic([], edgesInSubgraph, [], shiftKey, ctrlKey);
                                    } else if (clickData.type === 'face') {
                                        const facesInSubgraph = allFaces.filter(f => f.vertexIds.every(vId => verticesInSubgraph.has(vId))).map(f => U.getFaceId(f));
                                        applySelectionLogic([], [], facesInSubgraph, shiftKey, ctrlKey);
                                    }
                                }
                            }
                            clickData.count = 0;
                            break;
                    }

                    const newActiveTargets = [];
                    if (selectedFaceIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_FACE);
                    if (selectedEdgeIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_EDGE);
                    if (selectedVertexIds.length > 0) newActiveTargets.push(C.COLOR_TARGET_VERTEX);

                    if (newActiveTargets.length > 0) {
                        activeColorTargets = newActiveTargets;
                    }
                }
            }
        } 
    }

    isActionInProgress = false;
    isDragConfirmed = false;
    isPanningBackground = false;
    isRectangleSelecting = false;
    actionContext = null;
    transformIndicatorData = null;
    canvas.style.cursor = 'crosshair';
    if (!currentShiftPressed) ghostVertexPosition = null;
}

function updateAffectedEdgeProperties(movedVertexIds, transformIndicatorData) {
    if (movedVertexIds.length === 0) return;

    // For rotation or translation, properties are preserved, so we do nothing.
    const isRotation = transformIndicatorData && transformIndicatorData.transformType === C.TRANSFORMATION_TYPE_ROTATION;
    const isTranslation = !transformIndicatorData;
    if (isRotation || isTranslation) {
        return;
    }

    const affectedEdges = new Set();
    movedVertexIds.forEach(vertexId => {
        findNeighborEdges(vertexId).forEach(edge => affectedEdges.add(edge));
    });

    const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

    // For scaling, we recalculate the property for each affected edge.
    affectedEdges.forEach(edge => {
        const v1 = findVertexById(edge.id1);
        const v2 = findVertexById(edge.id2);
        if (!v1 || !v2) return;

        const deltaX = v1.x - v2.x;
        const deltaY = v1.y - v2.y;
        const dx_grid_float = deltaX / gridInterval;
        const dy_grid_float = deltaY / gridInterval;
        const epsilon = 1e-5;

        const isGridVector = gridInterval &&
            Math.abs(dx_grid_float - Math.round(dx_grid_float)) < epsilon &&
            Math.abs(dy_grid_float - Math.round(dy_grid_float)) < epsilon;

        if (isGridVector) {
            edge.labelMode = 'exact';
            const dx_grid = Math.round(dx_grid_float);
            const dy_grid = Math.round(dy_grid_float);
            edge.exactValue = {
                g2gSquaredSum: dx_grid * dx_grid + dy_grid * dy_grid,
                gridInterval: gridInterval
            };
        } else {
            edge.labelMode = 'decimal';
            delete edge.exactValue;
        }
    });
}

function handleRightMouseButtonDown(event) {
    isActionInProgress = true;
    isRectangleSelecting = false; 
    rectangleSelectStartPos = actionStartPos;
    actionContext = { target: 'canvas' };
}

function handleRightMouseButtonUp(event) {
    if (isDragConfirmed && isRectangleSelecting) {
        const dataP1 = screenToData({ x: Math.min(actionStartPos.x, mousePos.x), y: Math.min(actionStartPos.y, mousePos.y) });
        const dataP2 = screenToData({ x: Math.max(actionStartPos.x, mousePos.x), y: Math.max(actionStartPos.y, mousePos.y) });
        const minX = Math.min(dataP1.x, dataP2.x);
        const maxX = Math.max(dataP1.x, dataP2.x);
        const minY = Math.min(dataP1.y, dataP2.y);
        const maxY = Math.max(dataP1.y, dataP2.y);
        const verticesInRect = allVertices.filter(p => p.type === 'regular' && p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY).map(p => p.id);
        const edgesInRect = allEdges.filter(e => verticesInRect.includes(e.id1) && verticesInRect.includes(e.id2)).map(e => U.getEdgeId(e));
        const allVerticesInRect = new Set(verticesInRect);
        const facesInRect = allFaces.filter(f => f.vertexIds.every(vId => allVerticesInRect.has(vId))).map(f => U.getFaceId(f));
        applySelectionLogic(verticesInRect, edgesInRect, facesInRect, actionContext.shiftKey, actionContext.ctrlKey);

        const newActiveTargets = [];
        if (facesInRect.length > 0) newActiveTargets.push(C.COLOR_TARGET_FACE);
        if (edgesInRect.length > 0) newActiveTargets.push(C.COLOR_TARGET_EDGE);
        if (verticesInRect.length > 0) newActiveTargets.push(C.COLOR_TARGET_VERTEX);

        if (newActiveTargets.length > 0) {
            activeColorTargets = newActiveTargets;
            if (isColorPaletteExpanded) {
                buildColorPaletteUI();
            }
        }
    } else {
        // This handles a simple right-click without a drag
        performEscapeAction();
        canvas.style.cursor = 'crosshair';
    }
}

function handleMouseDownDispatcher(event) {
    if (contextMenu.style.display === 'block') {
        contextMenu.style.display = 'none';
    }

    const targetElement = event.target;
    if (targetElement && targetElement.closest('.katex')) {
        event.stopPropagation();
        return;
    }

    // This check now correctly cancels drawing or transform placement with a right-click
    if ((isDrawingMode || isPlacingTransform) && event.button === 2) {
        performEscapeAction();
        event.preventDefault();
        return;
    }

    mousePos = U.getMousePosOnCanvas(event, canvas);
    actionStartPos = { ...mousePos };
    currentMouseButton = event.button;

    if (currentMouseButton === 0) {
        handleLeftMouseButtonDown(event);
    } else if (currentMouseButton === 2) {
        handleRightMouseButtonDown(event);
    }
}

function handleMouseUpDispatcher(event) {
    if (currentMouseButton === 0) {
        handleLeftMouseButtonUp(event);
    } else if (currentMouseButton === 2) {
        handleRightMouseButtonUp(event);
    }

    // Common cleanup for ANY mouse up action
    isActionInProgress = false;
    isDragConfirmed = false;
    isPanningBackground = false;
    isRectangleSelecting = false;
    actionContext = null;
    transformIndicatorData = null;
    
    // Only reset the cursor if we are NOT in the middle of placing a transform
    if (!isPlacingTransform) {
        canvas.style.cursor = 'crosshair';
    }

    if (!currentShiftPressed) ghostVertexPosition = null;
}

function handleAddFaceFromMenu() {
    if (contextMenuFaceId) {
        const allPossibleFaces = U.detectClosedPolygons(allEdges, findVertexById);
        const faceToAdd = allPossibleFaces.find(f => f.id === contextMenuFaceId);

        if (faceToAdd) {
            saveStateForUndo();

            if (!allFaces.some(f => f.id === faceToAdd.id)) {
                faceToAdd.color = getColorForTarget(C.COLOR_TARGET_FACE);
                allFaces.push(faceToAdd);

                deletedFaceIds.delete(faceToAdd.id);

                ensureFaceCoordinateSystems();
            }
        }
        contextMenuFaceId = null;
    }
    contextMenu.style.display = 'none';
}

function applyCoordinateSystemConstraintsOnDragEnd(face, initialSystem, initialDragVertexStates, dragPreviewVertices, findVertexById) {
    // This function now correctly solves constraints based on the final vertex positions (dragPreviewVertices)
    // without incorrectly checking against the initial set of dragged vertices.

    if (!initialSystem.isCustom) {
        const faceVertices = face.vertexIds.map(id => {
            return dragPreviewVertices.find(p => p.id === id) || findVertexById(id);
        }).filter(v => v && v.type === 'regular');
        
        if (faceVertices.length >= 3) {
            const incircle = U.calculateIncenter(faceVertices);
            if (incircle) {
                face.localCoordSystem.origin = incircle.center;
                face.localCoordSystem.scale = incircle.radius;
            }
        }
        return;
    }

    let finalOrigin = { ...initialSystem.origin };
    let finalAngle = initialSystem.angle;
    let finalScale = initialSystem.scale;
    
    if (face.localCoordSystem.attachedToVertex) {
        const finalVertex = dragPreviewVertices.find(p => p.id === face.localCoordSystem.attachedToVertex);
        if (finalVertex) {
            finalOrigin = { x: finalVertex.x, y: finalVertex.y };
        }
    } else if (face.localCoordSystem.attachedToEdge) {
        const finalV1 = dragPreviewVertices.find(p => p.id === face.localCoordSystem.attachedToEdge.v1) || findVertexById(face.localCoordSystem.attachedToEdge.v1);
        const finalV2 = dragPreviewVertices.find(p => p.id === face.localCoordSystem.attachedToEdge.v2) || findVertexById(face.localCoordSystem.attachedToEdge.v2);
        
        if (finalV1 && finalV2) {
            finalOrigin = {
                x: finalV1.x + face.localCoordSystem.attachedToEdge.t * (finalV2.x - finalV1.x),
                y: finalV1.y + face.localCoordSystem.attachedToEdge.t * (finalV2.y - finalV1.y)
            };
        }
    }
    
    if (face.localCoordSystem.rotationAlignedToEdge) {
        const finalV1 = dragPreviewVertices.find(p => p.id === face.localCoordSystem.rotationAlignedToEdge.v1) || findVertexById(face.localCoordSystem.rotationAlignedToEdge.v1);
        const finalV2 = dragPreviewVertices.find(p => p.id === face.localCoordSystem.rotationAlignedToEdge.v2) || findVertexById(face.localCoordSystem.rotationAlignedToEdge.v2);
        
        if (finalV1 && finalV2) {
            const newEdgeAngle = Math.atan2(finalV2.y - finalV1.y, finalV2.x - finalV1.x);
            const originalEdgeAngle = face.localCoordSystem.rotationAlignedToEdge.originalAngle;
            const originalSystemAngle = face.localCoordSystem.rotationAlignedToEdge.originalSystemAngle;
            
            const angleOffset = originalSystemAngle - originalEdgeAngle;
            finalAngle = U.normalizeAngle(newEdgeAngle + angleOffset);
            
            face.localCoordSystem.rotationAlignedToEdge.originalAngle = newEdgeAngle;
            face.localCoordSystem.rotationAlignedToEdge.originalSystemAngle = finalAngle;
        }
    }
    
    if (face.localCoordSystem.scaleAttachedToEdge) {
        const finalV1 = dragPreviewVertices.find(p => p.id === face.localCoordSystem.scaleAttachedToEdge.v1) || findVertexById(face.localCoordSystem.scaleAttachedToEdge.v1);
        const finalV2 = dragPreviewVertices.find(p => p.id === face.localCoordSystem.scaleAttachedToEdge.v2) || findVertexById(face.localCoordSystem.scaleAttachedToEdge.v2);
        
        if (finalV1 && finalV2) {
            const newEdgeLength = U.distance(finalV1, finalV2);
            finalScale = newEdgeLength * face.localCoordSystem.scaleAttachedToEdge.scaleRatio;
            face.localCoordSystem.scaleAttachedToEdge.originalLength = newEdgeLength;
        }
    }
    
    const finalFaceVertices = face.vertexIds.map(id => {
        return dragPreviewVertices.find(p => p.id === id) || findVertexById(id);
    }).filter(v => v && v.type === 'regular');
    
    if (finalFaceVertices.length >= 3) {
        face.localCoordSystem.origin = U.clampPointToPolygon(finalOrigin, finalFaceVertices);
        face.localCoordSystem.angle = finalAngle;
        face.localCoordSystem.scale = Math.max(0.01, finalScale);
        face.localCoordSystem.isCustom = true;
    }
}




function backupFaceCoordinateSystemsBeforeMerge(allFaces, findRoot) {
    const faceCoordSystemBackup = new Map();
    allFaces.forEach(face => {
        const remappedVertexIds = [...new Set(face.vertexIds.map(vId => findRoot(vId)))];
        if (remappedVertexIds.length >= 3) {
            const newFaceId = U.getFaceId({ vertexIds: remappedVertexIds });
            if (face.localCoordSystem && face.localCoordSystem.isCustom) {
                const backup = JSON.parse(JSON.stringify(face.localCoordSystem));

                if (backup.attachedToVertex) {
                    backup.attachedToVertex = findRoot(backup.attachedToVertex);
                }
                if (backup.attachedToEdge) {
                    backup.attachedToEdge.v1 = findRoot(backup.attachedToEdge.v1);
                    backup.attachedToEdge.v2 = findRoot(backup.attachedToEdge.v2);
                }
                if (backup.rotationAlignedToEdge) {
                    backup.rotationAlignedToEdge.v1 = findRoot(backup.rotationAlignedToEdge.v1);
                    backup.rotationAlignedToEdge.v2 = findRoot(backup.rotationAlignedToEdge.v2);
                }
                if (backup.scaleAttachedToEdge) {
                    backup.scaleAttachedToEdge.v1 = findRoot(backup.scaleAttachedToEdge.v1);
                    backup.scaleAttachedToEdge.v2 = findRoot(backup.scaleAttachedToEdge.v2);
                }

                faceCoordSystemBackup.set(newFaceId, backup);
            }
        }
    });
    return faceCoordSystemBackup;
}

function handleKeyUp(event) {
    if (event.key === 'Shift') {
        currentShiftPressed = false;
        ghostVertexPosition = null;
        placingSnapPos = null;
        ghostVertices = [];
        
        if (isDraggingCoordSystem && draggedCoordSystemElement && draggedCoordSystemElement.type === 'center') {
            const mouseDataPos = screenToData(mousePos);
            const face = draggedCoordSystemElement.face;
            const coordSystem = face.localCoordSystem;
            const faceVertices = face.vertexIds.map(id => findVertexById(id)).filter(p => p && p.type === 'regular');
            const clampedPos = U.clampPointToPolygon(mouseDataPos, faceVertices);
            coordSystem.origin.x = clampedPos.x;
            coordSystem.origin.y = clampedPos.y;
            coordSystem.isCustom = true;
        }
    }
}

function handleContextMenu(event) {
    event.preventDefault();
    contextMenu.innerHTML = '';
    contextMenu.style.display = 'none';

    mousePos = U.getMousePosOnCanvas(event, canvas);
    const dataPos = screenToData(mousePos);

    let menuItems = [];
    contextMenuFaceId = null;
    contextMenuEdgeId = null;
    contextMenuVertexId = null;

    const clickedVertex = findClickedVertex(mousePos);
    const clickedEdge = !clickedVertex ? findClickedEdge(mousePos) : null;
    const clickedFace = !clickedVertex && !clickedEdge ? findClickedFace(mousePos) : null;

    if (clickedVertex && clickedVertex.type === 'regular') {
        contextMenuVertexId = clickedVertex.id;
        menuItems.push({
            text: 'Remove Vertex',
            handler: handleRemoveVertexFromMenu
        });
    } else if (clickedEdge) {
        contextMenuEdgeId = U.getEdgeId(clickedEdge);
        menuItems.push({
            text: 'Remove Edge',
            handler: handleRemoveEdgeFromMenu
        });
    } else if (clickedFace) {
        contextMenuFaceId = U.getFaceId(clickedFace);
        menuItems.push({
            text: 'Remove Face',
            handler: handleRemoveFaceFromMenu
        });
    } else {
        const allPossibleFaces = U.detectClosedPolygons(allEdges, findVertexById);
        const existingFaceIds = new Set(allFaces.map(f => f.id));

        const potentialNewFaces = allPossibleFaces.filter(potentialFace =>
            !existingFaceIds.has(potentialFace.id)
        );

        let smallestEnclosingFace = null;
        let smallestArea = Infinity;

        potentialNewFaces.forEach(potentialFace => {
            const vertices = potentialFace.vertexIds.map(id => findVertexById(id));
            if (vertices.every(Boolean) && U.isVertexInPolygon(dataPos, vertices)) {
                const area = Math.abs(U.shoelaceArea(vertices));
                if (area < smallestArea) {
                    smallestArea = area;
                    smallestEnclosingFace = potentialFace;
                }
            }
        });

        if (smallestEnclosingFace) {
            contextMenuFaceId = smallestEnclosingFace.id;
            menuItems.push({
                text: 'Add Face',
                handler: handleAddFaceFromMenu
            });
        }
    }

    if (menuItems.length > 0) {
        const ul = document.createElement('ul');
        menuItems.forEach(itemData => {
            const li = document.createElement('li');
            li.textContent = itemData.text;
            li.addEventListener('click', itemData.handler);
            ul.appendChild(li);
        });
        contextMenu.appendChild(ul);

        contextMenu.style.left = `${event.clientX - C.CONTEXT_MENU_INSET}px`;
        contextMenu.style.top = `${event.clientY - C.CONTEXT_MENU_INSET}px`;
        contextMenu.style.display = 'block';
    }
}

function handleRemoveVertexFromMenu() {
    if (contextMenuVertexId) {
        saveStateForUndo();
        selectedEdgeIds = [];
        selectedFaceIds = [];
        selectedCenterIds = [];
        selectedVertexIds = [contextMenuVertexId];

        deleteSelectedItems();
        contextMenuVertexId = null;
    }
    contextMenu.style.display = 'none';
}

function handleRemoveEdgeFromMenu() {
    if (contextMenuEdgeId) {
        saveStateForUndo();
        selectedVertexIds = [];
        selectedFaceIds = [];
        selectedCenterIds = [];
        selectedEdgeIds = [contextMenuEdgeId];

        deleteSelectedItems();
        contextMenuEdgeId = null;
    }
    contextMenu.style.display = 'none';
}

function handleRemoveFaceFromMenu() {
    if (contextMenuFaceId) {
        saveStateForUndo();
        selectedVertexIds = [];
        selectedEdgeIds = [];
        selectedCenterIds = [];
        selectedFaceIds = [contextMenuFaceId];

        deleteSelectedItems();
        contextMenuFaceId = null;
    }
    contextMenu.style.display = 'none';
}


// Event listeners setup
canvas.addEventListener('wheel', (event) => {
    event.preventDefault();
    const mouseScreen = U.getMousePosOnCanvas(event, canvas);
    const scaleFactor = event.deltaY > 0 ? 1 / 1.15 : 1.15;
    zoomAt(mouseScreen, scaleFactor);
}, { passive: false });

canvas.addEventListener('mouseenter', () => {
    isMouseOverCanvas = true;
});

canvas.addEventListener('mouseleave', () => {
    isMouseOverCanvas = false;
    redrawAll();
});

canvas.addEventListener('contextmenu', (event) => event.preventDefault());

canvas.addEventListener('mousemove', handleMouseMove);

canvas.addEventListener("mouseup", handleMouseUpDispatcher);

canvas.addEventListener('mousedown', handleMouseDownDispatcher);

window.addEventListener('keyup', handleKeyUp);

window.addEventListener('keydown', handleKeyDown);

window.addEventListener('resize', resizeCanvas);

window.addEventListener('load', () => {
    initializeApp();
});

=== style.css ===
:root {
    --container-bg-color: #1e1e1e;
    --default-text-color: #e2e8f0; /* A light default text color */
}

html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background-color: var(--container-bg-color);
    /* Set a default text color for the whole page */
    color: var(--default-text-color);
}

.container {
    /* Scope the specific font only to the app's container */
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
}

.canvas-container {
    flex-grow: 1;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    box-sizing: border-box;
}

.canvas-wrapper-relative {
    position: relative;
    width: 100%;
    height: 100%;
}

/* This rule is now specific to the main drawing canvas */
#drawingCanvas {
    display: block;
    background-color: #1a1a1a;
    cursor: crosshair;
}

#html-overlay {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    width: 100%;
    height: 100%;
}

.context-menu {
    display: none;
    position: absolute;
    background-color: #2a2a2e;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 5px 0;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    z-index: 1000;
}

.context-menu ul {
    list-style: none;
    margin: 0;
    padding: 0;
}

.context-menu ul li {
    padding: 8px 15px;
    cursor: pointer;
}

.context-menu ul li:hover {
    background-color: #4a4a50;
}


=== utils.js ===
import * as C from './constants.js';


export function formatNumber(value, sigFigs, forceScientific = false) {
    if (value === 0) return "0";
    const absValue = Math.abs(value);
    const sign = value < 0 ? "-" : "";
    let formattedString;
    if (forceScientific || absValue >= C.SCIENTIFIC_NOTATION_UPPER_BOUND || (absValue !== 0 && absValue < C.SCIENTIFIC_NOTATION_LOWER_BOUND)) {
        if (value === 0) return "0";
        const expStr = absValue.toExponential(Math.max(0, sigFigs - 1));
        const parts = expStr.split('e');
        let coefficient = parseFloat(parts[0]).toString();
        let exponent = parseInt(parts[1], 10);
        formattedString = `${coefficient} \\cdot 10^{${exponent}}`;
    } else {
        const integerDigits = absValue < 1 ? 0 : Math.floor(Math.log10(absValue)) + 1;
        let decimalPlacesToDisplay;
        if (absValue === 0) {
            decimalPlacesToDisplay = sigFigs - 1;
        } else if (absValue < 1) {
            let k = 0;
            let temp = absValue;
            while (temp < 1 && k < sigFigs + 5) {
                temp *= 10;
                k++;
            }
            decimalPlacesToDisplay = Math.max(0, (k - 1) + sigFigs);
        } else {
            decimalPlacesToDisplay = Math.max(0, sigFigs - integerDigits);
        }
        let fixedStr = absValue.toFixed(decimalPlacesToDisplay);
        let num = parseFloat(fixedStr);
        if (Math.abs(num) === 0 && value !== 0) {
            return "0";
        }
        formattedString = Math.abs(num).toString();
    }
    return sign + formattedString;
}

export function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b);
}

export function getEdgeId(edge) {
    return edge.id1 < edge.id2 
        ? `${edge.id1}${C.EDGE_ID_DELIMITER}${edge.id2}` 
        : `${edge.id2}${C.EDGE_ID_DELIMITER}${edge.id1}`;
}

export function distanceToSegment(px, py, x1, y1, x2, y2) {
    // Compute vector AB = (x2 - x1, y2 - y1)
    const abX = x2 - x1;
    const abY = y2 - y1;
    
    // Compute squared length
    const lSquared = abX * abX + abY * abY;
    
    // If points are the same, distance is to that point
    if (lSquared === 0) {
        const dx = px - x1;
        const dy = py - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    // Compute projection parameter t = -((x1 - px) * (x2 - x1) + (y1 - py) * (y2 - y1)) / l_squared
    let t = -((x1 - px) * abX + (y1 - py) * abY) / lSquared;
    
    // Clamp t to [0, 1]
    if (t < 0) t = 0;
    if (t > 1) t = 1;
    
    // Compute closest point C = (x1 + t * (x2 - x1), y1 + t * (y2 - y1))
    const cX = x1 + t * abX;
    const cY = y1 + t * abY;
    
    // Compute distance from point to closest point
    const dx = px - cX;
    const dy = py - cY;
    return Math.sqrt(dx * dx + dy * dy);
}

export function getFaceId(face) {
    if (face.id) return face.id;
    if (face.vertexIds) {
        return `face_${[...face.vertexIds].sort().join('_')}`;
    }
    return null;
}

export function getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, angularGridState, getMultipleRect = false) {
    const candidates = [];
    if (gridDisplayMode === 'none' || !gridInterval || gridInterval <= 0) {
        return candidates;
    }

    if (gridDisplayMode === 'polar') {
        const mouseAngleDeg = (Math.atan2(mouseDataPos.y, mouseDataPos.x) * 180 / Math.PI + 360) % 360;
        const mouseRadius = Math.hypot(mouseDataPos.x, mouseDataPos.y);
        const snappedRadius = Math.round(mouseRadius / gridInterval) * gridInterval;

        angularGridState.forEach(level => {
            if (level.alpha > 0.01 && level.angle > 0) {
                const angularInterval = level.angle;
                const snappedAngleDeg = Math.round(mouseAngleDeg / angularInterval) * angularInterval;
                const snappedAngleRad = snappedAngleDeg * Math.PI / 180;
                candidates.push({ x: snappedRadius * Math.cos(snappedAngleRad), y: snappedRadius * Math.sin(snappedAngleRad), isGridPoint: true });
            }
        });
    } else if (gridDisplayMode === 'triangular') {
        const y_step = gridInterval * C.TRIANGULAR_GRID_Y_STEP_FACTOR;
        const i_f = (mouseDataPos.x / gridInterval) - (mouseDataPos.y / (gridInterval * Math.sqrt(3)));
        const j_f = mouseDataPos.y / y_step;

        let i_r = Math.round(i_f);
        let j_r = Math.round(j_f);
        let k_r = Math.round(-i_f - j_f);

        const i_diff = Math.abs(i_r - i_f);
        const j_diff = Math.abs(j_r - j_f);
        const k_diff = Math.abs(k_r - (-i_f - j_f));

        if (i_diff > j_diff && i_diff > k_diff) {
            i_r = -j_r - k_r;
        } else if (j_diff > k_diff) {
            j_r = -i_r - k_r;
        }

        const snappedX = i_r * gridInterval + j_r * gridInterval / 2;
        const snappedY = j_r * y_step;
        candidates.push({ x: snappedX, y: snappedY, isGridPoint: true });
    } else {
        if (getMultipleRect) {
            const gridX = Math.floor(mouseDataPos.x / gridInterval) * gridInterval;
            const gridY = Math.floor(mouseDataPos.y / gridInterval) * gridInterval;
            candidates.push(
                { x: gridX, y: gridY, isGridPoint: true },
                { x: gridX + gridInterval, y: gridY, isGridPoint: true },
                { x: gridX, y: gridY + gridInterval, isGridPoint: true },
                { x: gridX + gridInterval, y: gridY + gridInterval, isGridPoint: true }
            );
        } else {
            candidates.push({ x: Math.round(mouseDataPos.x / gridInterval) * gridInterval, y: Math.round(mouseDataPos.y / gridInterval) * gridInterval, isGridPoint: true });
        }
    }
    return candidates;
}

export function generateUniqueId() {
    return crypto.randomUUID();
}

export function normalizeAngle(angleRad) {
    while (angleRad < 0) angleRad += C.RADIANS_IN_CIRCLE;
    while (angleRad >= C.RADIANS_IN_CIRCLE) angleRad -= C.RADIANS_IN_CIRCLE;
    return angleRad;
}

export function calculateRotationAngle(initialStartAngle, currentMouseAngle, totalAccumulatedRotationFromStart = 0) {
    let rawDeltaAngle = currentMouseAngle - initialStartAngle;
    let numRevolutions = Math.round((totalAccumulatedRotationFromStart - rawDeltaAngle) / (2 * Math.PI));
    let continuousDeltaAngle = rawDeltaAngle + numRevolutions * (2 * Math.PI);
    return continuousDeltaAngle;
}

export function normalizeAngleToPi(angleRad) {
    angleRad = normalizeAngle(angleRad);
    if (angleRad > Math.PI) {
        angleRad -= C.RADIANS_IN_CIRCLE;
    }
    return angleRad;
}

export function normalizeAngleDegrees(angleDeg) {
    while (angleDeg < 0) angleDeg += C.DEGREES_IN_CIRCLE;
    while (angleDeg >= C.DEGREES_IN_CIRCLE) angleDeg -= C.DEGREES_IN_CIRCLE;
    return angleDeg;
}

export function getLineCircleIntersection(line, circle) {
    const { p1, p2 } = line;
    const { center, radius } = circle;
    const d = { x: p2.x - p1.x, y: p2.y - p1.y };
    const f = { x: p1.x - center.x, y: p1.y - center.y };
    const a = d.x * d.x + d.y * d.y;
    const b = 2 * (f.x * d.x + f.y * d.y);
    const c = f.x * f.x + f.y * f.y - radius * radius;
    let discriminant = b * b - 4 * a * c;

    if (discriminant < 0) return [];

    discriminant = Math.sqrt(discriminant);
    const t1 = (-b - discriminant) / (2 * a);
    const t2 = (-b + discriminant) / (2 * a);

    return [
        { x: p1.x + t1 * d.x, y: p1.y + t1 * d.y },
        { x: p1.x + t2 * d.x, y: p1.y + t2 * d.y }
    ];
}

export function getLineLineIntersection(line1, line2) {
    const p1 = line1.p1, p2 = line1.p2, p3 = line2.p1, p4 = line2.p2;
    const den = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
    if (Math.abs(den) < C.GEOMETRY_CALCULATION_EPSILON) return null;
    const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / den;
    const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / den;
    
    if (u >= 0 && u <= 1) {
        return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
    }
    return null;
}

export function simplifySquareRoot(n) {
    if (n < 0 || !Number.isInteger(n)) return [null, null];
    if (n === 0) return [0, 1];
    
    let coefficient = 1;
    let radicand = n;

    for (let i = 2; i * i <= radicand; i++) {
        while (radicand % (i * i) === 0) {
            radicand /= (i * i);
            coefficient *= i;
        }
    }

    return [coefficient, radicand];
}

export function formatSimplifiedRoot(coeff, radicand, symbol = '') {
    const symString = symbol ? `\\${symbol}` : '';

    if (radicand === 1) {
        if (coeff === 1 && symbol) return symString;
        return `${coeff}${symString}`;
    }
    if (coeff === 1) {
        return `\\sqrt{${radicand}}${symString}`;
    }
    return `${coeff}\\sqrt{${radicand}}${symString}`;
}

export function distance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

export function formatFraction(decimal, tolerance = C.FRACTION_FORMAT_TOLERANCE, maxDisplayDenominator = C.FRACTION_FORMAT_MAX_DENOMINATOR) {
    if (Math.abs(decimal) < C.ZERO_TOLERANCE) return "0";
    const originalSign = decimal < 0 ? "-" : "";
    const absDecimal = Math.abs(decimal);

    if (Math.abs(absDecimal - Math.round(absDecimal)) < tolerance) {
        const rounded = Math.round(absDecimal);
        return originalSign + rounded.toString();
    }

    const fractions = [
        [1,2],[1,3],[2,3],[1,4],[3,4],[1,5],[2,5],[3,5],[4,5],[1,6],[5,6],
        [1,8],[3,8],[5,8],[7,8],[1,10],[3,10],[7,10],[9,10],
        [1,12],[5,12],[7,12],[11,12],[1,16],[3,16],[5,16],[7,16],[9,16],[11,16],[13,16],[15,16]
    ];

    for (const [num, den] of fractions) {
        if (den <= maxDisplayDenominator) {
            if (Math.abs(absDecimal - num/den) < tolerance) {
                return originalSign + `${num}/${den}`;
            }
        }
    }

    for (let currentDen = 1; currentDen <= maxDisplayDenominator; currentDen++) {
        const currentNum = Math.round(absDecimal * currentDen);
        if (currentNum === 0 && absDecimal > C.ZERO_TOLERANCE) continue;
        if (Math.abs(absDecimal - currentNum / currentDen) < tolerance / currentDen) {
            const common = gcd(currentNum, currentDen);
            const n = currentNum/common;
            const d = currentDen/common;
            if (d === 1) return originalSign + `${n}`;
            return originalSign + `${n}/${d}`;
        }
    }
    let fixedPrecision = 2;
        if (absDecimal < 0.01) fixedPrecision = 3;
    else if (absDecimal < 0.1)  fixedPrecision = 2;
    else if (absDecimal < 10)   fixedPrecision = 1;
    else                        fixedPrecision = 0;
    
    return originalSign + absDecimal.toFixed(fixedPrecision);
}

export function isVertexInPolygon(vertex, vertices) {
    if (vertices.length < 3) return false;
    
    let inside = false;
    const x = vertex.x;
    const y = vertex.y;
    
    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        const xi = vertices[i].x;
        const yi = vertices[i].y;
        const xj = vertices[j].x;
        const yj = vertices[j].y;
        
        if (((yi > y) !== (yj > y)) && 
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
            inside = !inside;
        }
    }
    
    return inside;
}

export function parseColor(colorString) {
    if (!colorString || typeof colorString !== 'string') {
        return { r: 255, g: 255, b: 255, a: 1.0 };
    }
    
    if (colorString.startsWith('rgba(')) {
        const match = colorString.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        if (match) {
            return {
                r: Math.max(0, Math.min(255, parseInt(match[1]))),
                g: Math.max(0, Math.min(255, parseInt(match[2]))),
                b: Math.max(0, Math.min(255, parseInt(match[3]))),
                a: Math.max(0, Math.min(1, parseFloat(match[4])))
            };
        }
    }
    
    if (colorString.startsWith('rgb(')) {
        const match = colorString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (match) {
            return {
                r: Math.max(0, Math.min(255, parseInt(match[1]))),
                g: Math.max(0, Math.min(255, parseInt(match[2]))),
                b: Math.max(0, Math.min(255, parseInt(match[3]))),
                a: 1.0
            };
        }
    }
    
    if (colorString.startsWith('#')) {
        const hex = colorString.slice(1);
        if (hex.length === 6) {
            return {
                r: parseInt(hex.slice(0, 2), 16),
                g: parseInt(hex.slice(2, 4), 16),
                b: parseInt(hex.slice(4, 6), 16),
                a: 1.0
            };
        }
        if (hex.length === 3) {
            return {
                r: parseInt(hex[0] + hex[0], 16),
                g: parseInt(hex[1] + hex[1], 16),
                b: parseInt(hex[2] + hex[2], 16),
                a: 1.0
            };
        }
    }
    
    return { r: 255, g: 255, b: 255, a: 1.0 };
}

export function findCoordinateSystemElement(screenPos, face, dataToScreen) {
    const coordSystem = face.localCoordSystem;
    if (!coordSystem) return null;

    const centerScreen = dataToScreen(coordSystem.origin);
    const centerSelectRadius = 8;

    if (distance(screenPos, centerScreen) < centerSelectRadius) {
        return { face, type: 'center' };
    }

    const armSelectThreshold = 5;

    const xAxisEndGlobal = localToGlobal({ x: 1, y: 0 }, coordSystem);
    const xAxisScreenEnd = dataToScreen(xAxisEndGlobal);
    const closestOnX = getClosestPointOnLineSegment(screenPos, centerScreen, xAxisScreenEnd);
    if (closestOnX.distance < armSelectThreshold) {
        return { face, type: 'x_axis' };
    }

    const yAxisEndGlobal = localToGlobal({ x: 0, y: 1 }, coordSystem);
    const yAxisScreenEnd = dataToScreen(yAxisEndGlobal);
    const closestOnY = getClosestPointOnLineSegment(screenPos, centerScreen, yAxisScreenEnd);
    if (closestOnY.distance < armSelectThreshold) {
        return { face, type: 'y_axis' };
    }

    return null;
}

export function clampPointToPolygon(point, vertices) {
    if (isVertexInPolygon(point, vertices)) {
        return point;
    }
    
    let closestPoint = point;
    let minDistance = Infinity;
    
    // Check distance to each edge and find closest point
    for (let i = 0; i < vertices.length; i++) {
        const v1 = vertices[i];
        const v2 = vertices[(i + 1) % vertices.length];
        const edgeClosest = getClosestPointOnLineSegment(point, v1, v2);
        
        if (edgeClosest.distance < minDistance) {
            minDistance = edgeClosest.distance;
            closestPoint = { x: edgeClosest.x, y: edgeClosest.y };
        }
    }
    
    return closestPoint;
}

export function getClickedUIElement(screenPos, canvasUI, { isToolbarExpanded, isColorPaletteExpanded, isTransformPanelExpanded, isDisplayPanelExpanded, isVisibilityPanelExpanded }) {
    const isInside = (pos, rect) => {
        if (!rect) return false;
        return pos.x >= rect.x && pos.x <= rect.x + rect.width &&
               pos.y >= rect.y && pos.y <= rect.y + rect.height;
    };

    if (isColorPaletteExpanded) {
        for (const icon of (canvasUI.colorTargetIcons || [])) {
            if (isInside(screenPos, icon)) return { ...icon, type: 'colorTargetIcon' };
        }
        for (const swatch of (canvasUI.colorSwatches || [])) {
            if (isInside(screenPos, swatch)) return { ...swatch, type: 'colorSwatch' };
        }
        if (isInside(screenPos, canvasUI.applyColorsButton)) return { ...canvasUI.applyColorsButton, type: 'button' };
        if (isInside(screenPos, canvasUI.randomColorButton)) return { ...canvasUI.randomColorButton, type: 'button' };
        if (isInside(screenPos, canvasUI.removeColorButton)) return { ...canvasUI.removeColorButton, type: 'button' };
        if (isInside(screenPos, canvasUI.addColorButton)) return { ...canvasUI.addColorButton, type: 'button' };
    }

    if (isTransformPanelExpanded) {
        for (const icon of (canvasUI.transformIcons || [])) {
            if (isInside(screenPos, icon)) return { ...icon, type: 'transformIcon' };
        }
    }
    
    if (isDisplayPanelExpanded) {
        for (const icon of (canvasUI.displayIcons || [])) {
            if (isInside(screenPos, icon)) return { ...icon, type: 'displayIcon' };
        }
    }
    
    if (isVisibilityPanelExpanded) {
        for (const icon of (canvasUI.visibilityIcons || [])) {
            if (isInside(screenPos, icon)) return { ...icon, type: 'visibilityIcon' };
        }
    }

    if (isToolbarExpanded) {
        if (isInside(screenPos, canvasUI.colorToolButton)) return { ...canvasUI.colorToolButton, type: 'toolButton' };
        if (isInside(screenPos, canvasUI.transformToolButton)) return { ...canvasUI.transformToolButton, type: 'toolButton' };
        if (isInside(screenPos, canvasUI.displayToolButton)) return { ...canvasUI.displayToolButton, type: 'toolButton' };
        if (isInside(screenPos, canvasUI.visibilityToolButton)) return { ...canvasUI.visibilityToolButton, type: 'toolButton' };
        if (isInside(screenPos, canvasUI.themeToggleButton)) return { ...canvasUI.themeToggleButton, type: 'toolButton' };
    }

    if (isInside(screenPos, canvasUI.toolbarButton)) return { ...canvasUI.toolbarButton, type: 'menuButton' };

    return null;
}


export function normalize(v) {
    const mag = Math.hypot(v.x, v.y);
    if (mag === 0) return { x: 0, y: 0 };
    return { x: v.x / mag, y: v.y / mag };
}

export function getClosestPointOnLineSegment(p, a, b) {
    const abx = b.x - a.x;
    const aby = b.y - a.y;
    const acx = p.x - a.x;
    const acy = p.y - a.y;
    const lenSqAB = abx * abx + aby * aby;

    if (lenSqAB === 0) {
        return { x: a.x, y: a.y, distance: distance(p, a), onSegmentStrict: true, t: 0 };
    }
    let t = (acx * abx + acy * aby) / lenSqAB;
    const onSegmentStrict = t > C.ON_SEGMENT_STRICT_T_MIN && t < C.ON_SEGMENT_STRICT_T_MAX;
    const clampedT = Math.max(0, Math.min(1, t));
    const closestX = a.x + clampedT * abx;
    const closestY = a.y + clampedT * aby;
    const dist = distance(p, { x: closestX, y: closestY });
    return { x: closestX, y: closestY, distance: dist, onSegmentStrict: onSegmentStrict, t: clampedT };
}

export function getClosestPointOnLine(p, a, b) {
    const abx = b.x - a.x;
    const aby = b.y - a.y;
    const acx = p.x - a.x;
    const acy = p.y - a.y;
    const lenSqAB = abx * abx + aby * aby;

    if (lenSqAB === 0) {
        return { x: a.x, y: a.y, distance: distance(p, a) };
    }
    let t = (acx * abx + acy * aby) / lenSqAB;
    const closestX = a.x + t * abx;
    const closestY = a.y + t * aby;
    const dist = distance(p, { x: closestX, y: closestY });
    return { x: closestX, y: closestY, distance: dist };
}

export function findCircleFromPointsAndAngle(p1, p2, referenceAngle, referencePointForSide) {
    if (Math.abs(referenceAngle) < C.GEOMETRY_CALCULATION_EPSILON || Math.abs(referenceAngle - Math.PI) < C.GEOMETRY_CALCULATION_EPSILON) {
        return null;
    }

    const d = distance(p1, p2);
    const radius = Math.abs((d / 2) / Math.sin(referenceAngle));
    
    const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
    const h = Math.sqrt(Math.max(0, radius * radius - (d / 2) * (d / 2)));
    
    const perpVec = { x: -(p2.y - p1.y), y: p2.x - p1.x };
    const perpVecMag = Math.hypot(perpVec.x, perpVec.y);
    const perpVecNorm = { x: perpVec.x / perpVecMag, y: perpVec.y / perpVecMag };
    
    const center1 = { x: midPoint.x + h * perpVecNorm.x, y: midPoint.y + h * perpVecNorm.y };
    const center2 = { x: midPoint.x - h * perpVecNorm.x, y: midPoint.y - h * perpVecNorm.y };

    const crossProduct = (p2.x - p1.x) * (referencePointForSide.y - p1.y) - (p2.y - p1.y) * (referencePointForSide.x - p1.x);
    const crossProductCenter1 = (p2.x - p1.x) * (center1.y - p1.y) - (p2.y - p1.y) * (center1.x - p1.x);

    const center = (crossProduct * crossProductCenter1 > 0) ? center1 : center2;
    
    return { center, radius };
}

export function getMousePosOnCanvas(event, canvasElement) {
    const rect = canvasElement.getBoundingClientRect();
    return { x: event.clientX - rect.left, y: event.clientY - rect.top };
}


export function findFacesToSplit(vertexId1, vertexId2, allFaces, findVertexById) {
    const facesToSplit = [];
    
    allFaces.forEach(face => {
        if (!face.vertexIds || face.vertexIds.length < 3) return;
        
        const hasVertex1 = face.vertexIds.includes(vertexId1);
        const hasVertex2 = face.vertexIds.includes(vertexId2);
        
        
        if (hasVertex1 && hasVertex2) {
            const index1 = face.vertexIds.indexOf(vertexId1);
            const index2 = face.vertexIds.indexOf(vertexId2);
            const faceLength = face.vertexIds.length;
            
            const areAdjacent = 
                (index1 === (index2 + 1) % faceLength) || 
                (index2 === (index1 + 1) % faceLength);
            
            
            if (!areAdjacent) {
                facesToSplit.push(face);
            }
        }
    });
    
    return facesToSplit;
}

function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0;
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}

export function getCoordinateSystemSnapPosition(mouseDataPos, snapTargets, isShiftPressed, gridDisplayMode, lastGridState, lastAngularGridState) {
    if (!isShiftPressed) {
        return mouseDataPos;
    }
    
    let closestSnap = null;
    let minDistance = Infinity;
    
    if (snapTargets) {
        // Check vertex snaps
        snapTargets.vertices.forEach(vertex => {
            const dist = distance(mouseDataPos, vertex);
            if (dist < minDistance) {
                minDistance = dist;
                closestSnap = vertex;
            }
        });
        
        // Check edge midpoints
        snapTargets.edgeMidvertices.forEach(midpoint => {
            const dist = distance(mouseDataPos, midpoint);
            if (dist < minDistance) {
                minDistance = dist;
                closestSnap = midpoint;
            }
        });
        
        // Check other face centers
        snapTargets.faceCenters.forEach(center => {
            const dist = distance(mouseDataPos, center);
            if (dist < minDistance) {
                minDistance = dist;
                closestSnap = center;
            }
        });
    }
    
    // Check grid snaps
    if (gridDisplayMode && gridDisplayMode !== 'none' && lastGridState && lastGridState.interval1) {
        const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) 
            ? lastGridState.interval2 
            : lastGridState.interval1;
        
        const gridCandidates = getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true);
        gridCandidates.forEach(gridPoint => {
            const dist = distance(mouseDataPos, gridPoint);
            if (dist < minDistance) {
                minDistance = dist;
                closestSnap = gridPoint;
            }
        });
    }
    
    return closestSnap || mouseDataPos;
}

export function getAxisSnapAngle(mouseDataPos, origin, isShiftPressed, snapTargets, snapRadius = null) {
    const rawAngle = Math.atan2(mouseDataPos.y - origin.y, mouseDataPos.x - origin.x);
    
    if (!isShiftPressed || !snapTargets) {
        return { angle: rawAngle, edgeIndex: null, snapType: null, snapped: false, targetVertexId: null };
    }
    
    const snapThreshold = Math.PI / 24; // About 7.5 degrees
    let bestSnap = { angle: rawAngle, difference: Infinity, edgeIndex: null, snapType: null, targetVertexId: null };

    const priorities = {
        edge: 1,
        vertex_direction: 2,
        cardinal: 3
    };

    const checkSnap = (snapAngle, snapType, edgeIndex = null, targetVertexId = null) => {
        const normalizedSnap = normalizeAngleToPi(snapAngle);
        const diff = Math.abs(normalizeAngleToPi(rawAngle - normalizedSnap));

        if (diff < snapThreshold) {
            const newSnapPriority = priorities[snapType];
            const oldSnapPriority = bestSnap.snapType ? priorities[bestSnap.snapType] : Infinity;
            
            if (newSnapPriority < oldSnapPriority) {
                bestSnap = { angle: normalizedSnap, difference: diff, edgeIndex, snapType, targetVertexId };
            } else if (newSnapPriority === oldSnapPriority && diff < bestSnap.difference) {
                bestSnap = { angle: normalizedSnap, difference: diff, edgeIndex, snapType, targetVertexId };
            }
        }
    };

    // Check for snaps in order of priority (lower is better)
    
    // Priority 1: Edges
    if (snapTargets.edgeAngles) {
        snapTargets.edgeAngles.forEach((angle, edgeIndex) => {
            [angle, angle + Math.PI / 2, angle - Math.PI / 2, angle + Math.PI].forEach(checkAngle => {
                checkSnap(checkAngle, 'edge', edgeIndex);
            });
        });
    }

    // Priority 2: Vertices
    if (snapTargets.vertices) {
        snapTargets.vertices.forEach(vertex => {
            if (distance(origin, vertex) > C.GEOMETRY_CALCULATION_EPSILON) {
                const angleToVertex = Math.atan2(vertex.y - origin.y, vertex.x - origin.x);
                checkSnap(angleToVertex, 'vertex_direction', null, vertex.id);
            }
        });
    }

    // Priority 3: Cardinal Directions
    const cardinalAngles = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
    cardinalAngles.forEach(angle => checkSnap(angle, 'cardinal'));
    
    return {
        angle: bestSnap.angle,
        edgeIndex: bestSnap.edgeIndex,
        snapType: bestSnap.snapType,
        snapped: bestSnap.difference < Infinity,
        targetVertexId: bestSnap.targetVertexId
    };
}

export function getAxisScaleSnap(origin, axisAngle, snapTargets, face, findVertexById, currentScale = null, viewTransform = null, draggedAxisType = 'x_axis') {
    if (!currentScale || !viewTransform || !snapTargets.alignedEdgeInfo) {
        return { snapped: false };
    }
    
    const pixelSnapThreshold = 15 / viewTransform.scale;
    let snapCandidates = [];
    
    const { v1Id, v2Id } = snapTargets.alignedEdgeInfo;
    const v1 = findVertexById(v1Id);
    const v2 = findVertexById(v2Id);
    
    if (v1 && v2 && v1.type === 'regular' && v2.type === 'regular') {
        const edgeLength = distance(v1, v2);
        const fractions = [0.25, 1/3, 0.5, 2/3, 0.75, 1.0];
        
        fractions.forEach(frac => {
            const targetScale = edgeLength * frac;
            const scaleDifference = Math.abs(currentScale - targetScale);
            
            snapCandidates.push({
                scale: targetScale,
                distance: scaleDifference,
                type: 'edge_fraction',
                priority: frac === 0.5 ? 1 : (frac === 1.0 ? 2 : 3),
                fraction: frac
            });
        });
    }
    
    if (snapCandidates.length === 0) {
        return { snapped: false };
    }

    snapCandidates.sort((a, b) => {
        if (a.priority !== b.priority) return a.priority - b.priority;
        return a.distance - b.distance;
    });
    
    const closestSnap = snapCandidates.find(candidate => candidate.distance < pixelSnapThreshold);
    
    if (closestSnap) {
        return {
            snapped: true,
            scale: closestSnap.scale,
            snapType: 'edge_fraction',
            edgeFraction: closestSnap.fraction
        };
    }
    
    return { snapped: false };
}

export function getCoordinateSystemCenterSnap(mouseDataPos, snapTargets, gridDisplayMode, lastGridState, lastAngularGridState) {
    let bestSnap = null;
    let minDistance = Infinity;
    
    if (snapTargets) {
        // Check vertex snaps
        snapTargets.vertices.forEach(vertex => {
            const dist = distance(mouseDataPos, vertex);
            if (dist < minDistance) {
                minDistance = dist;
                bestSnap = {
                    snapped: true,
                    snapPoint: vertex,
                    snapType: 'vertex',
                    vertexId: vertex.id
                };
            }
        });
        
        // Check edge fractional snaps
        for (let edgeIndex = 0; edgeIndex < snapTargets.edgeMidvertices.length; edgeIndex++) {
            const v1Id = snapTargets.edgeVertexIds[edgeIndex * 2];
            const v2Id = snapTargets.edgeVertexIds[edgeIndex * 2 + 1];
            
            // Find vertices (assuming findVertexById is available in scope)
            const v1 = { id: v1Id, ...snapTargets.vertices.find(v => v.id === v1Id) };
            const v2 = { id: v2Id, ...snapTargets.vertices.find(v => v.id === v2Id) };
            
            if (v1 && v2) {
                const fractions = [0, 0.25, 1/3, 0.5, 2/3, 0.75, 1];
                
                fractions.forEach(frac => {
                    const fracPoint = {
                        x: v1.x + frac * (v2.x - v1.x),
                        y: v1.y + frac * (v2.y - v1.y)
                    };
                    
                    const dist = distance(mouseDataPos, fracPoint);
                    if (dist < minDistance) {
                        minDistance = dist;
                        bestSnap = {
                            snapped: true,
                            snapPoint: fracPoint,
                            snapType: 'edge',
                            edgeInfo: {
                                v1: v1Id,
                                v2: v2Id,
                                t: frac,
                                originalAngle: snapTargets.edgeAngles[edgeIndex],
                                edgeIndex: edgeIndex
                            }
                        };
                    }
                });
            }
        }
    }
    
    // Check grid snaps
    if (gridDisplayMode && gridDisplayMode !== 'none' && lastGridState && lastGridState.interval1) {
        const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) 
            ? lastGridState.interval2 
            : lastGridState.interval1;
        
        const gridCandidates = getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true);
        gridCandidates.forEach(gridPoint => {
            const dist = distance(mouseDataPos, gridPoint);
            if (dist < minDistance) {
                minDistance = dist;
                bestSnap = {
                    snapped: true,
                    snapPoint: gridPoint,
                    snapType: 'grid'
                };
            }
        });
    }
    
    return bestSnap || { snapped: false };
}

export function invertGrayscaleValue(value) {
    if (Array.isArray(value)) {
        const [h, s, l] = rgbToHsl(value[0], value[1], value[2]);
        const invertedL = 1 - l;
        const [newR, newG, newB] = hslToRgb(h, s, invertedL);
        return [newR, newG, newB];
    }
    
    if (typeof value === 'string') {
        if (value.startsWith('rgba(')) {
            const match = value.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
            if (match) {
                const [, r, g, b, a] = match;
                const rVal = parseInt(r), gVal = parseInt(g), bVal = parseInt(b);
                const [h, s, l] = rgbToHsl(rVal, gVal, bVal);
                const invertedL = 1 - l;
                const [newR, newG, newB] = hslToRgb(h, s, invertedL);
                return `rgba(${newR}, ${newG}, ${newB}, ${a})`;
            }
        }
        
        if (value.startsWith('#')) {
            if (value.length === 7) {
                const r = parseInt(value.slice(1, 3), 16);
                const g = parseInt(value.slice(3, 5), 16);
                const b = parseInt(value.slice(5, 7), 16);
                const [h, s, l] = rgbToHsl(r, g, b);
                const invertedL = 1 - l;
                const [newR, newG, newB] = hslToRgb(h, s, invertedL);
                return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
            }
        }
        
        if (value === 'white') return 'black';
        if (value === 'black') return 'white';
    }
    
    return value;
}

export function shoelaceArea(vertices) {
    let area = 0.0;
    const n = vertices.length;
    for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        area += vertices[i].x * vertices[j].y;
        area -= vertices[j].x * vertices[i].y;
    }
    return area / 2.0;
}

export function clamp(v, minv, maxv) {
    return Math.max(minv, Math.min(maxv, v));
}

export function computeAngle(prev, curr, next) {
    const u = { x: prev.x - curr.x, y: prev.y - curr.y };
    const v = { x: next.x - curr.x, y: next.y - curr.y };
    const dot = u.x * v.x + u.y * v.y;
    const mag_u = Math.hypot(u.x, u.y);
    const mag_v = Math.hypot(v.x, v.y);
    if (mag_u === 0 || mag_v === 0) return Math.PI;
    const cos_theta = dot / (mag_u * mag_v);
    return Math.acos(clamp(cos_theta, -1, 1));
}


export function triangulatePolygon(vertices) {
    let n = vertices.length;
    if (n < 3) return [];
    
    let area = shoelaceArea(vertices);
    let windingSign = area > 0 ? 1 : (area < 0 ? -1 : 1);
    
    const triangles = [];
    const indices = Array.from({length: n}, (_, i) => i);
    
    function isEar(i, verts, indices, windingSign) {
        const prevIdx = (i - 1 + indices.length) % indices.length;
        const currIdx = i;
        const nextIdx = (i + 1) % indices.length;
        
        const prev = verts[indices[prevIdx]];
        const curr = verts[indices[currIdx]];
        const next = verts[indices[nextIdx]];
        
        const dx1 = curr.x - prev.x;
        const dy1 = curr.y - prev.y;
        const dx2 = next.x - curr.x;
        const dy2 = next.y - curr.y;
        const cross = dx1 * dy2 - dy1 * dx2;
        if (cross * windingSign <= 0) return false;
        
        const tri = [prev, curr, next];
        for (let j = 0; j < indices.length; j++) {
            const idx = indices[j];
            if (idx === indices[prevIdx] || idx === indices[currIdx] || idx === indices[nextIdx]) continue;
            if (vertexInTriangle(verts[idx], tri)) return false;
        }
        return true;
    }
    
    function vertexInTriangle(pt, tri) {
        const [p1, p2, p3] = tri;
        const denom = (p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y);
        if (Math.abs(denom) < 1e-10) return false;
        
        const a = ((p2.y - p3.y) * (pt.x - p3.x) + (p3.x - p2.x) * (pt.y - p3.y)) / denom;
        const b = ((p3.y - p1.y) * (pt.x - p3.x) + (p1.x - p3.x) * (pt.y - p3.y)) / denom;
        const c = 1 - a - b;
        
        return a >= 0 && a <= 1 && b >= 0 && b <= 1 && c >= 0 && c <= 1;
    }
    
    while (indices.length > 3) {
        const ears = [];
        for (let i = 0; i < indices.length; i++) {
            if (isEar(i, vertices, indices, windingSign)) {
                const prevIdx = (i - 1 + indices.length) % indices.length;
                const currIdx = i;
                const nextIdx = (i + 1) % indices.length;
                const angle = computeAngle(vertices[indices[prevIdx]], vertices[indices[currIdx]], vertices[indices[nextIdx]]);
                ears.push({ index: i, angle });
            }
        }
        
        if (ears.length === 0) break;
        
        ears.sort((a, b) => a.angle - b.angle);
        
        const earToClip = ears[0];
        const i = earToClip.index;
        
        const prev = indices[(i - 1 + indices.length) % indices.length];
        const curr = indices[i];
        const next = indices[(i + 1) % indices.length];
        
        triangles.push([prev, curr, next]);
        indices.splice(i, 1);
    }
    
    if (indices.length === 3) {
        triangles.push([indices[0], indices[1], indices[2]]);
    }
    
    return triangles;
}

export function getCurrentTheme(activeThemeName, baseTheme) {
    if (activeThemeName === 'dark') {
        return baseTheme;
    } else {
        const lightTheme = {};
        for (const [key, value] of Object.entries(baseTheme)) {
            if (key === 'frozenReference' || key === 'feedbackSnapped' || key === 'geometryInfoTextSnapped') {
                lightTheme[key] = 'rgba(217, 119, 6, 0.95)';
            } else {
                lightTheme[key] = invertGrayscaleValue(value);
            }
        }
        return lightTheme;
    }
}

export function hslToRgb(h, s, l) {
    let r, g, b;

    if (s === 0) {
        r = g = b = l;
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (6 * (2 / 3 - t));
            return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

export function formatSnapFactor(factor, symbol) {
    const fractionStr = formatFraction(factor, 0.001);
    const newSymbol = symbol === 'A' ? '\\theta' : (symbol === 'D' ? '\\delta' : symbol);
    
    if (fractionStr === "0") return `0${newSymbol}`;
    if (fractionStr === "1") return newSymbol;
    if (fractionStr === "-1") return `-${newSymbol}`;

    if (fractionStr.endsWith("/1")) {
        return `${fractionStr.slice(0, -2)}${newSymbol}`;
    }

    if (fractionStr.includes('/')) {
        let sign = '';
        let workStr = fractionStr;
        if (workStr.startsWith('-')) {
            sign = '-';
            workStr = workStr.substring(1);
        }

        const parts = workStr.split('/');
        const num = parts[0];
        const den = parts[1];
        
        if (num === "1") return `${sign}\\frac{1}{${den}}${newSymbol}`;
        return `${sign}\\frac{${num}}{${den}}${newSymbol}`;
    }
    return `${fractionStr}${newSymbol}`;
}

export function applyTransformToVertex(vertex, center, rotation, scale, directionalScale, startVector) {
    const pointVector = { x: vertex.x - center.x, y: vertex.y - center.y };

    if (directionalScale) {
        const startDist = Math.hypot(startVector.x, startVector.y);
        if (startDist > C.GEOMETRY_CALCULATION_EPSILON) {
            const startNormalized = { x: startVector.x / startDist, y: startVector.y / startDist };

            const parallelComponent = (pointVector.x * startNormalized.x + pointVector.y * startNormalized.y);
            const perpVector = {
                x: pointVector.x - parallelComponent * startNormalized.x,
                y: pointVector.y - parallelComponent * startNormalized.y
            };

            const scaledParallelComponent = parallelComponent * scale;

            const newVector = {
                x: scaledParallelComponent * startNormalized.x + perpVector.x,
                y: scaledParallelComponent * startNormalized.y + perpVector.y
            };

            return { x: center.x + newVector.x, y: center.y + newVector.y };
        }
        return { x: vertex.x, y: vertex.y };
    } else {
        let transformedVector = { ...pointVector };

        transformedVector.x *= scale;
        transformedVector.y *= scale;

        const x = transformedVector.x;
        const y = transformedVector.y;
        transformedVector.x = x * Math.cos(rotation) - y * Math.sin(rotation);
        transformedVector.y = x * Math.sin(rotation) + y * Math.cos(rotation);

        return { x: center.x + transformedVector.x, y: center.y + transformedVector.y };
    }
}

export function calculateIncenter(vertices) {
    if (vertices.length < 3) return null;

    if (vertices.length === 3) {
        const [a, b, c] = vertices;
        const sideA = distance(b, c);
        const sideB = distance(a, c);
        const sideC = distance(a, b);
        const perimeter = sideA + sideB + sideC;
        if (perimeter < C.GEOMETRY_CALCULATION_EPSILON) return null;
        const incenterX = (sideA * a.x + sideB * b.x + sideC * c.x) / perimeter;
        const incenterY = (sideA * a.y + sideB * b.y + sideC * c.y) / perimeter;
        const area = Math.abs((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y)) / 2;
        const inradius = (2 * area) / perimeter;
        return {
            center: { x: incenterX, y: incenterY },
            radius: inradius
        };
    }

    return findLargestInscribedCircle(vertices);
}

export function findLargestInscribedCircle(vertices) {
    if (vertices.length < 3) return null;

    let centroid = {
        x: vertices.reduce((sum, v) => sum + v.x, 0) / vertices.length,
        y: vertices.reduce((sum, v) => sum + v.y, 0) / vertices.length
    };

    if (!isVertexInPolygon(centroid, vertices)) {
        centroid.x = (vertices[0].x + vertices[1].x + vertices[2].x) / 3;
        centroid.y = (vertices[0].y + vertices[1].y + vertices[2].y) / 3;
    }

    let bestCenter = centroid;
    let bestRadius = distanceToPolygonEdges(centroid, vertices);

    for (let iter = 0; iter < C.INSCRIBED_CIRCLE_ITERATIONS; iter++) {
        let improved = false;
        const stepSize = bestRadius * C.INSCRIBED_CIRCLE_STEP_FACTOR;

        const directions = [
            { x: stepSize, y: 0 }, { x: -stepSize, y: 0 },
            { x: 0, y: stepSize }, { x: 0, y: -stepSize },
            { x: stepSize * Math.SQRT1_2, y: stepSize * Math.SQRT1_2 },
            { x: -stepSize * Math.SQRT1_2, y: stepSize * Math.SQRT1_2 },
            { x: stepSize * Math.SQRT1_2, y: -stepSize * Math.SQRT1_2 },
            { x: -stepSize * Math.SQRT1_2, y: -stepSize * Math.SQRT1_2 }
        ];

        for (const dir of directions) {
            const testPoint = {
                x: bestCenter.x + dir.x,
                y: bestCenter.y + dir.y
            };

            if (isVertexInPolygon(testPoint, vertices)) {
                const testRadius = distanceToPolygonEdges(testPoint, vertices);
                if (testRadius > bestRadius) {
                    bestCenter = testPoint;
                    bestRadius = testRadius;
                    improved = true;
                }
            }
        }

        if (!improved) break;
    }

    return {
        center: bestCenter,
        radius: Math.max(bestRadius, C.GEOMETRY_CALCULATION_EPSILON)
    };
}

export function distanceToPolygonEdges(point, vertices) {
    let minDistance = Infinity;
    for (let i = 0; i < vertices.length; i++) {
        const v1 = vertices[i];
        const v2 = vertices[(i + 1) % vertices.length];
        const edgeDistance = distancePointToLineSegment(point, v1, v2);
        minDistance = Math.min(minDistance, edgeDistance);
    }
    return minDistance;
}

export function distancePointToLineSegment(point, lineStart, lineEnd) {
    return getClosestPointOnLineSegment(point, lineStart, lineEnd).distance;
}


export function updateFaceLocalCoordinateSystems(allFaces, findPointById) {
    allFaces.forEach(face => {
        if (!face.localCoordSystem) {
            face.localCoordSystem = createFaceLocalCoordinateSystem(face, findPointById);
        } else if (!face.localCoordSystem.isCustom) {
            // Recalculate if not manually positioned
            const newSystem = createFaceLocalCoordinateSystem(face, findPointById);
            if (newSystem) {
                face.localCoordSystem.origin = newSystem.origin;
                face.localCoordSystem.scale = newSystem.scale;
            }
        }
    });
}

function walkMinimalFaceDirected(startVertex, secondVertex, adjacencyMap) {
    const facePath = [startVertex];
    let prevNode = startVertex;
    let currentNode = secondVertex;
    
    const maxSteps = adjacencyMap.size + 2;
    for (let stepCount = 0; stepCount < maxSteps; stepCount++) {
        facePath.push(currentNode);

        if (currentNode === startVertex) {
            facePath.pop();
            return facePath;
        }

        const neighbors = adjacencyMap.get(currentNode);
        if (!neighbors || neighbors.length < 1) return null; 

        const prevNodeIndex = neighbors.indexOf(prevNode);
        if (prevNodeIndex === -1) return null;

        const nextNodeIndex = (prevNodeIndex + 1) % neighbors.length;
        const nextNode = neighbors[nextNodeIndex];
        
        prevNode = currentNode;
        currentNode = nextNode;
    }
    return null;
}

function findAllTriangularFaces(adjacencyMap, vertices) {
    const triangularFaces = [];
    const processedTriangles = new Set();
    
    for (const [v1, neighbors1] of adjacencyMap.entries()) {
        for (let i = 0; i < neighbors1.length; i++) {
            const v2 = neighbors1[i];
            const neighbors2 = adjacencyMap.get(v2) || [];
            
            for (let j = 0; j < neighbors2.length; j++) {
                const v3 = neighbors2[j];
                if (v3 === v1) continue;
                
                const neighbors3 = adjacencyMap.get(v3) || [];
                
                if (neighbors3.includes(v1)) {
                    if (v1 !== v2 && v2 !== v3 && v3 !== v1) {
                        const triangle = [v1, v2, v3];
                        const triangleKey = triangle.slice().sort().join('_');
                        
                        if (!processedTriangles.has(triangleKey)) {
                            processedTriangles.add(triangleKey);
                            triangularFaces.push(triangle);
                        }
                    }
                }
            }
        }
    }
    
    return triangularFaces;
}

function filterCompositeFaces(allFaces, allEdges, findPointById) {
    if (allFaces.length <= 1) return allFaces;

    const allVertexIdsInComponent = new Set();
    const edgeSet = new Set();
    
    allEdges.forEach(edge => {
        allVertexIdsInComponent.add(edge.id1);
        allVertexIdsInComponent.add(edge.id2);
        const edgeKey = [edge.id1, edge.id2].sort().join('_');
        edgeSet.add(edgeKey);
    });

    return allFaces.filter(face => {
        const faceVertexSet = new Set(face.vertexIds);

        for (const vertexId of allVertexIdsInComponent) {
            if (!faceVertexSet.has(vertexId)) {
                const vertex = findPointById(vertexId);
                const faceVertices = face.vertexIds.map(id => findPointById(id));
                
                if (vertex && faceVertices.every(v => v) && isVertexInPolygon(vertex, faceVertices)) {
                    return false;
                }
            }
        }

        const faceBoundaryEdges = new Set();
        for (let i = 0; i < face.vertexIds.length; i++) {
            const v1 = face.vertexIds[i];
            const v2 = face.vertexIds[(i + 1) % face.vertexIds.length];
            const edgeKey = [v1, v2].sort().join('_');
            faceBoundaryEdges.add(edgeKey);
        }

        for (let i = 0; i < face.vertexIds.length; i++) {
            for (let j = i + 2; j < face.vertexIds.length; j++) {
                if (j === face.vertexIds.length - 1 && i === 0) continue;
                
                const v1 = face.vertexIds[i];
                const v2 = face.vertexIds[j];
                const edgeKey = [v1, v2].sort().join('_');
                
                if (edgeSet.has(edgeKey)) {
                    return false;
                }
            }
        }

        return true;
    });
}

function isSelfIntersectingImproved(vertices) {
    const n = vertices.length;
    if (n <= 3) return false;
    
    for (let i = 0; i < n; i++) {
        const p1 = vertices[i];
        const p2 = vertices[(i + 1) % n];
        
        for (let j = i + 2; j < n; j++) {
            if (j === (i + n - 1) % n || (j + 1) % n === i) continue;
            
            const q1 = vertices[j];
            const q2 = vertices[(j + 1) % n];
            
            if (linesIntersectProper(p1, p2, q1, q2)) {
                return true;
            }
        }
    }
    return false;
}

function linesIntersectProper(a, b, c, d) {
    function ccw(A, B, C) {
        return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
    }
    
    const intersect = ccw(a, c, d) !== ccw(b, c, d) && ccw(a, b, c) !== ccw(a, b, d);
    
    if (!intersect) return false;
    
    const samePoint = (p1, p2) => Math.abs(p1.x - p2.x) < 1e-10 && Math.abs(p1.y - p2.y) < 1e-10;
    
    return !(samePoint(a, c) || samePoint(a, d) || samePoint(b, c) || samePoint(b, d));
}

export function detectClosedPolygons(allEdges, findPointById) {
    const adjacencyMap = new Map();
    const vertices = new Map();

    allEdges.forEach(edge => {
        const p1 = findPointById(edge.id1);
        const p2 = findPointById(edge.id2);
        if (!p1 || !p2 || p1.type !== 'regular' || p2.type !== 'regular') return;
        if (!vertices.has(p1.id)) vertices.set(p1.id, p1);
        if (!vertices.has(p2.id)) vertices.set(p2.id, p2);
        if (!adjacencyMap.has(edge.id1)) adjacencyMap.set(edge.id1, []);
        if (!adjacencyMap.has(edge.id2)) adjacencyMap.set(edge.id2, []);
        adjacencyMap.get(edge.id1).push(edge.id2);
        adjacencyMap.get(edge.id2).push(edge.id1);
    });

    for (const [vertexId, neighbors] of adjacencyMap.entries()) {
        const centerPoint = vertices.get(vertexId);
        if (!centerPoint) continue;
        neighbors.sort((a, b) => {
            const pA = vertices.get(a);
            const pB = vertices.get(b);
            if (!pA || !pB) return 0;
            const angleA = Math.atan2(pA.y - centerPoint.y, pA.x - centerPoint.x);
            const angleB = Math.atan2(pB.y - centerPoint.y, pB.x - centerPoint.x);
            return angleA - angleB;
        });
    }

    const allPossibleFaces = [];
    const processedDirectedEdges = new Set();
    
    for (const [startVertex, neighbors] of adjacencyMap.entries()) {
        for (const nextVertex of neighbors) {
            const directedEdgeKey = `${startVertex}->${nextVertex}`;
            if (processedDirectedEdges.has(directedEdgeKey)) continue;

            const facePath = walkMinimalFaceDirected(startVertex, nextVertex, adjacencyMap);
            
            if (facePath && facePath.length >= 3) {
                const uniqueVertices = new Set(facePath);
                if (uniqueVertices.size === facePath.length) {
                    for (let i = 0; i < facePath.length; i++) {
                        const v1 = facePath[i];
                        const v2 = facePath[(i + 1) % facePath.length];
                        processedDirectedEdges.add(`${v1}->${v2}`);
                    }
                    
                    const newFace = { vertexIds: facePath };
                    newFace.id = getFaceId(newFace);
                    allPossibleFaces.push(newFace);
                }
            }
        }
    }

    const principleFaces = filterCompositeFaces(allPossibleFaces, allEdges, findPointById);

    const uniqueFaces = [];
    const seenFaceVertexSets = new Set();
    
    principleFaces.forEach(face => {
        const sortedVertexIds = [...face.vertexIds].sort().join('_');
        if (!seenFaceVertexSets.has(sortedVertexIds)) {
            uniqueFaces.push(face);
            seenFaceVertexSets.add(sortedVertexIds);
        }
    });

    return uniqueFaces;
}

export function createEdge(v1, v2, gridInterval, getColorForTarget) {
    const newEdge = { id1: v1.id, id2: v2.id };

    const deltaX = v1.x - v2.x;
    const deltaY = v1.y - v2.y;
    const dx_grid_float = deltaX / gridInterval;
    const dy_grid_float = deltaY / gridInterval;
    const epsilon = 1e-5;

    const isGridVector = gridInterval &&
        Math.abs(dx_grid_float - Math.round(dx_grid_float)) < epsilon &&
        Math.abs(dy_grid_float - Math.round(dy_grid_float)) < epsilon;

    if (isGridVector) {
        newEdge.labelMode = 'exact';
        const dx_grid = Math.round(dx_grid_float);
        const dy_grid = Math.round(dy_grid_float);
        newEdge.exactValue = {
            g2gSquaredSum: dx_grid * dx_grid + dy_grid * dy_grid,
            gridInterval: gridInterval
        };
    } else {
        newEdge.labelMode = 'decimal';
    }
    
    newEdge.color = getColorForTarget(C.COLOR_TARGET_EDGE);
    return newEdge;
}

export function detectFacesFromNewEdge(newEdge, allEdges, findPointById, deletedFaceIds = new Set()) {
    // Get all possible faces with the current edge set
    const allPossibleFaces = detectClosedPolygons(allEdges, findPointById);
    
    // Create a set of edges before adding the new edge
    const edgesWithoutNew = allEdges.filter(e => 
        !(e.id1 === newEdge.id1 && e.id2 === newEdge.id2) && 
        !(e.id1 === newEdge.id2 && e.id2 === newEdge.id1)
    );
    
    // Get faces that existed before
    const facesBefore = detectClosedPolygons(edgesWithoutNew, findPointById);
    const faceIdsBefore = new Set(facesBefore.map(f => `face_${[...f.vertexIds].sort().join('_')}`));
    
    // Return only the new faces that weren't there before and aren't blacklisted
    const newFaces = allPossibleFaces.filter(face => {
        if (!face.vertexIds || face.vertexIds.length < 3) return false;
        
        const faceId = `face_${[...face.vertexIds].sort().join('_')}`;
        
        // Skip if blacklisted or existed before
        if (deletedFaceIds.has(faceId) || faceIdsBefore.has(faceId)) return false;
        
        return true;
    });
    
    return newFaces.map(face => ({
        ...face,
        id: `face_${[...face.vertexIds].sort().join('_')}`
    }));
}

export function findClosestUIElement(pos, elements) {
    let closest = null;
    let minDist = Infinity;
    elements.forEach(el => {
        if (!el) return;
        const dist = Math.abs(pos.x - (el.x + el.width / 2));
        if (dist < minDist && dist < (el.width / 2 + C.UI_BUTTON_PADDING)) {
            minDist = dist;
            closest = el;
        }
    });
    return closest;
}


export function convertColorToColormapFormat(colormapData) {
    // Handle colormap selector format (uses 'points' instead of 'vertices')
    if (colormapData && colormapData.points) {
        const processedVertices = colormapData.points.map(p => ({
            pos: p.pos,
            color: Array.isArray(p.color) ? p.color : [p.color.r || 0, p.color.g || 0, p.color.b || 0],
            alpha: p.alpha !== undefined ? p.alpha : 1.0
        }));
        
        if (processedVertices.length === 1) {
            const singlePoint = processedVertices[0];
            const colorValue = (singlePoint.alpha !== undefined && singlePoint.alpha < 1)
                ? `rgba(${singlePoint.color.join(',')},${singlePoint.alpha})`
                : `rgb(${singlePoint.color.join(',')})`;
            return { type: 'color', value: colorValue };
        }
        
        return {
            type: 'colormap',
            vertices: processedVertices,
            isCyclic: colormapData.isCyclic === true
        };
    }
    
    if (colormapData && colormapData.vertices && colormapData.vertices.length === 1) {
        const singlePoint = colormapData.vertices[0];
        const colorValue = (singlePoint.alpha !== undefined && singlePoint.alpha < 1)
            ? `rgba(${singlePoint.color.join(',')},${singlePoint.alpha})`
            : `rgb(${singlePoint.color.join(',')})`;
        return { type: 'color', value: colorValue };
    } else if (colormapData && colormapData.vertices) {
        const processedVertices = colormapData.vertices.map(p => ({
            ...p,
            alpha: p.alpha !== undefined ? p.alpha : 1.0
        }));
        return {
            type: 'colormap',
            vertices: processedVertices,
            isCyclic: colormapData.isCyclic === true
        };
    }
    return colormapData;
}

export function sampleColormap(colormapItem, t) {
    if (!colormapItem || colormapItem.type !== 'colormap' || !colormapItem.vertices) {
        return '#ffffff';
    }

    const vertices = colormapItem.vertices;
    if (vertices.length === 0) return '#ffffff';
    if (vertices.length === 1) {
        const p = vertices[0];
        const alpha = p.alpha !== undefined ? p.alpha : 1.0;
        return `rgba(${p.color.join(',')},${alpha})`;
    }

    // Clamp t to [0, 1]
    t = Math.max(0, Math.min(1, t));

    // Find the two vertices to interpolate between
    let leftPoint = vertices[0];
    let rightPoint = vertices[vertices.length - 1];

    for (let i = 0; i < vertices.length - 1; i++) {
        if (t >= vertices[i].pos && t <= vertices[i + 1].pos) {
            leftPoint = vertices[i];
            rightPoint = vertices[i + 1];
            break;
        }
    }

    // Interpolate between the two vertices
    const range = rightPoint.pos - leftPoint.pos;
    const localT = range > 0 ? (t - leftPoint.pos) / range : 0;

    const r = Math.round(leftPoint.color[0] + (rightPoint.color[0] - leftPoint.color[0]) * localT);
    const g = Math.round(leftPoint.color[1] + (rightPoint.color[1] - leftPoint.color[1]) * localT);
    const b = Math.round(leftPoint.color[2] + (rightPoint.color[2] - leftPoint.color[2]) * localT);

    const leftAlpha = leftPoint.alpha !== undefined ? leftPoint.alpha : 1.0;
    const rightAlpha = rightPoint.alpha !== undefined ? rightPoint.alpha : 1.0;
    const alpha = leftAlpha + (rightAlpha - leftAlpha) * localT;

    return `rgba(${r},${g},${b},${alpha})`;
}


export function createFaceLocalCoordinateSystem(face, findPointById) {
    const vertices = face.vertexIds
        .map(id => findPointById(id))
        .filter(p => p && p.type === 'regular');
    
    if (vertices.length < 3) return null;
    
    const incircle = calculateIncenter(vertices);
    if (!incircle) return null;
    
    return {
        origin: { ...incircle.center },
        angle: 0,
        scale: incircle.radius,
        isCustom: false,
        showCoordSystem: false
    };
}
export function globalToLocal(globalPoint, coordSystem) {
    if (!coordSystem) return globalPoint;
    const translated = {
        x: globalPoint.x - coordSystem.origin.x,
        y: globalPoint.y - coordSystem.origin.y
    };
    const cos = Math.cos(-coordSystem.angle);
    const sin = Math.sin(-coordSystem.angle);
    const rotated = {
        x: translated.x * cos - translated.y * sin,
        y: translated.x * sin + translated.y * cos
    };
    if (coordSystem.scale === 0) return { x: 0, y: 0 };
    return {
        x: rotated.x / coordSystem.scale,
        y: rotated.y / coordSystem.scale
    };
}

export function findNeighbors(vertexId, allEdges) {
    const neighbors = new Set();
    allEdges.forEach(edge => {
        if (edge.id1 === vertexId) {
            neighbors.add(edge.id2);
        } else if (edge.id2 === vertexId) {
            neighbors.add(edge.id1);
        }
    });
    return Array.from(neighbors);
}

export function localToGlobal(localPoint, coordSystem) {
    if (!coordSystem) return localPoint;

    const scaled = {
        x: localPoint.x * coordSystem.scale,
        y: localPoint.y * coordSystem.scale
    };

    const cos = Math.cos(coordSystem.angle);
    const sin = Math.sin(coordSystem.angle);
    const rotated = {
        x: scaled.x * cos - scaled.y * sin,
        y: scaled.x * sin + scaled.y * cos
    };
    return {
        x: rotated.x + coordSystem.origin.x,
        y: rotated.y + coordSystem.origin.y
    };
}

export function getPerpendicularBisector(p1, p2) {
    const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
    const perpVector = { x: -(p2.y - p1.y), y: p2.x - p1.x };
    return {
        p1: midPoint,
        p2: {
            x: midPoint.x + perpVector.x,
            y: midPoint.y + perpVector.y
        }
    };
}



export function getCircleCircleIntersection(c1, c2) {
    const d = distance(c1.center, c2.center);

    if (d > c1.radius + c2.radius || d < Math.abs(c1.radius - c2.radius) || d === 0) {
        return [];
    }

    const a = (c1.radius * c1.radius - c2.radius * c2.radius + d * d) / (2 * d);
    const h = Math.sqrt(Math.max(0, c1.radius * c1.radius - a * a));
    const p2x = c1.center.x + a * (c2.center.x - c1.center.x) / d;
    const p2y = c1.center.y + a * (c2.center.y - c1.center.y) / d;

    const p3x_offset = h * (c2.center.y - c1.center.y) / d;
    const p3y_offset = h * (c2.center.x - c1.center.x) / d;

    const pA = { x: p2x + p3x_offset, y: p2y - p3y_offset };
    const pB = { x: p2x - p3x_offset, y: p2y + p3y_offset };

    if (h === 0) return [pA];
    return [pA, pB];
}





=== vite.config.js ===
import { defineConfig } from 'vite';
import { resolve } from 'path';

export default defineConfig({
  base: '/', // This is correct for custom domain
  resolve: {
    alias: {
      'colormap-selector': resolve(process.cwd(), 'node_modules/colormap-selector')
    }
  }
});


=== LLM Instructions ===
Now please just read the project and the rules for writing code and just wait for instructions.

Here are the rules:
1. DONT write comments, placeholders or docstrings if not explicitely told.
2. Write functions with the correct initial indentation so that if the function is indented so is your code that you write.
3. DO NOT USE NON-TERMINATED SPACES: " ". MAKE SURE TO FOLLOW THIS!
4. For changes that require multiple replacements please tell me what to replace with what instead of rewriting large portions of text. You can use vscode valid regexp for instance.
5. For small functions less than 100 lines of code please rewrite the full function. For larger functions please only write complete control statements if/while/case.
6. Never omit/change working logic if not explicitely statet that it should be removed/change
7. DONT use the CANVAS TOOL where code is written in artifacts.
8. Write only functions that are new seperately from functions that needs updates.
9. Make sure to write what has been change where to place/what to replace for each code snippet.
