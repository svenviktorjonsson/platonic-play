=== Project Directory Structure ===
Root: C:\Users\viktor.jonsson\OneDrive - CellMax Technologies AB\Documents\Repositories\svenviktorjonsson\platonic-play
Relevant files and folders (excluding specified patterns):

.
├── constants.js
├── index.html
├── package.json
├── readme.md
├── renderer.js
├── script.js
├── style.css
├── utils.js


=== File Contents ===

=== constants.js ===
// constants.js

export const BASE_THEME = {
    background: '#1a1a1a',
    htmlBody: '#1e1e1e',
    grid: [136, 136, 136],
    axis: 'rgba(255, 255, 255, 1)',
    axisTickLabel: [255, 255, 255],
    defaultStroke: 'white',
    vertex: '#ffffff',
    edge: '#BFC5D0',
    face: '#808080',
    frozenReference: 'rgba(240, 240, 130, 0.95)',
    feedbackDefault: [230, 230, 230],
    feedbackSnapped: 'rgba(240, 240, 130, 0.95)',
    geometryInfoText: 'rgba(255, 255, 255, 0.95)',
    geometryInfoTextSnapped: 'rgba(240, 240, 130, 0.95)',
    mouseCoords: 'rgba(255, 255, 255, 0.7)',
    uiIcon: 'white',
    uiIconDefault: '#9CA3AF',
    uiIconSelected: '#F9FAFB',
    uiTextSelected: '#E0F2FE',
    uiTextDefault: '#D1D5DB',
    uiDefault: 'rgba(255, 255, 255, 0.8)',
    selectionGlow: '#4da6ff',
    activeCenterGlow: '#00ffff',
    helperLine: 'rgba(200, 200, 200, 0.6)'
};


export const INSCRIBED_CIRCLE_ITERATIONS = 20;
export const INSCRIBED_CIRCLE_STEP_FACTOR = 0.1;
// --- GEOMETRY & DRAWING ---
export const UI_FACE_ICON_FILL_COLOR = '#808080';
export const VERTEX_RADIUS = 5;
export const CENTER_POINT_VISUAL_RADIUS = VERTEX_RADIUS * 2;
export const VERTEX_SELECT_RADIUS = 10;
export const LINE_WIDTH = 2;
export const GRID_LINEWIDTH = 1;
export const DASH_PATTERN = [6, 6];
export const DASH_PATTERN_SMALL = [3, 3];
export const SELECTED_INDICATOR_OFFSET = 3;
export const DEGREES_IN_CIRCLE = 360;
export const DEGREES_IN_HALF_CIRCLE = 180;
export const DEGREES_IN_QUADRANT = 90;
export const RADIANS_IN_CIRCLE = 2 * Math.PI;
export const MIN_ALPHA_FOR_DRAWING = 0.01;
export const TRIANGULAR_GRID_Y_STEP_FACTOR = Math.sqrt(3) / 2;
export const POLAR_TO_LINE_TRANSITION_RADIUS_FACTOR = 400;
export const ORIGIN_TICK_ANGLE_RAD = Math.PI / 3;
export const AXIS_MAJOR_TICK_SCALE_FACTOR = 1.5;
export const AXIS_ARROW_ANGLE_RAD = Math.PI / 6;
export const MAJOR_TICK_LINE_WIDTH = 1.5;
export const HELPER_LINE_DASH_PATTERN = [2, 3];
export const REF_LINE_DASH_PATTERN = [1, 3];

// --- INTERACTION ---
export const EDGE_ID_DELIMITER = '_EDGE_';
export const DOUBLE_CLICK_MS = 300;
export const DRAG_THRESHOLD = 3;
export const EDGE_CLICK_THRESHOLD = 7;
export const MIN_SCALE_VALUE = 1e-20;
export const ZOOM_FACTOR = 1.15;
export const KEYBOARD_ZOOM_FACTOR = 1.15;
export const ANGLE_SNAP_THRESHOLD_RAD = Math.PI / 24;
export const ON_SEGMENT_STRICT_T_MIN = 1e-5;
export const ON_SEGMENT_STRICT_T_MAX = 1 - 1e-5;
export const MIN_TRANSFORM_ACTION_THRESHOLD = 0.001;
export const BISECTOR_LINE_EXTENSION_FACTOR = 100000;
export const GRID_SNAP_THRESHOLD_FACTOR = 0.8;

// --- AXES & TICKS ---
export const AXIS_LINE_WIDTH = 1.5;
export const AXIS_TICK_SIZE = 4;
export const AXIS_TICK_LABEL_ALPHA = 0.9;
export const AXIS_NAME_FONT_SIZE = 24;
export const AXIS_TICK_FONT_SIZE = 10;
export const AXIS_LABEL_OFFSET = 8;
export const AXIS_LABEL_PADDING = 20;
export const AXIS_ARROW_SIZE = 12;
export const INITIAL_POLAR_REL_RADIUS = 0.309;
export const X_AXIS_LABEL_DISTANCE = 5;
export const X_AXIS_LABEL_ARROW_DIST = 20;
export const Y_AXIS_LABEL_DISTANCE = 10;
export const Y_AXIS_LABEL_ARROW_DIST = 5;
export const POLAR_THETA_LABEL_DISTANCE = 20;
export const POLAR_THETA_LABEL_ARROW_DIST = 12;
export const ANGLE_PRECISION_FACTOR = 1e6;
export const BOUNDARY_ANGLE_PRECISION = 7;
export const LABEL_ID_PRECISION_FACTOR = 1e15;
export const ORIGIN_LABEL_TEXT = '\\phantom{-}0';
export const POLAR_AXIS_RADIUS_BUFFER_FACTOR = 1.1;
export const TICK_LABEL_SIGFIG_THRESH_1 = 80;
export const TICK_LABEL_SIGFIG_THRESH_2 = 40;
export const TICK_LABEL_SIGFIG_THRESH_3 = 20;
export const FINE_TICK_ANGLE_THRESHOLD_DEG = 5;
export const IMAGINARY_UNIT_SYMBOL = 'i';
export const POLAR_RADIUS_SYMBOL = 'r';
export const COMPLEX_REAL_LABEL = '\\mathrm{Re}';
export const COMPLEX_IMAGINARY_LABEL = '\\mathrm{Im}';

// --- DEFAULTS ---
export const DEFAULT_CALIBRATION_VIEW_SCALE = 80.0;
export const DEFAULT_REFERENCE_DISTANCE = 1.0;
export const DEFAULT_REFERENCE_ANGLE_RAD = Math.PI / 2;
export const DEFAULT_POLAR_ANGLE_DIFF = 30;

// --- UI & TOOLBAR ---
export const UI_BUTTON_PADDING = 10;
export const UI_TOOLBAR_WIDTH = 56;
export const UI_SWATCH_SIZE = 30;
export const UI_PADDING = 10;
export const MENU_BUTTON_WIDTH = 36;
export const MENU_BUTTON_HEIGHT = 30;
export const TOOL_BUTTON_HEIGHT = 40;
export const TOOLBAR_SECTION_GAP = 20;
export const UI_ICON_BASE_SIZE = 32;
export const UI_ICON_LINE_WIDTH = 2;
export const UI_ICON_LINE_WIDTH_SMALL = 1.5;
export const UI_ICON_DASH_PATTERN = [2, 4];
export const UI_ICON_VERTEX_RADIUS = 1.5;
export const UI_ICON_LABEL_FONT_SIZE = 10;
export const UI_MENU_ICON_LINE_WIDTH = 3;
export const TRANSFORM_ICON_SIZE = 30;
export const TRANSFORM_ICON_PADDING = 15;
export const TRANSFORM_ICON_Y_OFFSET = 5;
export const UI_TRANSFORM_TOOL_LABEL_FONT_SIZE = 24;
export const UI_TRANSFORM_TOOL_LABEL_TEXT = 'T';
export const UI_SYMMETRY_TOOL_LABEL_FONT_SIZE = 24;
export const UI_SYMMETRY_TOOL_LABEL_TEXT = 'S';
export const DISPLAY_ICON_SIZE = 40;
export const DISPLAY_ICON_PADDING = 15;
export const UI_DISPLAY_ICON_BAR_WIDTH_PADDING = 12;
export const UI_DISPLAY_ICON_Y_OFFSET = 10;
export const UI_DISPLAY_ICON_Y_SPACING = 10;
export const UI_DISPLAY_ICON_KNOB_RADIUS = 3;
export const UI_SWATCH_SELECTED_BORDER_WIDTH = 3;
export const UI_BUTTON_BORDER_WIDTH = 2;
export const UI_BUTTON_ICON_PADDING = 7;
export const UI_GHOST_ICON_SIZE = 30;
export const COLOR_PALETTE_Y_OFFSET = 5;
export const COLOR_WHEEL_FADE_START_RADIUS_FACTOR = 0.75;
export const DEFAULT_RECENT_COLORS = ['#ffffff', '#BFC5D0', '#808080', '#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff']

// --- FEEDBACK LABELS & TEXT ---
export const FEEDBACK_LABEL_FONT_SIZE = 12;
export const FEEDBACK_ARC_RADIUS_SCREEN = 30;
export const FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN = 18;
export const FEEDBACK_LINE_VISUAL_WIDTH = 1;
export const REF_TEXT_SCREEN_PIXEL_THRESHOLD = 1.5;
export const REF_TEXT_KATEX_FONT_SIZE = 11;
export const REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN = 18;
export const REF_TEXT_ANGLE_LABEL_OFFSET_SCREEN = 50;
export const ANGLE_LABEL_RADIUS_SCREEN = 75;
export const REF_CIRCLE_MIN_DISPLAY_RADIUS = 20;
export const REF_CIRCLE_MIN_TICK_SPACING = 8;
export const REF_CIRCLE_THETA_LABEL_OFFSET = 30;
export const REF_ARC_RADIUS_SCREEN = 35;
export const SNAP_ANGLE_LABEL_OFFSET = 60;
export const TRANSFORM_ANGLE_LABEL_OFFSET = 20;
export const TRANSFORM_SCALE_LABEL_OFFSET = 18;
export const SCIENTIFIC_NOTATION_UPPER_BOUND = 1000;
export const SCIENTIFIC_NOTATION_LOWER_BOUND = 0.001;
export const MAX_DECIMAL_PLACES_FORMAT = 10;
export const ZERO_TOLERANCE = 0.00001;
export const FRACTION_FORMAT_TOLERANCE = 0.015;
export const FRACTION_FORMAT_MAX_DENOMINATOR = 32;
export const FRACTION_FORMAT_MAX_DENOMINATOR_TRANSFORM = 10;
export const COORD_PRECISION_FACTOR = 0.999;
export const MAX_COORD_DECIMAL_PLACES = 6;
export const MAX_ANGLE_DECIMAL_PLACES = 4;
export const MOUSE_COORD_FONT_SIZE = 14;
export const KATEX_MINUS_PHANTOM = '\\hphantom{-}';
export const PI_SYMBOL_KATEX = '\\pi';
export const DELTA_SYMBOL_KATEX = '\\delta';
export const DELTA_EQUALS_KATEX = '\\delta = ';
export const THETA_EQUALS_KATEX = '\\theta = ';
export const SELECTION_GLOW_BLUR_RADIUS = 15;
export const SELECTION_GLOW_ALPHA = 0.8;
export const SELECTION_GLOW_RADIUS_OFFSET = 3;
export const SELECTION_GLOW_LINE_WIDTH = 2;
export const EDGE_SELECTION_GLOW_WIDTH_OFFSET = 4;
export const MAX_VERTICES_FOR_ANGLES = 1;
export const MAX_EDGES_FOR_LABELS = 3;

// --- GRID CALCULATIONS ---
export const GRID_TARGET_SPACING = 140;
export const GRID_ALPHA_TRANSITION_START = 0.4;
export const GRID_ALPHA_TRANSITION_END = 0.9;
export const GRID_ALPHA_CLAMP_THRESHOLD = 0.05;
export const GRID_POLAR_CIRCLE_MIN_SPACING = 10;
export const GRID_POLAR_SPOKE_MIN_SPACING = 10;
export const GRID_POLAR_SPOKE_MIN_RADIUS = 50;
export const GRID_POINT_RADIUS = 1.5;
export const ANGULAR_GRID_PREDEFINED_LEVELS = [15, 5, 1];
export const ANGULAR_GRID_TARGET_SPACING = 80;
export const ANGULAR_GRID_FADE_IN_THRESHOLD = 0.01;

// --- SNAPPING PARAMETERS ---
export const GEOMETRY_CALCULATION_EPSILON = 1e-9;
export const FLOATING_POINT_PRECISION_LIMIT = 1e-15;
export const VERTICAL_LINE_COS_THRESHOLD = 0.1;
export const SNAP_STICKINESS_RADIUS_SCREEN = 30;
export const LINE_TO_SNAP_RADIUS_SCREEN = 10;
export const VERTEX_ON_LINE_SNAP_RADIUS_SCREEN = 15;
export const DRAG_SNAP_GEOMETRIC_DISTANCE_FACTORS = [0.5, 1, 1.5, 2, 3, 4, 5];
export const DRAW_SNAP_CANDIDATE_COUNT_PER_SIDE = 2;
export const DRAW_SNAP_DISTANCE_FACTOR_STEP = 0.5;
export const DRAW_SNAP_DISTANCE_FACTOR_LIMIT = 50;
export const GHOST_SNAP_RADIUS_SCREEN = 30;
export const MAX_HISTORY_SIZE = 50;

// --- SNAP GENERATION PARAMETERS ---
export const MAX_FRACTION_DENOMINATOR_FOR_ANGLE_SNAPS = 6;
export const MAX_BASE_ANGLE_MULTIPLIER_FOR_SNAPS = 2;
export const MAX_INITIAL_METER_SNAP_MULTIPLIER = 10;
export const MAX_SNAP_DENOMINATOR = 6;
export const MAX_SNAP_INTEGER = 10;

export const MERGE_RADIUS_SCREEN = 5;

export const NINETY_DEG_ANGLE_SNAP_FRACTIONS = (() => {
    const uniqueFractions = new Set();
    const denominators = [1, 2, 3, 4, 5, 6];
    for (const q of denominators) {
        for (let p = 1; p <= q * 4; p++) {
            uniqueFractions.add(p / q);
        }
    }
    return Array.from(uniqueFractions).sort((a, b) => a - b);
})();


function generateSnapFactors(maxDenominator, maxInteger) {
    const fractionsSet = new Set();
    fractionsSet.add(0);
    for (let q = 1; q <= maxDenominator; q++) {
        for (let p = 1; p <= q * maxInteger; p++) {
            fractionsSet.add(p / q);
        }
    }
    return Array.from(fractionsSet).sort((a, b) => a - b);
}

export const SNAP_FACTORS = generateSnapFactors(MAX_SNAP_DENOMINATOR, MAX_SNAP_INTEGER);

// --- ENUMS & LITERALS ---
export const VERTEX_TYPE_REGULAR = 'regular';
export const TRANSFORMATION_TYPE_ROTATION = ' transformation_rotation';
export const TRANSFORMATION_TYPE_SCALE = ' transformation_scale';
export const TRANSFORMATION_TYPE_DIRECTIONAL_SCALE = 'transformation_directional_scale';
export const COORDS_DISPLAY_MODE_NONE = 'none';
export const COORDS_DISPLAY_MODE_REGULAR = 'regular';
export const COORDS_DISPLAY_MODE_COMPLEX = 'complex';
export const COORDS_DISPLAY_MODE_POLAR = 'polar';
export const GRID_DISPLAY_MODE_NONE = 'none';
export const GRID_DISPLAY_MODE_LINES = 'lines';
export const GRID_DISPLAY_MODE_POINTS = 'points';
export const GRID_DISPLAY_MODE_TRIANGULAR = 'triangular';
export const GRID_DISPLAY_MODE_POLAR = 'polar';
export const ANGLE_DISPLAY_MODE_DEGREES = 'degrees';
export const ANGLE_DISPLAY_MODE_RADIANS = 'radians';
export const ANGLE_DISPLAY_MODE_NONE = 'none';
export const DISTANCE_DISPLAY_MODE_ON = 'on';
export const DISTANCE_DISPLAY_MODE_NONE = 'none';
export const KEY_SPACE = ' ';
export const KEY_ESCAPE = 'Escape';
export const KEY_DELETE = 'Delete';
export const KEY_BACKSPACE = 'Backspace';
export const KEY_REPEAT = 'r';
export const KEY_ZOOM_IN = '=';
export const KEY_ZOOM_IN_PLUS = '+';
export const KEY_ZOOM_OUT = '-';
export const KEY_COPY = 'c';
export const KEY_PASTE = 'v';
export const KEY_CUT = 'x';
export const KEY_UNDO = 'z';
export const KEY_REDO = 'y';
export const KEY_SELECT_ALL = 'a';
export const COLOR_TARGET_VERTEX = 'vertex';
export const COLOR_TARGET_EDGE = 'edge';
export const COLOR_TARGET_FACE = 'face';


=== index.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Platonic Play</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <div class="canvas-wrapper-relative">
                <canvas id="drawingCanvas"></canvas>
                <div id="html-overlay"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script type="module" src="/script.js"></script>
</body>
</html>

=== package.json ===
{
  "name": "platonic-play",
  "version": "1.0.0",
  "description": "",
  "main": "script.js",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "vite": "^5.3.3"
  },
  "dependencies": {
    "colormap-selector": "github:svenviktorjonsson/colormap-selector"
  }
}


=== readme.md ===



=== renderer.js ===
import * as U from './utils.js';
import * as C from './constants.js';

let colorWheelIcon = null

export function calculateGridIntervals(viewTransformScale) {
    const effectiveDataInterval = C.GRID_TARGET_SPACING / viewTransformScale;

    let lowerPowerOf10 = Math.pow(10, Math.floor(Math.log10(effectiveDataInterval)));
    let higherPowerOf10 = Math.pow(10, Math.ceil(Math.log10(effectiveDataInterval)));

    if (Math.abs(lowerPowerOf10 - higherPowerOf10) < C.GEOMETRY_CALCULATION_EPSILON || lowerPowerOf10 === 0) {
        higherPowerOf10 = lowerPowerOf10 === 0 ? 0.001 : lowerPowerOf10 * 10;
        if (lowerPowerOf10 === 0) lowerPowerOf10 = 0.0001;
    }

    const grid1Interval = lowerPowerOf10;
    const grid2Interval = higherPowerOf10;

    let logInterpFactor = 0;
    if (grid2Interval > grid1Interval && grid1Interval > 0) {
        logInterpFactor = (Math.log10(effectiveDataInterval) - Math.log10(grid1Interval)) / (Math.log10(grid2Interval) - Math.log10(grid1Interval));
    }

    let interpValue = (logInterpFactor - C.GRID_ALPHA_TRANSITION_START) / (C.GRID_ALPHA_TRANSITION_END - C.GRID_ALPHA_TRANSITION_START);
    interpValue = Math.max(0, Math.min(1, interpValue));
    interpValue = interpValue * interpValue * (3 - 2 * interpValue);

    let alpha1 = 1 - interpValue;
    let alpha2 = interpValue;

    if (alpha1 < C.GRID_ALPHA_CLAMP_THRESHOLD) alpha1 = 0; else if (alpha1 > 1 - C.GRID_ALPHA_CLAMP_THRESHOLD) alpha1 = 1;
    if (alpha2 < C.GRID_ALPHA_CLAMP_THRESHOLD) alpha2 = 0; else if (alpha2 > 1 - C.GRID_ALPHA_CLAMP_THRESHOLD) alpha2 = 1;

    const totalAlpha = alpha1 + alpha2;
    if (totalAlpha > 0 && totalAlpha !== 2) {
        alpha1 /= totalAlpha;
        alpha2 /= totalAlpha;
    }

    return { grid1Interval, grid2Interval, alpha1, alpha2 };
}

export function getDynamicAngularIntervals(viewTransform, canvasWidth, canvasHeight, dataToScreen) {
    const originScreen = dataToScreen({ x: 0, y: 0 });
    const screenCenter = { x: canvasWidth / 2, y: canvasHeight / 2 };

    const radiusToCenterScreen = U.distance(originScreen, screenCenter);
    let targetAngleDeg;

    if (radiusToCenterScreen < 1e-6) {
        targetAngleDeg = C.ANGULAR_GRID_TARGET_SPACING;
    } else {
        const targetAngleRad = C.ANGULAR_GRID_TARGET_SPACING / radiusToCenterScreen;
        targetAngleDeg = targetAngleRad * (180 / Math.PI);
    }

    if (isNaN(targetAngleDeg) || targetAngleDeg <= C.GEOMETRY_CALCULATION_EPSILON) {
        targetAngleDeg = C.GEOMETRY_CALCULATION_EPSILON;
    }

    const results = [];
    let allLevels = [...C.ANGULAR_GRID_PREDEFINED_LEVELS];

    let lastGeneratedLevel = allLevels[allLevels.length - 1];
    
    const absoluteMinimum = 1e-15;
    
    while (lastGeneratedLevel > absoluteMinimum) {
        lastGeneratedLevel /= 10;
        if (!allLevels.includes(lastGeneratedLevel)) {
            allLevels.push(lastGeneratedLevel);
        }
    }

    allLevels.sort((a, b) => b - a);

    let primaryLevel = null;
    let secondaryLevel = null;

    for (let i = allLevels.length - 1; i >= 0; i--) {
        const currentLevel = allLevels[i];

        if (targetAngleDeg < currentLevel) {
            primaryLevel = { angle: currentLevel, alpha: 1.0 };
            if (i + 1 < allLevels.length) {
                secondaryLevel = { angle: allLevels[i + 1], alpha: 0 };
            }
            break;
        }
    }

    if (!primaryLevel && allLevels.length > 0) {
        primaryLevel = { angle: allLevels[0], alpha: 1.0 };
        if (allLevels.length > 1) {
            secondaryLevel = { angle: allLevels[1], alpha: 0 };
        }
    } else if (!primaryLevel && allLevels.length === 0) {
        primaryLevel = { angle: C.ANGULAR_GRID_PREDEFINED_LEVELS[0], alpha: 1.0 };
    }

    results.push(primaryLevel);

    if (secondaryLevel) {
        const logPrimary = Math.log10(primaryLevel.angle);
        const logSecondary = Math.log10(secondaryLevel.angle);
        const logTarget = Math.log10(targetAngleDeg);

        let interpValue;
        if (logSecondary === logPrimary) {
            interpValue = 0;
        } else {
            interpValue = (logTarget - logPrimary) / (logSecondary - logPrimary);
        }

        interpValue = Math.max(0, Math.min(1, interpValue));

        const fadeInAlpha = interpValue * interpValue * (3 - 2 * interpValue);

        if (fadeInAlpha > C.ANGULAR_GRID_FADE_IN_THRESHOLD) {
            secondaryLevel.alpha = fadeInAlpha;
            results.push(secondaryLevel);
        }
    }

    const uniqueResults = [];
    const seenAngles = new Set();
    results.sort((a, b) => b.angle - a.angle);

    for (const res of results) {
        if (!seenAngles.has(res.angle)) {
            uniqueResults.push(res);
            seenAngles.add(res.angle);
        }
    }

    if (uniqueResults.length === 0) {
        uniqueResults.push({ angle: C.ANGULAR_GRID_PREDEFINED_LEVELS[0], alpha: 1.0 });
    }

    return uniqueResults;
}

export function drawFaceGlows(ctx, { allFaces, hoveredFaceId, selectedFaceIds, colors, isDragConfirmed, dragPreviewVertices }, dataToScreen, findVertexById, getFaceId) {
    if (!hoveredFaceId && selectedFaceIds.length === 0) return;

    const getLiveVertex = (vertexId) => {
        if (isDragConfirmed && dragPreviewVertices) {
            const previewVertex = dragPreviewVertices.find(p => p && p.id === vertexId);
            if (previewVertex) {
                return previewVertex;
            }
        }
        return findVertexById(vertexId);
    };

    allFaces.forEach(face => {
        const faceId = getFaceId(face);
        const isSelected = selectedFaceIds.includes(faceId);
        const isHovered = faceId === hoveredFaceId;

        if (isSelected || isHovered) {
            const vertices = face.vertexIds.map(id => getLiveVertex(id)).filter(p => p && p.type === 'regular');
            if (vertices.length < 3) return;

            const screenVertices = vertices.map(v => dataToScreen(v));

            ctx.save();
            ctx.fillStyle = colors.selectionGlow;
            ctx.globalAlpha = 0.25;
            
            ctx.beginPath();
            screenVertices.forEach((vertex, index) => {
                if (index === 0) {
                    ctx.moveTo(vertex.x, vertex.y);
                } else {
                    ctx.lineTo(vertex.x, vertex.y);
                }
            });
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
    });
}

function calculateVisibleAngleRange(originScreen, screenRadius, canvasWidth, canvasHeight) {
    if (originScreen.x >= 0 && originScreen.x <= canvasWidth && 
        originScreen.y >= 0 && originScreen.y <= canvasHeight) {
        return { minAngle: 0, maxAngle: 360, isFullCircle: true };
    }

    const rect = {
        left: 0,
        right: canvasWidth,
        top: 0,
        bottom: canvasHeight
    };

    if (originScreen.x + screenRadius < rect.left || 
        originScreen.x - screenRadius > rect.right ||
        originScreen.y + screenRadius < rect.top || 
        originScreen.y - screenRadius > rect.bottom) {
        return null;
    }

    const corners = [
        { x: rect.left, y: rect.top },
        { x: rect.right, y: rect.top },
        { x: rect.right, y: rect.bottom },
        { x: rect.left, y: rect.bottom }
    ];

    const allCornersInside = corners.every(corner => {
        const distSq = (corner.x - originScreen.x) ** 2 + (corner.y - originScreen.y) ** 2;
        return distSq <= screenRadius ** 2;
    });

    if (allCornersInside) {
        return { minAngle: 0, maxAngle: 360, isFullCircle: true };
    }

    const intersectionAngles = [];

    corners.forEach(corner => {
        const distSq = (corner.x - originScreen.x) ** 2 + (corner.y - originScreen.y) ** 2;
        if (distSq > screenRadius ** 2) {
            const dx = corner.x - originScreen.x;
            const dy = corner.y - originScreen.y;
            const angle = Math.atan2(-dy, dx);
            const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle;
            intersectionAngles.push(normalizedAngle * 180 / Math.PI);
        }
    });

    const edges = [
        { x1: rect.left, y1: rect.top, x2: rect.right, y2: rect.top },
        { x1: rect.right, y1: rect.top, x2: rect.right, y2: rect.bottom },
        { x1: rect.right, y1: rect.bottom, x2: rect.left, y2: rect.bottom },
        { x1: rect.left, y1: rect.bottom, x2: rect.left, y2: rect.top }
    ];

    edges.forEach(edge => {
        const intersections = U.getLineCircleIntersection(
            {p1: {x: edge.x1, y: edge.y1}, p2: {x: edge.x2, y: edge.y2}},
            {center: {x: originScreen.x, y: originScreen.y}, radius: screenRadius}
        );
        
        intersections.forEach(vertex => {
            const dx = vertex.x - originScreen.x;
            const dy = vertex.y - originScreen.y;
            const angle = Math.atan2(-dy, dx);
            const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle;
            intersectionAngles.push(normalizedAngle * 180 / Math.PI);
        });
    });

    if (intersectionAngles.length === 0) {
        return { minAngle: 0, maxAngle: 360, isFullCircle: true };
    }

    const uniqueAngles = [...new Set(intersectionAngles.map(a => Math.round(a * 1e6) / 1e6))].sort((a, b) => a - b);

    if (uniqueAngles.length < 2) {
        return { minAngle: 0, maxAngle: 360, isFullCircle: true };
    }

    let maxGap = 0;
    let maxGapStartAngle = 0;
    let maxGapEndAngle = 0;

    for (let i = 0; i < uniqueAngles.length; i++) {
        const currentAngle = uniqueAngles[i];
        const nextAngle = uniqueAngles[(i + 1) % uniqueAngles.length];
        
        let gap;
        if (i === uniqueAngles.length - 1) {
            gap = (360 - currentAngle) + nextAngle;
        } else {
            gap = nextAngle - currentAngle;
        }

        if (gap > maxGap) {
            maxGap = gap;
            maxGapStartAngle = currentAngle;
            maxGapEndAngle = nextAngle;
        }
    }

    if (maxGapEndAngle > maxGapStartAngle) {
        return {
            minAngle: maxGapEndAngle,
            maxAngle: maxGapStartAngle + 360,
            isFullCircle: false
        };
    } else {
        return {
            minAngle: maxGapEndAngle,
            maxAngle: maxGapStartAngle,
            isFullCircle: false
        };
    }
}

export function clearCanvas(ctx, { canvas, dpr, colors }) {
    const actualCanvasWidth = canvas.width / dpr;
    const actualCanvasHeight = canvas.height / dpr;
    ctx.resetTransform();
    ctx.scale(dpr, dpr);
    ctx.fillStyle = colors.background;
    ctx.fillRect(0, 0, actualCanvasWidth, actualCanvasHeight);
}

export function drawCopyPreviews(ctx, {
    copyCount,
    isDragConfirmed,
    initialDragVertexStates,
    dragPreviewVertices,
    transformIndicatorData,
    allEdges,
    findVertexById,
    findNeighbors,
    colors
}, dataToScreen) {

    ctx.save();
    ctx.globalAlpha = 0.5;

    const verticesToCopy = initialDragVertexStates.filter(p => p.type === 'regular');
    const vertexIdsToCopy = new Set(verticesToCopy.map(p => p.id));
    const incidentEdges = allEdges.filter(edge =>
        vertexIdsToCopy.has(edge.id1) && vertexIdsToCopy.has(edge.id2)
    );

    verticesToCopy.forEach(p => drawVertex(ctx, p, { selectedVertexIds: [], selectedCenterIds: [], activeCenterId: null, currentColor: p.color, colors, verticesVisible: true }, dataToScreen, () => {}));
    ctx.setLineDash(C.DASH_PATTERN);
    incidentEdges.forEach(edge => {
        const p1 = findVertexById(edge.id1);
        const p2 = findVertexById(edge.id2);
        if (p1 && p2) {
            const p1Screen = dataToScreen(p1);
            const p2Screen = dataToScreen(p2);
            ctx.beginPath();
            ctx.moveTo(p1Screen.x, p1Screen.y);
            ctx.lineTo(p2Screen.x, p2Screen.y);
            ctx.strokeStyle = colors.defaultStroke;
            ctx.stroke();
        }
    });

    for (let i = 1; i < copyCount; i++) {
        let previewVerticesForThisCopy;

        if (transformIndicatorData) {
            const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
            const effectiveRotation = rotation * i;
            const effectiveScale = Math.pow(scale, i);
            const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
            previewVerticesForThisCopy = verticesToCopy.map(p => {
                const newPos = U.applyTransformToVertex(p, center, effectiveRotation, effectiveScale, directionalScale, startVector);
                return { ...p, id: `preview_${p.id}_${i}`, x: newPos.x, y: newPos.y };
            });
        } else {
            const deltaX = dragPreviewVertices[0].x - initialDragVertexStates[0].x;
            const deltaY = dragPreviewVertices[0].y - initialDragVertexStates[0].y;
            const effectiveDeltaX = deltaX * i;
            const effectiveDeltaY = deltaY * i;
            previewVerticesForThisCopy = verticesToCopy.map(p => ({
                ...p, id: `preview_${p.id}_${i}`, x: p.x + effectiveDeltaX, y: p.y + effectiveDeltaY
            }));
        }

        const newIdMap = new Map(previewVerticesForThisCopy.map((p, j) => [verticesToCopy[j].id, p.id]));

        ctx.setLineDash(C.DASH_PATTERN);
        incidentEdges.forEach(edge => {
            const p1 = previewVerticesForThisCopy.find(p => p.id === newIdMap.get(edge.id1));
            const p2 = previewVerticesForThisCopy.find(p => p.id === newIdMap.get(edge.id2));
            if (p1 && p2) {
                const p1Screen = dataToScreen(p1);
                const p2Screen = dataToScreen(p2);
                ctx.beginPath();
                ctx.moveTo(p1Screen.x, p1Screen.y);
                ctx.lineTo(p2Screen.x, p2Screen.y);
                ctx.stroke();
            }
        });

        verticesToCopy.forEach(originalVertex => {
            const correspondingPreviewVertex = previewVerticesForThisCopy.find(p => p.id === newIdMap.get(originalVertex.id));
            if (!correspondingPreviewVertex) return;
            const neighbors = findNeighbors(originalVertex.id);
            neighbors.forEach(neighborId => {
                if (!vertexIdsToCopy.has(neighborId)) {
                    const neighborVertex = findVertexById(neighborId);
                    if (neighborVertex && neighborVertex.type === 'regular') {
                        const previewScreen = dataToScreen(correspondingPreviewVertex);
                        const neighborScreen = dataToScreen(neighborVertex);
                        ctx.beginPath();
                        ctx.moveTo(previewScreen.x, previewScreen.y);
                        ctx.lineTo(neighborScreen.x, neighborScreen.y);
                        ctx.stroke();
                    }
                }
            });
        });

        previewVerticesForThisCopy.forEach(vertex => drawVertex(ctx, vertex, { selectedVertexIds: [], selectedCenterIds: [], activeCenterId: null, currentColor: vertex.color, colors, verticesVisible: true }, dataToScreen, () => {}));
    }

    ctx.restore();
}

export function drawDrawingPreview(ctx, { startVertex, snappedData, isShiftPressed, currentColor, nextCreationColor, nextEdgeColor, colors, edgeColormapInfo }, dataToScreen) {
    const startScreen = dataToScreen(startVertex);
    const targetScreen = dataToScreen(snappedData);

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(startScreen.x, startScreen.y);
    ctx.lineTo(targetScreen.x, targetScreen.y);
    ctx.setLineDash(C.DASH_PATTERN);
    
    if (edgeColormapInfo && edgeColormapInfo.colormapItem) {
        const gradient = ctx.createLinearGradient(startScreen.x, startScreen.y, targetScreen.x, targetScreen.y);
        const startColor = U.sampleColormap(edgeColormapInfo.colormapItem, edgeColormapInfo.startT);
        const endColor = U.sampleColormap(edgeColormapInfo.colormapItem, edgeColormapInfo.endT);
        gradient.addColorStop(0, startColor);
        gradient.addColorStop(1, endColor);
        ctx.strokeStyle = gradient;
    } else if (snappedData.snapped) {
        ctx.strokeStyle = colors.feedbackSnapped;
    } else if (isShiftPressed) {
        ctx.strokeStyle = colors.feedbackSnapped;
    } else {
        ctx.strokeStyle = nextEdgeColor;
    }
    
    ctx.lineWidth = C.LINE_WIDTH;
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.beginPath();
    ctx.arc(targetScreen.x, targetScreen.y, C.VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
    
    if (snappedData.snapped) {
        ctx.fillStyle = colors.feedbackSnapped;
    } else {
        ctx.fillStyle = nextCreationColor;
    }
    
    ctx.fill();
    ctx.restore();
}

export function drawMergePreviews(ctx, { allVertices, dragPreviewVertices, viewTransform, colors, transformIndicatorData, copyCount, initialDragVertexStates }, dataToScreen) {
    if (!dragPreviewVertices || dragPreviewVertices.length === 0 || !initialDragVertexStates || initialDragVertexStates.length === 0) {
        return;
    }

    const indicatorMergeThreshold = C.GEOMETRY_CALCULATION_EPSILON;
    const drawnMergeIndicators = new Set();
    const draggedIds = new Set(initialDragVertexStates.map(p => p.id));
    const verticesToTransform = initialDragVertexStates.filter(p => p.type === 'regular');

    const staticVertices = allVertices.filter(p => p.type === 'regular' && !draggedIds.has(p.id));

    const multipliers = copyCount === 1 ? [1] : Array.from({ length: copyCount }, (_, k) => k);

    const copies = [];
    if (verticesToTransform.length > 0) {
        if (transformIndicatorData) {
            const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
            const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
            multipliers.forEach(k => {
                const effectiveRotation = rotation * k;
                const effectiveScale = Math.pow(scale, k);
                const transformedVertices = verticesToTransform.map(p_orig => {
                    const newPos = U.applyTransformToVertex(p_orig, center, effectiveRotation, effectiveScale, directionalScale, startVector);
                    return { ...p_orig, ...newPos };
                });
                copies.push(transformedVertices);
            });
        } else {
            const deltaX = dragPreviewVertices[0].x - initialDragVertexStates[0].x;
            const deltaY = dragPreviewVertices[0].y - initialDragVertexStates[0].y;
            multipliers.forEach(k => {
                const effectiveDeltaX = deltaX * k;
                const effectiveDeltaY = deltaY * k;
                const transformedVertices = verticesToTransform.map(p_orig => ({
                    ...p_orig,
                    x: p_orig.x + effectiveDeltaX,
                    y: p_orig.y + effectiveDeltaY,
                }));
                copies.push(transformedVertices);
            });
        }
    }

    const drawIndicator = (p1, p2) => {
        if (p1.id === p2.id) return;
        if (U.distance(p1, p2) < indicatorMergeThreshold) {
            const mergePos = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            const screenPos = dataToScreen(mergePos);
            const key = `${Math.round(screenPos.x)},${Math.round(screenPos.y)}`;
            if (!drawnMergeIndicators.has(key)) {
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, C.VERTEX_RADIUS, 0, 2 * Math.PI);
                ctx.fill();
                drawnMergeIndicators.add(key);
            }
        }
    };

    ctx.fillStyle = colors.feedbackSnapped;

    for (const copy of copies) {
        for (const p_copy of copy) {
            for (const p_static of staticVertices) {
                drawIndicator(p_copy, p_static);
            }
        }
    }

    for (let i = 0; i < copies.length; i++) {
        for (let j = i + 1; j < copies.length; j++) {
            for (const pA of copies[i]) {
                for (const pB of copies[j]) {
                    drawIndicator(pA, pB);
                }
            }
        }
    }
}

function generateOptimizedAngleSequence(angleStep, minAngle, maxAngle) {
    const angles = [];
    
    const isWraparound = maxAngle > 360;
    
    if (isWraparound) {
        const actualMaxAngle = maxAngle - 360;
        
        const startAngle1 = Math.floor(minAngle / angleStep) * angleStep;
        for (let angle = startAngle1; angle < 360; angle += angleStep) {
            if (angle >= minAngle) {
                angles.push(angle);
            }
        }
        
        for (let angle = 0; angle <= actualMaxAngle + angleStep; angle += angleStep) {
            if (angle <= actualMaxAngle) {
                angles.push(angle);
            }
        }
    } else {
        const startAngle = Math.floor(minAngle / angleStep) * angleStep;
        for (let angle = startAngle; angle <= maxAngle + angleStep; angle += angleStep) {
            if (angle >= minAngle && angle <= maxAngle && angle >= 0 && angle < 360) {
                angles.push(angle);
            }
        }
    }
    
    return [...new Set(angles)].sort((a, b) => a - b);
}

function isTickVisible(tickEnd, canvasWidth, canvasHeight) {
    return tickEnd.x >= -C.AXIS_LABEL_PADDING && 
           tickEnd.x <= canvasWidth + C.AXIS_LABEL_PADDING && 
           tickEnd.y >= -C.AXIS_LABEL_PADDING && 
           tickEnd.y <= canvasHeight + C.AXIS_LABEL_PADDING;
}

export function drawPolarReferenceCircle(ctx, htmlOverlay, updateHtmlLabel, radius, alpha, { canvas, dpr, viewTransform, angleDisplayMode, colors }, dataToScreen, lastAngularGridState) {
    if (typeof dataToScreen !== 'function' || typeof updateHtmlLabel !== 'function') {
        return;
    }

    const originScreen = dataToScreen({ x: 0, y: 0 });
    const canvasWidthCSS = canvas.width / dpr;
    const canvasHeightCSS = canvas.height / dpr;
    const screenCenter = { x: canvasWidthCSS / 2, y: canvasHeightCSS / 2 };
    const baseRadius = Math.min(canvasWidthCSS, canvasHeightCSS) / 4;
    const panDistance = U.distance(originScreen, screenCenter);
    const screenRadius = baseRadius + panDistance;

    if (screenRadius < C.REF_CIRCLE_MIN_DISPLAY_RADIUS || !isCircleInView(originScreen.x, originScreen.y, screenRadius, canvasWidthCSS, canvasHeightCSS)) {
        return;
    }

    ctx.save();
    ctx.strokeStyle = `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;

    const transitionRadius = Math.min(canvasWidthCSS, canvasHeightCSS) * 400;
    const isLineMode = screenRadius > transitionRadius;

    let visibleAngleRange = null;

    if (isLineMode) {
        const screenRect = { x: 0, y: 0, w: canvasWidthCSS, h: canvasHeightCSS };
        const circle = { x: originScreen.x, y: originScreen.y, r: screenRadius };
        const intersections = getCircleRectIntersections(circle, screenRect);

        if (intersections.length >= 2) {
            let p1 = intersections[0], p2 = intersections[1];
            let maxDistSq = 0;
            for (let i = 0; i < intersections.length; i++) {
                for (let j = i + 1; j < intersections.length; j++) {
                    const dSq = (intersections[i].x - intersections[j].x)**2 + (intersections[i].y - intersections[j].y)**2;
                    if (dSq > maxDistSq) {
                        maxDistSq = dSq;
                        p1 = intersections[i];
                        p2 = intersections[j];
                    }
                }
            }
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            const angle1 = (Math.atan2(originScreen.y - p1.y, p1.x - originScreen.x) * 180 / Math.PI + 360) % 360;
            const angle2 = (Math.atan2(originScreen.y - p2.y, p2.x - originScreen.x) * 180 / Math.PI + 360) % 360;
            visibleAngleRange = { minAngle: Math.min(angle1, angle2), maxAngle: Math.max(angle1, angle2), isFullCircle: false };
            if (Math.abs(angle1 - angle2) > 180) {
                 visibleAngleRange = { minAngle: Math.max(angle1, angle2), maxAngle: Math.min(angle1, angle2) + 360, isFullCircle: false };
            }
        }
    } else {
        ctx.beginPath();
        ctx.arc(originScreen.x, originScreen.y, screenRadius, 0, 2 * Math.PI);
        ctx.stroke();
        visibleAngleRange = calculateVisibleAngleRange(originScreen, screenRadius, canvasWidthCSS, canvasHeightCSS);
    }
    
    ctx.restore();
    
    if (!visibleAngleRange) return;

    const dataRadius = screenRadius / (viewTransform.scale / dpr);
    const drawnAnglesSimple = new Set();
    const drawnAnglesComplex = new Map();

    lastAngularGridState.forEach(level => {
        const tickAlpha = level.alpha;
        if (tickAlpha < 0.01) return;

        const screenSeparation = screenRadius * (level.angle * Math.PI / 180);
        
        if (screenSeparation < C.REF_CIRCLE_MIN_TICK_SPACING * 0.5) return;

        const finalColor = `rgba(${colors.feedbackDefault.join(',')}, ${tickAlpha * 0.95})`;

        let anglesToProcess;
        if (visibleAngleRange.isFullCircle) {
            anglesToProcess = [];
            for (let deg = 0; deg < 360; deg += level.angle) {
                anglesToProcess.push(deg);
            }
        } else {
            anglesToProcess = generateOptimizedAngleSequence(
                level.angle,
                visibleAngleRange.minAngle,
                visibleAngleRange.maxAngle
            );
        }

        anglesToProcess.forEach(deg => {
            if (angleDisplayMode === 'degrees') {
                if (drawnAnglesSimple.has(deg)) return;
            }
            else if (angleDisplayMode === 'radians') {
                const levelKey = `${deg}-${level.angle}`;
                if (drawnAnglesComplex.has(levelKey)) return;
            }

            const angleRad = deg * Math.PI / 180;
            let labelOptions = { textAlign: 'center', textBaseline: 'middle' };
            
            if (angleDisplayMode === 'radians') {
                labelOptions = { textAlign: 'left', textBaseline: 'middle' };
            }
            
            let labelPos;

            ctx.save();
            ctx.strokeStyle = finalColor;
            ctx.lineWidth = C.GRID_LINEWIDTH;

            if (deg % 90 === 0 && deg < 360) {
                const vertexOnCircle = { 
                    x: originScreen.x + screenRadius * Math.cos(angleRad), 
                    y: originScreen.y - screenRadius * Math.sin(angleRad) 
                };

                let tickVec;
                const tickLength = C.AXIS_TICK_SIZE * 1.5;
                
                switch (deg) {
                    case 0:
                        tickVec = { x: Math.SQRT1_2, y: -Math.SQRT1_2 };
                        labelOptions = { textAlign: 'left', textBaseline: 'bottom' };
                        break;
                    case 90:
                        tickVec = { x: Math.SQRT1_2, y: -Math.SQRT1_2 };
                        labelOptions = { textAlign: 'left', textBaseline: 'bottom' };
                        break;
                    case 180:
                        tickVec = { x: -Math.SQRT1_2, y: -Math.SQRT1_2 };
                        labelOptions = { textAlign: 'right', textBaseline: 'bottom' };
                        break;
                    case 270:
                        tickVec = { x: Math.SQRT1_2, y: Math.SQRT1_2 };
                        labelOptions = { textAlign: 'left', textBaseline: 'top' };
                        break;
                }
                
                const tickEnd = {
                    x: vertexOnCircle.x + tickVec.x * tickLength,
                    y: vertexOnCircle.y + tickVec.y * tickLength
                };

                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(vertexOnCircle.x, vertexOnCircle.y);
                ctx.lineTo(tickEnd.x, tickEnd.y);
                ctx.stroke();
                
                labelPos = { x: tickEnd.x, y: tickEnd.y };

            } else {
                const tickStart = { 
                    x: originScreen.x + (screenRadius - C.VERTEX_RADIUS) * Math.cos(angleRad), 
                    y: originScreen.y - (screenRadius - C.VERTEX_RADIUS) * Math.sin(angleRad) 
                };
                const tickEnd = { 
                    x: originScreen.x + (screenRadius + C.VERTEX_RADIUS) * Math.cos(angleRad), 
                    y: originScreen.y - (screenRadius + C.VERTEX_RADIUS) * Math.sin(angleRad) 
                };
                if (isTickVisible(tickEnd, canvasWidthCSS, canvasHeightCSS)) {
                    ctx.beginPath();
                    ctx.moveTo(tickStart.x, tickStart.y);
                    ctx.lineTo(tickEnd.x, tickEnd.y);
                    ctx.stroke();
                }
                labelPos = { 
                    x: originScreen.x + (screenRadius + C.REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN) * Math.cos(angleRad), 
                    y: originScreen.y - (screenRadius + C.REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN) * Math.sin(angleRad) 
                };
            }
            
            ctx.restore();
            
            let angleText = '';
            if (angleDisplayMode === 'degrees') {
                let precision = Math.max(0, (level.angle.toString().split('.')[1] || '').length);
                
                if (level.angle < 1) {
                    precision = Math.max(precision, Math.ceil(-Math.log10(level.angle)) + 1);
                }
                
                const formattedDeg = parseFloat(deg.toFixed(precision));
                angleText = `${formattedDeg}^{\\circ}`;
            } else {
                if (deg === 0 && angleDisplayMode === 'radians') {
                    angleText = '0';
                } else if (deg !== 0) {
                    const isFineTick = level.angle <= 5;
                    
                    if (isFineTick) {
                        const radianValue = deg * Math.PI / 180;
                        
                        let precision;
                        if (level.angle >= 1) {
                            precision = 3;
                        } else if (level.angle >= 0.1) {
                            precision = 4;
                        } else if (level.angle >= 0.01) {
                            precision = 5;
                        } else if (level.angle >= 0.001) {
                            precision = 6;
                        } else {
                            precision = 7;
                        }
                        
                        let formattedRadian = radianValue.toFixed(precision);
                        
                        if (parseFloat(formattedRadian) !== 0) {
                            angleText = formattedRadian;
                        }
                    } else {
                        const numerator = deg;
                        const denominator = 180;
                        
                        const gcdValue = U.gcd(numerator, denominator);
                        const simplifiedNum = numerator / gcdValue;
                        const simplifiedDen = denominator / gcdValue;
                        
                        if (simplifiedDen === 1) {
                            if (simplifiedNum === 1) angleText = '\\pi';
                            else if (simplifiedNum === -1) angleText = '-\\pi';
                            else angleText = `${simplifiedNum}\\pi`;
                        } else {
                            if (simplifiedNum === 1) angleText = `\\frac{\\pi}{${simplifiedDen}}`;
                            else if (simplifiedNum === -1) angleText = `-\\frac{\\pi}{${simplifiedDen}}`;
                            else if (simplifiedNum < 0) angleText = `-\\frac{${Math.abs(simplifiedNum)}\\pi}{${simplifiedDen}}`;
                            else angleText = `\\frac{${simplifiedNum}\\pi}{${simplifiedDen}}`;
                        }
                    }
                }
            }

            if (angleText) {
                const labelId = angleDisplayMode === 'radians' 
                    ? `circ-label-${deg}-${level.angle}-${dataRadius.toExponential(15)}`
                    : `circ-label-${deg}-${dataRadius.toExponential(15)}`;
                    
                updateHtmlLabel({ 
                    id: labelId, 
                    content: angleText, 
                    x: labelPos.x, 
                    y: labelPos.y, 
                    color: finalColor, 
                    fontSize: C.REF_TEXT_KATEX_FONT_SIZE, 
                    options: labelOptions
                });
                
                if (angleDisplayMode === 'degrees') {
                    drawnAnglesSimple.add(deg);
                } else {
                    const levelKey = `${deg}-${level.angle}`;
                    drawnAnglesComplex.set(levelKey, { 
                        levelAngle: level.angle, 
                        alpha: tickAlpha,
                        labelId: labelId 
                    });
                }
            }
        });
    });

    const arrowColor = colors.feedbackDefault;
    let stickyArrowAngle = -Infinity;
    const zeroDegVertex = { x: originScreen.x + screenRadius, y: originScreen.y };
    if (zeroDegVertex.x > -C.AXIS_LABEL_PADDING && zeroDegVertex.x < canvasWidthCSS + C.AXIS_LABEL_PADDING && zeroDegVertex.y > -C.AXIS_LABEL_PADDING && zeroDegVertex.y < canvasHeightCSS + C.AXIS_LABEL_PADDING) {
        stickyArrowAngle = 0;
    } else {
        const screenRect = { x: 0, y: 0, w: canvasWidthCSS, h: canvasHeightCSS };
        const circle = { x: originScreen.x, y: originScreen.y, r: screenRadius };
        const intersections = getCircleRectIntersections(circle, screenRect);
        let boundaryAngles = intersections.map(p => Math.atan2(originScreen.y - p.y, p.x - originScreen.x));
        const corners = [{x:0,y:0}, {x:screenRect.w,y:0}, {x:screenRect.w,y:screenRect.h}, {x:0,y:screenRect.h}];
        corners.forEach(c => {
            if (U.distance(c, circle) < circle.r) {
                boundaryAngles.push(Math.atan2(originScreen.y - c.y, c.x - originScreen.x));
            }
        });

        if (boundaryAngles.length > 0) {
            boundaryAngles = boundaryAngles.map(a => (a < 0) ? a + 2 * Math.PI : a).sort((a, b) => a - b);
            let uniqueAngles = [...new Set(boundaryAngles.map(a => parseFloat(a.toFixed(7))))];
            if (uniqueAngles.length > 0) {
                uniqueAngles.push(uniqueAngles[0] + 2 * Math.PI);
                let lastVisibleEndAngle = -Infinity;
                for (let i = 0; i < uniqueAngles.length - 1; i++) {
                    const startAngle = uniqueAngles[i];
                    const endAngle = uniqueAngles[i+1];
                    const midAngle = (startAngle + endAngle) / 2;
                    const midVertex = { x: circle.x + circle.r * Math.cos(midAngle), y: circle.y - circle.r * Math.sin(midAngle) };
                    if (midVertex.x > 0 && midVertex.x < screenRect.w && midVertex.y > 0 && midVertex.y < screenRect.h) {
                        lastVisibleEndAngle = endAngle;
                    }
                }
                if (lastVisibleEndAngle > -Infinity) {
                    stickyArrowAngle = lastVisibleEndAngle % (2 * Math.PI);
                }
            }
        }
    }

    if (stickyArrowAngle > -Infinity) {
        const arrowAngle = stickyArrowAngle;
        const tipPos = { x: originScreen.x + screenRadius * Math.cos(arrowAngle), y: originScreen.y - screenRadius * Math.sin(arrowAngle) };
        const tangentVec = { x: -Math.sin(arrowAngle), y: -Math.cos(arrowAngle) };
        const radialVec = { x: Math.cos(arrowAngle), y: -Math.sin(arrowAngle) };
        const p1 = { x: tipPos.x - C.AXIS_ARROW_SIZE * tangentVec.x + (C.AXIS_ARROW_SIZE / 2) * radialVec.x, y: tipPos.y - C.AXIS_ARROW_SIZE * tangentVec.y + (C.AXIS_ARROW_SIZE / 2) * radialVec.y };
        const p2 = { x: tipPos.x - C.AXIS_ARROW_SIZE * tangentVec.x - (C.AXIS_ARROW_SIZE / 2) * radialVec.x, y: tipPos.y - C.AXIS_ARROW_SIZE * tangentVec.y - (C.AXIS_ARROW_SIZE / 2) * radialVec.y };
        ctx.save();
        ctx.fillStyle = `rgba(${arrowColor.join(',')}, 1.0)`;
        ctx.beginPath();
        ctx.moveTo(tipPos.x, tipPos.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        let labelPos;
        if (arrowAngle === 0) {
            labelPos = {
                x: tipPos.x - C.POLAR_THETA_LABEL_DISTANCE,
                y: tipPos.y + C.POLAR_THETA_LABEL_ARROW_DIST + C.AXIS_ARROW_SIZE
            };
        } else {
            const radialVecInward = { x: -Math.cos(arrowAngle), y: Math.sin(arrowAngle) };
            labelPos = {
                x: tipPos.x + radialVecInward.x * (C.POLAR_THETA_LABEL_ARROW_DIST + C.AXIS_ARROW_SIZE) + tangentVec.x * C.POLAR_THETA_LABEL_DISTANCE,
                y: tipPos.y + radialVecInward.y * (C.POLAR_THETA_LABEL_ARROW_DIST + C.AXIS_ARROW_SIZE) + tangentVec.y * C.POLAR_THETA_LABEL_DISTANCE
            };
        }
        updateHtmlLabel({ id: `theta-label-sticky`, content: '\\theta', x: labelPos.x, y: labelPos.y, color: `rgba(${arrowColor.join(',')}, 1.0)`, fontSize: C.AXIS_NAME_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } });
    }
}

function getCircleRectIntersections(circle, rect) {
    const { x: cx, y: cy, r } = circle;
    const { x: rx, y: ry, w: rw, h: rh } = rect;
    const intersections = [];
    const checkLine = (x1, y1, x2, y2) => {
        const dx = x2 - x1, dy = y2 - y1;
        const a = dx * dx + dy * dy;
        const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
        const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
        const discriminant = b * b - 4 * a * c;
        if (discriminant < 0) return;
        const sqrtD = Math.sqrt(discriminant);
        const t1 = (-b + sqrtD) / (2 * a);
        const t2 = (-b - sqrtD) / (2 * a);
        [t1, t2].forEach(t => {
            if (t >= 0 && t <= 1) {
                intersections.push({ x: x1 + t * dx, y: y1 + t * dy });
            }
        });
    };
    checkLine(rx, ry, rx + rw, ry);
    checkLine(rx + rw, ry, rx + rw, ry + rh);
    checkLine(rx + rw, ry + rh, rx, ry + rh);
    checkLine(rx, ry + rh, rx, ry);
    return intersections;
}

export function isCircleInView(circleX, circleY, circleRadius, canvasWidth, canvasHeight) {
    if (circleX + circleRadius < 0 ||
        circleX - circleRadius > canvasWidth ||
        circleY + circleRadius < 0 ||
        circleY - circleRadius > canvasHeight) {
        return false;
    }
    return true;
}

function drawZeroTickAndTickLabel(ctx, origin, canvasWidth, canvasHeight, coordsDisplayMode, updateHtmlLabel, colors) {
    const tickColor = `rgba(${colors.axisTickLabel.join(',')}, ${C.AXIS_TICK_LABEL_ALPHA})`;
    const longTickSize = C.AXIS_TICK_SIZE * C.AXIS_MAJOR_TICK_SCALE_FACTOR;
    
    ctx.save();
    ctx.strokeStyle = tickColor;
    ctx.lineWidth = C.MAJOR_TICK_LINE_WIDTH;
    ctx.setLineDash([]);
    
    const yLength = longTickSize;
    const xLength = yLength / Math.tan(C.ORIGIN_TICK_ANGLE_RAD);
    
    const endX = origin.x - xLength;
    const endY = origin.y + yLength;
    
    ctx.beginPath();
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
    ctx.restore();
    
    updateHtmlLabel({
        id: 'tick-label-origin',
        content: C.ORIGIN_LABEL_TEXT,
        x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET,
        y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET,
        color: tickColor,
        fontSize: C.AXIS_TICK_FONT_SIZE,
        options: { textAlign: 'right', textBaseline: 'top' }
    });
}

export function drawAxes(ctx, htmlOverlay, { canvas, dpr, coordsDisplayMode, viewTransform, angleDisplayMode, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState, updateHtmlLabel) {
    ctx.save();
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;
    const origin = dataToScreen({ x: 0, y: 0 });

    const drawAxisWithArrows = (x1, y1, x2, y2) => {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        const angle = Math.atan2(y2 - y1, x2 - x1);
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - C.AXIS_ARROW_SIZE * Math.cos(angle - C.AXIS_ARROW_ANGLE_RAD), y2 - C.AXIS_ARROW_SIZE * Math.sin(angle - C.AXIS_ARROW_ANGLE_RAD));
        ctx.lineTo(x2 - C.AXIS_ARROW_SIZE * Math.cos(angle + C.AXIS_ARROW_ANGLE_RAD), y2 - C.AXIS_ARROW_SIZE * Math.sin(angle + C.AXIS_ARROW_ANGLE_RAD));
        ctx.closePath();
        ctx.fill();
    };

    const drawTicksAndLabels = (interval1, alpha1, interval2, alpha2, isPolar) => {
        const drawnXPositions = new Map();
        const drawnYPositions = new Map();
        
        const addTicksForInterval = (interval, alpha, isCoarser) => {
            if (!interval || alpha < C.MIN_ALPHA_FOR_DRAWING) return;
            const topLeftData = screenToData({ x: 0, y: 0 });
            const bottomRightData = screenToData({ x: canvasWidth, y: canvasHeight });
            const localZeroThreshold = interval * C.GEOMETRY_CALCULATION_EPSILON;
            
            if (isPolar) {
                const maxRadiusData = Math.hypot(Math.max(Math.abs(topLeftData.x), Math.abs(bottomRightData.x)), Math.max(Math.abs(topLeftData.y), Math.abs(bottomRightData.y))) * C.POLAR_AXIS_RADIUS_BUFFER_FACTOR;
                
                for (let r_data = interval; r_data <= maxRadiusData; r_data += interval) {
                    if (Math.abs(r_data) < localZeroThreshold) continue;
                    const existing = drawnXPositions.get(r_data);
                    if (!existing) {
                        drawnXPositions.set(r_data, { alpha, isCoarser });
                    } else if (isCoarser) {
                        drawnXPositions.set(r_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                    } else {
                        if (!existing.isCoarser) {
                            drawnXPositions.set(r_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                        }
                    }
                }
            } else {
                const startTickX = Math.floor(topLeftData.x / interval) * interval;
                const endTickX = Math.ceil(bottomRightData.x / interval) * interval;
                const startTickY = Math.floor(bottomRightData.y / interval) * interval;
                const endTickY = Math.ceil(topLeftData.y / interval) * interval;
                
                for (let x_data = startTickX; x_data <= endTickX; x_data += interval) {
                    if (Math.abs(x_data) < localZeroThreshold) continue;
                    const existing = drawnXPositions.get(x_data);
                    if (!existing) {
                        drawnXPositions.set(x_data, { alpha, isCoarser });
                    } else if (isCoarser) {
                        drawnXPositions.set(x_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                    } else {
                        if (!existing.isCoarser) {
                            drawnXPositions.set(x_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                        }
                    }
                }
                
                for (let y_data = startTickY; y_data <= endTickY; y_data += interval) {
                    if (Math.abs(y_data) < localZeroThreshold) continue;
                    const existing = drawnYPositions.get(y_data);
                    if (!existing) {
                        drawnYPositions.set(y_data, { alpha, isCoarser });
                    } else if (isCoarser) {
                        drawnYPositions.set(y_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: true });
                    } else {
                        if (!existing.isCoarser) {
                            drawnYPositions.set(y_data, { alpha: Math.max(existing.alpha, alpha), isCoarser: false });
                        }
                    }
                }
            }
        };
        
        const interval1IsCoarser = !interval2 || interval1 >= interval2;
        
        addTicksForInterval(interval1, alpha1, interval1IsCoarser);
        addTicksForInterval(interval2, alpha2, !interval1IsCoarser);
        
        drawnXPositions.forEach((tickInfo, x_data) => {
            const effectiveAlpha = tickInfo.isCoarser ? 1.0 : tickInfo.alpha;
            const tickLabelColor = `rgba(${colors.axisTickLabel.join(',')}, ${C.AXIS_TICK_LABEL_ALPHA * effectiveAlpha})`;
            ctx.strokeStyle = tickLabelColor;
            ctx.lineWidth = C.GRID_LINEWIDTH;
            
            let sourceInterval = interval1;
            if (interval2 && Math.abs(x_data % interval2) < Math.abs(x_data % interval1)) {
                sourceInterval = interval2;
            }
            const screenSpacing = sourceInterval * viewTransform.scale;
            let sigFigsForLabel = 0;
            if (screenSpacing > C.TICK_LABEL_SIGFIG_THRESH_1) sigFigsForLabel = 3; 
            else if (screenSpacing > C.TICK_LABEL_SIGFIG_THRESH_2) sigFigsForLabel = 2; 
            else if (screenSpacing > C.TICK_LABEL_SIGFIG_THRESH_3) sigFigsForLabel = 1; 
            else sigFigsForLabel = 0;
            
            const decimalPlacesInInterval = sourceInterval > 0 ? -Math.floor(Math.log10(sourceInterval)) : 0;
            if (decimalPlacesInInterval > 0) {
                sigFigsForLabel = Math.max(sigFigsForLabel, decimalPlacesInInterval + 1);
            }
            
            if (isPolar) {
                const labelText = U.formatNumber(x_data, sigFigsForLabel);
                const stableIdPart = x_data.toExponential(15);
                
                const isYAxisOnScreen = origin.y > -C.AXIS_LABEL_PADDING && origin.y < canvasHeight + C.AXIS_LABEL_PADDING;
                const isXAxisOnScreen = origin.x > -C.AXIS_LABEL_PADDING && origin.x < canvasWidth + C.AXIS_LABEL_PADDING;

                const pX = dataToScreen({ x: x_data, y: 0 });
                if (isYAxisOnScreen && pX.x > -C.AXIS_LABEL_PADDING && pX.x < canvasWidth + C.AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(pX.x, origin.y - C.AXIS_TICK_SIZE / 2); 
                    ctx.lineTo(pX.x, origin.y + C.AXIS_TICK_SIZE / 2); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-x-${stableIdPart}`, 
                        content: labelText, 
                        x: pX.x, 
                        y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET, 
                        color: tickLabelColor, 
                        fontSize: C.AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'center', textBaseline: 'top' } 
                    });
                }
                
                const pNegX = dataToScreen({ x: -x_data, y: 0 });
                if (isYAxisOnScreen && pNegX.x > -C.AXIS_LABEL_PADDING && pNegX.x < canvasWidth + C.AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(pNegX.x, origin.y - C.AXIS_TICK_SIZE / 2); 
                    ctx.lineTo(pNegX.x, origin.y + C.AXIS_TICK_SIZE / 2); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-negx-${stableIdPart}`, 
                        content: labelText, 
                        x: pNegX.x, 
                        y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET, 
                        color: tickLabelColor, 
                        fontSize: C.AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'center', textBaseline: 'top' } 
                    });
                }
                
                const pPosY = dataToScreen({ x: 0, y: x_data });
                if (isXAxisOnScreen && pPosY.y > -C.AXIS_LABEL_PADDING && pPosY.y < canvasHeight + C.AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(origin.x - C.AXIS_TICK_SIZE / 2, pPosY.y); 
                    ctx.lineTo(origin.x + C.AXIS_TICK_SIZE / 2, pPosY.y); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-posy-${stableIdPart}`, 
                        content: labelText, 
                        x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET, 
                        y: pPosY.y, 
                        color: tickLabelColor, 
                        fontSize: C.AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'right', textBaseline: 'middle' } 
                    });
                }
                
                const pNegY = dataToScreen({ x: 0, y: -x_data });
                if (isXAxisOnScreen && pNegY.y > -C.AXIS_LABEL_PADDING && pNegY.y < canvasHeight + C.AXIS_LABEL_PADDING) {
                    ctx.beginPath(); 
                    ctx.moveTo(origin.x - C.AXIS_TICK_SIZE / 2, pNegY.y); 
                    ctx.lineTo(origin.x + C.AXIS_TICK_SIZE / 2, pNegY.y); 
                    ctx.stroke();
                    updateHtmlLabel({ 
                        id: `polartick-r-negy-${stableIdPart}`, 
                        content: labelText, 
                        x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET, 
                        y: pNegY.y, 
                        color: tickLabelColor, 
                        fontSize: C.AXIS_TICK_FONT_SIZE, 
                        options: { textAlign: 'right', textBaseline: 'middle' } 
                    });
                }
            } else {
                const screenX = dataToScreen({ x: x_data, y: 0 }).x;
                ctx.beginPath(); 
                ctx.moveTo(screenX, origin.y); 
                ctx.lineTo(screenX, origin.y + C.AXIS_TICK_SIZE); 
                ctx.stroke();
                
                const getStableId = (prefix, num) => `${prefix}-${num.toExponential(15)}`;
                updateHtmlLabel({ 
                    id: getStableId('tick-label-x', x_data), 
                    content: U.formatNumber(x_data, sigFigsForLabel), 
                    x: screenX, 
                    y: origin.y + C.AXIS_TICK_SIZE + C.AXIS_LABEL_OFFSET, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'center', textBaseline: 'top' } 
                });
            }
        });
        
        if (!isPolar) {
            drawnYPositions.forEach((tickInfo, y_data) => {
                const effectiveAlpha = tickInfo.isCoarser ? 1.0 : tickInfo.alpha;
                const tickLabelColor = `rgba(${colors.axisTickLabel.join(',')}, ${C.AXIS_TICK_LABEL_ALPHA * effectiveAlpha})`;
                ctx.strokeStyle = tickLabelColor;
                ctx.lineWidth = C.GRID_LINEWIDTH;
                
                let sourceInterval = interval1;
                if (interval2 && Math.abs(y_data % interval2) < Math.abs(y_data % interval1)) {
                    sourceInterval = interval2;
                }
                const screenSpacing = sourceInterval * viewTransform.scale;
                let sigFigsForLabel = 0;
                if (screenSpacing > C.TICK_LABEL_SIGFIG_THRESH_1) sigFigsForLabel = 3; 
                else if (screenSpacing > C.TICK_LABEL_SIGFIG_THRESH_2) sigFigsForLabel = 2; 
                else if (screenSpacing > C.TICK_LABEL_SIGFIG_THRESH_3) sigFigsForLabel = 1; 
                else sigFigsForLabel = 0;
                
                const decimalPlacesInInterval = sourceInterval > 0 ? -Math.floor(Math.log10(sourceInterval)) : 0;
                if (decimalPlacesInInterval > 0) {
                    sigFigsForLabel = Math.max(sigFigsForLabel, decimalPlacesInInterval + 1);
                }
                
                const screenY = dataToScreen({ x: 0, y: y_data }).y;
                let yLabelContent = U.formatNumber(y_data, sigFigsForLabel);
                if (coordsDisplayMode === C.COORDS_DISPLAY_MODE_COMPLEX && yLabelContent !== "0") {
                    if (yLabelContent === '1') yLabelContent = C.IMAGINARY_UNIT_SYMBOL;
                    else if (yLabelContent === '-1') yLabelContent = `-${C.IMAGINARY_UNIT_SYMBOL}`;
                    else yLabelContent += C.IMAGINARY_UNIT_SYMBOL;
                }
                
                ctx.beginPath(); 
                ctx.moveTo(origin.x, screenY); 
                ctx.lineTo(origin.x - C.AXIS_TICK_SIZE, screenY); 
                ctx.stroke();
                
                const getStableId = (prefix, num) => `${prefix}-${num.toExponential(15)}`;
                updateHtmlLabel({ 
                    id: getStableId('tick-label-y', y_data), 
                    content: yLabelContent, 
                    x: origin.x - C.AXIS_TICK_SIZE - C.AXIS_LABEL_OFFSET, 
                    y: screenY, 
                    color: tickLabelColor, 
                    fontSize: C.AXIS_TICK_FONT_SIZE, 
                    options: { textAlign: 'right', textBaseline: 'middle' } 
                });
            });
        }
    };

    ctx.lineWidth = C.AXIS_LINE_WIDTH;
    ctx.strokeStyle = colors.axis;
    ctx.fillStyle = colors.axis;

    if (coordsDisplayMode === C.COORDS_DISPLAY_MODE_POLAR) {
        const { interval1, interval2, alpha1, alpha2 } = lastGridState;
        ctx.lineWidth = C.GRID_LINEWIDTH;
        
        const posXVisible = canvasWidth > origin.x;
        const negXVisible = 0 < origin.x;
        const posYVisible = 0 < origin.y;
        const negYVisible = canvasHeight > origin.y;
        
        if (posXVisible) {
            drawAxisWithArrows(origin.x, origin.y, canvasWidth, origin.y);
            updateHtmlLabel({ 
                id: 'axis-label-r-posx', 
                content: C.POLAR_RADIUS_SYMBOL, 
                x: canvasWidth - C.AXIS_ARROW_SIZE - C.X_AXIS_LABEL_ARROW_DIST, 
                y: origin.y - C.X_AXIS_LABEL_DISTANCE, 
                color: colors.axis, 
                fontSize: C.AXIS_NAME_FONT_SIZE, 
                options: { textAlign: 'center', textBaseline: 'bottom' } 
            });
        }
        
        if (negXVisible) {
            drawAxisWithArrows(origin.x, origin.y, 0, origin.y);
            updateHtmlLabel({ 
                id: 'axis-label-r-negx', 
                content: C.POLAR_RADIUS_SYMBOL, 
                x: C.AXIS_ARROW_SIZE + C.X_AXIS_LABEL_ARROW_DIST, 
                y: origin.y - C.X_AXIS_LABEL_DISTANCE, 
                color: colors.axis, 
                fontSize: C.AXIS_NAME_FONT_SIZE, 
                options: { textAlign: 'center', textBaseline: 'bottom' } 
            });
        }
        
        if (posYVisible) {
            drawAxisWithArrows(origin.x, origin.y, origin.x, 0);
            updateHtmlLabel({ 
                id: 'axis-label-r-posy', 
                content: C.POLAR_RADIUS_SYMBOL, 
                x: origin.x + C.Y_AXIS_LABEL_DISTANCE, 
                y: C.AXIS_ARROW_SIZE + C.Y_AXIS_LABEL_ARROW_DIST, 
                color: colors.axis, 
                fontSize: C.AXIS_NAME_FONT_SIZE, 
                options: { textAlign: 'left', textBaseline: 'middle' } 
            });
        }
        
        if (negYVisible) {
            drawAxisWithArrows(origin.x, origin.y, origin.x, canvasHeight);
            updateHtmlLabel({ 
                id: 'axis-label-r-negy', 
                content: C.POLAR_RADIUS_SYMBOL, 
                x: origin.x + C.Y_AXIS_LABEL_DISTANCE, 
                y: canvasHeight - C.AXIS_ARROW_SIZE - C.Y_AXIS_LABEL_ARROW_DIST, 
                color: colors.axis, 
                fontSize: C.AXIS_NAME_FONT_SIZE, 
                options: { textAlign: 'left', textBaseline: 'middle' } 
            });
        }
        
        drawTicksAndLabels(interval1, alpha1, interval2, alpha2, true);
        drawPolarReferenceCircle(ctx, htmlOverlay, updateHtmlLabel, 0, 0, { canvas, dpr, coordsDisplayMode, viewTransform, angleDisplayMode, colors }, dataToScreen, lastAngularGridState);
    } else {
        if (origin.y > 0 && origin.y < canvasHeight) drawAxisWithArrows(0, origin.y, canvasWidth, origin.y);
        if (origin.x > 0 && origin.x < canvasWidth) drawAxisWithArrows(origin.x, canvasHeight, origin.x, 0);
        
        let xLabel = 'x';
        let yLabel = 'y';
        if (coordsDisplayMode === C.COORDS_DISPLAY_MODE_COMPLEX) {
            xLabel = C.COMPLEX_REAL_LABEL;
            yLabel = C.COMPLEX_IMAGINARY_LABEL;
        }
        
        updateHtmlLabel({ 
            id: 'axis-label-x', 
            content: xLabel, 
            x: canvasWidth - C.AXIS_ARROW_SIZE - C.X_AXIS_LABEL_ARROW_DIST, 
            y: origin.y - C.X_AXIS_LABEL_DISTANCE, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'center', textBaseline: 'bottom' } 
        });
        
        updateHtmlLabel({ 
            id: 'axis-label-y', 
            content: yLabel, 
            x: origin.x + C.Y_AXIS_LABEL_DISTANCE, 
            y: C.AXIS_ARROW_SIZE + C.Y_AXIS_LABEL_ARROW_DIST, 
            color: colors.axis, 
            fontSize: C.AXIS_NAME_FONT_SIZE, 
            options: { textAlign: 'left', textBaseline: 'middle' } 
        });
        
        drawTicksAndLabels(lastGridState.interval1, lastGridState.alpha1, lastGridState.interval2, lastGridState.alpha2, false);
    }

    drawZeroTickAndTickLabel(ctx, origin, canvasWidth, canvasHeight, coordsDisplayMode, updateHtmlLabel, colors);

    ctx.restore();
}

export function drawGrid(ctx, { gridDisplayMode, canvas, dpr, viewTransform, gridAlpha, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState) {
    
    if (gridDisplayMode === C.GRID_DISPLAY_MODE_NONE) return;

    ctx.save();

    const origin = dataToScreen({ x: 0, y: 0 });
    const canvasWidth = canvas.width / dpr;
    const canvasHeight = canvas.height / dpr;

    if (gridDisplayMode === C.GRID_DISPLAY_MODE_POLAR) {
        const topLeftData = screenToData({ x: 0, y: 0 });
        const bottomRightData = screenToData({ x: canvasWidth, y: canvasHeight });
        const maxDataRadius = Math.hypot(Math.max(Math.abs(topLeftData.x), Math.abs(bottomRightData.x)), Math.max(Math.abs(topLeftData.y), Math.abs(bottomRightData.y)));
        const transitionRadius = Math.min(canvasWidth, canvasHeight) * C.POLAR_TO_LINE_TRANSITION_RADIUS_FACTOR;

        const drawPolarCircles = (interval, alpha) => {
            if (!interval || alpha < C.MIN_ALPHA_FOR_DRAWING) return;
            
            const screenSpacing = interval * viewTransform.scale / dpr;
            if (screenSpacing < C.GRID_POLAR_CIRCLE_MIN_SPACING) return;

            ctx.strokeStyle = `rgba(${colors.grid.join(',')}, ${alpha * gridAlpha})`;
            ctx.lineWidth = C.GRID_LINEWIDTH;
            for (let r = interval; r <= maxDataRadius; r += interval) {
                const screenRadius = r * viewTransform.scale / dpr;
                
                if (screenRadius > transitionRadius) {
                    const circle = { x: origin.x, y: origin.y, r: screenRadius };
                    const intersections = getCircleRectIntersections(circle, {x: 0, y: 0, w: canvasWidth, h: canvasHeight});
                    if (intersections.length >= 2) {
                        let p1 = intersections[0], p2 = intersections[1], maxDistSq = 0;
                        for (let i = 0; i < intersections.length; i++) {
                            for (let j = i + 1; j < intersections.length; j++) {
                                const dSq = (intersections[i].x - intersections[j].x)**2 + (intersections[i].y - intersections[j].y)**2;
                                if (dSq > maxDistSq) {
                                    maxDistSq = dSq;
                                    p1 = intersections[i];
                                    p2 = intersections[j];
                                }
                            }
                        }
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                } else {
                    if (isCircleInView(origin.x, origin.y, screenRadius, canvasWidth, canvasHeight)) {
                        ctx.beginPath();
                        ctx.arc(origin.x, origin.y, screenRadius, 0, C.RADIANS_IN_CIRCLE);
                        ctx.stroke();
                    }
                }
            }
        };

        drawPolarCircles(lastGridState.interval1, lastGridState.alpha1);
        drawPolarCircles(lastGridState.interval2, lastGridState.alpha2);

        const screenRadiusForSpokes = maxDataRadius * viewTransform.scale / dpr;
        const drawnAngles = new Set();
        
        let visibleAngleInfo = null;
        if (screenRadiusForSpokes < canvasWidth * 10) {
            visibleAngleInfo = { ranges: [[0, 360]], isFullCircle: true };
        } else {
            visibleAngleInfo = calculateVisibleAngleRange(origin, screenRadiusForSpokes, canvasWidth, canvasHeight);
        }

        if (!visibleAngleInfo) {
            ctx.restore();
            return;
        }

        lastAngularGridState.forEach(level => {
            if (level.alpha < C.MIN_ALPHA_FOR_DRAWING) return;

            const screenSeparation = screenRadiusForSpokes * (level.angle * Math.PI / 180);
            if (screenSeparation < C.GRID_POLAR_SPOKE_MIN_SPACING && screenRadiusForSpokes > C.GRID_POLAR_SPOKE_MIN_RADIUS) return;

            ctx.strokeStyle = `rgba(${colors.grid.join(',')}, ${level.alpha * gridAlpha})`;
            ctx.lineWidth = C.GRID_LINEWIDTH;

            let anglesToProcess = [];
            if (visibleAngleInfo.isFullCircle) {
                for (let deg = 0; deg < C.DEGREES_IN_CIRCLE; deg += level.angle) {
                    anglesToProcess.push(deg);
                }
            } else {
                visibleAngleInfo.ranges.forEach(range => {
                    const [min, max] = range;
                    anglesToProcess.push(...generateOptimizedAngleSequence(level.angle, min, max));
                });
                anglesToProcess = [...new Set(anglesToProcess)];
            }

            anglesToProcess.forEach(angle => {
                if (drawnAngles.has(angle)) return;

                const rad = angle * Math.PI / 180;
                const endX = origin.x + screenRadiusForSpokes * Math.cos(rad);
                const endY = origin.y - screenRadiusForSpokes * Math.sin(rad);
                ctx.beginPath();
                ctx.moveTo(origin.x, origin.y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                drawnAngles.add(angle);
            });
        });

    } else {
        const drawGridElements = (interval, alpha) => {
            if (!interval || alpha < C.MIN_ALPHA_FOR_DRAWING) return;
            const gridElementColor = `rgba(${colors.grid.join(',')}, ${alpha * gridAlpha})`;

            const start = screenToData({ x: 0, y: canvasHeight });
            const end = screenToData({ x: canvasWidth, y: 0 });
            const startTickX = Math.floor(start.x / interval) * interval;
            const endTickX = Math.ceil(end.x / interval) * interval;
            const startTickY = Math.floor(start.y / interval) * interval;
            const endTickY = Math.ceil(end.y / interval) * interval;

            if (gridDisplayMode === C.GRID_DISPLAY_MODE_LINES) {
                ctx.strokeStyle = gridElementColor;
                ctx.lineWidth = C.GRID_LINEWIDTH;
                for (let x = startTickX; x <= endTickX; x += interval) {
                    const screenX = dataToScreen({ x: x, y: 0 }).x;
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, canvasHeight);
                    ctx.stroke();
                }
                for (let y = startTickY; y <= endTickY; y += interval) {
                    const screenY = dataToScreen({ x: 0, y: y }).y;
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(canvasWidth, screenY);
                    ctx.stroke();
                }
            } else if (gridDisplayMode === C.GRID_DISPLAY_MODE_POINTS) {
                ctx.fillStyle = gridElementColor;
                const vertexRadius = C.GRID_POINT_RADIUS * dpr;
                for (let x = startTickX; x <= endTickX; x += interval) {
                    for (let y = startTickY; y <= endTickY; y += interval) {
                        const screenPos = dataToScreen({ x: x, y: y });
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, vertexRadius, 0, C.RADIANS_IN_CIRCLE);
                        ctx.fill();
                    }
                }
            } else if (gridDisplayMode === C.GRID_DISPLAY_MODE_TRIANGULAR) {
                ctx.fillStyle = gridElementColor;
                const vertexRadius = C.GRID_POINT_RADIUS * dpr;
                const y_step = interval * C.TRIANGULAR_GRID_Y_STEP_FACTOR;
                
                const startTickY_tri = Math.floor(start.y / y_step) * y_step;
                const endTickY_tri = Math.ceil(end.y / y_step) * y_step;
                
                for (let y = startTickY_tri; y <= endTickY_tri; y += y_step) {
                    const rowIndex = Math.round(y / y_step);
                    const x_offset = (rowIndex % 2 !== 0) ? interval / 2 : 0;
                    for (let x = startTickX; x <= endTickX; x += interval) {
                        const finalX = x + x_offset;
                        const screenPos = dataToScreen({ x: finalX, y: y });
                        ctx.beginPath();
                        ctx.arc(screenPos.x, screenPos.y, vertexRadius, 0, C.RADIANS_IN_CIRCLE);
                        ctx.fill();
                    }
                }
            }
        };
        drawGridElements(lastGridState.interval1, lastGridState.alpha1);
        drawGridElements(lastGridState.interval2, lastGridState.alpha2);
    }
    ctx.restore();
}

export function drawAngleArc(ctx, centerScreen, dataStartAngleRad, dataEndAngleRad, radius, color, isDashed = false) {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = C.GRID_LINEWIDTH;
    ctx.setLineDash(isDashed ? C.DASH_PATTERN_SMALL : []);
    const canvasStartAngle = -dataStartAngleRad;
    const canvasEndAngle = -dataEndAngleRad;
    let signedAngleDiffData = U.normalizeAngleToPi(dataEndAngleRad - dataStartAngleRad);
    ctx.beginPath();
    ctx.arc(centerScreen.x, centerScreen.y, radius, canvasStartAngle, canvasEndAngle, signedAngleDiffData > 0);
    ctx.stroke();
    ctx.restore();
}

export function drawVertex(ctx, vertex, { selectedVertexIds, selectedCenterIds, activeCenterId, colors, verticesVisible = true, isHovered = false }, dataToScreen, updateHtmlLabel) {
    let isSelected;
    if (vertex.type === C.POINT_TYPE_REGULAR) {
        isSelected = selectedVertexIds.includes(vertex.id);
        
        if (!verticesVisible && !isSelected && !isHovered) {
            return;
        }
    } else {
        isSelected = selectedCenterIds.includes(vertex.id);
    }

    const vertexColor = vertex.color || colors.vertex;
    const screenPos = dataToScreen(vertex);

    switch (vertex.type) {
        case C.POINT_TYPE_REGULAR:
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, C.VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            ctx.fillStyle = vertexColor;
            ctx.fill();
            break;
        case C.TRANSFORMATION_TYPE_ROTATION:
        case C.TRANSFORMATION_TYPE_SCALE:
        case C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE:
            const onCanvasIconSize = C.CENTER_POINT_VISUAL_RADIUS * 2;
            const icon = {
                type: vertex.type,
                x: screenPos.x - onCanvasIconSize / 2,
                y: screenPos.y - onCanvasIconSize / 2,
                width: onCanvasIconSize,
                height: onCanvasIconSize
            };
            drawUITransformationSymbols(ctx, icon, colors);
            break;
    }

    const shouldGlow = isSelected || isHovered;
    if (shouldGlow) {
        ctx.save();
        ctx.shadowColor = vertex.id === activeCenterId ? colors.activeCenterGlow : colors.selectionGlow;
        ctx.shadowBlur = C.SELECTION_GLOW_BLUR_RADIUS;
        ctx.globalAlpha = C.SELECTION_GLOW_ALPHA;

        ctx.beginPath();
        let glowRadius;
        if (vertex.type === C.POINT_TYPE_REGULAR) {
            glowRadius = C.VERTEX_RADIUS + C.SELECTION_GLOW_RADIUS_OFFSET;
        } else {
            glowRadius = C.CENTER_POINT_VISUAL_RADIUS + C.SELECTION_GLOW_RADIUS_OFFSET;
        }
        ctx.arc(screenPos.x, screenPos.y, glowRadius, 0, C.RADIANS_IN_CIRCLE);
        ctx.strokeStyle = vertex.id === activeCenterId ? colors.activeCenterGlow : colors.selectionGlow;
        ctx.lineWidth = C.SELECTION_GLOW_LINE_WIDTH;
        ctx.stroke();

        ctx.restore();
    }
}

export function drawAllEdges(ctx, { allEdges, selectedEdgeIds, isDragConfirmed, dragPreviewVertices, colors, edgesVisible }, dataToScreen, findVertexById, getEdgeId) {
    ctx.lineWidth = C.LINE_WIDTH;
    allEdges.forEach(edge => {
        const p1_orig = findVertexById(edge.id1);
        const p2_orig = findVertexById(edge.id2);
        if (!p1_orig || !p2_orig || p1_orig.type !== C.VERTEX_TYPE_REGULAR || p2_orig.type !== C.VERTEX_TYPE_REGULAR) return;

        const edgeId = getEdgeId(edge);
        const isSelected = selectedEdgeIds.includes(edgeId);
        
        if (!edgesVisible && !isSelected) return;

        let p1_render = { ...p1_orig };
        let p2_render = { ...p2_orig };
        let shouldBeDashed = false;

        if (isDragConfirmed && dragPreviewVertices.length > 0) {
            const p1Preview = dragPreviewVertices.find(dp => dp.id === p1_orig.id);
            const p2Preview = dragPreviewVertices.find(dp => dp.id === p2_orig.id);
            
            const p1BeingDragged = !!p1Preview;
            const p2BeingDragged = !!p2Preview;
            shouldBeDashed = p1BeingDragged !== p2BeingDragged;
            
            if (p1Preview) { p1_render.x = p1Preview.x; p1_render.y = p1Preview.y; }
            if (p2Preview) { p2_render.x = p2Preview.x; p2_render.y = p2Preview.y; }
        }

        const p1Screen = dataToScreen(p1_render);
        const p2Screen = dataToScreen(p2_render);

        ctx.beginPath();
        ctx.moveTo(p1Screen.x, p1Screen.y);
        ctx.lineTo(p2Screen.x, p2Screen.y);

        if (edge.colormapItem) {
            const gradient = ctx.createLinearGradient(p1Screen.x, p1Screen.y, p2Screen.x, p2Screen.y);
            const startColor = U.sampleColormap(edge.colormapItem, edge.gradientStart);
            const endColor = U.sampleColormap(edge.colormapItem, edge.gradientEnd);
            gradient.addColorStop(0, startColor);
            gradient.addColorStop(1, endColor);
            ctx.strokeStyle = gradient;
        } else {
            ctx.strokeStyle = edge.color || colors.defaultStroke;
        }

        ctx.setLineDash(shouldBeDashed ? C.DASH_PATTERN : []);
        ctx.lineWidth = C.LINE_WIDTH;
        ctx.stroke();
        ctx.setLineDash([]);

        if (isSelected) {
            ctx.beginPath();
            ctx.moveTo(p1Screen.x, p1Screen.y);
            ctx.lineTo(p2Screen.x, p2Screen.y);
            ctx.strokeStyle = colors.selectionGlow;
            ctx.globalAlpha = C.SELECTION_GLOW_ALPHA;
            ctx.lineWidth = C.LINE_WIDTH + C.EDGE_SELECTION_GLOW_WIDTH_OFFSET;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }
    });
    ctx.setLineDash([]);
    ctx.strokeStyle = colors.defaultStroke;
}

export function drawTransformIndicators(ctx, htmlOverlay, { transformIndicatorData, angleSigFigs, distanceSigFigs, colors }, dataToScreen, updateHtmlLabel) {
    if (!transformIndicatorData) return;

    const { center, startPos, currentPos, rotation, scale, isSnapping, snappedScaleValue, gridToGridInfo, transformType, directionalScale } = transformIndicatorData;

    const centerScreen = dataToScreen(center);
    const startScreen = dataToScreen(startPos);
    const color = isSnapping ? colors.feedbackSnapped : `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;

    ctx.save();
    ctx.setLineDash(C.DASH_PATTERN);
    ctx.strokeStyle = color;
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;

    if (transformType === C.TRANSFORMATION_TYPE_ROTATION) {
        const currentScreen = dataToScreen(currentPos);
        const startVecScreen = { x: startScreen.x - centerScreen.x, y: startScreen.y - centerScreen.y };
        const currentVecScreen = { x: currentScreen.x - centerScreen.x, y: currentScreen.y - centerScreen.y };
        const startAngleScreen = Math.atan2(startVecScreen.y, startVecScreen.x);
        const currentAngleScreen = Math.atan2(currentVecScreen.y, currentVecScreen.x);
        const arcRadius = Math.hypot(startVecScreen.x, startVecScreen.y);

        ctx.beginPath();
        ctx.moveTo(centerScreen.x, centerScreen.y);
        ctx.lineTo(startScreen.x, startScreen.y);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(centerScreen.x, centerScreen.y);
        ctx.lineTo(currentScreen.x, currentScreen.y);
        ctx.stroke();

        if (Math.abs(rotation) > C.MIN_TRANSFORM_ACTION_THRESHOLD) {
            const screenRotation = -rotation;
            const anticlockwise = rotation > 0;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(centerScreen.x, centerScreen.y, arcRadius, startAngleScreen, startAngleScreen + screenRotation, anticlockwise);
            ctx.stroke();
        }
    } else if (transformType === C.TRANSFORMATION_TYPE_SCALE || transformType === C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE) {
        const scaledPos = {
            x: center.x + (startPos.x - center.x) * scale,
            y: center.y + (startPos.y - center.y) * scale
        };
        const scaledScreen = dataToScreen(scaledPos);

        ctx.beginPath();
        ctx.moveTo(centerScreen.x, centerScreen.y);
        ctx.lineTo(startScreen.x, startScreen.y);
        ctx.stroke();

        if (Math.abs(scale - 1) > C.MIN_TRANSFORM_ACTION_THRESHOLD) {
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(centerScreen.x, centerScreen.y);
            ctx.lineTo(scaledScreen.x, scaledScreen.y);
            ctx.stroke();
        }
    }

    ctx.setLineDash([]);
    ctx.restore();

    if (transformType === C.TRANSFORMATION_TYPE_ROTATION && Math.abs(rotation) > C.MIN_TRANSFORM_ACTION_THRESHOLD) {
        const angleDeg = rotation * (180 / Math.PI);
        const angleText = `${parseFloat(angleDeg.toFixed(4)).toString()}^{\\circ}`;
        const startVecScreen = { x: startScreen.x - centerScreen.x, y: startScreen.y - centerScreen.y };
        const currentVecScreen = { x: dataToScreen(currentPos).x - centerScreen.x, y: dataToScreen(currentPos).y - centerScreen.y };
        const startAngleScreen = Math.atan2(startVecScreen.y, startVecScreen.x);
        const currentAngleScreen = Math.atan2(currentVecScreen.y, currentVecScreen.x);
        
        const bisectorAngle = startAngleScreen + (-rotation) / 2;
        const arcRadius = Math.hypot(startVecScreen.x, startVecScreen.y);
        const labelRadius = arcRadius + C.TRANSFORM_ANGLE_LABEL_OFFSET;
        const angleTextX = centerScreen.x + labelRadius * Math.cos(bisectorAngle);
        const angleTextY = centerScreen.y + labelRadius * Math.sin(bisectorAngle);

        updateHtmlLabel({ id: 'transform-angle-indicator', content: angleText, x: angleTextX, y: angleTextY, color: color, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } });
    } else {
        updateHtmlLabel({ id: 'transform-angle-indicator', content: '', x: 0, y: 0, color: color, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }

    if ((transformType === C.TRANSFORMATION_TYPE_SCALE || transformType === C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE) && Math.abs(scale - 1) > C.MIN_TRANSFORM_ACTION_THRESHOLD) {
        let scaleText;
        const effectiveScale = isSnapping && snappedScaleValue !== null ? snappedScaleValue : scale;
        
        if (Math.abs(effectiveScale - 1) < 0.001) {
            scaleText = `\\times 1`;
        } else if (isSnapping && gridToGridInfo) {
            const { startSquaredSum, snapSquaredSum, gridInterval } = gridToGridInfo;
            const [startCoeff, startRadicand] = U.simplifySquareRoot(startSquaredSum);
            const [snapCoeff, snapRadicand] = U.simplifySquareRoot(snapSquaredSum);
            
            if (startRadicand === 1 && snapRadicand === 1) {
                scaleText = `\\times \\frac{${snapCoeff}}{${startCoeff}}`;
            } else if (startRadicand === snapRadicand) {
                scaleText = `\\times \\frac{${snapCoeff}}{${startCoeff}}`;
            } else {
                const numerator = U.formatSimplifiedRoot(snapCoeff, snapRadicand);
                const denominator = U.formatSimplifiedRoot(startCoeff, startRadicand);
                scaleText = `\\times \\frac{${numerator}}{${denominator}}`;
            }
        } else if (isSnapping && snappedScaleValue !== null) {
            scaleText = `\\times ${U.formatFraction(snappedScaleValue, C.FRACTION_FORMAT_TOLERANCE, C.FRACTION_FORMAT_MAX_DENOMINATOR_TRANSFORM)}`;
        } else {
            const formattedScale = parseFloat(effectiveScale.toFixed(4)).toString();
            scaleText = `\\times ${formattedScale}`;
        }

        const midX = (centerScreen.x + startScreen.x) / 2;
        const midY = (centerScreen.y + startScreen.y) / 2;
        const lineAngle = Math.atan2(startScreen.y - centerScreen.y, startScreen.x - centerScreen.x);
        let textPerpAngle = lineAngle - Math.PI / 2;
        const scaleTextX = midX + Math.cos(textPerpAngle) * C.TRANSFORM_SCALE_LABEL_OFFSET;
        const scaleTextY = midY + Math.sin(textPerpAngle) * C.TRANSFORM_SCALE_LABEL_OFFSET;

        let rotationDeg = lineAngle * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
        if (rotationDeg > C.DEGREES_IN_QUADRANT || rotationDeg < -C.DEGREES_IN_QUADRANT) {
            rotationDeg += C.DEGREES_IN_HALF_CIRCLE;
        }

        updateHtmlLabel({ id: 'transform-scale-indicator', content: scaleText, x: scaleTextX, y: scaleTextY, color: color, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'bottom', rotation: rotationDeg } }, htmlOverlay);
    } else {
        updateHtmlLabel({ id: 'transform-scale-indicator', content: '', x: 0, y: 0, color: color, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'bottom' } }, htmlOverlay);
    }
}

export function drawReferenceElementsGeometry(ctx, context, dataToScreen, screenToData, { showAngles, showDistances, viewTransform, mousePos, colors }) {
    if ((!showAngles && !showDistances) || !context.frozen_Origin_Data_to_display) return;
    
    const startVertexData = context.frozen_Origin_Data_to_display;
    const mouseDataPos = screenToData(mousePos);
    const previewDistance = U.distance(startVertexData, mouseDataPos);
    
    if (previewDistance < C.GEOMETRY_CALCULATION_EPSILON) return;

    const refElementColor = colors.frozenReference;

    const turnAngleData = context.displayAngleA_valueRad_for_A_equals_label;
    const baseAngleData = context.frozen_A_baseRad_to_display !== null ? context.frozen_A_baseRad_to_display : 0;
    const distanceData = context.frozen_D_du_to_display;

    if (!startVertexData) return;

    const frozenOriginScreen = dataToScreen(startVertexData);
    const absoluteAngleForRefLine = baseAngleData + turnAngleData;

    ctx.save();
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
    ctx.strokeStyle = refElementColor;

    if (showAngles && context.displayAngleA_valueRad_for_A_equals_label !== null && Math.abs(context.displayAngleA_valueRad_for_A_equals_label) > C.GEOMETRY_CALCULATION_EPSILON) {
        const effectiveRadiusForLine = C.REF_ARC_RADIUS_SCREEN + ctx.lineWidth / 2;

        const dottedLineEndVertexData = {
            x: startVertexData.x + Math.cos(baseAngleData) * (effectiveRadiusForLine / viewTransform.scale),
            y: startVertexData.y + Math.sin(baseAngleData) * (effectiveRadiusForLine / viewTransform.scale)
        };
        const dottedLineEndVertexScreen = dataToScreen(dottedLineEndVertexData);

        ctx.beginPath();
        ctx.moveTo(frozenOriginScreen.x, frozenOriginScreen.y);
        ctx.lineTo(dottedLineEndVertexScreen.x, dottedLineEndVertexScreen.y);
        ctx.setLineDash(C.REF_LINE_DASH_PATTERN);
        ctx.stroke();

        drawAngleArc(ctx, frozenOriginScreen, baseAngleData, absoluteAngleForRefLine, C.REF_ARC_RADIUS_SCREEN, refElementColor, false);
    }
    ctx.restore();
}

export function prepareSnapInfoTexts(ctx, htmlOverlay, startVertexData, targetDataPos, snappedOutput, { showDistances, showAngles, currentShiftPressed, distanceSigFigs, angleSigFigs, angleDisplayMode, viewTransform, frozenReference_D_du, gridDisplayMode, frozenReference_A_rad, colors }, dataToScreen, drawingContext, updateHtmlLabel) {
    if ((!showAngles && !showDistances) || snappedOutput.distance < C.GEOMETRY_CALCULATION_EPSILON) {
        return;
    }

    const startScreen = dataToScreen(startVertexData);
    const { angle: snappedAbsoluteAngleDeg, distance: snappedDistanceData, lengthSnapFactor, angleSnapFactor, angleTurn, gridToGridSquaredSum, gridInterval } = snappedOutput;
    const { offsetAngleRad, isFirstSegmentBeingDrawn } = drawingContext;
    const currentElementColor = currentShiftPressed ? colors.feedbackSnapped : colors.geometryInfoText;
    const currentLineAbsoluteAngle = Math.atan2(targetDataPos.y - startVertexData.y, targetDataPos.x - startVertexData.x);

    if (snappedDistanceData * viewTransform.scale / window.devicePixelRatio < C.VERTEX_RADIUS) {
        return;
    }

    const isAngleFeedbackActive = showAngles && snappedDistanceData > C.GEOMETRY_CALCULATION_EPSILON && Math.abs(angleTurn) > C.GEOMETRY_CALCULATION_EPSILON;

    if (showDistances) {
        let distanceText = '';

        if (currentShiftPressed && !isFirstSegmentBeingDrawn && frozenReference_D_du !== null) {
            const currentExactDistance = snappedDistanceData;

            if (gridToGridSquaredSum !== null && gridInterval) {
                const actualGridDistance = gridInterval * Math.sqrt(gridToGridSquaredSum);
                if (Math.abs(actualGridDistance - frozenReference_D_du) < C.GEOMETRY_CALCULATION_EPSILON) {
                    distanceText = C.DELTA_SYMBOL_KATEX;
                } else {
                    let foundFraction = false;
                    for (const factor of C.SNAP_FACTORS) {
                        if (Math.abs(currentExactDistance / frozenReference_D_du - factor) < C.GEOMETRY_CALCULATION_EPSILON) {
                            distanceText = U.formatSnapFactor(factor, 'D');
                            foundFraction = true;
                            break;
                        }
                    }
                    if (!foundFraction) {
                        const [coeff, radicand] = U.simplifySquareRoot(gridToGridSquaredSum);
                        const finalCoeff = gridInterval * coeff;
                        const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                        distanceText = U.formatSimplifiedRoot(roundedFinalCoeff, radicand);
                    }
                }
            } else if (frozenReference_D_du > C.GEOMETRY_CALCULATION_EPSILON) {
                const ratio = currentExactDistance / frozenReference_D_du;
                let foundFraction = false;
                for (const factor of C.SNAP_FACTORS) {
                    if (Math.abs(ratio - factor) < C.GEOMETRY_CALCULATION_EPSILON) {
                        distanceText = U.formatSnapFactor(factor, 'D');
                        foundFraction = true;
                        break;
                    }
                }
                if (!foundFraction) {
                    distanceText = U.formatNumber(snappedDistanceData, distanceSigFigs);
                }
            } else {
                distanceText = U.formatNumber(snappedDistanceData, distanceSigFigs);
            }
        } else if (currentShiftPressed && isFirstSegmentBeingDrawn && gridDisplayMode !== C.GRID_DISPLAY_MODE_NONE && gridInterval) {
            if (gridToGridSquaredSum !== null && gridInterval) {
                if (gridToGridSquaredSum >= 0) {
                    const [coeff, radicand] = U.simplifySquareRoot(gridToGridSquaredSum);
                    const finalCoeff = gridInterval * coeff;
                    const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                    distanceText = U.formatSimplifiedRoot(roundedFinalCoeff, radicand);
                }
            } else {
                distanceText = U.formatNumber(snappedDistanceData, distanceSigFigs);
            }
        } else {
            distanceText = U.formatNumber(snappedDistanceData, distanceSigFigs);
        }

        if (distanceText) {
            const startScreenPos = dataToScreen(startVertexData);
            const endScreenPos = dataToScreen(targetDataPos);
            const edgeAngleScreen = Math.atan2(endScreenPos.y - startScreenPos.y, endScreenPos.x - startScreenPos.x);
            const midX = (startScreenPos.x + endScreenPos.x) / 2;
            const midY = (startScreenPos.y + endScreenPos.y) / 2;

            let textPerpAngle;

            if (isAngleFeedbackActive) {
                if (angleTurn > C.GEOMETRY_CALCULATION_EPSILON) {
                    textPerpAngle = edgeAngleScreen - Math.PI / 2;
                } else if (angleTurn < -C.GEOMETRY_CALCULATION_EPSILON) {
                    textPerpAngle = edgeAngleScreen + Math.PI / 2;
                } else {
                    textPerpAngle = edgeAngleScreen - Math.PI / 2;
                }
            } else {
                if (Math.abs(Math.sin(edgeAngleScreen)) < C.VERTICAL_LINE_COS_THRESHOLD) {
                    textPerpAngle = edgeAngleScreen - Math.PI / 2;
                } else if (Math.abs(Math.cos(edgeAngleScreen)) < C.VERTICAL_LINE_COS_THRESHOLD) {
                    textPerpAngle = edgeAngleScreen;
                    if (Math.sin(edgeAngleScreen) < 0) {
                        textPerpAngle += Math.PI / 2;
                    } else {
                        textPerpAngle -= Math.PI / 2;
                    }
                } else {
                    textPerpAngle = edgeAngleScreen - Math.PI / 2;
                    if (Math.sin(textPerpAngle) > 0) {
                        textPerpAngle += Math.PI;
                    }
                }
            }
            
            const distanceTextX = midX + Math.cos(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
            const distanceTextY = midY + Math.sin(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
            let rotationDeg = edgeAngleScreen * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
            if (rotationDeg > C.DEGREES_IN_QUADRANT || rotationDeg < -C.DEGREES_IN_QUADRANT) {
                rotationDeg += C.DEGREES_IN_HALF_CIRCLE;
            }
            updateHtmlLabel({ id: 'snap-dist', content: distanceText, x: distanceTextX, y: distanceTextY, color: currentElementColor, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle', rotation: rotationDeg } }, htmlOverlay);
        }
    }

    if (isAngleFeedbackActive) {
        const baseAngleForArc = isFirstSegmentBeingDrawn ? 0 : offsetAngleRad;

        drawAngleArc(ctx, startScreen, baseAngleForArc, currentLineAbsoluteAngle, C.FEEDBACK_ARC_RADIUS_SCREEN, currentElementColor);

        ctx.save();
        ctx.beginPath();
        const effectiveRadiusForLine = C.FEEDBACK_ARC_RADIUS_SCREEN + ctx.lineWidth / 2;
        const baseLineEndData = {
            x: startVertexData.x + (effectiveRadiusForLine / viewTransform.scale) * Math.cos(baseAngleForArc),
            y: startVertexData.y + (effectiveRadiusForLine / viewTransform.scale) * Math.sin(baseAngleForArc)
        };
        const baseLineEndScreen = dataToScreen(baseLineEndData);
        ctx.moveTo(startScreen.x, startScreen.y);
        ctx.lineTo(baseLineEndScreen.x, baseLineEndScreen.y);
        ctx.strokeStyle = currentElementColor;
        ctx.setLineDash(C.HELPER_LINE_DASH_PATTERN);
        ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
        ctx.stroke();
        ctx.restore();

        let angleText = '';
        const canReferToTheta = !isFirstSegmentBeingDrawn && frozenReference_A_rad !== null && Math.abs(frozenReference_A_rad) > C.GEOMETRY_CALCULATION_EPSILON;

        if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
            if (currentShiftPressed && canReferToTheta) {
                const referenceAngleRad = Math.abs(drawingContext.currentSegmentReferenceA_for_display);
                let potentialFactor = null;

                if (typeof angleSnapFactor === 'number') {
                    potentialFactor = angleSnapFactor;
                } else if (angleTurn !== null) {
                    if (Math.abs(referenceAngleRad) > C.GEOMETRY_CALCULATION_EPSILON) {
                        const calculatedFactor = angleTurn / referenceAngleRad;
                        for (const frac of C.NINETY_DEG_ANGLE_SNAP_FRACTIONS) {
                            if (Math.abs(Math.abs(calculatedFactor) - frac) < C.GEOMETRY_CALCULATION_EPSILON) {
                                potentialFactor = calculatedFactor < 0 ? -frac : frac;
                                break;
                            }
                        }
                    }
                }
                if (potentialFactor !== null && Math.abs(potentialFactor) > C.GEOMETRY_CALCULATION_EPSILON) {
                    angleText = U.formatSnapFactor(potentialFactor, 'A');
                } else {
                    let degrees = angleTurn * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
                    if (Math.abs(degrees) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = `${U.formatNumber(degrees, angleSigFigs)}^{\\circ}`;
                    }
                }
            } else {
                let angleToFormatRad = isFirstSegmentBeingDrawn ? currentLineAbsoluteAngle : angleTurn;
                if (currentShiftPressed && !isFirstSegmentBeingDrawn) {
                    let angleToFormatDeg = angleToFormatRad * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
                    if (Math.abs(angleToFormatDeg) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = `${U.formatNumber(angleToFormatDeg, angleSigFigs)}^{\\circ}`;
                    }
                } else {
                    let angleToFormatDeg = U.normalizeAngleToPi(angleToFormatRad) * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
                    if (Math.abs(angleToFormatDeg) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = `${U.formatNumber(angleToFormatDeg, angleSigFigs)}^{\\circ}`;
                    }
                }
            }
        } else if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_RADIANS) {
            if (currentShiftPressed && canReferToTheta) {
                const referenceAngleRad = Math.abs(drawingContext.currentSegmentReferenceA_for_display);
                let potentialFactor = null;

                if (typeof angleSnapFactor === 'number') {
                    potentialFactor = angleSnapFactor;
                } else if (angleTurn !== null) {
                    if (Math.abs(referenceAngleRad) > C.GEOMETRY_CALCULATION_EPSILON) {
                        const calculatedFactor = angleTurn / referenceAngleRad;
                        for (const frac of C.NINETY_DEG_ANGLE_SNAP_FRACTIONS) {
                            if (Math.abs(Math.abs(calculatedFactor) - frac) < C.GEOMETRY_CALCULATION_EPSILON) {
                                potentialFactor = calculatedFactor < 0 ? -frac : frac;
                                break;
                            }
                        }
                    }
                }
                if (potentialFactor !== null && Math.abs(potentialFactor) > C.GEOMETRY_CALCULATION_EPSILON) {
                    const fracStr = U.formatSnapFactor(potentialFactor, null);
                    angleText = `${fracStr === '0' ? '0' : fracStr + C.PI_SYMBOL_KATEX}`;
                    if (angleText.startsWith(`1${C.PI_SYMBOL_KATEX}`)) angleText = C.PI_SYMBOL_KATEX;
                    if (angleText.startsWith(`-1${C.PI_SYMBOL_KATEX}`)) angleText = `-${C.PI_SYMBOL_KATEX}`;
                    if (angleText === `0${C.PI_SYMBOL_KATEX}`) angleText = "0";
                } else {
                    let radians = angleTurn;
                    if (Math.abs(radians) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = U.formatNumber(radians, angleSigFigs);
                    }
                }
            } else {
                let angleToFormatRad = isFirstSegmentBeingDrawn ? currentLineAbsoluteAngle : angleTurn;
                if (currentShiftPressed && !isFirstSegmentBeingDrawn) {
                    let radians = angleToFormatRad;
                    if (Math.abs(radians) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = U.formatNumber(radians, angleSigFigs);
                    }
                } else {
                    let radians = U.normalizeAngleToPi(angleToFormatRad);
                    if (Math.abs(radians) > C.GEOMETRY_CALCULATION_EPSILON) {
                        angleText = U.formatNumber(radians, angleSigFigs);
                    }
                }
            }
        }

        if (angleText) {
            const canvasStartAngle = -baseAngleForArc;
            const canvasEndAngle = -currentLineAbsoluteAngle;
            const sumCos = Math.cos(canvasStartAngle) + Math.cos(canvasEndAngle);
            const sumSin = Math.sin(canvasStartAngle) + Math.sin(canvasEndAngle);
            let bisectorCanvasAngle = Math.atan2(sumSin, sumCos);
            const angleTextX = startScreen.x + Math.cos(bisectorCanvasAngle) * C.SNAP_ANGLE_LABEL_OFFSET;
            const angleTextY = startScreen.y + Math.sin(bisectorCanvasAngle) * C.SNAP_ANGLE_LABEL_OFFSET;
            updateHtmlLabel({ id: 'snap-angle', content: angleText, x: angleTextX, y: angleTextY, color: currentElementColor, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
        }
    }
}

export function prepareReferenceElementsTexts(htmlOverlay, context, { showAngles, showDistances, viewTransform, mousePos, frozenReference_D_du, distanceSigFigs, angleSigFigs, angleDisplayMode, colors }, screenToData, dataToScreen, updateHtmlLabel) {
    const dataThreshold = C.REF_TEXT_SCREEN_PIXEL_THRESHOLD / viewTransform.scale;

    let previewDistance = -1;
    if (context.frozen_Origin_Data_to_display) {
        const startVertexData = context.frozen_Origin_Data_to_display;
        const mouseDataPos = screenToData(mousePos);
        previewDistance = U.distance(startVertexData, mouseDataPos);
    }

    if ((!showAngles && !showDistances) || !context.frozen_Origin_Data_to_display || previewDistance < dataThreshold) {
        return;
    }

    const refElementColor = colors.frozenReference;

    const startVertexData = context.frozen_Origin_Data_to_display;
    const turnAngleData = context.displayAngleA_valueRad_for_A_equals_label;
    const baseAngleData = context.frozen_A_baseRad_to_display !== null ? context.frozen_A_baseRad_to_display : 0;
    const distanceData = context.frozen_D_du_to_display;
    const frozenG2GSquaredSum = context.frozen_D_g2g_to_display ? context.frozen_D_g2g_to_display.g2gSquaredSum : null;
    const frozenG2GInterval = context.frozen_D_g2g_to_display ? context.frozen_D_g2g_to_display.interval : null;

    if (!startVertexData) {
        return;
    }

    const absoluteAngleForRefLine = baseAngleData + turnAngleData;
    const endVertexData = {
        x: startVertexData.x + distanceData * Math.cos(absoluteAngleForRefLine),
        y: startVertexData.y + distanceData * Math.sin(absoluteAngleForRefLine)
    };

    const startVertexScreen = dataToScreen(startVertexData);
    const endVertexScreen = dataToScreen(endVertexData);

    if (showDistances && distanceData !== null && distanceData > dataThreshold && frozenReference_D_du !== null) {
        let distanceText = '';

        if (frozenG2GSquaredSum !== null && frozenG2GSquaredSum > 0 && frozenG2GInterval) {
            const [coeff, radicand] = U.simplifySquareRoot(frozenG2GSquaredSum);
            const finalCoeff = frozenG2GInterval * coeff;
            const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
            distanceText = `${C.DELTA_EQUALS_KATEX}${U.formatSimplifiedRoot(roundedFinalCoeff, radicand)}`;
        } else {
            const platonicValue = distanceData / C.DEFAULT_REFERENCE_DISTANCE;
            distanceText = `${C.DELTA_EQUALS_KATEX}${U.formatNumber(platonicValue, distanceSigFigs)}`;
        }

        const edgeAngleScreen = Math.atan2(endVertexScreen.y - startVertexScreen.y, endVertexScreen.x - startVertexScreen.x);
        const midX_screen = (startVertexScreen.x + endVertexScreen.x) / 2;
        const midY_screen = (startVertexScreen.y + endVertexScreen.y) / 2;
        
        let rotationDeg = edgeAngleScreen * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
        if (rotationDeg > C.DEGREES_IN_QUADRANT || rotationDeg < -C.DEGREES_IN_QUADRANT) {
            rotationDeg += C.DEGREES_IN_HALF_CIRCLE;
        }
        let textPerpAngle;

        if (showAngles && turnAngleData !== null && Math.abs(turnAngleData) > C.GEOMETRY_CALCULATION_EPSILON) {
            const canvasStartAngle = -baseAngleData;
            const canvasEndAngle = -(baseAngleData + turnAngleData);
            const sumCos = Math.cos(canvasStartAngle) + Math.cos(canvasEndAngle);
            const sumSin = Math.sin(canvasStartAngle) + Math.sin(canvasEndAngle);
            const angleLabelBisectorRad = Math.atan2(sumSin, sumCos);
            const perp1 = edgeAngleScreen - Math.PI / 2;
            const perp2 = edgeAngleScreen + Math.PI / 2;
            const diff1 = Math.abs(U.normalizeAngleToPi(perp1 - angleLabelBisectorRad));
            const diff2 = Math.abs(U.normalizeAngleToPi(perp2 - angleLabelBisectorRad));
            textPerpAngle = diff1 > diff2 ? perp1 : perp2;
        } else {
            textPerpAngle = edgeAngleScreen - Math.PI / 2;
            if (Math.sin(textPerpAngle) > 0) {
                textPerpAngle += Math.PI;
            }
        }
        const textDistLabelX_D = midX_screen + Math.cos(textPerpAngle) * C.REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN;
        const textDistLabelY_D = midY_screen + Math.sin(textPerpAngle) * C.REF_TEXT_DISTANCE_LABEL_OFFSET_SCREEN;

        updateHtmlLabel({ id: 'ref-dist', content: distanceText, x: textDistLabelX_D, y: textDistLabelY_D, color: refElementColor, fontSize: C.REF_TEXT_KATEX_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle', rotation: rotationDeg } }, htmlOverlay);
    }

    if (showAngles && turnAngleData !== null && Math.abs(turnAngleData) > C.GEOMETRY_CALCULATION_EPSILON) {
        const startAngleCanvas = -baseAngleData;
        const endAngleCanvas = -(baseAngleData + turnAngleData);

        const sumCos = Math.cos(startAngleCanvas) + Math.cos(endAngleCanvas);
        const sumSin = Math.sin(startAngleCanvas) + Math.sin(endAngleCanvas);
        let bisectorCanvasAngle = Math.atan2(sumSin, sumCos);
        const angleLabelOffsetDistance = C.REF_TEXT_ANGLE_LABEL_OFFSET_SCREEN;

        const textAngleLabelX_A = startVertexScreen.x + Math.cos(bisectorCanvasAngle) * angleLabelOffsetDistance;
        const textAngleLabelY_A = startVertexScreen.y + Math.sin(bisectorCanvasAngle) * angleLabelOffsetDistance;

        let aKatexText = '';
        if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
            let aValueDeg = turnAngleData * (C.DEGREES_IN_HALF_CIRCLE / Math.PI);
            aKatexText = `${C.THETA_EQUALS_KATEX}${U.formatNumber(aValueDeg, angleSigFigs)}^{\\circ}`;
        } else if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_RADIANS) {
            let aValueRad = turnAngleData;
            aKatexText = `${C.THETA_EQUALS_KATEX}${U.formatFraction(aValueRad / Math.PI, C.FRACTION_FORMAT_TOLERANCE, C.FRACTION_FORMAT_MAX_DENOMINATOR)}${C.PI_SYMBOL_KATEX}`;
            if (aKatexText === `${C.THETA_EQUALS_KATEX}1${C.PI_SYMBOL_KATEX}`) aKatexText = C.PI_SYMBOL_KATEX;
            if (aKatexText === `${C.THETA_EQUALS_KATEX}-1${C.PI_SYMBOL_KATEX}`) aKatexText = `-${C.PI_SYMBOL_KATEX}`;
            if (aKatexText === `${C.THETA_EQUALS_KATEX}0${C.PI_SYMBOL_KATEX}`) aKatexText = "0";
        }

        updateHtmlLabel({ id: 'ref-angle', content: aKatexText, x: textAngleLabelX_A, y: textAngleLabelY_A, color: refElementColor, fontSize: C.REF_TEXT_KATEX_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function updateMouseCoordinates(htmlOverlay, { coordsDisplayMode, isMouseOverCanvas, currentShiftPressed, ghostVertexPosition, gridDisplayMode, lastGridState, angleDisplayMode, canvas, dpr, mousePos, colors}, screenToData, updateHtmlLabel) {
    
    if (coordsDisplayMode === C.COORDS_DISPLAY_MODE_NONE || !mousePos || !isMouseOverCanvas) {
        return;
    }

    let displayPos;
    if (currentShiftPressed && ghostVertexPosition) {
        displayPos = ghostVertexPosition;
    } else {
        displayPos = screenToData(mousePos);
    }

    let effectiveGridInterval = 1;
    if (gridDisplayMode !== C.GRID_DISPLAY_MODE_NONE && lastGridState && lastGridState.interval1) {
        effectiveGridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
    }

    let decimalPlaces = 0;
    if (effectiveGridInterval > 0) {
        decimalPlaces = Math.max(0, -Math.floor(Math.log10(effectiveGridInterval * C.COORD_PRECISION_FACTOR)));
        decimalPlaces = Math.min(decimalPlaces + 1, C.MAX_COORD_DECIMAL_PLACES);
    }

    const angleDecimalPlaces = Math.min(decimalPlaces + 1, C.MAX_ANGLE_DECIMAL_PLACES);
    let textContent = '';

    switch (coordsDisplayMode) {
        case C.COORDS_DISPLAY_MODE_REGULAR: {
            let xValue = displayPos.x;
            let yValue = displayPos.y;
            let xText = xValue.toFixed(decimalPlaces);
            if (xValue >= 0) xText = `${C.KATEX_MINUS_PHANTOM}${xText}`;
            let yText = yValue.toFixed(decimalPlaces);
            if (yValue >= 0) yText = `${C.KATEX_MINUS_PHANTOM}${yText}`;
            textContent = `\\begin{pmatrix*}[r] x \\\\ y \\end{pmatrix*} = \\begin{pmatrix*}[r] ${xText} \\\\ ${yText} \\end{pmatrix*}`;
            break;
        }
        case C.COORDS_DISPLAY_MODE_COMPLEX: {
            let reValue = displayPos.x;
            let imValue = displayPos.y;
            let rePart = reValue.toFixed(decimalPlaces);
            if (reValue >= 0) rePart = `${C.KATEX_MINUS_PHANTOM}${rePart}`;
            let imPartAbs = Math.abs(imValue).toFixed(decimalPlaces);
            const sign = imValue < 0 ? '-' : '+';
            textContent = `z = ${rePart} ${sign} ${imPartAbs}${C.IMAGINARY_UNIT_SYMBOL}`;
            break;
        }
        case C.COORDS_DISPLAY_MODE_POLAR: {
            let rValue = Math.hypot(displayPos.x, displayPos.y);
            let thetaRaw = Math.atan2(displayPos.y, displayPos.x);
            let rText = rValue.toFixed(decimalPlaces);
            if (rValue >= 0) rText = `${C.KATEX_MINUS_PHANTOM}${rText}`;
            let angleStr;
            if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
                let thetaDeg = U.normalizeAngleDegrees(thetaRaw * 180 / Math.PI);
                angleStr = thetaDeg.toFixed(angleDecimalPlaces);
                if (thetaDeg >= 0) angleStr = `${C.KATEX_MINUS_PHANTOM}${angleStr}`;
                angleStr += `^{\\circ}`;
            } else {
                let thetaRad = U.normalizeAngleToPi(thetaRaw);
                angleStr = thetaRad.toFixed(angleDecimalPlaces);
                if (thetaRad >= 0) angleStr = `${C.KATEX_MINUS_PHANTOM}${angleStr}`;
            }
            textContent = `\\begin{pmatrix*}[r] r \\\\ \\theta \\end{pmatrix*} = \\begin{pmatrix*}[r] ${rText} \\\\ ${angleStr} \\end{pmatrix*}`;
            break;
        }
    }

    const canvasWidth = canvas.width / dpr;
    updateHtmlLabel({ id: 'mouse-coord-text', content: textContent, x: canvasWidth - C.UI_PADDING, y: C.UI_PADDING, color: colors.mouseCoords, fontSize: C.MOUSE_COORD_FONT_SIZE, options: { textAlign: 'right', textBaseline: 'top' } }, htmlOverlay);
}

export function createColorWheelIcon(size, dpr) {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = size * dpr;
    tempCanvas.height = size * dpr;
    const tempCtx = tempCanvas.getContext('2d');
    const imageData = tempCtx.createImageData(tempCanvas.width, tempCanvas.height);
    const pixels = imageData.data;
    const centerX = tempCanvas.width / 2;
    const centerY = tempCanvas.height / 2;
    const radius = tempCanvas.width / 2;
    for (let y = 0; y < tempCanvas.height; y++) {
        for (let x = 0; x < tempCanvas.width; x++) {
            const i = (y * tempCanvas.width + x) * 4;
            const dx = x - centerX;
            const dy = y - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > radius) continue;
            const hue = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
            const saturation = 100;
            const lightness = 50;
            let alpha;
            const fadeStartRadius = radius * C.COLOR_WHEEL_FADE_START_RADIUS_FACTOR;
            if (dist < fadeStartRadius) {
                alpha = 1.0;
            } else {
                const fadeDistance = radius - fadeStartRadius;
                alpha = 1.0 - ((dist - fadeStartRadius) / fadeDistance);
            }
            const [R, G, B] = U.hslToRgb(hue / 360, saturation / 100, lightness / 100);
            pixels[i] = R;
            pixels[i + 1] = G;
            pixels[i + 2] = B;
            pixels[i + 3] = Math.round(Math.max(0, alpha) * 255);
        }
    }
    tempCtx.putImageData(imageData, 0, 0);
    return tempCanvas;
}

function drawThemeIcon(ctx, rect, activeThemeName, colors) {
    ctx.save();
    const centerX = rect.x + rect.width / 2;
    const centerY = rect.y + rect.height / 2;
    const radius = rect.width / 2 * 0.6;

    ctx.strokeStyle = colors.uiIcon;
    ctx.fillStyle = colors.uiIcon;
    ctx.lineWidth = 2;

    if (activeThemeName === 'dark') {
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 0.7, 0, 2 * Math.PI);
        ctx.fill();
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * 2 * Math.PI;
            const startX = centerX + Math.cos(angle) * (radius * 0.85);
            const startY = centerY + Math.sin(angle) * (radius * 0.85);
            const endX = centerX + Math.cos(angle) * (radius * 1.1);
            const endY = centerY + Math.sin(angle) * (radius * 1.1);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
    } else {
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(centerX - 5, centerY - 3, radius, 0, 2 * Math.PI);
        ctx.fillStyle = colors.background;
        ctx.fill();
    }
    ctx.restore();
}

export function drawCoordsIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    const x_offset = 1;
    ctx.strokeStyle = colorStrong;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(2 + x_offset, 30); ctx.lineTo(30 + x_offset, 30);
    ctx.moveTo(2 + x_offset, 30); ctx.lineTo(2 + x_offset, 2);
    ctx.stroke();
    ctx.fillStyle = colorStrong;
    const vertex = { x: 16 + x_offset, y: 16 };
    let labelPos = { x: 17 + x_offset, y: 8 };
    let label = '';
    switch (mode) {
        case C.COORDS_DISPLAY_MODE_REGULAR:
            ctx.setLineDash(C.UI_ICON_DASH_PATTERN);
            ctx.beginPath();
            ctx.moveTo(vertex.x, vertex.y); ctx.lineTo(vertex.x, 30);
            ctx.moveTo(vertex.x, vertex.y); ctx.lineTo(2 + x_offset, vertex.y);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            ctx.fill();
            label = '(x,y)';
            break;
        case C.COORDS_DISPLAY_MODE_COMPLEX:
            ctx.setLineDash(C.UI_ICON_DASH_PATTERN);
            ctx.beginPath();
            ctx.moveTo(2 + x_offset, 30); ctx.lineTo(vertex.x, vertex.y);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            ctx.fill();
            label = 'x+iy';
            break;
        case C.COORDS_DISPLAY_MODE_POLAR:
            ctx.setLineDash(C.UI_ICON_DASH_PATTERN);
            ctx.beginPath();
            ctx.moveTo(2 + x_offset, 30); ctx.lineTo(vertex.x, vertex.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(2 + x_offset, 30, 8, -Math.atan2(30 - vertex.y, vertex.x - (2 + x_offset)), 0);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(vertex.x, vertex.y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            ctx.fill();
            label = '(r,\\theta)';
            break;
        case C.COORDS_DISPLAY_MODE_NONE:
            break;
    }
    ctx.restore();
    if (label) {
        const labelId = 'icon-label-coords';
        const labelColor = isSelected ? colors.uiTextSelected : colors.uiTextDefault;
        updateHtmlLabel({ id: labelId, content: label, x: center.x + (labelPos.x - 16) * scale, y: center.y + (labelPos.y - 16) * scale, color: labelColor, fontSize: C.UI_ICON_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function drawAngleIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    let sizeIncrease = 0;
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    ctx.strokeStyle = colorStrong;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    const p1 = { x: 28, y: 30 };
    const p2 = { x: 4, y: 30 };
    const p3 = { x: 16, y: 8 };
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.lineTo(p3.x, p3.y);
    ctx.stroke();
    let label = '';
    let labelPos = { x: 20, y: 22 };
    if (mode !== C.ANGLE_DISPLAY_MODE_NONE) {
        ctx.beginPath();
        const angle = Math.atan2(p3.y - p2.y, p3.x - p2.x);
        ctx.arc(p2.x, p2.y, 8, angle, 0);
        ctx.stroke();
        if (mode === C.ANGLE_DISPLAY_MODE_DEGREES) {
            label = '60^\\circ';
        } else if (mode === C.ANGLE_DISPLAY_MODE_RADIANS) {
            label = '\\frac{\\pi}{3}';
            sizeIncrease = 2
        }
    }
    ctx.restore();
    if (label) {
        const labelId = 'icon-label-angles';
        const labelColor = isSelected ? colors.uiTextSelected : colors.uiTextDefault;
        updateHtmlLabel({ id: labelId, content: label, x: center.x + (labelPos.x - 16) * scale, y: center.y + (labelPos.y - 20) * scale, color: labelColor, fontSize: C.UI_ICON_LABEL_FONT_SIZE+sizeIncrease, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function drawDistanceIcon(ctx, rect, mode, isSelected, htmlOverlay, updateHtmlLabel, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    ctx.strokeStyle = colorStrong;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    ctx.beginPath();
    ctx.moveTo(2, 30);
    ctx.lineTo(30, 30);
    ctx.stroke();
    let label = '';
    let labelPos = { x: 16, y: 22 };
    if (mode === C.DISTANCE_DISPLAY_MODE_ON) {
        label = '3.14';
    }
    ctx.restore();
    if (label) {
        const labelId = 'icon-label-distances';
        const labelColor = isSelected ? colors.uiTextSelected : colors.uiTextDefault;
        updateHtmlLabel({ id: labelId, content: label, x: center.x + (labelPos.x - 16) * scale, y: center.y + (labelPos.y - 16) * scale, color: labelColor, fontSize: 12, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
    }
}

export function drawGridIcon(ctx, rect, mode, isSelected, colors) {
    const colorStrong = isSelected ? colors.uiIconSelected : colors.uiIconDefault;
    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    ctx.save();
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    ctx.strokeStyle = colorStrong;
    ctx.fillStyle = colorStrong;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    switch (mode) {
        case C.GRID_DISPLAY_MODE_LINES:
            ctx.strokeRect(2, 2, 28, 28);
            ctx.beginPath();
            ctx.moveTo(2, 16); ctx.lineTo(30, 16);
            ctx.moveTo(16, 2); ctx.lineTo(16, 30);
            ctx.stroke();
            break;
        case C.GRID_DISPLAY_MODE_POINTS:
            ctx.strokeRect(2, 2, 28, 28);
            ctx.beginPath();
            [8, 16, 24].forEach(x => {
                [8, 16, 24].forEach(y => {
                    ctx.moveTo(x, y);
                    ctx.arc(x, y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
                });
            });
            ctx.fill();
            break;
        case C.GRID_DISPLAY_MODE_TRIANGULAR:
            ctx.strokeRect(2, 2, 28, 28);
            const triRadius = 8;
            const triCenterX = 16;
            const triCenterY = 16;
            ctx.beginPath();
            ctx.arc(triCenterX, triCenterY, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const x = triCenterX + triRadius * Math.cos(angle);
                const y = triCenterY + triRadius * Math.sin(angle);
                ctx.moveTo(x, y);
                ctx.arc(x, y, C.UI_ICON_VERTEX_RADIUS, 0, C.RADIANS_IN_CIRCLE);
            }
            ctx.fill();
            break;
        case C.GRID_DISPLAY_MODE_POLAR:
            ctx.beginPath();
            ctx.arc(16, 16, 14, 0, C.RADIANS_IN_CIRCLE);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(16, 16, 7, 0, C.RADIANS_IN_CIRCLE);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(2, 16); ctx.lineTo(30, 16);
            ctx.moveTo(16, 2); ctx.lineTo(16, 30);
            ctx.stroke();
            break;
        case C.GRID_DISPLAY_MODE_NONE:
            ctx.strokeRect(2, 2, 28, 28);
            break;
    }
    ctx.restore();
}

export function drawDisplayIcon(ctx, icon, state, htmlOverlay, updateHtmlLabel) {
    const { coordsDisplayMode, gridDisplayMode, angleDisplayMode, distanceDisplayMode, colors } = state;
    let isSelected = false;
    switch (icon.group) {
        case 'coords':
            isSelected = coordsDisplayMode !== C.COORDS_DISPLAY_MODE_NONE;
            break;
        case 'grid':
            isSelected = gridDisplayMode !== C.GRID_DISPLAY_MODE_NONE;
            break;
        case 'angles':
            isSelected = angleDisplayMode !== C.ANGLE_DISPLAY_MODE_NONE;
            break;
        case 'distances':
            isSelected = distanceDisplayMode === C.DISTANCE_DISPLAY_MODE_ON;
            break;
    }
    const rect = { x: icon.x, y: icon.y, width: icon.width, height: icon.height };
    switch (icon.group) {
        case 'coords':
            drawCoordsIcon(ctx, rect, coordsDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);
            break;
        case 'grid':
            drawGridIcon(ctx, rect, gridDisplayMode, isSelected, colors);
            break;
        case 'angles':
            drawAngleIcon(ctx, rect, angleDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);
            break;
        case 'distances':
            drawDistanceIcon(ctx, rect, distanceDisplayMode, isSelected, htmlOverlay, updateHtmlLabel, colors);
            break;
    }
}

function drawUITransformationSymbols(ctx, icon, colors) {
    const screenPos = { x: icon.x + icon.width / 2, y: icon.y + icon.height / 2 };
    const radius = icon.width / 2;
    ctx.strokeStyle = colors.uiIcon;
    ctx.fillStyle = colors.uiIcon;
    ctx.setLineDash([]);
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    ctx.save();
    ctx.translate(screenPos.x, screenPos.y);

    switch (icon.type) {
        case C.TRANSFORMATION_TYPE_ROTATION: {
            const arcAngle = -Math.PI / 4;
            
            ctx.beginPath();
            ctx.arc(0, 0, radius,  arcAngle,-arcAngle);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(0, 0, radius, Math.PI+arcAngle, Math.PI-arcAngle);
            ctx.stroke();
            
            const arrowSize = radius * 0.25;
            
            const arrow1X = radius * Math.cos(arcAngle);
            const arrow1Y = radius * Math.sin(arcAngle);
            
            ctx.save();
            ctx.translate(arrow1X, arrow1Y);
            ctx.rotate(arcAngle-Math.PI/2);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, -arrowSize * 0.5);
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, arrowSize * 0.5);
            ctx.stroke();
            ctx.restore();
            
            const arrow2X = radius * Math.cos(Math.PI + arcAngle);
            const arrow2Y = radius * Math.sin(Math.PI + arcAngle);
            
            ctx.save();
            ctx.translate(arrow2X, arrow2Y);
            ctx.rotate(arcAngle+Math.PI/2);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, -arrowSize * 0.5);
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowSize, arrowSize * 0.5);
            ctx.stroke();
            ctx.restore();
            break;
        }

        case C.TRANSFORMATION_TYPE_SCALE: {
            const lineLength = radius * 0.8;
            const arrowSize = radius * 0.25;
            
            ctx.beginPath();
            ctx.moveTo(-lineLength, 0);
            ctx.lineTo(lineLength, 0);
            ctx.moveTo(0, -lineLength);
            ctx.lineTo(0, lineLength);
            ctx.stroke();
            
            const arrowPositions = [
                { x: lineLength, y: 0, dirX: 1, dirY: 0 },
                { x: -lineLength, y: 0, dirX: -1, dirY: 0 },
                { x: 0, y: -lineLength, dirX: 0, dirY: -1 },
                { x: 0, y: lineLength, dirX: 0, dirY: 1 }
            ];
            
            arrowPositions.forEach(pos => {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize + pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize - pos.dirX * arrowSize * 0.5);
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize - pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize + pos.dirX * arrowSize * 0.5);
                ctx.stroke();
            });
            break;
        }

        case C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE: {
            const lineLength = radius * 0.8;
            const arrowSize = radius * 0.25;
            
            ctx.beginPath();
            ctx.moveTo(-lineLength / Math.sqrt(2), -lineLength / Math.sqrt(2));
            ctx.lineTo(lineLength / Math.sqrt(2), lineLength / Math.sqrt(2));
            ctx.moveTo(lineLength / Math.sqrt(2), -lineLength / Math.sqrt(2));
            ctx.lineTo(-lineLength / Math.sqrt(2), lineLength / Math.sqrt(2));
            ctx.stroke();
            
            const arrowPositions = [
                { 
                    x: lineLength / Math.sqrt(2), 
                    y: -lineLength / Math.sqrt(2), 
                    dirX: 1/Math.sqrt(2), 
                    dirY: -1/Math.sqrt(2)
                },
                { 
                    x: -lineLength / Math.sqrt(2), 
                    y: lineLength / Math.sqrt(2), 
                    dirX: -1/Math.sqrt(2), 
                    dirY: 1/Math.sqrt(2)
                }
            ];
            
            arrowPositions.forEach(pos => {
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize + pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize - pos.dirX * arrowSize * 0.5);
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x - pos.dirX * arrowSize - pos.dirY * arrowSize * 0.5, 
                           pos.y - pos.dirY * arrowSize + pos.dirX * arrowSize * 0.5);
                ctx.stroke();
            });
            break;
        }
    }
    ctx.restore();
}

export function drawVisibilityIcon(ctx, rect, colors) {
    const centerX = rect.x + rect.width / 2;
    const centerY = rect.y + rect.height / 2;
    const eyeWidth = rect.width * 0.6;
    const eyeHeight = rect.height * 0.3;
    
    ctx.save();
    ctx.strokeStyle = colors.uiIcon;
    ctx.fillStyle = colors.uiIcon;
    ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
    ctx.lineCap = 'round';
    
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, eyeWidth / 2, eyeHeight / 2, 0, 0, 2 * Math.PI);
    ctx.stroke();
    
    const pupilRadius = eyeHeight * 0.3;
    ctx.beginPath();
    ctx.arc(centerX, centerY, pupilRadius, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.restore();
}

function drawColorToolbarPreview(ctx, rect, { verticesVisible, edgesVisible, facesVisible, colorAssignments, allColors }, colors) {
    const options = {
        vertexState: verticesVisible ? 'filled' : 'outline',
        edgeState: edgesVisible ? 'solid' : 'dashed',
        faceState: facesVisible ? 'filled' : 'dotted'
    };
    
    const vertexColorIndex = colorAssignments[C.COLOR_TARGET_VERTEX];
    if (vertexColorIndex !== -1) {
        const vertexColorItem = allColors[vertexColorIndex];
        if (vertexColorItem && vertexColorItem.type === 'colormap') {
            options.vertexColormapItem = vertexColorItem;
        } else if (vertexColorItem && vertexColorItem.type === 'color') {
            options.vertexColor = vertexColorItem.value;
        }
    } else {
        options.vertexColor = colors.vertex;
    }
    
    const edgeColorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
    if (edgeColorIndex !== -1) {
        const edgeColorItem = allColors[edgeColorIndex];
        if (edgeColorItem && edgeColorItem.type === 'colormap') {
            options.edgeColormapItem = edgeColorItem;
        } else if (edgeColorItem && edgeColorItem.type === 'color') {
            options.edgeColor = edgeColorItem.value;
        }
    } else {
        options.edgeColor = colors.edge;
    }
    
    const faceColorIndex = colorAssignments[C.COLOR_TARGET_FACE];
    if (faceColorIndex !== -1) {
        const faceColorItem = allColors[faceColorIndex];
        if (faceColorItem && faceColorItem.type === 'color') {
            options.faceColor = faceColorItem.value;
        }
    } else {
        options.faceColor = colors.face;
    }
    
    drawTriangleIcon(ctx, rect, options, colors);
}

function drawTriangleIcon(ctx, rect, options, colors, isActive = false) {
    const { vertexState = 'none', edgeState = 'none', faceState = 'none', faceColor, edgeColor, vertexColor: optionsVertexColor } = options;
    
    ctx.save();
    
    if (isActive) {
        ctx.shadowColor = colors.activeCenterGlow;
        ctx.shadowBlur = 15;
    }

    const center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
    
    ctx.translate(center.x, center.y);
    const scale = rect.width / C.UI_ICON_BASE_SIZE;
    ctx.scale(scale, scale);
    ctx.translate(-16, -16);
    
    const triangleSize = 26;
    const height = triangleSize * Math.sqrt(3) / 2;
    
    const vertices = [
        { x: 16, y: 16 - height / 1.5 },
        { x: 16 - triangleSize / 2, y: 16 + height / 3 },
        { x: 16 + triangleSize / 2, y: 16 + height / 3 }
    ];

    const facePath = new Path2D();
    facePath.moveTo(vertices[0].x, vertices[0].y);
    facePath.lineTo(vertices[1].x, vertices[1].y);
    facePath.lineTo(vertices[2].x, vertices[2].y);
    facePath.closePath();
    
    if (faceState === 'filled' || faceState === 'dotted') {
        if (faceState === 'dotted') {
            const patternCanvas = document.createElement('canvas');
            const patternCtx = patternCanvas.getContext('2d');
            patternCanvas.width = 5;
            patternCanvas.height = 5;
            patternCtx.fillStyle = colors.uiIcon;
            patternCtx.beginPath();
            patternCtx.arc(1.5, 1.5, 1, 0, 2 * Math.PI);
            patternCtx.fill();
            ctx.fillStyle = ctx.createPattern(patternCanvas, 'repeat');
        } else {
            ctx.fillStyle = faceColor || colors.face;
        }
        ctx.fill(facePath);
    }
    
    if (edgeState === 'solid' || edgeState === 'dashed') {
        ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
        ctx.setLineDash(edgeState === 'dashed' ? C.UI_ICON_DASH_PATTERN : []);
        
        const edges = [
            [vertices[0], vertices[1]],
            [vertices[1], vertices[2]],
            [vertices[2], vertices[0]]
        ];
        
        edges.forEach((edge, edgeIndex) => {
            const [start, end] = edge;
            
            if (options.edgeColormapItem && options.edgeColormapItem.type === 'colormap') {
                const gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
                const edgeOffset = edges.length > 1 ? edgeIndex / (edges.length - 1) : 0.5;
                const startT = Math.max(0, Math.min(1, edgeOffset));
                const endT = Math.max(0, Math.min(1, edgeOffset + 0.3));
                const startColor = U.sampleColormap(options.edgeColormapItem, startT);
                const endColor = U.sampleColormap(options.edgeColormapItem, endT);
                gradient.addColorStop(0, startColor);
                gradient.addColorStop(1, endColor);
                ctx.strokeStyle = gradient;
            } else {
                ctx.strokeStyle = edgeColor || colors.edge;
            }
            
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
        });
    }
    
    if (vertexState === 'filled' || vertexState === 'outline') {
        ctx.lineWidth = C.UI_ICON_LINE_WIDTH_SMALL;
        
        vertices.forEach((vertex, index) => {
            let currentVertexColor = optionsVertexColor || colors.vertex;
            
            if (options.vertexColormapItem && options.vertexColormapItem.type === 'colormap') {
                const t = vertices.length > 1 ? index / (vertices.length - 1) : 0.5;
                currentVertexColor = U.sampleColormap(options.vertexColormapItem, t);
            }
            
            const vertexPath = new Path2D();
            vertexPath.moveTo(vertex.x + C.UI_ICON_VERTEX_RADIUS * 2, vertex.y);
            vertexPath.arc(vertex.x, vertex.y, C.UI_ICON_VERTEX_RADIUS * 2, 0, 2 * Math.PI);
            
            if (vertexState === 'filled') {
                ctx.fillStyle = currentVertexColor;
                ctx.setLineDash([]);
                ctx.fill(vertexPath);
            } else {
                ctx.strokeStyle = currentVertexColor;
                ctx.setLineDash(C.UI_ICON_DASH_PATTERN);
                ctx.stroke(vertexPath);
            }
        });
    }
    
    ctx.restore();
}

export function drawFace(ctx, screenVertices, color, colors) {
    if (screenVertices.length < 3) return;

    if (U.isSelfIntersecting(screenVertices)) {
        return;
    }

    ctx.save();
    ctx.fillStyle = color || colors.face;
    ctx.beginPath();
    screenVertices.forEach((vertex, index) => {
        if (index === 0) {
            ctx.moveTo(vertex.x, vertex.y);
        } else {
            ctx.lineTo(vertex.x, vertex.y);
        }
    });
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

export function drawFaces(ctx, { allFaces, facesVisible, isDragConfirmed, dragPreviewVertices, colors }, dataToScreen, findVertexById) {
    if (!facesVisible || !allFaces) return;

    const getLiveVertex = (vertexId) => {
        if (isDragConfirmed && dragPreviewVertices) {
            const previewVertex = dragPreviewVertices.find(p => p && p.id === vertexId);
            if (previewVertex) {
                return previewVertex;
            }
        }
        return findVertexById(vertexId);
    };

    allFaces.forEach(face => {
        const vertices = face.vertexIds.map(id => getLiveVertex(id)).filter(p => p && p.type === 'regular');
        if (vertices.length < 3) return;

        const screenVertices = vertices.map(v => dataToScreen(v));
        drawFace(ctx, screenVertices, face.color, colors);
    });
}

function drawVisibilityPanelIcon(ctx, icon, state, htmlOverlay, updateHtmlLabel, iconColors) {
    const { verticesVisible, edgesVisible, facesVisible, angleDisplayMode, distanceDisplayMode, colors } = state;
    
    const rect = { x: icon.x, y: icon.y, width: icon.width, height: icon.height };
    switch (icon.group) {
        case 'angles':
            drawAngleIcon(ctx, rect, angleDisplayMode, angleDisplayMode !== C.ANGLE_DISPLAY_MODE_NONE, htmlOverlay, updateHtmlLabel, colors);
            break;
        case 'distances':
            drawDistanceIcon(ctx, rect, distanceDisplayMode, distanceDisplayMode === C.DISTANCE_DISPLAY_MODE_ON, htmlOverlay, updateHtmlLabel, colors);
            break;
    }
}

function drawVisibilityPanel(ctx, htmlOverlay, state, updateHtmlLabel) {
    const { canvasUI, colorAssignments, allColors, colors } = state;

    const getColor = (target) => {
        if (!colorAssignments || !allColors) return colors.uiIcon;
        const colorIndex = colorAssignments[target];
        if (colorIndex === -1) return 'rgba(128, 128, 128, 1)';
        const item = allColors[colorIndex];
        if (!item) return colors.uiIcon;
        if (item.type === 'color') return item.value;
        return colors.uiIcon; 
    };

    const iconColors = {
        vertexColor: getColor(C.COLOR_TARGET_VERTEX),
        edgeColor: getColor(C.COLOR_TARGET_EDGE),
        faceColor: getColor(C.COLOR_TARGET_FACE)
    };

    canvasUI.visibilityIcons.forEach(icon => {
        drawVisibilityPanelIcon(ctx, icon, state, htmlOverlay, updateHtmlLabel, iconColors);
    });
}

function drawMainToolbar(ctx, htmlOverlay, state, updateHtmlLabel) {
   const { canvasUI, colors, activeThemeName, colorAssignments, allColors, verticesVisible, edgesVisible, facesVisible } = state;

   const btn = canvasUI.toolbarButton;
   ctx.strokeStyle = colors.uiDefault;
   ctx.lineWidth = C.UI_MENU_ICON_LINE_WIDTH;
   ctx.beginPath();
   for (let i = 0; i < 3; i++) {
       const lineY = btn.y + 5 + i * 10;
       ctx.moveTo(btn.x + 4, lineY);
       ctx.lineTo(btn.x + btn.width - 4, lineY);
   }
   ctx.stroke();

   const ctb = canvasUI.colorToolButton;
   if (ctb) {
       drawColorToolbarPreview(ctx, ctb, {
           verticesVisible,
           edgesVisible,
           facesVisible,
           colorAssignments,
           allColors
       }, colors);
   }

   const ttb = canvasUI.transformToolButton;
   if (ttb) {
       updateHtmlLabel({ id: 'transform-tool-label', content: C.UI_TRANSFORM_TOOL_LABEL_TEXT, x: ttb.x + ttb.width / 2, y: ttb.y + ttb.height / 2, color: colors.uiIcon, fontSize: C.UI_TRANSFORM_TOOL_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
   }

   const dtb = canvasUI.displayToolButton;
   if (dtb) {
       ctx.strokeStyle = colors.uiDefault;
       ctx.fillStyle = colors.uiDefault;
       ctx.lineWidth = C.UI_ICON_LINE_WIDTH;
       const barWidth = dtb.width - C.UI_DISPLAY_ICON_BAR_WIDTH_PADDING;
       for (let i = 0; i < 3; i++) {
           const y = dtb.y + C.UI_DISPLAY_ICON_Y_OFFSET + i * C.UI_DISPLAY_ICON_Y_SPACING;
           ctx.beginPath();
           ctx.moveTo(dtb.x + 6, y);
           ctx.lineTo(dtb.x + 6 + barWidth, y);
           ctx.stroke();
           ctx.beginPath();
           ctx.arc(dtb.x + 6 + barWidth * (i / 2), y, C.UI_DISPLAY_ICON_KNOB_RADIUS, 0, 2 * Math.PI);
           ctx.fill();
       }
   }

   const vtb = canvasUI.visibilityToolButton;
   if (vtb) {
       drawVisibilityIcon(ctx, vtb, colors);
   }

   const themeBtn = canvasUI.themeToggleButton;
   if (themeBtn) {
       drawThemeIcon(ctx, themeBtn, activeThemeName, colors);
   }
}

function drawColorPalette(ctx, htmlOverlay, state, updateHtmlLabel) {
    const { canvasUI, colors, allColors, namedColors, colorAssignments, activeColorTarget, verticesVisible, edgesVisible, facesVisible } = state;

    const checkerboardColor1 = '#808080';
    const checkerboardColor2 = '#c0c0c0';
    
    function drawCheckerboard(rect) {
        const tileSize = rect.height / 3;
        const numCols = Math.ceil(rect.width / tileSize);
        for (let row = 0; row < 3; row++) {
            for (let col = 0; col < numCols; col++) {
                ctx.fillStyle = (row + col) % 2 === 0 ? checkerboardColor1 : checkerboardColor2;
                const tileX = rect.x + col * tileSize;
                const tileY = rect.y + row * tileSize;
                const tileWidth = Math.min(tileSize, rect.x + rect.width - tileX);
                const tileHeight = Math.min(tileSize, rect.y + rect.height - tileY);
                if (tileWidth > 0 && tileHeight > 0) ctx.fillRect(tileX, tileY, tileWidth, tileHeight);
            }
        }
    }
    
    const applyBtn = canvasUI.applyColorsButton;
    if (applyBtn) {
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = C.UI_BUTTON_BORDER_WIDTH;
        ctx.strokeRect(applyBtn.x, applyBtn.y, applyBtn.width, applyBtn.height);
        const centerX = applyBtn.x + applyBtn.width / 2;
        const centerY = applyBtn.y + applyBtn.height / 2;
        const bucketSize = applyBtn.width * 0.6;
        ctx.fillStyle = colors.uiDefault;
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(centerX - bucketSize/3, centerY + bucketSize/4);
        ctx.lineTo(centerX + bucketSize/3, centerY + bucketSize/4);
        ctx.lineTo(centerX + bucketSize/4, centerY - bucketSize/4);
        ctx.lineTo(centerX - bucketSize/4, centerY - bucketSize/4);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX, centerY - bucketSize/4);
        ctx.lineTo(centerX + bucketSize/6, centerY - bucketSize/2);
        ctx.moveTo(centerX + bucketSize/6, centerY - bucketSize/2);
        ctx.lineTo(centerX + bucketSize/3, centerY - bucketSize/3);
        ctx.stroke();
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(centerX - bucketSize/6 + i * bucketSize/8, centerY - bucketSize/8, 1, 0, 2 * Math.PI);
            ctx.fill();
        }
    }

    const randomBtn = canvasUI.randomColorButton;
    if (randomBtn) {
        ctx.fillStyle = '#000000';
        ctx.fillRect(randomBtn.x, randomBtn.y, randomBtn.width, randomBtn.height);
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = C.UI_BUTTON_BORDER_WIDTH;
        ctx.strokeRect(randomBtn.x, randomBtn.y, randomBtn.width, randomBtn.height);
        const centerX = randomBtn.x + randomBtn.width / 2;
        const centerY = randomBtn.y + randomBtn.height / 2;
        const wheelRadius = randomBtn.width * 0.35;
        const segments = 8;
        for (let i = 0; i < segments; i++) {
            const angle1 = (i / segments) * 2 * Math.PI;
            const angle2 = ((i + 1) / segments) * 2 * Math.PI;
            const hue = (i / segments) * 360;
            ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, wheelRadius, angle1, angle2);
            ctx.closePath();
            ctx.fill();
        }
        ctx.fillStyle = colors.background;
        ctx.beginPath();
        ctx.arc(centerX, centerY, wheelRadius * 0.4, 0, 2 * Math.PI);
        ctx.fill();
    }

    const removeBtn = canvasUI.removeColorButton;
    if (removeBtn) {
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = C.UI_BUTTON_BORDER_WIDTH;
        ctx.strokeRect(removeBtn.x, removeBtn.y, removeBtn.width, removeBtn.height);
        ctx.beginPath();
        ctx.moveTo(removeBtn.x + C.UI_BUTTON_ICON_PADDING, removeBtn.y + removeBtn.height / 2);
        ctx.lineTo(removeBtn.x + removeBtn.width - C.UI_BUTTON_ICON_PADDING, removeBtn.y + removeBtn.height / 2);
        ctx.stroke();
    }

    canvasUI.colorSwatches.forEach((swatch) => {
        const colorItem = swatch.item;
        let hasAlpha = false;
        if (colorItem && colorItem.type === 'color') {
            const parsedColor = U.parseColor(colorItem.value);
            if (parsedColor && parsedColor.a < 1.0) hasAlpha = true;
        } else if (colorItem && colorItem.type === 'colormap') {
            if (colorItem.vertices.some(p => p.alpha !== undefined && p.alpha < 1.0)) hasAlpha = true;
        }
        if (hasAlpha) drawCheckerboard(swatch);
        if (colorItem && colorItem.type === 'colormap') {
            const gradient = ctx.createLinearGradient(swatch.x, swatch.y, swatch.x + swatch.width, swatch.y);
            colorItem.vertices.forEach(vertex => {
                let colorValue = vertex.color;
                if (typeof colorValue === 'string') colorValue = namedColors[colorValue] || [0, 0, 0];
                gradient.addColorStop(vertex.pos, `rgba(${colorValue.join(',')},${vertex.alpha || 1.0})`);
            });
            ctx.fillStyle = gradient;
        } else if (colorItem) {
            ctx.fillStyle = colorItem.value;
        }
        ctx.fillRect(swatch.x, swatch.y, swatch.width, swatch.height);
    });

    const addBtn = canvasUI.addColorButton;
    if (addBtn) {
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = C.UI_BUTTON_BORDER_WIDTH;
        ctx.strokeRect(addBtn.x, addBtn.y, addBtn.width, addBtn.height);
        ctx.beginPath();
        ctx.moveTo(addBtn.x + addBtn.width / 2, addBtn.y + C.UI_BUTTON_ICON_PADDING);
        ctx.lineTo(addBtn.x + addBtn.width / 2, addBtn.y + addBtn.height - C.UI_BUTTON_ICON_PADDING);
        ctx.moveTo(addBtn.x + C.UI_BUTTON_ICON_PADDING, addBtn.y + addBtn.height / 2);
        ctx.lineTo(addBtn.x + addBtn.width - C.UI_BUTTON_ICON_PADDING, addBtn.y + addBtn.height / 2);
        ctx.stroke();
    }

    if (canvasUI.colorTargetIcons) {
        const getIconOptions = (target) => {
            const colorIndex = colorAssignments[target];
            const colorItem = (colorIndex === -1) ? null : allColors[colorIndex];

            const options = {};
            if (target === C.COLOR_TARGET_VERTEX) {
                options.vertexState = verticesVisible ? 'filled' : 'outline';
                if (colorItem && colorItem.type === 'color') {
                    options.vertexColor = colorItem.value;
                } else if (colorItem && colorItem.type === 'colormap') {
                    options.vertexColormapItem = colorItem;
                }
            } else if (target === C.COLOR_TARGET_EDGE) {
                options.edgeState = edgesVisible ? 'solid' : 'dashed';
                if (colorItem && colorItem.type === 'color') {
                    options.edgeColor = colorItem.value;
                } else if (colorItem && colorItem.type === 'colormap') {
                    options.edgeColormapItem = colorItem;
                }
            } else if (target === C.COLOR_TARGET_FACE) {
                options.faceState = facesVisible ? 'filled' : 'dotted';
                if (colorItem && colorItem.type === 'color') {
                    options.faceColor = colorItem.value;
                }
            }
            return options;
        };

        const drawOrder = [C.COLOR_TARGET_FACE, C.COLOR_TARGET_EDGE, C.COLOR_TARGET_VERTEX];
        drawOrder.forEach(targetToDraw => {
            const icon = canvasUI.colorTargetIcons.find(i => i.target === targetToDraw);
            if (icon) {
                drawTriangleIcon(ctx, icon, getIconOptions(targetToDraw), colors, activeColorTarget === targetToDraw);
            }
        });
    }
}

function drawTransformPanel(ctx, state) {
    const { canvasUI, colors } = state;
    canvasUI.transformIcons.forEach(icon => {
        drawUITransformationSymbols(ctx, icon, colors);
    });
}

function drawDisplayPanel(ctx, htmlOverlay, state, updateHtmlLabel) {
    const { canvasUI, colors, colorAssignments, allColors, coordsDisplayMode, gridDisplayMode, angleDisplayMode, distanceDisplayMode } = state;
    

    canvasUI.displayIcons.forEach(icon => {
        const rect = { x: icon.x, y: icon.y, width: icon.width, height: icon.height };
        switch (icon.group) {
            case 'coords':
                drawCoordsIcon(ctx, rect, coordsDisplayMode, coordsDisplayMode !== C.COORDS_DISPLAY_MODE_NONE, htmlOverlay, updateHtmlLabel, colors);
                break;
            case 'grid':
                drawGridIcon(ctx, rect, gridDisplayMode, gridDisplayMode !== C.GRID_DISPLAY_MODE_NONE, colors);
                break;
        }
    });
}


export function drawCanvasUI(ctx, htmlOverlay, state, updateHtmlLabel) {
    const { dpr, isToolbarExpanded, isColorPaletteExpanded, isTransformPanelExpanded, isDisplayPanelExpanded, isVisibilityPanelExpanded,
        isPlacingTransform, placingTransformType, placingSnapPos, mousePos, colors } = state;

    ctx.save();
    ctx.resetTransform();
    ctx.scale(dpr, dpr);

    if (isToolbarExpanded) {
        drawMainToolbar(ctx, htmlOverlay, state, updateHtmlLabel);
    } else {
        const btn = state.canvasUI.toolbarButton;
        ctx.strokeStyle = colors.uiDefault;
        ctx.lineWidth = C.UI_MENU_ICON_LINE_WIDTH;
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
            const lineY = btn.y + 5 + i * 10;
            ctx.moveTo(btn.x + 4, lineY);
            ctx.lineTo(btn.x + btn.width - 4, lineY);
        }
        ctx.stroke();
    }

    if (isColorPaletteExpanded) {
        drawColorPalette(ctx, htmlOverlay, state, updateHtmlLabel);
    }
    if (isTransformPanelExpanded) {
        drawTransformPanel(ctx, state);
    }
    if (isDisplayPanelExpanded) {
        drawDisplayPanel(ctx, htmlOverlay, state, updateHtmlLabel);
    }
    if (isVisibilityPanelExpanded) {
        drawVisibilityPanel(ctx, htmlOverlay, state, updateHtmlLabel);
    }

    if (isPlacingTransform) {
        const finalDrawPos = placingSnapPos || mousePos;
        if (finalDrawPos) {
            const iconHalfSize = C.UI_GHOST_ICON_SIZE / 2;
            const ghostIcon = { type: placingTransformType, x: finalDrawPos.x - iconHalfSize, y: finalDrawPos.y - iconHalfSize, width: C.UI_GHOST_ICON_SIZE, height: C.UI_GHOST_ICON_SIZE };
            drawUITransformationSymbols(ctx, ghostIcon, colors);
        }
    }

    ctx.restore();
}

export function drawSelectedEdgeDistances(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showDistances, distanceSigFigs, colors, lastGridState }, findVertexById, getEdgeId, dataToScreen, updateHtmlLabel, currentVertexStates = null) {
    if (!showDistances || selectedEdgeIds.length === 0) return;

    const isVertexOnGrid = (vertex, interval) => {
        if (!vertex || !interval || interval <= 0) return false;
        const epsilon = interval * 1e-6;
        const isOnGridX = Math.abs(vertex.x / interval - Math.round(vertex.x / interval)) < epsilon;
        const isOnGridY = Math.abs(vertex.y / interval - Math.round(vertex.y / interval)) < epsilon;
        return isOnGridX && isOnGridY;
    };
    
    const gridInterval = (lastGridState && lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : (lastGridState ? lastGridState.interval1 : null);
    
    selectedEdgeIds.forEach(edgeId => {
        const edge = allEdges.find(e => getEdgeId(e) === edgeId);
        if (edge) {
            let p1 = findVertexById(edge.id1);
            let p2 = findVertexById(edge.id2);
            
            if (currentVertexStates) {
                const p1State = currentVertexStates.find(p => p.id === edge.id1);
                const p2State = currentVertexStates.find(p => p.id === edge.id2);
                if (p1State) p1 = p1State;
                if (p2State) p2 = p2State;
            }
            
            if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
                let distanceText;
                const areBothVerticesOnGrid = gridInterval && isVertexOnGrid(p1, gridInterval) && isVertexOnGrid(p2, gridInterval);

                if (areBothVerticesOnGrid) {
                    const deltaX = p1.x - p2.x;
                    const deltaY = p1.y - p2.y;
                    const dx_grid = Math.round(deltaX / gridInterval);
                    const dy_grid = Math.round(deltaY / gridInterval);
                    const g2gSquaredSumForDisplay = dx_grid * dx_grid + dy_grid * dy_grid;
                    if (g2gSquaredSumForDisplay === 0) {
                        distanceText = '0';
                    } else {
                        const [coeff, radicand] = U.simplifySquareRoot(g2gSquaredSumForDisplay);
                        const finalCoeff = gridInterval * coeff;
                        const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                        distanceText = U.formatSimplifiedRoot(roundedFinalCoeff, radicand);
                    }
                } else {
                    const edgeLength = U.distance(p1, p2);
                    distanceText = U.formatNumber(edgeLength, distanceSigFigs);
                }
                
                const p1Screen = dataToScreen(p1);
                const p2Screen = dataToScreen(p2);
                const midX = (p1Screen.x + p2Screen.x) / 2;
                const midY = (p1Screen.y + p2Screen.y) / 2;
                const edgeAngleScreen = Math.atan2(p2Screen.y - p1Screen.y, p2Screen.x - p1Screen.x);
                
                let textPerpAngle = edgeAngleScreen - Math.PI / 2;
                if (Math.sin(textPerpAngle) > 0) {
                    textPerpAngle += Math.PI;
                }
                
                const distanceTextX = midX + Math.cos(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                const distanceTextY = midY + Math.sin(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                
                let rotationDeg = edgeAngleScreen * (180 / Math.PI);
                if (rotationDeg > 90 || rotationDeg < -90) {
                    rotationDeg += 180;
                }
                
                updateHtmlLabel({ 
                    id: `selected-edge-dist-${edgeId}`, 
                    content: distanceText, 
                    x: distanceTextX, 
                    y: distanceTextY, 
                    color: `rgba(${colors.feedbackDefault.join(',')}, 1.0)`, 
                    fontSize: C.FEEDBACK_LABEL_FONT_SIZE, 
                    options: { textAlign: 'center', textBaseline: 'middle', rotation: rotationDeg } 
                });
            }
        }
    });
}

export function drawSelectionRectangle(ctx, startPos, currentPos, colors) {
    ctx.save();
    ctx.strokeStyle = colors.mouseCoords;
    ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
    ctx.setLineDash(C.DASH_PATTERN);

    const rX = Math.min(startPos.x, currentPos.x);
    const rY = Math.min(startPos.y, currentPos.y);
    const rW = Math.abs(startPos.x - currentPos.x);
    const rH = Math.abs(startPos.y - currentPos.y);

    ctx.strokeRect(rX, rY, rW, rH);
    ctx.restore();
}

export function drawDragFeedback(ctx, htmlOverlay, targetVertexId, currentVertexStates, { lastGridState, showDistances, showAngles, distanceSigFigs, angleDisplayMode, angleSigFigs, currentShiftPressed, viewTransform, colors }, dataToScreen, findNeighbors, getEdgeId, isSnapping = false, excludedEdgeId = null, updateHtmlLabel = null, selectedVertexIds = [], isDragging = false, initialDragVertexStates = [], activeCenterId = null) {
    const feedbackColor = isSnapping ? colors.feedbackSnapped : `rgba(${colors.feedbackDefault.join(',')}, 1.0)`;

    const liveVertices = new Map(currentVertexStates.map(p => [p.id, { ...p }]));
    const getLiveVertex = (id) => liveVertices.get(id);

    const vertex = getLiveVertex(targetVertexId);
    if (!vertex) return;

    const neighbors = findNeighbors(vertex.id).map(getLiveVertex).filter(Boolean);
    const vertexScreen = dataToScreen(vertex);
    const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

    const isVertexOnGrid = (vertex, interval) => {
        if (!vertex || !interval || interval <= 0) return false;
        const epsilon = interval * 1e-6;
        const isOnGridX = Math.abs(vertex.x / interval - Math.round(vertex.x / interval)) < epsilon;
        const isOnGridY = Math.abs(vertex.y / interval - Math.round(vertex.y / interval)) < epsilon;
        return isOnGridX && isOnGridY;
    };

    const allNeighborsAreDragged = neighbors.every(n => selectedVertexIds.includes(n.id));
    const originalVertexState = initialDragVertexStates.find(p => p.id === targetVertexId);

    if (!activeCenterId && isDragging && currentShiftPressed && allNeighborsAreDragged && originalVertexState && U.distance(originalVertexState, vertex) > C.GEOMETRY_CALCULATION_EPSILON) {
        const p1Screen = dataToScreen(originalVertexState);
        const p2Screen = vertexScreen;
        const dragVectorAngle = Math.atan2(p2Screen.y - p1Screen.y, p2Screen.x - p1Screen.x);

        if (showDistances) {
            let distText;
            const dragStartedOnGrid = gridInterval && isVertexOnGrid(originalVertexState, gridInterval);
            const dragEndedOnGrid = gridInterval && isVertexOnGrid(vertex, gridInterval);
            if (dragStartedOnGrid && dragEndedOnGrid) {
                const deltaX = vertex.x - originalVertexState.x;
                const deltaY = vertex.y - originalVertexState.y;
                const dx_grid = Math.round(deltaX / gridInterval);
                const dy_grid = Math.round(deltaY / gridInterval);
                const g2gSquaredSumForDisplay = dx_grid * dx_grid + dy_grid * dy_grid;
                if (g2gSquaredSumForDisplay === 0) {
                    distText = '0';
                } else {
                    const [coeff, radicand] = U.simplifySquareRoot(g2gSquaredSumForDisplay);
                    const finalCoeff = gridInterval * coeff;
                    const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                    distText = U.formatSimplifiedRoot(roundedFinalCoeff, radicand);
                }
            } else {
                distText = U.formatNumber(U.distance(originalVertexState, vertex), distanceSigFigs);
            }
            const midX = (p1Screen.x + p2Screen.x) / 2;
            const midY = (p1Screen.y + p2Screen.y) / 2;
            let textPerpAngle = dragVectorAngle - Math.PI / 2;
            if (Math.sin(textPerpAngle) > 0) {
                textPerpAngle += Math.PI;
            }
            const distanceTextX = midX + Math.cos(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
            const distanceTextY = midY + Math.sin(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
            let rotationDeg = dragVectorAngle * (180 / Math.PI);
            if (rotationDeg > 90 || rotationDeg < -90) {
                rotationDeg += 180;
            }
            updateHtmlLabel({ id: `drag-dist-vector-${vertex.id}`, content: distText, x: distanceTextX, y: distanceTextY, color: feedbackColor, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle', rotation: rotationDeg } }, htmlOverlay);
        }

        ctx.save();
        ctx.setLineDash(C.DASH_PATTERN);
        ctx.strokeStyle = feedbackColor;
        ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
        ctx.beginPath();
        ctx.moveTo(p1Screen.x, p1Screen.y);
        ctx.lineTo(p2Screen.x, p2Screen.y);
        ctx.stroke();
        ctx.restore();
        
        if (showAngles && Math.abs(dragVectorAngle) > C.GEOMETRY_CALCULATION_EPSILON) {
            const dataAngle = Math.atan2(vertex.y - originalVertexState.y, vertex.x - originalVertexState.x);
            drawAngleArc(ctx, p1Screen, 0, dataAngle, C.FEEDBACK_ARC_RADIUS_SCREEN, feedbackColor);
            
            let angleText;
            if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
                angleText = `${U.formatNumber(dataAngle * (180 / Math.PI), angleSigFigs)}^{\\circ}`;
            } else {
                angleText = U.formatNumber(dataAngle, angleSigFigs);
            }

            if (angleText) {
                const bisectorAngle = -dataAngle / 2.0;
                const angleLabelScreenPos = {
                    x: p1Screen.x + C.ANGLE_LABEL_RADIUS_SCREEN * Math.cos(bisectorAngle),
                    y: p1Screen.y + C.ANGLE_LABEL_RADIUS_SCREEN * Math.sin(bisectorAngle)
                };
                updateHtmlLabel({ id: `drag-angle-vector-${vertex.id}`, content: angleText, x: angleLabelScreenPos.x, y: angleLabelScreenPos.y, color: feedbackColor, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
            }
        }
    }
    
    if (showDistances) {
        neighbors.forEach(neighbor => {
            const isNeighborSelected = selectedVertexIds.includes(neighbor.id);
            if (!isDragging || !isNeighborSelected) {
                const p1 = vertex;
                const p2 = neighbor;
                const edgeId = getEdgeId({ id1: p1.id, id2: p2.id });
                let distanceText;
                const areBothVerticesOnGrid = gridInterval && isVertexOnGrid(p1, gridInterval) && isVertexOnGrid(p2, gridInterval);

                if (areBothVerticesOnGrid) {
                    const deltaX = p1.x - p2.x;
                    const deltaY = p1.y - p2.y;
                    const dx_grid = Math.round(deltaX / gridInterval);
                    const dy_grid = Math.round(deltaY / gridInterval);
                    const g2gSquaredSumForDisplay = dx_grid * dx_grid + dy_grid * dy_grid;
                    if (g2gSquaredSumForDisplay === 0) {
                        distanceText = '0';
                    } else {
                        const [coeff, radicand] = U.simplifySquareRoot(g2gSquaredSumForDisplay);
                        const finalCoeff = gridInterval * coeff;
                        const roundedFinalCoeff = parseFloat(finalCoeff.toFixed(10));
                        distanceText = U.formatSimplifiedRoot(roundedFinalCoeff, radicand);
                    }
                } else {
                    const edgeLength = U.distance(p1, p2);
                    distanceText = U.formatNumber(edgeLength, distanceSigFigs);
                }
                
                const p1Screen = dataToScreen(p1);
                const p2Screen = dataToScreen(p2);
                const midX = (p1Screen.x + p2Screen.x) / 2;
                const midY = (p1Screen.y + p2Screen.y) / 2;
                const edgeAngleScreen = Math.atan2(p2Screen.y - p1Screen.y, p2Screen.x - p1Screen.x);
                
                let textPerpAngle = edgeAngleScreen - Math.PI / 2;
                if (Math.sin(textPerpAngle) > 0) {
                    textPerpAngle += Math.PI;
                }
                
                const distanceTextX = midX + Math.cos(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                const distanceTextY = midY + Math.sin(textPerpAngle) * C.FEEDBACK_DISTANCE_LABEL_OFFSET_SCREEN;
                
                let rotationDeg = edgeAngleScreen * (180 / Math.PI);
                if (rotationDeg > 90 || rotationDeg < -90) {
                    rotationDeg += 180;
                }
                
                updateHtmlLabel({ 
                    id: `drag-dist-${edgeId}`, 
                    content: distanceText, 
                    x: distanceTextX, 
                    y: distanceTextY, 
                    color: feedbackColor, 
                    fontSize: C.FEEDBACK_LABEL_FONT_SIZE, 
                    options: { textAlign: 'center', textBaseline: 'middle', rotation: rotationDeg } 
                });
            }
        });
    }
    
    if (showAngles && neighbors.length >= 2 && (!isDragging || neighbors.some(n => !selectedVertexIds.includes(n.id)))) {
        const sortedNeighbors = [...neighbors].sort((a, b) => {
            const angleA = Math.atan2(a.y - vertex.y, a.x - vertex.x);
            const angleB = Math.atan2(b.y - vertex.y, b.x - vertex.x);
            return angleA - angleB;
        });

        for (let i = 0; i < sortedNeighbors.length; i++) {
            const p1 = sortedNeighbors[i];
            const p2 = sortedNeighbors[(i + 1) % sortedNeighbors.length];
            
            const p1IsSelected = selectedVertexIds.includes(p1.id);
            const p2IsSelected = selectedVertexIds.includes(p2.id);
            const angleIsChanging = !isDragging || !p1IsSelected || !p2IsSelected;
            
            if (!angleIsChanging) continue;
            
            const v1 = { x: p1.x - vertex.x, y: p1.y - vertex.y };
            const v2 = { x: p2.x - vertex.x, y: p2.y - vertex.y };
            const angle1_data = Math.atan2(v1.y, v1.x);
            const angle2_data = Math.atan2(v2.y, v2.x);
            let angleToDisplayRad = angle2_data - angle1_data;
            if (angleToDisplayRad < 0) {
                angleToDisplayRad += 2 * Math.PI;
            }
            if (angleToDisplayRad < C.GEOMETRY_CALCULATION_EPSILON) continue;
            
            const bisectorAngle = angle1_data + (angleToDisplayRad / 2);
            ctx.save();
            ctx.strokeStyle = feedbackColor;
            ctx.lineWidth = C.FEEDBACK_LINE_VISUAL_WIDTH;
            ctx.beginPath();
            ctx.arc(vertexScreen.x, vertexScreen.y, C.FEEDBACK_ARC_RADIUS_SCREEN, -angle1_data, -angle2_data, false);
            ctx.stroke();
            ctx.restore();

            let angleText;
            if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_DEGREES) {
                angleText = `${U.formatNumber(angleToDisplayRad * (180 / Math.PI), angleSigFigs)}^{\\circ}`;
            } else if (angleDisplayMode === C.ANGLE_DISPLAY_MODE_RADIANS) {
                if (currentShiftPressed) {
                    angleText = U.formatFraction(angleToDisplayRad / Math.PI, 0.015, 32) + "\\pi";
                    if (angleText.startsWith(`1\\pi`)) angleText = "\\pi";
                    if (angleText.startsWith(`-1\\pi`)) angleText = `-\\pi`;
                    if (angleText === `0\\pi`) angleText = "0";
                } else {
                    angleText = U.formatNumber(angleToDisplayRad, angleSigFigs);
                }
            }

            if (angleText) {
                const angleLabelDataPos = {
                    x: vertex.x + (C.ANGLE_LABEL_RADIUS_SCREEN / viewTransform.scale) * Math.cos(bisectorAngle),
                    y: vertex.y + (C.ANGLE_LABEL_RADIUS_SCREEN / viewTransform.scale) * Math.sin(bisectorAngle)
                };
                const angleLabelScreenPos = dataToScreen(angleLabelDataPos);
                const labelId = `drag-angle-${vertex.id}-${p1.id}-${p2.id}`;
                updateHtmlLabel({ id: labelId, content: angleText, x: angleLabelScreenPos.x, y: angleLabelScreenPos.y, color: feedbackColor, fontSize: C.FEEDBACK_LABEL_FONT_SIZE, options: { textAlign: 'center', textBaseline: 'middle' } }, htmlOverlay);
            }
        }
    }
}

export function drawSelectedEdgeAngles(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showAngles, angleSigFigs, angleDisplayMode, currentShiftPressed, distanceSigFigs, viewTransform, lastGridState, colors }, findVertexById, getEdgeId, dataToScreen, findNeighbors, updateHtmlLabel) {
    if (!showAngles || selectedEdgeIds.length === 0) return;
    
    selectedEdgeIds.forEach(edgeId => {
        const edge = allEdges.find(e => getEdgeId(e) === edgeId);
        if (edge) {
            const p1 = findVertexById(edge.id1);
            const p2 = findVertexById(edge.id2);
            if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
                const feedbackState = {
                    lastGridState,
                    showDistances: false,
                    showAngles: true,
                    distanceSigFigs,
                    angleDisplayMode,
                    angleSigFigs,
                    currentShiftPressed,
                    viewTransform,
                    colors
                };
                
                drawDragFeedback(ctx, htmlOverlay, p1.id, [p1, p2], feedbackState, dataToScreen, findNeighbors, getEdgeId, false, null, updateHtmlLabel);
                drawDragFeedback(ctx, htmlOverlay, p2.id, [p1, p2], feedbackState, dataToScreen, findNeighbors, getEdgeId, false, null, updateHtmlLabel);
            }
        }
    });
}

export function drawFaceCoordinateSystems(ctx, { allFaces, selectedFaceIds, colors, isDragConfirmed, dragPreviewVertices }, dataToScreen, findVertexById) {
    const facesToDraw = new Set(selectedFaceIds);
    if (facesToDraw.size === 0) return;

    const getLiveVertex = (vertexId) => {
        if (isDragConfirmed && dragPreviewVertices) {
            const previewVertex = dragPreviewVertices.find(p => p && p.id === vertexId);
            if (previewVertex) return previewVertex;
        }
        return findVertexById(vertexId);
    };

    facesToDraw.forEach(faceId => {
        const face = allFaces.find(f => f.id === faceId);
        if (!face || !face.localCoordSystem) return;

        const vertices = face.vertexIds
            .map(id => getLiveVertex(id))
            .filter(p => p && p.type === 'regular');

        if (vertices.length < 3) return;

        if (isDragConfirmed && !face.localCoordSystem.isCustom) {
            updateFaceCoordinateSystemForDrag(face, vertices);
        }

        drawCoordinateSystemCross(ctx, face.localCoordSystem, colors, dataToScreen);
    });
}

function updateFaceCoordinateSystemForDrag(face, liveVertices) {
    const incircle = U.calculateIncenter(liveVertices);
    if (incircle) {
        face.localCoordSystem.origin = incircle.center;
        face.localCoordSystem.scale = incircle.radius;
    }
}

function drawCoordinateSystemCross(ctx, coordSystem, colors, dataToScreen) {
    const centerScreen = dataToScreen(coordSystem.origin);

    const xAxisEnd = U.localToGlobal({ x: 1, y: 0 }, coordSystem);
    const yAxisEnd = U.localToGlobal({ x: 0, y: 1 }, coordSystem);
    const negXAxisEnd = U.localToGlobal({ x: -1, y: 0 }, coordSystem);
    const negYAxisEnd = U.localToGlobal({ x: 0, y: -1 }, coordSystem);

    const xAxisScreenEnd = dataToScreen(xAxisEnd);
    const yAxisScreenEnd = dataToScreen(yAxisEnd);
    const negXAxisScreenEnd = dataToScreen(negXAxisEnd);
    const negYAxisScreenEnd = dataToScreen(negYAxisEnd);

    ctx.save();

    // Add glow for visibility
    ctx.shadowColor = colors.selectionGlow;
    ctx.shadowBlur = C.SELECTION_GLOW_BLUR_RADIUS;
    ctx.globalAlpha = C.SELECTION_GLOW_ALPHA;

    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.strokeStyle = colors.uiIcon;

    // Draw X-axis
    ctx.beginPath();
    ctx.moveTo(negXAxisScreenEnd.x, negXAxisScreenEnd.y);
    ctx.lineTo(xAxisScreenEnd.x, xAxisScreenEnd.y);
    ctx.stroke();

    // Draw Y-axis
    ctx.beginPath();
    ctx.moveTo(negYAxisScreenEnd.x, negYAxisScreenEnd.y);
    ctx.lineTo(yAxisScreenEnd.x, yAxisScreenEnd.y);
    ctx.stroke();

    // The center vertex
    ctx.fillStyle = colors.uiIcon;
    ctx.beginPath();
    ctx.arc(centerScreen.x, centerScreen.y, 4, 0, 2 * Math.PI);
    ctx.fill();

    ctx.restore(); // Restore from glow effect

    // Draw custom indicator separately if needed, without the main glow
    if (coordSystem.isCustom) {
        ctx.save();
        ctx.strokeStyle = colors.selectionGlow;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(centerScreen.x, centerScreen.y, 8, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.restore();
    }
}


=== script.js ===
import ColormapSelector from 'colormap-selector';
import 'colormap-selector/styles.css';

import * as C from './constants.js';
import * as U from './utils.js';
import * as R from './renderer.js';

const canvas = document.getElementById('drawingCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const htmlOverlay = document.getElementById('html-overlay');
const dpr = window.devicePixelRatio || 1;
const activeHtmlLabels = new Map();
let colorEditor;
const canvasUI = {
    toolbarButton: null,
    mainToolbar: null,
    colorToolButton: null,
    colorSwatches: [],
    addColorButton: null,
    transformToolButton: null,
    transformIcons: [],
    displayToolButton: null,
    displayIcons: [],
    themeToggleButton: null,
    symmetryToolButton: null,
    symmetryIcons: []
};


let isDraggingColorTarget = false;
let draggedColorTargetInfo = null;

let currentDrawingPath = [];
let frozenReference_A_rad = null;
let frozenReference_A_baseRad = null;
let frozenReference_D_du = null;
let frozenReference_Origin_Data = null;
let isMouseOverCanvas = false;
let placingSnapPos = null;
let isDisplayPanelExpanded = false;
let isVisibilityPanelExpanded = false;
let coordsDisplayMode = 'regular';
let gridDisplayMode = 'lines';
let angleDisplayMode = 'degrees';
let distanceDisplayMode = 'on';
let verticesVisible = true;
let edgesVisible = true;
let facesVisible = false;

let hoveredVertexId = null;
let hoveredEdgeId = null;
let hoveredFaceId = null;
let isEdgeTransformDrag = false;
let isDraggingCenter = false;
let allVertices = [];
let allEdges = [];
let allFaces = [];
let selectedVertexIds = [];
let selectedEdgeIds = [];
let selectedFaceIds = [];
let activeCenterId = null;
let mousePos = { x: 0, y: 0 };

let frozenReference_D_g2g = null;
let isToolbarExpanded = false;
let isColorPaletteExpanded = false;
let isEditingColor = false;
let editingColorIndex = null;
let isTransformPanelExpanded = false;
let isPlacingTransform = false;
let placingTransformType = null;
let drawingSequence = [];
let currentSequenceIndex = 0;
let showAngles = true;
let showDistances = true;
let angleSigFigs = 4;
let distanceSigFigs = 3;
let gridAlpha = 0.5;
let transformIndicatorData = null;
let isActionInProgress = false;
let isDragConfirmed = false;
let isPanningBackground = false;
let isRectangleSelecting = false;
let currentMouseButton = -1;
let actionStartPos = { x: 0, y: 0 };
let backgroundPanStartOffset = { x: 0, y: 0 };
let initialDragVertexStates = [];
let rectangleSelectStartPos = { x: 0, y: 0 };
let actionContext = null;
let allColors = C.DEFAULT_RECENT_COLORS;
let isDrawingMode = false;
let previewLineStartVertexId = null;
let actionTargetVertex = null;
let dragPreviewVertices = [];
let currentShiftPressed = false;
let clipboard = { vertices: [], edges: [], faces: [], referenceVertex: null };
let clickData = { targetId: null, type: null, count: 0, timestamp: 0 };
let undoStack = [];
let redoStack = [];
let ghostVertexPosition = null;
let selectedCenterIds = [];
let copyCountInput = '';
let copyCountTimer = null;
let ghostVertices = [];
let currentAccumulatedRotation = 0;
let lastGridState = {
    interval1: null,
    interval2: null,
    alpha1: 0,
    alpha2: 0,
    scale: null
};
let viewTransform = {
    scale: C.DEFAULT_CALIBRATION_VIEW_SCALE,
    offsetX: 0,
    offsetY: 0
};
let lastAngularGridState = {
    angle1: 30,
    angle2: 15,
    alpha1: 1,
    alpha2: 0,
};
let labelsToKeepThisFrame = new Set();
let activeThemeName = 'dark';

let activeColorTarget = C.COLOR_TARGET_VERTEX;
let colorAssignments = {
    [C.COLOR_TARGET_VERTEX]: 0,
    [C.COLOR_TARGET_EDGE]: 1,
    [C.COLOR_TARGET_FACE]: 2,
};

let isDraggingCoordSystem = false;
let draggedCoordSystemElement = null;
let coordSystemSnapTargets = null;


function ensureFaceCoordinateSystems() {
    U.updateFaceLocalCoordinateSystems(allFaces, findVertexById);
}

function createFaceWithCoordinateSystem(vertexIds) {
    const newFace = {
        id: U.getFaceId({ vertexIds }),
        vertexIds: vertexIds,
        localCoordSystem: null
    };

    if (!allFaces.some(f => f.id === newFace.id)) {
        allFaces.push(newFace);
    }

    ensureFaceCoordinateSystems();
    return newFace;
}

function getColors() {
    const theme = U.getCurrentTheme(activeThemeName, C.BASE_THEME);
    return theme;
}

function generateRandomColor() {
    const r = Math.floor(Math.random() * 256);
    const g = Math.floor(Math.random() * 256);
    const b = Math.floor(Math.random() * 256);
    const a = Math.random() * 0.8 + 0.2;
    return `rgba(${r}, ${g}, ${b}, ${a.toFixed(2)})`;
}

function getColorForTarget(targetType, index = 0, total = 1) {
    const colorIndex = colorAssignments[targetType];
    if (colorIndex === -1) {
        return generateRandomColor();
    }
    const item = allColors[colorIndex];
    if (item?.type === 'color') {
        return item.value;
    } else if (item?.type === 'colormap') {
        const t = total > 1 ? index / (total - 1) : 0.5;
        return U.sampleColormap(item, t);
    }
    return getColors().vertex;
}

function applyColormapToEdge(edge, index = 0, total = 1) {
    const colorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
    if (colorIndex === -1) {
        edge.color = generateRandomColor();
        return;
    }
    
    const colorItem = allColors[colorIndex];
    if (colorItem && colorItem.type === 'colormap') {
        const startT = total > 1 ? index / total : 0;
        const endT = total > 1 ? (index + 1) / total : 1;
        edge.gradientStart = startT;
        edge.gradientEnd = endT;
        edge.colormapItem = colorItem;
        delete edge.colormapOffset;
        delete edge.color;
    } else if (colorItem && colorItem.type === 'color') {
        edge.color = colorItem.value;
        delete edge.gradientStart;
        delete edge.gradientEnd;
        delete edge.colormapItem;
        delete edge.colormapOffset;
    } else {
        edge.color = getColors().edge;
        delete edge.gradientStart;
        delete edge.gradientEnd;
        delete edge.colormapItem;
        delete edge.colormapOffset;
    }
}

function applyColorsToSelection() {
    saveStateForUndo();

    const colorIndex = colorAssignments[activeColorTarget];
    if (colorIndex === -1 && activeColorTarget !== C.COLOR_TARGET_VERTEX) {
        return;
    }

    if (activeColorTarget === C.COLOR_TARGET_VERTEX) {
        const colorItem = allColors[colorIndex];
        if (colorItem && colorItem.type === 'colormap') {
            const verticesToColor = selectedVertexIds.map(id => findVertexById(id)).filter(p => p && p.type === 'regular');
            verticesToColor.forEach((vertex, index) => {
                const t = verticesToColor.length > 1 ? index / (verticesToColor.length - 1) : 0.5;
                vertex.color = U.sampleColormap(colorItem, t);
            });
        } else {
            selectedVertexIds.forEach(id => {
                const vertex = findVertexById(id);
                if (vertex && vertex.type === 'regular') {
                    vertex.color = getColorForTarget(C.COLOR_TARGET_VERTEX);
                }
            });
        }
    } else if (activeColorTarget === C.COLOR_TARGET_EDGE) {
        const colorItem = allColors[colorIndex];
        if (colorItem && colorItem.type === 'colormap') {
            selectedEdgeIds.forEach((edgeId, index) => {
                const edge = allEdges.find(e => U.getEdgeId(e) === edgeId);
                if (edge) {
                    const totalEdges = selectedEdgeIds.length;
                    const startT = totalEdges > 1 ? index / totalEdges : 0;
                    const endT = totalEdges > 1 ? (index + 1) / totalEdges : 1;
                    edge.gradientStart = startT;
                    edge.gradientEnd = endT;
                    edge.colormapItem = colorItem;
                    delete edge.colormapOffset;
                    delete edge.color;
                }
            });
        } else {
            const color = getColorForTarget(C.COLOR_TARGET_EDGE);
            allEdges.forEach(edge => {
                if (selectedEdgeIds.includes(U.getEdgeId(edge))) {
                    edge.color = color;
                    delete edge.gradientStart;
                    delete edge.gradientEnd;
                    delete edge.colormapItem;
                    delete edge.colormapOffset;
                }
            });
        }
    } else if (activeColorTarget === C.COLOR_TARGET_FACE) {
        const color = getColorForTarget(C.COLOR_TARGET_FACE);
        allFaces.forEach(face => {
            if (selectedFaceIds.includes(U.getFaceId(face))) {
                face.color = color;
            }
        });
    }
}

function invertVertexColors() {
    allVertices.forEach(vertex => {
        if (vertex.type === C.POINT_TYPE_REGULAR) {
            if (vertex.color) {
                vertex.color = U.invertGrayscaleValue(vertex.color);
            } else {
                vertex.color = getColors().vertex;
            }
        }
    });
}

function updateHtmlLabel({ id, content, x, y, color, fontSize, options = {} }) {
    labelsToKeepThisFrame.add(id);
    let el = activeHtmlLabels.get(id);

    if (!el) {
        el = document.createElement('div');
        el.style.position = 'absolute';
        el.style.fontFamily = 'KaTeX_Main, Times New Roman, serif';
        el.style.whiteSpace = 'nowrap';
        htmlOverlay.appendChild(el);
        activeHtmlLabels.set(id, el);
    }

    let transform = '';
    if (options.textAlign === 'center') {
        transform += ' translateX(-50%)';
    } else if (options.textAlign === 'right') {
        transform += ' translateX(-100%)';
    }

    if (options.textBaseline === 'middle') {
        transform += ' translateY(-50%)';
    } else if (options.textBaseline === 'bottom') {
        transform += ' translateY(-100%)';
    }

    if (options.rotation !== undefined) {
        transform += ` rotate(${options.rotation}deg)`;
    }

    el.style.transform = transform.trim();
    el.style.left = `${x}px`;
    el.style.top = `${y}px`;
    el.style.color = color;
    el.style.fontSize = `${fontSize}px`;

    if (el.katexContent !== content) {
        if (typeof window.katex !== 'undefined') {
            katex.render(content, el, {
                throwOnError: false,
                displayMode: false
            });
        } else {
            el.textContent = content.replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, "$1/$2").replace(/[\\{}]/g, "");
        }
        el.katexContent = content;
    }
}

function cleanupHtmlLabels() {
    for (const [id, el] of activeHtmlLabels.entries()) {
        if (!labelsToKeepThisFrame.has(id)) {
            el.remove();
            activeHtmlLabels.delete(id);
        }
    }
}

function handleCenterSelection(centerId, shiftKey, ctrlKey) {
    if (ctrlKey) {
        const index = selectedCenterIds.indexOf(centerId);
        if (index > -1) {
            selectedCenterIds.splice(index, 1);
            if (activeCenterId === centerId) {
                activeCenterId = selectedCenterIds.length > 0 ? selectedCenterIds[selectedCenterIds.length - 1] : null;
            }
        } else {
            selectedCenterIds.push(centerId);
            activeCenterId = centerId;
        }
    } else if (shiftKey) {
        if (!selectedCenterIds.includes(centerId)) {
            selectedCenterIds.push(centerId);
            activeCenterId = centerId;
        }
    } else {
        selectedCenterIds = [centerId];
        activeCenterId = centerId;
    }
}

function getDeformingSnapPosition(dragOrigin, mouseDataPos, selectedVertexIds) {
    const snapStickinessData = C.SNAP_STICKINESS_RADIUS_SCREEN / viewTransform.scale;
    let allCandidates = [];

    const unselectedNeighbors = U.findNeighbors(dragOrigin.id, allEdges)
        .map(id => findVertexById(id))
        .filter(p => p && !selectedVertexIds.includes(p.id));

    const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

    allVertices.forEach(p => {
        if (p.id !== dragOrigin.id && p.type === 'regular') {
            allCandidates.push({ pos: p, type: 'vertex' });
        }
    });

    if (gridInterval) {
        U.getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true).forEach(p => {
            allCandidates.push({ pos: p, type: 'grid' });
        });
    }

    if (unselectedNeighbors.length >= 2) {
        for (let i = 0; i < unselectedNeighbors.length; i++) {
            for (let j = i + 1; j < unselectedNeighbors.length; j++) {
                const n1 = unselectedNeighbors[i];
                const n2 = unselectedNeighbors[j];
                const distN1N2 = U.distance(n1, n2);

                if (distN1N2 > C.GEOMETRY_CALCULATION_EPSILON) {
                    const midvertex = { x: (n1.x + n2.x) / 2, y: (n1.y + n2.y) / 2 };
                    const bisectorDir = U.normalize({ x: -(n2.y - n1.y), y: n2.x - n1.x });
                    const snapAnglesRad = C.NINETY_DEG_ANGLE_SNAP_FRACTIONS.map(f => f * Math.PI / 2);

                    snapAnglesRad.forEach(alpha => {
                        if (alpha > 0 && alpha < Math.PI) {
                            const h = (distN1N2 / 2) / Math.tan(alpha / 2);
                            const p1 = { x: midvertex.x + h * bisectorDir.x, y: midvertex.y + h * bisectorDir.y };
                            const p2 = { x: midvertex.x - h * bisectorDir.x, y: midvertex.y - h * bisectorDir.y };
                            allCandidates.push({ pos: p1, type: 'equidistant_angle' });
                            allCandidates.push({ pos: p2, type: 'equidistant_angle' });
                        }
                    });
                }
            }
        }
    }

    if (allCandidates.length === 0) {
        return { pos: mouseDataPos, snapped: false };
    }

    let bestCandidate = null;
    let minSnapDistSq = Infinity;

    allCandidates.forEach(candidate => {
        const distSq = (candidate.pos.x - mouseDataPos.x) ** 2 + (candidate.pos.y - mouseDataPos.y) ** 2;
        if (distSq < minSnapDistSq) {
            minSnapDistSq = distSq;
            bestCandidate = candidate;
        }
    });

    if (bestCandidate && Math.sqrt(minSnapDistSq) < snapStickinessData) {
        return { pos: bestCandidate.pos, snapped: true, snapType: bestCandidate.type };
    }

    return { pos: mouseDataPos, snapped: false };
}

function getDragSnapPosition(dragOrigin, mouseDataPos) {
    const candidates = [];

    allVertices.forEach(p => {
        if (p.id !== dragOrigin.id && p.type === 'regular') {
            candidates.push({
                priority: 1,
                dist: U.distance(mouseDataPos, p),
                pos: p,
                snapType: 'vertex'
            });
        }
    });

    const gridCandidates = U.getGridSnapCandidates(mouseDataPos, gridDisplayMode, lastGridState.interval1, lastAngularGridState, true);
    if (gridCandidates.length > 0) {
        gridCandidates.forEach(gridVertex => {
            candidates.push({
                priority: 2,
                dist: U.distance(mouseDataPos, gridVertex),
                pos: gridVertex,
                snapType: 'grid'
            });
        });
    }

    const drawingContext = getDrawingContext(dragOrigin.id);
    const baseDistance = drawingContext.currentSegmentReferenceD;
    const distanceFactors = C.SNAP_FACTORS.filter(f => f >= 0 && f <= 10);

    const angleFactors = C.NINETY_DEG_ANGLE_SNAP_FRACTIONS;
    const baseAngle = drawingContext.currentSegmentReferenceA_for_display;

    distanceFactors.forEach(distFactor => {
        const snapDistance = baseDistance * distFactor;

        angleFactors.forEach(angleFactor => {
            const snapAngle = drawingContext.offsetAngleRad + (angleFactor * baseAngle);
            const snapPos = {
                x: dragOrigin.x + snapDistance * Math.cos(snapAngle),
                y: dragOrigin.y + snapDistance * Math.sin(snapAngle)
            };

            candidates.push({
                priority: 3,
                dist: U.distance(mouseDataPos, snapPos),
                pos: snapPos,
                snapType: 'geometric',
                distanceFactor: distFactor,
                angleFactor: angleFactor,
                snapDistance: snapDistance,
                snapAngle: snapAngle
            });
        });
    });

    if (candidates.length === 0) {
        return { vertex: mouseDataPos, snapped: false, snapType: 'none' };
    }

    candidates.sort((a, b) => a.dist - b.dist);
    const bestCandidate = candidates[0];

    return {
        vertex: bestCandidate.pos,
        snapped: true,
        snapType: bestCandidate.snapType,
        distanceFactor: bestCandidate.distanceFactor,
        angleFactor: bestCandidate.angleFactor,
        snapDistance: bestCandidate.snapDistance,
        snapAngle: bestCandidate.snapAngle
    };
}

function getBestSnapPosition(mouseDataPos) {
    const candidates = U.getGridSnapCandidates(mouseDataPos, gridDisplayMode, lastGridState.interval1, lastAngularGridState, true);

    allVertices.forEach(p => {
        if (p.type === 'regular') {
            candidates.push({ x: p.x, y: p.y, isGridVertex: false });
        }
    });

    allEdges.forEach(edge => {
        const p1 = findVertexById(edge.id1);
        const p2 = findVertexById(edge.id2);
        if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
            const midvertex = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2, isGridVertex: false };
            candidates.push(midvertex);
        }
    });

    if (candidates.length === 0) {
        return null;
    }

    const distanceSq = (p1, p2) => (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;

    return candidates.reduce((best, current) => {
        const bestDist = distanceSq(mouseDataPos, best);
        const currentDist = distanceSq(mouseDataPos, current);
        return currentDist < bestDist ? current : best;
    });
}

export function getSnappedPosition(startVertex, mouseScreenPos, shiftPressed, isDragContext = false, overrideContext = null) {
    const mouseDataPos = screenToData(mouseScreenPos);
    const drawingContext = overrideContext || getDrawingContext(startVertex.id);

    if (!shiftPressed) {
        const candidates = [];
        const vertexSelectRadiusData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;
        for (const p of allVertices) {
            if (p.id !== startVertex.id && p.type === "regular" && U.distance(mouseDataPos, p) < vertexSelectRadiusData) {
                candidates.push({ priority: 1, dist: U.distance(mouseDataPos, p), pos: { x: p.x, y: p.y }, snapType: 'vertex', targetVertex: p });
            }
        }
        const edgeClickThresholdData = C.EDGE_CLICK_THRESHOLD / viewTransform.scale;
        for (const edge of allEdges) {
            const p1 = findVertexById(edge.id1);
            const p2 = findVertexById(edge.id2);
            if (p1 && p2 && p1.type === "regular" && p2.type === "regular") {
                const closest = U.getClosestPointOnLineSegment(mouseDataPos, p1, p2);
                if (closest.distance < edgeClickThresholdData && closest.onSegmentStrict) {
                    candidates.push({ priority: 2, dist: closest.distance, pos: { x: closest.x, y: closest.y }, snapType: 'edge', targetEdge: edge });
                }
            }
        }

        if (candidates.length > 0) {
            candidates.sort((a, b) => {
                if (a.priority !== b.priority) return a.priority - b.priority;
                return a.dist - b.dist;
            });
            const bestCandidate = candidates[0];
            const finalAngleRad = Math.atan2(bestCandidate.pos.y - startVertex.y, bestCandidate.pos.x - startVertex.x) || 0;
            return {
                ...bestCandidate.pos,
                angle: finalAngleRad * (180 / Math.PI),
                distance: U.distance(startVertex, bestCandidate.pos),
                snapped: true,
                snapType: bestCandidate.snapType,
                targetEdge: bestCandidate.targetEdge,
                targetVertex: bestCandidate.targetVertex,
                gridSnapped: false,
                lengthSnapFactor: null,
                angleSnapFactor: null,
                angleTurn: U.normalizeAngleToPi(finalAngleRad - drawingContext.offsetAngleRad),
                gridToGridSquaredSum: null,
                gridInterval: null
            };
        }

        const finalAngleRad = Math.atan2(mouseDataPos.y - startVertex.y, mouseDataPos.x - startVertex.x) || 0;
        return {
            x: mouseDataPos.x, y: mouseDataPos.y,
            angle: finalAngleRad * (180 / Math.PI),
            distance: U.distance(startVertex, mouseDataPos),
            snapped: false, gridSnapped: false, lengthSnapFactor: null, angleSnapFactor: null,
            angleTurn: U.normalizeAngleToPi(finalAngleRad - drawingContext.offsetAngleRad),
            gridToGridSquaredSum: null, gridInterval: null
        };
    }

    const highPriorityCandidates = [];
    const vertexSelectRadiusData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;
    for (const p of allVertices) {
        if (p.id !== startVertex.id && p.type === "regular" && U.distance(mouseDataPos, p) < vertexSelectRadiusData) {
            highPriorityCandidates.push({ priority: 1, dist: U.distance(mouseDataPos, p), pos: { x: p.x, y: p.y }, snapType: 'vertex', targetVertex: p });
        }
    }
    const edgeClickThresholdData = C.EDGE_CLICK_THRESHOLD / viewTransform.scale;
    for (const edge of allEdges) {
        const p1 = findVertexById(edge.id1);
        const p2 = findVertexById(edge.id2);
        if (p1 && p2 && p1.type === "regular" && p2.type === "regular") {
            const closest = U.getClosestPointOnLineSegment(mouseDataPos, p1, p2);
            if (closest.distance < edgeClickThresholdData && closest.onSegmentStrict) {
                highPriorityCandidates.push({ priority: 2, dist: closest.distance, pos: { x: closest.x, y: closest.y }, snapType: 'edge', targetEdge: edge });
            }
        }
    }

    if (highPriorityCandidates.length > 0) {
        highPriorityCandidates.sort((a, b) => {
            if (a.priority !== b.priority) return a.priority - b.priority;
            return a.dist - b.dist;
        });
        const bestCandidate = highPriorityCandidates[0];
        const finalAngleRad = Math.atan2(bestCandidate.pos.y - startVertex.y, bestCandidate.pos.x - startVertex.x) || 0;
        return {
            ...bestCandidate.pos,
            angle: finalAngleRad * (180 / Math.PI),
            distance: U.distance(startVertex, bestCandidate.pos),
            snapped: true,
            snapType: bestCandidate.snapType,
            targetEdge: bestCandidate.targetEdge,
            targetVertex: bestCandidate.targetVertex,
            gridSnapped: false,
            lengthSnapFactor: null,
            angleSnapFactor: null,
            angleTurn: U.normalizeAngleToPi(finalAngleRad - drawingContext.offsetAngleRad),
            gridToGridSquaredSum: null,
            gridInterval: null
        };
    }

    const unselectedNeighbors = U.findNeighbors(startVertex.id, allEdges)
        .map(id => findVertexById(id))
        .filter(p => p && p.type === 'regular' && !selectedVertexIds.includes(p.id));

    const isDeformingDrag = isDragContext && unselectedNeighbors.length > 0;

    if (isDeformingDrag) {
        const allSnapVertices = [];

        const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        if (gridDisplayMode !== 'none' && gridInterval) {
            const gridVertices = U.getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true);
            gridVertices.forEach(p => allSnapVertices.push({ pos: p, type: 'grid' }));
        }

        allVertices.forEach(p => {
            if (p.id !== startVertex.id && p.type === 'regular') {
                allSnapVertices.push({ pos: p, type: 'vertex' });
            }
        });

        const getPerpendicularBisector = (p1, p2) => {
            const midVertex = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            const perpVector = { x: -(p2.y - p1.y), y: p2.x - p1.x };
            return { p1: midVertex, p2: { x: midVertex.x + perpVector.x * C.BISECTOR_LINE_EXTENSION_FACTOR, y: midVertex.y + perpVector.y * C.BISECTOR_LINE_EXTENSION_FACTOR } };
        };

        for (let i = 0; i < unselectedNeighbors.length; i++) {
            for (let j = i + 1; j < unselectedNeighbors.length; j++) {
                const n1 = unselectedNeighbors[i];
                const n2 = unselectedNeighbors[j];
                const bisector = getPerpendicularBisector(n1, n2);

                if (gridInterval) {
                    const maxDist = U.distance(startVertex, mouseDataPos) + gridInterval * 10;
                    for (let d = gridInterval * 0.5; d < maxDist; d += gridInterval * 0.5) {
                        const intersections = U.getLineCircleIntersection(bisector, { center: n1, radius: d });
                        intersections.forEach(p => allSnapVertices.push({ pos: p, type: 'equidistant_grid_dist' }));
                    }
                }

                const distN1N2 = U.distance(n1, n2);
                if (distN1N2 > C.GEOMETRY_CALCULATION_EPSILON) {
                    const midvertex = { x: (n1.x + n2.x) / 2, y: (n1.y + n2.y) / 2 };
                    const bisectorDir = U.normalize({ x: -(n2.y - n1.y), y: n2.x - p1.x });

                    const snapAnglesRad = C.NINETY_DEG_ANGLE_SNAP_FRACTIONS.map(f => f * Math.PI / 2);
                    snapAnglesRad.forEach(alpha => {
                        if (alpha > 0 && alpha < Math.PI) {
                            const h = (distN1N2 / 2) / Math.tan(alpha / 2);
                            const p1 = { x: midvertex.x + h * bisectorDir.x, y: midvertex.y + h * bisectorDir.y };
                            const p2 = { x: midvertex.x - h * bisectorDir.x, y: midvertex.y - h * bisectorDir.y };
                            allSnapVertices.push({ pos: p1, type: 'equidistant_angle' });
                            allSnapVertices.push({ pos: p2, type: 'equidistant_angle' });
                        }
                    });
                }
            }
        }

        if (unselectedNeighbors.length >= 3) {
            for (let i = 0; i < unselectedNeighbors.length; i++) {
                for (let j = i + 1; j < unselectedNeighbors.length; j++) {
                    for (let k = j + 1; k < unselectedNeighbors.length; k++) {
                        const n1 = unselectedNeighbors[i];
                        const n2 = unselectedNeighbors[j];
                        const n3 = unselectedNeighbors[k];
                        const bisector1 = getPerpendicularBisector(n1, n2);
                        const bisector2 = getPerpendicularBisector(n2, n3);
                        const circumcenter = U.getLineLineIntersection(bisector1, bisector2);
                        if (circumcenter) {
                            allSnapVertices.push({ pos: circumcenter, type: 'circumcenter' });
                        }
                    }
                }
            }
        }

        if (allSnapVertices.length === 0) {
            const finalAngleRad = Math.atan2(mouseDataPos.y - startVertex.y, mouseDataPos.x - startVertex.x) || 0;
            return {
                x: mouseDataPos.x, y: mouseDataPos.y,
                angle: finalAngleRad * (180 / Math.PI), distance: U.distance(startVertex, mouseDataPos),
                snapped: false
            };
        }

        const bestCandidate = allSnapVertices.reduce((best, current) => {
            const currentDist = U.distance(mouseDataPos, current.pos);
            const bestDist = best.pos ? U.distance(mouseDataPos, best.pos) : Infinity;
            return currentDist < bestDist ? current : best;
        }, { pos: null });

        const finalPos = bestCandidate.pos;
        const finalAngle = Math.atan2(finalPos.y - startVertex.y, finalPos.x - startVertex.x) || 0;
        return {
            x: finalPos.x,
            y: finalPos.y,
            angle: finalAngle * (180 / Math.PI),
            distance: U.distance(startVertex, finalPos),
            snapped: true,
            snapType: bestCandidate.type,
            gridSnapped: bestCandidate.type === 'grid',
            lengthSnapFactor: null,
            angleSnapFactor: null,
            angleTurn: U.normalizeAngleToPi(finalAngle - drawingContext.offsetAngleRad),
            gridToGridSquaredSum: null,
            gridInterval: null,
        };

    } else {
        const allShiftCandidates = [];

        const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        if (gridDisplayMode !== 'none' && gridInterval) {
            const gridVertices = U.getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, lastAngularGridState, true);
            gridVertices.forEach(p => allShiftCandidates.push({ pos: p, isGridVertexSnap: true, type: 'grid' }));
        }

        const referenceAngleForSnapping = drawingContext.currentSegmentReferenceA_for_display;
        const baseUnitDistance = drawingContext.currentSegmentReferenceD;
        const symmetricalAngleFractions = new Set([0, ...C.NINETY_DEG_ANGLE_SNAP_FRACTIONS.flatMap(f => [f, -f])]);
        const sortedSymmetricalFractions = Array.from(symmetricalAngleFractions).sort((a, b) => a - b);
        const allSnapAngles = sortedSymmetricalFractions.map(f => ({ factor: f, angle: U.normalizeAngleToPi(drawingContext.offsetAngleRad + (f * referenceAngleForSnapping)), turn: U.normalizeAngleToPi(f * referenceAngleForSnapping) }));
        const allSnapDistances = [];
        for (let i = 0; i <= C.DRAW_SNAP_DISTANCE_FACTOR_LIMIT / C.DRAW_SNAP_DISTANCE_FACTOR_STEP; i++) {
            const factor = i * C.DRAW_SNAP_DISTANCE_FACTOR_STEP;
            allSnapDistances.push({ factor: factor, dist: factor * baseUnitDistance });
        }

        if (allSnapAngles.length > 0 && allSnapDistances.length > 0) {
            for (const angleData of allSnapAngles) {
                for (const distData of allSnapDistances) {
                    const pos = { x: startVertex.x + distData.dist * Math.cos(angleData.angle), y: startVertex.y + distData.dist * Math.sin(angleData.angle) };
                    allShiftCandidates.push({
                        pos: pos,
                        isGridVertexSnap: false,
                        type: 'geometric',
                        lengthSnapFactor: distData.factor,
                        angleSnapFactor: angleData.factor,
                        angleTurn: angleData.turn
                    });
                }
            }
        }

        if (allShiftCandidates.length > 0) {
            const bestOverallCandidate = allShiftCandidates.reduce((best, current) => {
                const currentDist = U.distance(mouseDataPos, current.pos);
                const bestDist = best.pos ? U.distance(mouseDataPos, best.pos) : Infinity;
                return currentDist < bestDist ? current : best;
            }, { pos: null });

            const finalAngle = Math.atan2(bestOverallCandidate.pos.y - startVertex.y, bestOverallCandidate.pos.x - startVertex.x) || 0;
            const snappedDistanceOutput = parseFloat(U.distance(startVertex, bestOverallCandidate.pos).toFixed(10));
            let gridToGridSquaredSum = null;
            let finalGridInterval = null;

            if (bestOverallCandidate.isGridVertexSnap && gridDisplayMode !== 'polar') {
                const currentGridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
                const epsilon = currentGridInterval * C.GEOMETRY_CALCULATION_EPSILON;
                const isVertexOnGrid = (vertex, interval) => Math.abs(vertex.x / interval - Math.round(vertex.x / interval)) < epsilon && Math.abs(vertex.y / interval - Math.round(vertex.y / interval)) < epsilon;
                if (isVertexOnGrid(startVertex, currentGridInterval)) {
                    const deltaX = bestOverallCandidate.pos.x - startVertex.x;
                    const deltaY = bestOverallCandidate.pos.y - startVertex.y;
                    const dx_grid = Math.round(deltaX / currentGridInterval);
                    const dy_grid = Math.round(deltaY / currentGridInterval);
                    gridToGridSquaredSum = dx_grid * dx_grid + dy_grid * dy_grid;
                    finalGridInterval = currentGridInterval;
                }
            }

            let finalAngleTurn = bestOverallCandidate.angleTurn != null ? bestOverallCandidate.angleTurn : U.normalizeAngleToPi(finalAngle - drawingContext.offsetAngleRad);

            return {
                x: parseFloat(bestOverallCandidate.pos.x.toFixed(10)),
                y: parseFloat(bestOverallCandidate.pos.y.toFixed(10)),
                angle: finalAngle * (180 / Math.PI),
                distance: snappedDistanceOutput,
                snapped: true,
                gridSnapped: !!bestOverallCandidate.isGridVertexSnap,
                snapType: bestOverallCandidate.isGridVertexSnap ? 'grid' : 'geometric',
                lengthSnapFactor: bestOverallCandidate.lengthSnapFactor || null,
                angleSnapFactor: bestOverallCandidate.angleSnapFactor || null,
                angleTurn: finalAngleTurn,
                gridToGridSquaredSum: gridToGridSquaredSum,
                gridInterval: finalGridInterval,
            };
        }

        const finalAngleRad = Math.atan2(mouseDataPos.y - startVertex.y, mouseDataPos.x - startVertex.x) || 0;
        return {
            x: mouseDataPos.x, y: mouseDataPos.y,
            angle: finalAngleRad * (180 / Math.PI),
            distance: U.distance(startVertex, mouseDataPos),
            snapped: false, gridSnapped: false, lengthSnapFactor: null, angleSnapFactor: null,
            angleTurn: U.normalizeAngleToPi(finalAngleRad - drawingContext.offsetAngleRad),
            gridToGridSquaredSum: null, gridInterval: null
        };
    }
}

function invertColors() {
    allColors = allColors.map(colorItem => {
        if (colorItem.type === 'color') {
            return { ...colorItem, value: U.invertGrayscaleValue(colorItem.value) };
        }
        return colorItem;
    });
}

function initializeCanvasUI() {
    canvasUI.toolbarButton = {
        id: "toolbar-button",
        x: C.UI_BUTTON_PADDING,
        y: C.UI_BUTTON_PADDING,
        width: C.MENU_BUTTON_WIDTH,
        height: C.MENU_BUTTON_HEIGHT,
        type: "menuButton"
    };
}

function buildTransformPanelUI() {
    canvasUI.transformIcons = [];
    const panelX = C.UI_TOOLBAR_WIDTH + C.UI_BUTTON_PADDING;
    const iconY = canvasUI.transformToolButton.y;
    const iconSize = C.TRANSFORM_ICON_SIZE;
    const iconPadding = C.TRANSFORM_ICON_PADDING;
    const transformTypes = [
        C.TRANSFORMATION_TYPE_ROTATION,
        C.TRANSFORMATION_TYPE_SCALE,
        C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE
    ];

    transformTypes.forEach((type, index) => {
        canvasUI.transformIcons.push({
            id: `transform-icon-${type}`,
            type: type,
            x: panelX + index * (iconSize + iconPadding),
            y: iconY + C.TRANSFORM_ICON_Y_OFFSET,
            width: iconSize,
            height: iconSize
        });
    });
}

function buildDisplayPanelUI() {
    canvasUI.displayIcons = [];
    if (!canvasUI.displayToolButton) return;

    const panelX = C.UI_TOOLBAR_WIDTH + C.UI_BUTTON_PADDING;
    const iconY = canvasUI.displayToolButton.y;
    const iconSize = C.DISPLAY_ICON_SIZE;
    const iconPadding = C.DISPLAY_ICON_PADDING;

    const iconGroups = ['coords', 'grid'];

    iconGroups.forEach((group, index) => {
        canvasUI.displayIcons.push({
            id: `display-icon-${group}`,
            group: group,
            x: panelX + index * (iconSize + iconPadding),
            y: iconY,
            width: iconSize,
            height: iconSize
        });
    });
}

function buildColorPaletteUI() {
   canvasUI.colorSwatches = [];
   canvasUI.colorTargetIcons = [];
   const paletteY = canvasUI.colorToolButton.y;

   let currentX = C.UI_TOOLBAR_WIDTH + C.UI_BUTTON_PADDING;

   canvasUI.applyColorsButton = {
       id: "apply-colors-button",
       type: "button",
       x: currentX,
       y: paletteY + C.COLOR_PALETTE_Y_OFFSET,
       width: C.UI_SWATCH_SIZE,
       height: C.UI_SWATCH_SIZE,
   };
   currentX += C.UI_SWATCH_SIZE + C.UI_BUTTON_PADDING;

   canvasUI.randomColorButton = {
       id: "random-color-button",
       type: "button",
       x: currentX,
       y: paletteY + C.COLOR_PALETTE_Y_OFFSET,
       width: C.UI_SWATCH_SIZE,
       height: C.UI_SWATCH_SIZE,
   };
   currentX += C.UI_SWATCH_SIZE + C.UI_BUTTON_PADDING;

   canvasUI.removeColorButton = {
       id: "remove-color-button",
       type: "button",
       x: currentX,
       y: paletteY + C.COLOR_PALETTE_Y_OFFSET,
       width: C.UI_SWATCH_SIZE,
       height: C.UI_SWATCH_SIZE,
   };
   currentX += C.UI_SWATCH_SIZE + C.UI_BUTTON_PADDING;

   allColors.forEach((item, index) => {
       const swatchWidth = (item.type === 'colormap')
           ? (C.UI_SWATCH_SIZE * 3) + (C.UI_BUTTON_PADDING * 2)
           : C.UI_SWATCH_SIZE;

       canvasUI.colorSwatches.push({
           id: `swatch-${index}`,
           type: "colorSwatch",
           x: currentX,
           y: paletteY + C.COLOR_PALETTE_Y_OFFSET,
           width: swatchWidth,
           height: C.UI_SWATCH_SIZE,
           index: index,
           item: item
       });
       currentX += swatchWidth + C.UI_BUTTON_PADDING;
   });

   const addButtonX = currentX;
   canvasUI.addColorButton = {
       id: "add-color-button",
       type: "button",
       x: addButtonX,
       y: paletteY + C.COLOR_PALETTE_Y_OFFSET,
       width: C.UI_SWATCH_SIZE,
       height: C.UI_SWATCH_SIZE,
   };

   Object.entries(colorAssignments).forEach(([target, colorIndex]) => {
       const iconSize = C.UI_SWATCH_SIZE * 0.75;
       let swatch;
       if (colorIndex === -1) {
           swatch = canvasUI.randomColorButton;
       } else {
           swatch = canvasUI.colorSwatches.find(s => s.index === colorIndex);
       }

       if (swatch) {
           canvasUI.colorTargetIcons.push({
               id: `target-icon-${target}`,
               target: target,
               x: swatch.x + (swatch.width - iconSize) / 2,
               y: swatch.y - iconSize - 5,
               width: iconSize,
               height: iconSize
           });
       }
   });
}

function buildVisibilityPanelUI() {
    canvasUI.visibilityIcons = [];
    if (!canvasUI.visibilityToolButton) return;

    const panelX = C.UI_TOOLBAR_WIDTH + C.UI_BUTTON_PADDING;
    const iconY = canvasUI.visibilityToolButton.y;
    const iconSize = C.DISPLAY_ICON_SIZE;
    const iconPadding = C.DISPLAY_ICON_PADDING;

    const iconGroups = ['angles', 'distances'];

    iconGroups.forEach((group, index) => {
        canvasUI.visibilityIcons.push({
            id: `visibility-icon-${group}`,
            group: group,
            x: panelX + index * (iconSize + iconPadding),
            y: iconY,
            width: iconSize,
            height: iconSize
        });
    });
}

function buildMainToolbarUI() {
    const canvasHeight = canvas.height / dpr;
    canvasUI.mainToolbar = {
        id: "main-toolbar-bg",
        x: 0,
        y: 0,
        width: C.UI_TOOLBAR_WIDTH,
        height: canvasHeight,
        type: "toolbar"
    };

    canvasUI.colorToolButton = {
        id: "color-tool-button",
        type: "toolButton",
        x: C.UI_BUTTON_PADDING,
        y: canvasUI.toolbarButton.y + canvasUI.toolbarButton.height + C.TOOLBAR_SECTION_GAP,
        width: C.UI_TOOLBAR_WIDTH - (2 * C.UI_BUTTON_PADDING),
        height: C.TOOL_BUTTON_HEIGHT,
    };

    canvasUI.transformToolButton = {
        id: "transform-tool-button",
        type: "toolButton",
        x: C.UI_BUTTON_PADDING,
        y: canvasUI.colorToolButton.y + canvasUI.colorToolButton.height + C.UI_BUTTON_PADDING,
        width: C.UI_TOOLBAR_WIDTH - (2 * C.UI_BUTTON_PADDING),
        height: C.TOOL_BUTTON_HEIGHT,
    };

    canvasUI.displayToolButton = {
        id: "display-tool-button",
        type: "toolButton",
        x: C.UI_BUTTON_PADDING,
        y: canvasUI.transformToolButton.y + canvasUI.transformToolButton.height + C.UI_BUTTON_PADDING,
        width: C.UI_TOOLBAR_WIDTH - (2 * C.UI_BUTTON_PADDING),
        height: C.TOOL_BUTTON_HEIGHT,
    };

    canvasUI.visibilityToolButton = {
        id: "visibility-tool-button",
        type: "toolButton",
        x: C.UI_BUTTON_PADDING,
        y: canvasUI.displayToolButton.y + canvasUI.displayToolButton.height + C.UI_BUTTON_PADDING,
        width: C.UI_TOOLBAR_WIDTH - (2 * C.UI_BUTTON_PADDING),
        height: C.TOOL_BUTTON_HEIGHT,
    };

    canvasUI.themeToggleButton = {
        id: "theme-toggle-button",
        type: "toolButton",
        x: C.UI_BUTTON_PADDING,
        y: canvasUI.visibilityToolButton.y + canvasUI.visibilityToolButton.height + C.UI_BUTTON_PADDING,
        width: C.UI_TOOLBAR_WIDTH - (2 * C.UI_BUTTON_PADDING),
        height: C.TOOL_BUTTON_HEIGHT,
    };
}

function handleDisplayPanelClick(screenPos) {
    if (isDisplayPanelExpanded) {
        for (const icon of canvasUI.displayIcons) {
            if (screenPos.x >= icon.x && screenPos.x <= icon.x + icon.width &&
                screenPos.y >= icon.y && screenPos.y <= icon.y + icon.height) {
                switch (icon.group) {
                    case 'coords':
                        const coordsModes = [C.COORDS_DISPLAY_MODE_NONE, C.COORDS_DISPLAY_MODE_REGULAR, C.COORDS_DISPLAY_MODE_COMPLEX, C.COORDS_DISPLAY_MODE_POLAR];
                        coordsDisplayMode = coordsModes[(coordsModes.indexOf(coordsDisplayMode) + 1) % coordsModes.length];
                        break;
                    case 'grid':
                        const gridModes = [C.GRID_DISPLAY_MODE_LINES, C.GRID_DISPLAY_MODE_POINTS, C.GRID_DISPLAY_MODE_TRIANGULAR, C.GRID_DISPLAY_MODE_POLAR, C.GRID_DISPLAY_MODE_NONE];
                        gridDisplayMode = gridModes[(gridModes.indexOf(gridDisplayMode) + 1) % gridModes.length];
                        break;
                }
                return true;
            }
        }
    }
    return false;
}

function handleVisibilityPanelClick(screenPos) {
    if (isVisibilityPanelExpanded) {
        for (const icon of canvasUI.visibilityIcons) {
            if (screenPos.x >= icon.x && screenPos.x <= icon.x + icon.width &&
                screenPos.y >= icon.y && screenPos.y <= icon.y + icon.height) {
                switch (icon.group) {
                    case 'angles':
                        const angleModes = [C.ANGLE_DISPLAY_MODE_DEGREES, C.ANGLE_DISPLAY_MODE_RADIANS, C.ANGLE_DISPLAY_MODE_NONE];
                        angleDisplayMode = angleModes[(angleModes.indexOf(angleDisplayMode) + 1) % angleModes.length];
                        showAngles = angleDisplayMode !== C.ANGLE_DISPLAY_MODE_NONE;
                        break;
                    case 'distances':
                        const distModes = [C.DISTANCE_DISPLAY_MODE_ON, C.DISTANCE_DISPLAY_MODE_NONE];
                        distanceDisplayMode = distModes[(distModes.indexOf(distanceDisplayMode) + 1) % distModes.length];
                        showDistances = distanceDisplayMode === C.DISTANCE_DISPLAY_MODE_ON;
                        break;
                }
                return true;
            }
        }
    }
    return false;
}

function handleCanvasUIClick(screenPos, shiftKey = false, ctrlKey = false) {
    const btn = canvasUI.toolbarButton;
    if (screenPos.x >= btn.x && screenPos.x <= btn.x + btn.width &&
        screenPos.y >= btn.y && screenPos.y <= btn.y + btn.height) {
        isToolbarExpanded = !isToolbarExpanded;
        if (isToolbarExpanded) {
            buildMainToolbarUI();
        } else {
            isColorPaletteExpanded = false;
            isTransformPanelExpanded = false;
            isDisplayPanelExpanded = false;
            isVisibilityPanelExpanded = false;
            selectedColorIndices = [];
        }
        return true;
    }

    if (isToolbarExpanded) {
        const ctb = canvasUI.colorToolButton;
        if (ctb && screenPos.x >= ctb.x && screenPos.x <= ctb.x + ctb.width &&
            screenPos.y >= ctb.y && screenPos.y <= ctb.y + ctb.height) {
            handleColorToolButtonClick();
            return true;
        }

        const ttb = canvasUI.transformToolButton;
        if (ttb && screenPos.x >= ttb.x && screenPos.x <= ttb.x + ttb.width &&
            screenPos.y >= ttb.y && screenPos.y <= ttb.y + ttb.height) {
            isTransformPanelExpanded = !isTransformPanelExpanded;
            if (isTransformPanelExpanded) buildTransformPanelUI();
            return true;
        }

        const dtb = canvasUI.displayToolButton;
        if (dtb && screenPos.x >= dtb.x && screenPos.x <= dtb.x + dtb.width &&
            screenPos.y >= dtb.y && screenPos.y <= dtb.y + dtb.height) {
            isDisplayPanelExpanded = !isDisplayPanelExpanded;
            if (isDisplayPanelExpanded) buildDisplayPanelUI();
            return true;
        }

        const vtb = canvasUI.visibilityToolButton;
        if (vtb && screenPos.x >= vtb.x && screenPos.x <= vtb.x + vtb.width &&
            screenPos.y >= vtb.y && screenPos.y <= vtb.y + vtb.height) {
            isVisibilityPanelExpanded = !isVisibilityPanelExpanded;
            if (isVisibilityPanelExpanded) buildVisibilityPanelUI();
            return true;
        }

        const themeBtn = canvasUI.themeToggleButton;
        if (themeBtn && screenPos.x >= themeBtn.x && screenPos.x <= themeBtn.x + themeBtn.width &&
            screenPos.y >= themeBtn.y && screenPos.y <= themeBtn.y + themeBtn.height) {
            handleThemeToggle();
            return true;
        }
    }

    if (isColorPaletteExpanded) {
        if (handleColorPaletteClick(screenPos, shiftKey, ctrlKey)) {
            return true;
        }
    }

    if (isTransformPanelExpanded) {
        for (const icon of canvasUI.transformIcons) {
            if (screenPos.x >= icon.x && screenPos.x <= icon.x + icon.width &&
                screenPos.y >= icon.y && screenPos.y <= icon.y + icon.height) {
                isPlacingTransform = true;
                placingTransformType = icon.type;
                return true;
            }
        }
    }

    if (isDisplayPanelExpanded) {
        if (handleDisplayPanelClick(screenPos, shiftKey, ctrlKey)) {
            return true;
        }
    }

    if (isVisibilityPanelExpanded) {
        if (handleVisibilityPanelClick(screenPos, shiftKey, ctrlKey)) {
            return true;
        }
    }

    return false;
}

function handleThemeToggle() {
    saveStateForUndo();

    activeThemeName = activeThemeName === 'dark' ? 'light' : 'dark';

    invertVertexColors();
    invertColors();

    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }
}

function addToColors(colorObject) {
    if (!colorObject || !colorObject.type) {
        console.error("Invalid color object passed to addToColors:", colorObject);
        return;
    }

    const isDuplicate = allColors.some(item => {
        if (!item || item.type !== colorObject.type) return false;
        if (item.type === 'colormap') {
            return JSON.stringify(item.vertices) === JSON.stringify(colorObject.vertices);
        }
        return item.value === colorObject.value;
    });

    if (isDuplicate) return;

    allColors.push(colorObject);

    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }
}

function getPrecedingSegment(vertexId, edgesToIgnoreIds = []) {
    const currentVertex = findVertexById(vertexId);
    if (!currentVertex) return null;
    for (let i = allEdges.length - 1; i >= 0; i--) {
        const edge = allEdges[i];
        const edgeIdentifier =  U.getEdgeId(edge);
        if (edgesToIgnoreIds.includes(edgeIdentifier)) continue;
        let otherVertexId = null;
        if (edge.id1 === vertexId) otherVertexId = edge.id2;
        else if (edge.id2 === vertexId) otherVertexId = edge.id1;
        if (otherVertexId) {
            const otherVertex = findVertexById(otherVertexId);
            if (otherVertex) {
                const dx = currentVertex.x - otherVertex.x; const dy = currentVertex.y - otherVertex.y;
                return { p1: otherVertex, p2: currentVertex, angleRad: Math.atan2(dy, dx), length: Math.sqrt(dx * dx + dy * dy), edgeId: edgeIdentifier };
            }
        }
    }
    return null;
}

function saveStateForUndo() {
    const state = {
        vertices: JSON.parse(JSON.stringify(allVertices)),
        edges: JSON.parse(JSON.stringify(allEdges)),
        faces: JSON.parse(JSON.stringify(allFaces)),
        selectedVertexIds: JSON.parse(JSON.stringify(selectedVertexIds)),
        selectedEdgeIds: JSON.parse(JSON.stringify(selectedEdgeIds)),
        selectedFaceIds: JSON.parse(JSON.stringify(selectedFaceIds)),
        activeCenterId: activeCenterId,
        isDrawingMode: isDrawingMode,
        previewLineStartVertexId: previewLineStartVertexId,
        frozenReference_A_rad, frozenReference_A_baseRad, frozenReference_D_du, frozenReference_Origin_Data,
        frozenReference_D_g2g
    };
    undoStack.push(state);
    if (undoStack.length > C.MAX_HISTORY_SIZE) undoStack.shift();
    redoStack = [];
}

function restoreState(state) {
    allVertices = JSON.parse(JSON.stringify(state.vertices));
    allEdges = JSON.parse(JSON.stringify(state.edges));
    allFaces = JSON.parse(JSON.stringify(state.faces || []));
    selectedVertexIds = JSON.parse(JSON.stringify(state.selectedVertexIds || []));
    selectedEdgeIds = JSON.parse(JSON.stringify(state.selectedEdgeIds || []));
    selectedFaceIds = JSON.parse(JSON.stringify(state.selectedFaceIds || []));
    activeCenterId = state.activeCenterId !== undefined ? state.activeCenterId : null;
    isDrawingMode = state.isDrawingMode !== undefined ? state.isDrawingMode : false;
    previewLineStartVertexId = state.previewLineStartVertexId !== undefined ? state.previewLineStartVertexId : null;
    frozenReference_A_rad = state.frozenReference_A_rad !== undefined ? state.frozenReference_A_rad : null;
    frozenReference_A_baseRad = state.frozenReference_A_baseRad !== undefined ? state.frozenReference_A_baseRad : null;
    frozenReference_D_du = state.frozenReference_D_du !== undefined ? state.frozenReference_D_du : null;
    frozenReference_Origin_Data = state.frozenReference_Origin_Data !== undefined ? state.frozenReference_Origin_Data : null;
    frozenReference_D_g2g = state.frozenReference_D_g2g !== undefined ? state.frozenReference_D_g2g : null;
    isActionInProgress = false; isDragConfirmed = false; isRectangleSelecting = false;
    isPanningBackground = false; dragPreviewVertices = [];
    actionTargetVertex = null; currentMouseButton = -1;
    clickData = { vertexId: null, count: 0, timestamp: 0 };
    canvas.style.cursor = 'crosshair';
    ensureFaceCoordinateSystems();
}

function handleUndo() {
    if (undoStack.length === 0) return;
    const currentStateForRedo = {
        vertices: JSON.parse(JSON.stringify(allVertices)),
        edges: JSON.parse(JSON.stringify(allEdges)),
        faces: JSON.parse(JSON.stringify(allFaces)),
        selectedVertexIds: JSON.parse(JSON.stringify(selectedVertexIds)),
        selectedEdgeIds: JSON.parse(JSON.stringify(selectedEdgeIds)),
        selectedFaceIds: JSON.parse(JSON.stringify(selectedFaceIds)),
        activeCenterId: activeCenterId,
        isDrawingMode: isDrawingMode,
        previewLineStartVertexId: previewLineStartVertexId,
        frozenReference_A_rad, frozenReference_A_baseRad, frozenReference_D_du, frozenReference_Origin_Data
    };
    redoStack.push(currentStateForRedo);
    if (redoStack.length > C.MAX_HISTORY_SIZE) redoStack.shift();
    const prevState = undoStack.pop();
    restoreState(prevState);
}

function handleRedo() {
    if (redoStack.length === 0) return;
    const currentStateForUndo = {
        vertices: JSON.parse(JSON.stringify(allVertices)),
        edges: JSON.parse(JSON.stringify(allEdges)),
        faces: JSON.parse(JSON.stringify(allFaces)),
        selectedVertexIds: JSON.parse(JSON.stringify(selectedVertexIds)),
        selectedEdgeIds: JSON.parse(JSON.stringify(selectedEdgeIds)),
        selectedFaceIds: JSON.parse(JSON.stringify(selectedFaceIds)),
        activeCenterId: activeCenterId,
        isDrawingMode: isDrawingMode,
        previewLineStartVertexId: previewLineStartVertexId,
        frozenReference_A_rad, frozenReference_A_baseRad, frozenReference_D_du, frozenReference_Origin_Data
    };
    undoStack.push(currentStateForUndo);
    if (undoStack.length > C.MAX_HISTORY_SIZE) undoStack.shift();
    const nextState = redoStack.pop();
    restoreState(nextState);
}

function screenToData(screenPos_css_pixels) {
    const screenX_physical = screenPos_css_pixels.x * dpr;
    const screenY_physical = screenPos_css_pixels.y * dpr;
    const canvasHeight_physical = canvas.height;
    return {
        x: (screenX_physical - viewTransform.offsetX) / viewTransform.scale,
        y: (canvasHeight_physical - screenY_physical - viewTransform.offsetY) / viewTransform.scale
    };
}

function dataToScreen(dataPos) {
    const canvasHeight_physical = canvas.height;
    const screenX_physical = dataPos.x * viewTransform.scale + viewTransform.offsetX;
    const screenY_physical = canvasHeight_physical - (dataPos.y * viewTransform.scale + viewTransform.offsetY);
    return {
        x: screenX_physical / dpr,
        y: screenY_physical / dpr
    };
}

function resizeCanvas() {
    const canvasContainer = document.querySelector('.canvas-container');
    const canvasWrapper = document.querySelector('.canvas-wrapper-relative');

    if (!canvasContainer || !canvasWrapper) {
        return;
    }

    const cW = canvasWrapper.offsetWidth;
    const cH = canvasWrapper.offsetHeight;

    canvas.width = cW * dpr;
    canvas.height = cH * dpr;
    canvas.style.width = `${cW}px`;
    canvas.style.height = `${cH}px`;

    if (htmlOverlay) {
        htmlOverlay.style.width = `${cW}px`;
        htmlOverlay.style.height = `${cH}px`;
    }
}

function findVertexById(id) { return allVertices.find(p => p.id === id); }

function findClickedVertex(clickPos) {
    const dataPos = screenToData(clickPos);
    const selectRadiusDataRegular = (C.VERTEX_RADIUS * 2) / viewTransform.scale;
    const selectRadiusDataCenter = (C.CENTER_POINT_VISUAL_RADIUS + C.VERTEX_RADIUS) / viewTransform.scale;

    for (let i = allVertices.length - 1; i >= 0; i--) {
        const vertex = allVertices[i];
        if (vertex.type !== 'regular') {
            if (U.distance(dataPos, vertex) < selectRadiusDataCenter) return vertex;
        }
    }

    for (let i = allVertices.length - 1; i >= 0; i--) {
        const vertex = allVertices[i];
        if (vertex.type === 'regular' && U.distance(dataPos, vertex) < selectRadiusDataRegular) return vertex;
    }
    return null;
}

function findClickedEdge(clickPos) {
    const dataPos = screenToData(clickPos);
    const edgeClickThresholdData = C.EDGE_CLICK_THRESHOLD / viewTransform.scale;

    for (let i = allEdges.length - 1; i >= 0; i--) {
        const edge = allEdges[i];
        const p1 = findVertexById(edge.id1);
        const p2 = findVertexById(edge.id2);
        if (p1 && p2 && p1.type === 'regular' && p2.type === 'regular') {
            const closest = U.getClosestPointOnLineSegment(dataPos, p1, p2);
            if (closest.distance < edgeClickThresholdData && closest.onSegmentStrict) {
                return edge;
            }
        }
    }
    return null;
}

function findClickedFace(clickPos) {
    const dataPos = screenToData(clickPos);

    for (let i = allFaces.length - 1; i >= 0; i--) {
        const face = allFaces[i];
        const vertices = face.vertexIds.map(id => findVertexById(id)).filter(p => p && p.type === 'regular');
        if (vertices.length < 3) continue;

        if (U.isVertexInPolygon(dataPos, vertices)) {
            return face;
        }
    }

    return null;
}

function findNeighborEdges(vertexId) {
    return allEdges.filter(e => e.id1 === vertexId || e.id2 === vertexId);
}

function findAllVerticesInSubgraph(startVertexId) {
    if (!findVertexById(startVertexId)) return [];
    const visited = new Set(); const queue = [startVertexId]; const subgraphVertexIds = [];
    visited.add(startVertexId);
    while (queue.length > 0) {
        const currentVertexId = queue.shift(); subgraphVertexIds.push(currentVertexId);
        U.findNeighbors(currentVertexId, allEdges).forEach(neighborId => {
            if (!visited.has(neighborId)) { visited.add(neighborId); queue.push(neighborId); }
        });
    }
    return subgraphVertexIds;
}



function handleCut() {
    if (selectedVertexIds.length === 0 && selectedEdgeIds.length === 0 && selectedCenterIds.length === 0) return;

    saveStateForUndo();
    handleCopy();
    deleteSelectedItems();
}

function handleCopy() {
    const verticesToCopyIds = new Set(selectedVertexIds);
    if (activeCenterId) verticesToCopyIds.add(activeCenterId);

    const facesToCopy = [];
    if (selectedFaceIds.length > 0) {
        selectedFaceIds.forEach(faceId => {
            // FIX: Find face by its canonical ID, not an object property
            const face = allFaces.find(f => U.getFaceId(f) === faceId);
            if (face) {
                facesToCopy.push(face);
                face.vertexIds.forEach(id => verticesToCopyIds.add(id));
            }
        });
    }

    selectedEdgeIds.forEach(edgeId => {
        const [id1, id2] = edgeId.split(C.EDGE_ID_DELIMITER);
        verticesToCopyIds.add(id1);
        verticesToCopyIds.add(id2);
    });

    clipboard.vertices = Array.from(verticesToCopyIds).map(id => {
        const p = findVertexById(id);
        return p ? { ...p } : null;
    }).filter(p => p);

    clipboard.edges = [];
    allEdges.forEach(edge => {
        if (verticesToCopyIds.has(edge.id1) && verticesToCopyIds.has(edge.id2)) {
            clipboard.edges.push({ ...edge });
        }
    });

    clipboard.faces = facesToCopy.map(f => ({ vertexIds: f.vertexIds }));
    clipboard.referenceVertex = screenToData(mousePos);
}

function handlePaste() {
    if (clipboard.vertices.length === 0 || !clipboard.referenceVertex) return;
    saveStateForUndo();
    const edgesBefore = JSON.parse(JSON.stringify(allEdges));

    const pastePosData = screenToData(mousePos);
    const deltaX = pastePosData.x - clipboard.referenceVertex.x;
    const deltaY = pastePosData.y - clipboard.referenceVertex.y;
    const oldToNewIdMap = new Map();
    const newPastedRegularVertexIds = [];
    let newPastedActiveCenterId = null;

    performEscapeAction();

    clipboard.vertices.forEach(cbVertex => {
        const newId = U.generateUniqueId();
        const newVertex = { ...cbVertex, id: newId, x: cbVertex.x + deltaX, y: cbVertex.y + deltaY };
        allVertices.push(newVertex);
        oldToNewIdMap.set(cbVertex.id, newId);
        if (newVertex.type === 'regular') {
            newPastedRegularVertexIds.push(newId);
        } else {
            newPastedActiveCenterId = newId;
        }
    });

    clipboard.edges.forEach(cbEdge => {
        const newP1Id = oldToNewIdMap.get(cbEdge.id1);
        const newP2Id = oldToNewIdMap.get(cbEdge.id2);
        if (newP1Id && newP2Id) allEdges.push({ id1: newP1Id, id2: newP2Id });
    });

    // FIX: Instead of manually creating faces, let the robust detection do it.
    updateFaces(edgesBefore, allEdges);

    // Select the newly pasted geometry
    selectedVertexIds = newPastedRegularVertexIds;
    selectedEdgeIds = clipboard.edges.map(e => U.getEdgeId({ id1: oldToNewIdMap.get(e.id1), id2: oldToNewIdMap.get(e.id2) }));
    selectedFaceIds = allFaces.filter(f => f.vertexIds.every(vid => oldToNewIdMap.has(vid))).map(f => U.getFaceId(f));
    activeCenterId = newPastedActiveCenterId;
}

function deleteSelectedItems() {
    const vertexIdsToDelete = new Set(selectedVertexIds);
    const centerIdsToDelete = new Set(selectedCenterIds);
    const edgeIdsToDelete = new Set(selectedEdgeIds);
    const faceIdsToExplicitlyDelete = new Set(selectedFaceIds);

    if (vertexIdsToDelete.size === 0 && centerIdsToDelete.size === 0 && edgeIdsToDelete.size === 0 && faceIdsToExplicitlyDelete.size === 0) {
        return;
    }
    saveStateForUndo();

    // When explicitly deleting faces, we just remove them from the active list.
    // We don't need to add them to a blacklist.
    if (faceIdsToExplicitlyDelete.size > 0) {
        allFaces = allFaces.filter(face => !faceIdsToExplicitlyDelete.has(U.getFaceId(face)));
    }

    const edgesBefore = [...allEdges];

    // Perform geometry deletions
    if (edgeIdsToDelete.size > 0) {
        allEdges = allEdges.filter(edge => !edgeIdsToDelete.has(U.getEdgeId(edge)));
    }
    if (vertexIdsToDelete.size > 0) {
        allVertices = allVertices.filter(p => !vertexIdsToDelete.has(p.id));
        allEdges = allEdges.filter(e => !vertexIdsToDelete.has(e.id1) && !vertexIdsToDelete.has(e.id2));
    }

    // Update faces based on the change in edges
    updateFaces(edgesBefore, allEdges);

    if (centerIdsToDelete.size > 0) {
        allVertices = allVertices.filter(p => !centerIdsToDelete.has(p.id));
    }

    performEscapeAction();
}

function zoomAt(zoomCenterScreen_css_pixels, scaleFactor) {
    let newScale = viewTransform.scale * scaleFactor;

    if (newScale < C.MIN_SCALE_VALUE) {
        newScale = C.MIN_SCALE_VALUE;
    }

    const mouseX_physical = zoomCenterScreen_css_pixels.x * dpr;
    const mouseY_physical = zoomCenterScreen_css_pixels.y * dpr;

    viewTransform.offsetX = mouseX_physical * (1 - scaleFactor) + viewTransform.offsetX * scaleFactor;

    viewTransform.offsetY = (canvas.height - mouseY_physical) * (1 - scaleFactor) + viewTransform.offsetY * scaleFactor;

    viewTransform.scale = newScale;
}

function getDrawingContext(currentDrawStartVertexId) {
    let offsetAngleRad = 0;
    let currentSegmentReferenceD;
    let currentSegmentReferenceA_for_display = Math.PI / 2;
    let isFirstSegmentBeingDrawn = true;

    const p_current = findVertexById(currentDrawStartVertexId);
    if (!p_current) {
        isFirstSegmentBeingDrawn = true;
        if (gridDisplayMode !== 'none' && lastGridState.interval1) {
            currentSegmentReferenceD = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        } else {
            currentSegmentReferenceD = C.DEFAULT_REFERENCE_DISTANCE;
        }
        if (frozenReference_D_du !== null) {
            currentSegmentReferenceD = frozenReference_D_du;
        }

        return {
            offsetAngleRad,
            currentSegmentReferenceD,
            currentSegmentReferenceA_for_display,
            isFirstSegmentBeingDrawn,
            displayAngleA_valueRad_for_A_equals_label: null,
            displayAngleA_originVertexData_for_A_equals_label: null,
            frozen_A_baseRad_to_display: null,
            frozen_D_du_to_display: null,
            frozen_D_g2g_to_display: null,
            frozen_Origin_Data_to_display: null
        };
    }

    const segment1_prev_to_current = getPrecedingSegment(p_current.id);

    if (segment1_prev_to_current) {
        isFirstSegmentBeingDrawn = false;
        offsetAngleRad = segment1_prev_to_current.angleRad;
        currentSegmentReferenceD = frozenReference_D_du !== null ? frozenReference_D_du : segment1_prev_to_current.length;

        if (frozenReference_A_rad !== null) {
            if (Math.abs(frozenReference_A_rad) < C.GEOMETRY_CALCULATION_EPSILON) {
                currentSegmentReferenceA_for_display = C.DEFAULT_REFERENCE_ANGLE_RAD;
            } else {
                currentSegmentReferenceA_for_display = Math.abs(frozenReference_A_rad);
            }
        } else {
            currentSegmentReferenceA_for_display = C.DEFAULT_REFERENCE_ANGLE_RAD;
        }
    } else {
        isFirstSegmentBeingDrawn = true;
        if (gridDisplayMode !== 'none' && lastGridState.interval1) {
            currentSegmentReferenceD = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;
        } else {
            currentSegmentReferenceD = C.DEFAULT_REFERENCE_DISTANCE;
        }
        if (frozenReference_D_du !== null) {
            currentSegmentReferenceD = frozenReference_D_du;
        }
        offsetAngleRad = 0;
        currentSegmentReferenceA_for_display = C.DEFAULT_REFERENCE_ANGLE_RAD;
    }

    return {
        offsetAngleRad,
        currentSegmentReferenceD,
        currentSegmentReferenceA_for_display,
        isFirstSegmentBeingDrawn,
        displayAngleA_valueRad_for_A_equals_label: frozenReference_A_rad,
        displayAngleA_originVertexData_for_A_equals_label: frozenReference_Origin_Data,
        frozen_A_baseRad_to_display: frozenReference_A_baseRad,
        frozen_D_du_to_display: frozenReference_D_du,
        frozen_D_g2g_to_display: frozenReference_D_g2g
    };
}

function getCompletedSegmentProperties(startVertex, endVertex, existingEdges) {
    if (!startVertex || !endVertex) return null;

    const angle = Math.atan2(endVertex.y - startVertex.y, endVertex.x - startVertex.x);
    const length = U.distance(startVertex, endVertex);

    let precedingSegmentAngle = 0;
    let isFirstSegmentOfLine = true;

    for (let i = existingEdges.length - 1; i >= 0; i--) {
        const edge = existingEdges[i];
        let otherVertexId = null;
        if (edge.id1 === startVertex.id && findVertexById(edge.id2)?.type === 'regular') otherVertexId = edge.id2;
        else if (edge.id2 === startVertex.id && findVertexById(edge.id1)?.type === 'regular') otherVertexId = edge.id1;

        if (otherVertexId && otherVertexId !== endVertex.id) {
            const prevVertex = findVertexById(otherVertexId);
            if (prevVertex) {
                precedingSegmentAngle = Math.atan2(startVertex.y - prevVertex.y, startVertex.x - prevVertex.x);
                isFirstSegmentOfLine = false;
                break;
            }
        }
    }

    const angleTurn = U.normalizeAngleToPi(angle - precedingSegmentAngle);

    return {
        startVertex,
        endVertex,
        absoluteAngleRad: angle,
        length: length,
        precedingSegmentAbsoluteAngleRad: precedingSegmentAngle,
        turnAngleRad: angleTurn,
        isFirstSegmentOfLine: isFirstSegmentOfLine
    };
}

function completeGraphOnSelectedVertices() {
    if (selectedVertexIds.length < 2) return;

    const regularVertexIds = selectedVertexIds.filter(id => {
        const vertex = findVertexById(id);
        return vertex && vertex.type === 'regular';
    });

    if (regularVertexIds.length < 2) return;

    saveStateForUndo();

    const edgesToAdd = [];
    for (let i = 0; i < regularVertexIds.length; i++) {
        for (let j = i + 1; j < regularVertexIds.length; j++) {
            const id1 = regularVertexIds[i];
            const id2 = regularVertexIds[j];

            const edgeExists = allEdges.some(edge =>
                (edge.id1 === id1 && edge.id2 === id2) ||
                (edge.id1 === id2 && edge.id2 === id1)
            );

            if (!edgeExists) {
                edgesToAdd.push({ id1, id2 });
            }
        }
    }

    if (edgesToAdd.length === 0) return;

    edgesToAdd.forEach(edge => allEdges.push(edge));

    if (facesVisible) {
        const newPolygons = U.detectClosedPolygons(allEdges, findVertexById);
        const existingFaceIds = new Set(allFaces.map(f => f.id));
        newPolygons.forEach(poly => {
            if (!existingFaceIds.has(poly.id)) {
                allFaces.push(poly);
            }
        });
        ensureFaceCoordinateSystems();
    }
}

function applySelectionLogic(vertexIdsToSelect = [], edgeIdsToSelect = [], faceIdsToSelect = [], wantsShift, wantsCtrl, targetIsCenter = false) {
    if (targetIsCenter) {
        handleCenterSelection(vertexIdsToSelect[0], wantsShift, wantsCtrl);
    } else {
        if (wantsShift) {
            selectedVertexIds = [...new Set([...selectedVertexIds, ...vertexIdsToSelect])];
            selectedEdgeIds = [...new Set([...selectedEdgeIds, ...edgeIdsToSelect])];
            selectedFaceIds = [...new Set([...selectedFaceIds, ...faceIdsToSelect])];
        } else if (wantsCtrl) {
            vertexIdsToSelect.forEach(id => {
                const index = selectedVertexIds.indexOf(id);
                if (index > -1) selectedVertexIds.splice(index, 1);
                else selectedVertexIds.push(id);
            });
            edgeIdsToSelect.forEach(id => {
                const index = selectedEdgeIds.indexOf(id);
                if (index > -1) selectedEdgeIds.splice(index, 1);
                else selectedEdgeIds.push(id);
            });
            faceIdsToSelect.forEach(id => {
                const index = selectedFaceIds.indexOf(id);
                if (index > -1) selectedFaceIds.splice(index, 1);
                else selectedFaceIds.push(id);
            });
        } else {
            selectedVertexIds = [...vertexIdsToSelect];
            selectedEdgeIds = [...edgeIdsToSelect];
            selectedFaceIds = [...faceIdsToSelect];
        }
    }
}



function handleColorToolButtonClick() {
    isColorPaletteExpanded = !isColorPaletteExpanded;
    if (isColorPaletteExpanded) {
        buildColorPaletteUI();
    }
}

function initializeApp() {
    allColors = C.DEFAULT_RECENT_COLORS.map(color => {
        if (typeof color === 'string') {
            return { type: 'color', value: color };
        }
        return color;
    });

    if (typeof window.katex === 'undefined') {
        console.error("KaTeX library failed to load or initialize. Math rendering will be broken.");
    }
    initializeCanvasUI();
    buildMainToolbarUI();
    resizeCanvas();

    colorEditor = new ColormapSelector();
    colorEditor.initialize();
    document.body.appendChild(colorEditor.getElement());

    colorEditor.getElement().addEventListener('select', (e) => {
        const colormapData = e.detail;
        const newItem = U.convertColorToColormapFormat(colormapData);

        if (!newItem) return;

        if (isEditingColor && editingColorIndex !== null) {
            allColors[editingColorIndex] = newItem;
            colorAssignments[activeColorTarget] = editingColorIndex;
        } else {
            addToColors(newItem);
            colorAssignments[activeColorTarget] = allColors.length - 1;
        }

        applyColorsToSelection();

        isEditingColor = false;
        editingColorIndex = null;
        buildColorPaletteUI();
    });

    viewTransform.scale = 70;
    viewTransform.offsetX = canvas.width / 2;
    viewTransform.offsetY = canvas.height / 2;
    coordsDisplayMode = 'regular';

    saveStateForUndo();
    gameLoop();
}

function calculateTransformFromMouse(center, mouseData, startReferenceVertex, centerType, currentAccumulatedRotation = 0) {
    const startVector = { x: startReferenceVertex.x - center.x, y: startReferenceVertex.y - center.y };
    const currentVector = { x: mouseData.x - center.x, y: mouseData.y - center.y };
    const startDist = Math.hypot(startVector.x, startVector.y);
    const currentDist = Math.hypot(currentVector.x, currentVector.y);
    const startAngle = Math.atan2(startVector.y, startVector.x);
    const currentAngle = Math.atan2(currentVector.y, currentVector.x);

    let rotation = 0;
    let scale = 1;
    let directionalScale = false;

    if (centerType === C.TRANSFORMATION_TYPE_ROTATION) {
        scale = 1.0;
        rotation = U.calculateRotationAngle(startAngle, currentAngle, currentAccumulatedRotation);
    } else if (centerType === C.TRANSFORMATION_TYPE_SCALE) {
        rotation = 0.0;
        if (startDist > C.GEOMETRY_CALCULATION_EPSILON) {
            scale = currentDist / startDist;
        }
    } else if (centerType === C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE) {
        directionalScale = true;
        rotation = 0;
        if (startDist > C.GEOMETRY_CALCULATION_EPSILON) {
            const startNormalized = { x: startVector.x / startDist, y: startVector.y / startDist };
            const projectedDistance = (currentVector.x * startNormalized.x + currentVector.y * startNormalized.y);
            scale = projectedDistance / startDist;
        }
    }

    return { rotation, scale, directionalScale };
}

function findFacesContainingEdge(edgeId1, edgeId2) {
    const facesWithEdge = [];

    allFaces.forEach(face => {
        const vertices = face.vertexIds;
        for (let i = 0; i < vertices.length; i++) {
            const currentVertex = vertices[i];
            const nextVertex = vertices[(i + 1) % vertices.length];

            if ((currentVertex === edgeId1 && nextVertex === edgeId2) ||
                (currentVertex === edgeId2 && nextVertex === edgeId1)) {
                facesWithEdge.push({
                    face: face,
                    edgeIndex: i,
                    isReversed: currentVertex === edgeId2
                });
                break;
            }
        }
    });

    return facesWithEdge;
}

function updateFaceWithNewVertex(face, edgeIndex, newVertexId, isReversed) {
    const newVertexIds = [...face.vertexIds];

    if (isReversed) {
        newVertexIds.splice(edgeIndex + 1, 0, newVertexId);
    } else {
        newVertexIds.splice(edgeIndex + 1, 0, newVertexId);
    }

    const updatedFace = {
        id: U.getFaceId({ vertexIds: newVertexIds }),
        vertexIds: newVertexIds,
        localCoordSystem: null
    };

    return updatedFace;
}

function insertVertexOnEdgeWithFaces(targetEdge, insertionVertex) {
    const p1 = findVertexById(targetEdge.id1);
    const p2 = findVertexById(targetEdge.id2);

    if (!p1 || !p2) return null;

    const facesContainingEdge = findFacesContainingEdge(targetEdge.id1, targetEdge.id2);

    const newVertex = {
        id: U.generateUniqueId(),
        x: insertionVertex.x,
        y: insertionVertex.y,
        type: 'regular',
        color: getColorForTarget(C.COLOR_TARGET_VERTEX)
    };

    allVertices.push(newVertex);

    // FIX: This now correctly uses U.getEdgeId to remove only the target edge
    allEdges = allEdges.filter(e => U.getEdgeId(e) !== U.getEdgeId(targetEdge));

    allEdges.push({ id1: targetEdge.id1, id2: newVertex.id });
    allEdges.push({ id1: newVertex.id, id2: targetEdge.id2 });

    if (facesVisible && facesContainingEdge.length > 0) {
        const facesToRemove = new Set();
        const facesToAdd = [];

        facesContainingEdge.forEach(({ face, edgeIndex, isReversed }) => {
            facesToRemove.add(U.getFaceId(face));

            const updatedFace = updateFaceWithNewVertex(face, edgeIndex, newVertex.id, isReversed);
            facesToAdd.push(updatedFace);
        });

        allFaces = allFaces.filter(face => !facesToRemove.has(U.getFaceId(face)));
        allFaces.push(...facesToAdd);
        ensureFaceCoordinateSystems();
    }

    return newVertex;
}

function getBestTranslationSnap(initialDragVertexStates, rawDelta, copyCount) {
    const snapStickinessData = (2 * C.VERTEX_RADIUS) / viewTransform.scale;
    if (initialDragVertexStates.length === 0) {
        return { delta: rawDelta, snapped: false };
    }

    const handleVertex = initialDragVertexStates[0];
    const mouseDragPos = { x: handleVertex.x + rawDelta.x, y: handleVertex.y + rawDelta.y };
    const allPossibleSnaps = [];

    const verticesToDrag = initialDragVertexStates.filter(p => p.type === 'regular');
    const staticVertices = allVertices.filter(p => p.type === 'regular' && !initialDragVertexStates.some(ip => ip.id === p.id));

    const multipliers = copyCount === 1 ? [1] : Array.from({ length: copyCount }, (_, k) => k);

    if (verticesToDrag.length > 0) {
        multipliers.forEach(k => {
            if (k === 0) return;

            verticesToDrag.forEach(p_orig => {
                staticVertices.forEach(p_target => {
                    const requiredDelta = {
                        x: (p_target.x - p_orig.x) / k,
                        y: (p_target.y - p_orig.y) / k,
                    };
                    allPossibleSnaps.push({ delta: requiredDelta });
                });
            });
        });

        if (copyCount > 1) {
            multipliers.forEach(k1 => {
                multipliers.forEach(k2 => {
                    if (k1 >= k2) return;

                    verticesToDrag.forEach(p1_orig => {
                        verticesToDrag.forEach(p2_orig => {
                            const denominator = k1 - k2;
                            if (Math.abs(denominator) > 0) {
                                const requiredDelta = {
                                    x: (p2_orig.x - p1_orig.x) / denominator,
                                    y: (p2_orig.y - p1_orig.y) / denominator,
                                };
                                allPossibleSnaps.push({ delta: requiredDelta });
                            }
                        });
                    });
                });
            });
        }
    }

    if (allPossibleSnaps.length === 0) {
        return { delta: rawDelta, snapped: false };
    }

    let bestSnap = null;
    let minSnapDist = Infinity;

    allPossibleSnaps.forEach(snap => {
        const handleAtSnapPos = {
            x: handleVertex.x + snap.delta.x,
            y: handleVertex.y + snap.delta.y,
        };
        const dist = U.distance(mouseDragPos, handleAtSnapPos);

        if (dist < minSnapDist) {
            minSnapDist = dist;
            bestSnap = snap;
        }
    });

    if (bestSnap && minSnapDist < snapStickinessData) {
        return {
            delta: bestSnap.delta,
            snapped: true,
            snapType: 'merge'
        };
    }

    return { delta: rawDelta, snapped: false };
}

function getBestRotationSnap(center, initialVertexStates, handleVertex, rawRotation) {
    const copyCount = parseInt(copyCountInput || '1', 10);
    let allPossibleSnaps = [];
    const snapThresholdData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;

    if (copyCount > 1) {
        const staticVertices = allVertices.filter(p => p.type === 'regular' && !initialVertexStates.some(ip => ip.id === p.id));
        const verticesToTransform = initialVertexStates.filter(p => p.type === 'regular');

        for (let i = 0; i < verticesToTransform.length; i++) {
            for (let j = 0; j < verticesToTransform.length; j++) {
                const p1_orig = verticesToTransform[i];
                const p2_orig = verticesToTransform[j];
                const v1 = { x: p1_orig.x - center.x, y: p1_orig.y - center.y };
                const v2 = { x: p2_orig.x - center.x, y: p2_orig.y - center.y };
                const r1 = Math.hypot(v1.x, v1.y);
                const r2 = Math.hypot(v2.x, v2.y);

                if (Math.abs(r1 - r2) < snapThresholdData) {
                    const theta1_orig = Math.atan2(v1.y, v1.x);
                    const theta2_orig = Math.atan2(v2.y, v2.x);

                    for (let c1 = 0; c1 < copyCount; c1++) {
                        for (let c2 = 0; c2 < copyCount; c2++) {
                            if (p1_orig.id === p2_orig.id && c1 === c2) continue;
                            if (c1 === c2) continue;

                            const delta_c = c1 - c2;
                            if (delta_c === 0) continue;

                            let delta_theta = theta2_orig - theta1_orig;
                            const target_delta_theta = rawRotation * delta_c;
                            const k = Math.round((target_delta_theta - delta_theta) / (2 * Math.PI));
                            delta_theta += k * (2 * Math.PI);

                            const exact_rotation = delta_theta / delta_c;
                            allPossibleSnaps.push({ rotation: exact_rotation, priority: Math.abs(exact_rotation - rawRotation) });
                        }
                    }
                }
            }
        }

        verticesToTransform.forEach(p_orig => {
            staticVertices.forEach(p_static => {
                const v_orig = { x: p_orig.x - center.x, y: p_orig.y - center.y };
                const v_static = { x: p_static.x - center.x, y: p_static.y - center.y };
                const r_orig = Math.hypot(v_orig.x, v_orig.y);
                const r_static = Math.hypot(v_static.x, v_static.y);

                if (Math.abs(r_orig - r_static) < snapThresholdData) {
                    const theta_orig = Math.atan2(v_orig.y, v_orig.x);
                    const theta_static = Math.atan2(v_static.y, v_static.y);

                    for (let c = 0; c < copyCount; c++) {
                        if (c === 0) {
                            if (Math.abs(U.normalizeAngleToPi(theta_static - theta_orig)) < C.GEOMETRY_CALCULATION_EPSILON) {
                                allPossibleSnaps.push({ rotation: 0, priority: Math.abs(rawRotation) });
                            }
                            continue;
                        }
                        let delta_theta = theta_static - theta_orig;
                        const target_delta_theta = rawRotation * c;
                        const k = Math.round((target_delta_theta - delta_theta) / (2 * Math.PI));
                        delta_theta += k * (2 * Math.PI);
                        const exact_rotation = delta_theta / c;
                        allPossibleSnaps.push({ rotation: exact_rotation, priority: Math.abs(exact_rotation - rawRotation) });
                    }
                }
            });
        });
    }

    if (Math.abs(rawRotation) < C.ANGLE_SNAP_THRESHOLD_RAD) {
        allPossibleSnaps.push({ rotation: 0, priority: Math.abs(rawRotation) });
    }

    if (currentShiftPressed) {
        for (const factor of C.NINETY_DEG_ANGLE_SNAP_FRACTIONS) {
            const snapAngle = factor * Math.PI / 2;
            if (Math.abs(rawRotation - snapAngle) < C.ANGLE_SNAP_THRESHOLD_RAD) {
                allPossibleSnaps.push({ rotation: snapAngle, priority: Math.abs(rawRotation - snapAngle) });
            }
            if (snapAngle !== 0 && Math.abs(rawRotation - (-snapAngle)) < C.ANGLE_SNAP_THRESHOLD_RAD) {
                allPossibleSnaps.push({ rotation: -snapAngle, priority: Math.abs(rawRotation - (-snapAngle)) });
            }
        }
    }

    if (allPossibleSnaps.length > 0) {
        allPossibleSnaps.sort((a, b) => a.priority - b.priority);
        const bestSnap = allPossibleSnaps[0];

        if (bestSnap.priority < C.ANGLE_SNAP_THRESHOLD_RAD) {
            const finalPos = U.applyTransformToVertex(handleVertex, center, bestSnap.rotation, 1, false, null);
            return {
                rotation: bestSnap.rotation,
                pos: finalPos,
                snapped: true,
                snapType: 'merge'
            };
        }
    }

    const finalPos = U.applyTransformToVertex(handleVertex, center, rawRotation, 1, false, null);
    return { rotation: rawRotation, pos: finalPos, snapped: false, snapType: null };
}

function getBestScaleSnap(center, initialVertexStates, handleVertex, rawScale) {
    const copyCount = parseInt(copyCountInput || '1', 10);
    let allPossibleSnaps = [];
    const snapThresholdData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;
    const angleThreshold = snapThresholdData / 100;

    if (copyCount > 1) {
        const staticVertices = allVertices.filter(p => p.type === 'regular' && !initialVertexStates.some(ip => ip.id === p.id));
        const verticesToTransform = initialVertexStates.filter(p => p.type === 'regular');

        for (let i = 0; i < verticesToTransform.length; i++) {
            for (let j = 0; j < verticesToTransform.length; j++) {
                const p1_orig = verticesToTransform[i];
                const p2_orig = verticesToTransform[j];

                const v1 = { x: p1_orig.x - center.x, y: p1_orig.y - center.y };
                const v2 = { x: p2_orig.x - center.x, y: p2_orig.y - center.y };

                const r1 = Math.hypot(v1.x, v1.y);
                const r2 = Math.hypot(v2.x, v2.y);

                if (r1 < C.GEOMETRY_CALCULATION_EPSILON || r2 < C.GEOMETRY_CALCULATION_EPSILON) continue;

                const theta1 = Math.atan2(v1.y, v1.x);
                const theta2 = Math.atan2(v2.y, v2.x);

                if (Math.abs(U.normalizeAngleToPi(theta1 - theta2)) < angleThreshold) {
                    for (let c1 = 0; c1 < copyCount; c1++) {
                        for (let c2 = 0; c2 < copyCount; c2++) {
                            if (p1_orig.id === p2_orig.id && c1 === c2) continue;
                            if (c1 === c2) continue;

                            const delta_c = c1 - c2;
                            if (delta_c === 0) continue;

                            const ratio = r2 / r1;
                            if (ratio <= 0) continue;

                            const exact_scale = Math.pow(ratio, 1 / delta_c);
                            allPossibleSnaps.push({ scale: exact_scale, priority: Math.abs(exact_scale - rawScale) });
                        }
                    }
                }
            }
        }

        verticesToTransform.forEach(p_orig => {
            staticVertices.forEach(p_static => {
                const v_orig = { x: p_orig.x - center.x, y: p_orig.y - center.y };
                const v_static = { x: p_static.x - center.x, y: p_static.y - center.y };
                const r_orig = Math.hypot(v_orig.x, v_orig.y);
                const r_static = Math.hypot(v_static.x, v_static.y);

                if (r_orig < C.GEOMETRY_CALCULATION_EPSILON || r_static < C.GEOMETRY_CALCULATION_EPSILON) return;

                const theta_orig = Math.atan2(v_orig.y, v_orig.x);
                const theta_static = Math.atan2(v_static.y, v_static.y);

                if (Math.abs(U.normalizeAngleToPi(theta_orig - theta_static)) < angleThreshold) {
                    for (let c = 0; c < copyCount; c++) {
                        if (c === 0) {
                            if (Math.abs(r_static - r_orig) < snapThresholdData) {
                                allPossibleSnaps.push({ scale: 1.0, priority: Math.abs(rawScale - 1.0) });
                            }
                            continue;
                        }
                        const ratio = r_static / r_orig;
                        if (ratio <= 0) continue;
                        const exact_scale = Math.pow(ratio, 1 / c);
                        allPossibleSnaps.push({ scale: exact_scale, priority: Math.abs(exact_scale - rawScale) });
                    }
                }
            });
        });
    }

    if (Math.abs(rawScale - 1.0) < 0.1) {
        allPossibleSnaps.push({ scale: 1.0, priority: Math.abs(rawScale - 1.0) });
    }

    if (currentShiftPressed) {
        for (const factor of C.SNAP_FACTORS) {
            if (factor !== 0 && Math.abs(rawScale - factor) < 0.1) {
                allPossibleSnaps.push({ scale: factor, priority: Math.abs(rawScale - factor) });
            }
        }
    }

    if (allPossibleSnaps.length > 0) {
        allPossibleSnaps.sort((a, b) => a.priority - b.priority);
        const bestSnap = allPossibleSnaps[0];

        if (bestSnap.priority < 0.1) {
            const finalPos = U.applyTransformToVertex(handleVertex, center, 0, bestSnap.scale, false, null);
            return {
                scale: bestSnap.scale,
                pos: finalPos,
                snapped: true,
                snapType: 'merge',
                snappedScaleValue: bestSnap.scale
            };
        }
    }

    const finalPos = U.applyTransformToVertex(handleVertex, center, 0, rawScale, false, null);
    return { scale: rawScale, pos: finalPos, snapped: false, snapType: null };
}

function getBestDirectionalScaleSnap(center, initialVertexStates, handleVertex, rawScale, startVector) {
    const copyCount = parseInt(copyCountInput || '1', 10);
    let allPossibleSnaps = [];
    const snapThresholdData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;

    const axis_dist = Math.hypot(startVector.x, startVector.y);
    if (axis_dist < C.GEOMETRY_CALCULATION_EPSILON) {
        const finalPos = U.applyTransformToVertex(handleVertex, center, 0, rawScale, true, startVector);
        return { scale: rawScale, pos: finalPos, snapped: false, snapType: null };
    }
    const axis_norm = { x: startVector.x / axis_dist, y: startVector.y / axis_dist };
    const getProjectedComponents = (p) => {
        const vec = { x: p.x - center.x, y: p.y - center.y };
        const parallel_dist = vec.x * axis_norm.x + vec.y * axis_norm.y;
        const perp_vec = { x: vec.x - parallel_dist * axis_norm.x, y: vec.y - parallel_dist * axis_norm.y };
        return { parallel_dist, perp_vec };
    };

    if (copyCount > 1) {
        const staticVertices = allVertices.filter(p => p.type === 'regular' && !initialVertexStates.some(ip => ip.id === p.id));
        const verticesToTransform = initialVertexStates.filter(p => p.type === 'regular');

        for (let i = 0; i < verticesToTransform.length; i++) {
            for (let j = 0; j < verticesToTransform.length; j++) {
                const p1_orig = verticesToTransform[i];
                const p2_orig = verticesToTransform[j];
                const proj1 = getProjectedComponents(p1_orig);
                const proj2 = getProjectedComponents(p2_orig);
                if (U.distance(proj1.perp_vec, proj2.perp_vec) < snapThresholdData) {
                    for (let c1 = 0; c1 < copyCount; c1++) {
                        for (let c2 = 0; c2 < copyCount; c2++) {
                            if (p1_orig.id === p2_orig.id && c1 === c2) continue;
                            if (c1 === c2) continue;
                            const delta_c = c1 - c2;
                            if (delta_c === 0 || Math.abs(proj1.parallel_dist) < C.GEOMETRY_CALCULATION_EPSILON) continue;
                            const ratio = proj2.parallel_dist / proj1.parallel_dist;
                            if (ratio >= 0) {
                                const pos_scale = Math.pow(ratio, 1 / delta_c);
                                allPossibleSnaps.push({ scale: pos_scale, priority: Math.abs(pos_scale - rawScale) });
                                if (delta_c % 2 === 0) {
                                    const neg_scale = -pos_scale;
                                    allPossibleSnaps.push({ scale: neg_scale, priority: Math.abs(neg_scale - rawScale) });
                                }
                            } else if (delta_c % 2 !== 0) {
                                const neg_scale = -Math.pow(Math.abs(ratio), 1 / delta_c);
                                allPossibleSnaps.push({ scale: neg_scale, priority: Math.abs(neg_scale - rawScale) });
                            }
                        }
                    }
                }
            }
        }

        verticesToTransform.forEach(p_orig => {
            const proj_orig = getProjectedComponents(p_orig);
            staticVertices.forEach(p_static => {
                const proj_static = getProjectedComponents(p_static);
                if (U.distance(proj_orig.perp_vec, proj_static.perp_vec) < snapThresholdData) {
                    if (Math.abs(proj_orig.parallel_dist) < C.GEOMETRY_CALCULATION_EPSILON) return;
                    for (let c = 0; c < copyCount; c++) {
                        if (c === 0) {
                            if (Math.abs(proj_static.parallel_dist - proj_orig.parallel_dist) < snapThresholdData) {
                                allPossibleSnaps.push({ scale: 1.0, priority: Math.abs(rawScale - 1.0) });
                            }
                            continue;
                        }
                        const ratio = proj_static.parallel_dist / proj_orig.parallel_dist;
                        let exact_scale;
                        if (ratio >= 0) exact_scale = Math.pow(ratio, 1 / c);
                        else if (c % 2 !== 0) exact_scale = -Math.pow(Math.abs(ratio), 1 / c);
                        else continue;
                        allPossibleSnaps.push({ scale: exact_scale, priority: Math.abs(exact_scale - rawScale) });
                    }
                }
            });
        });

        const collapsedPositions = verticesToTransform.map(p => ({ p, collapsed: { x: center.x + getProjectedComponents(p).perp_vec.x, y: center.y + getProjectedComponents(p).perp_vec.y } }));
        for (const item of collapsedPositions) {
            if (staticVertices.some(sp => U.distance(item.collapsed, sp) < snapThresholdData)) {
                allPossibleSnaps.push({ scale: 0, priority: Math.abs(rawScale) });
            }
        }
        for (let i = 0; i < collapsedPositions.length; i++) {
            for (let j = i + 1; j < collapsedPositions.length; j++) {
                if (U.distance(collapsedPositions[i].collapsed, collapsedPositions[j].collapsed) < snapThresholdData) {
                    allPossibleSnaps.push({ scale: 0, priority: Math.abs(rawScale) });
                }
            }
        }
    }

    if (Math.abs(rawScale - 1.0) < 0.1) {
        allPossibleSnaps.push({ scale: 1.0, priority: Math.abs(rawScale - 1.0) });
    }
    if (Math.abs(rawScale) < 0.1) {
        allPossibleSnaps.push({ scale: 0, priority: Math.abs(rawScale) });
    }

    if (currentShiftPressed) {
        const scaleSnapFactors = C.SNAP_FACTORS.filter(f => f !== 0);
        for (const factor of scaleSnapFactors) {
            if (Math.abs(rawScale - factor) < 0.1) {
                allPossibleSnaps.push({ scale: factor, priority: Math.abs(rawScale - factor) });
            }
            if (Math.abs(rawScale - (-factor)) < 0.1) {
                allPossibleSnaps.push({ scale: -factor, priority: Math.abs(rawScale - (-factor)) });
            }
        }
    }

    if (allPossibleSnaps.length > 0) {
        allPossibleSnaps.sort((a, b) => a.priority - b.priority);
        const bestSnap = allPossibleSnaps[0];
        if (bestSnap.priority < 0.1) {
            const finalPos = U.applyTransformToVertex(handleVertex, center, 0, bestSnap.scale, true, startVector);
            return {
                scale: bestSnap.scale,
                pos: finalPos,
                snapped: true,
                snapType: 'merge',
                snappedScaleValue: bestSnap.scale
            };
        }
    }

    const finalPos = U.applyTransformToVertex(handleVertex, center, 0, rawScale, true, startVector);
    return { scale: rawScale, pos: finalPos, snapped: false, snapType: null };
}

function redrawAll() {
    labelsToKeepThisFrame.clear();
    const colors = getColors();
    R.clearCanvas(ctx, { canvas, dpr, colors });

    const actualCanvasWidth = canvas.width / dpr;
    const actualCanvasHeight = canvas.height / dpr;

    const { grid1Interval, grid2Interval, alpha1, alpha2 } = R.calculateGridIntervals(viewTransform.scale);
    lastGridState = { interval1: grid1Interval, interval2: grid2Interval, alpha1, alpha2, scale: viewTransform.scale };
    lastAngularGridState = R.getDynamicAngularIntervals(viewTransform, actualCanvasWidth, actualCanvasHeight, dataToScreen);

    R.drawGrid(ctx, { gridDisplayMode, canvas, dpr, viewTransform, gridAlpha, colors }, dataToScreen, screenToData, lastGridState, lastAngularGridState);

    if (coordsDisplayMode !== C.COORDS_DISPLAY_MODE_NONE) {
        const stateForAxes = { canvas, dpr, coordsDisplayMode, viewTransform, angleDisplayMode, colors };
        R.drawAxes(ctx, htmlOverlay, stateForAxes, dataToScreen, screenToData, lastGridState, lastAngularGridState, updateHtmlLabel);
    }

    if (facesVisible && allVertices.length > 0) {
        R.drawFaces(ctx, {
            allFaces,
            facesVisible,
            isDragConfirmed,
            dragPreviewVertices
        }, dataToScreen, findVertexById);
    }

    const copyCount = parseInt(copyCountInput || '1', 10);
    const isCopyPreviewActive = copyCount > 1 && isDragConfirmed && initialDragVertexStates.length > 0 && initialDragVertexStates.some(p => p.type === 'regular');

    const edgesWithHover = hoveredEdgeId ? [...selectedEdgeIds, hoveredEdgeId] : selectedEdgeIds;
    const stateForEdges = { allEdges, selectedEdgeIds: edgesWithHover, isDragConfirmed, dragPreviewVertices, colors, edgesVisible };
    R.drawAllEdges(ctx, stateForEdges, dataToScreen, findVertexById, U.getEdgeId);

    allVertices.forEach(vertex => {
        let vertexToDraw = { ...vertex };
        if (isDragConfirmed && dragPreviewVertices.length > 0) {
            const preview = dragPreviewVertices.find(dp => dp.id === vertex.id);
            if (preview) vertexToDraw = { ...preview };
        }
        R.drawVertex(ctx, vertexToDraw, { selectedVertexIds, selectedCenterIds, activeCenterId, colors, verticesVisible, isHovered: hoveredVertexId === vertex.id }, dataToScreen, updateHtmlLabel);
    });

    if (isCopyPreviewActive) {
        R.drawCopyPreviews(ctx, { copyCount, isDragConfirmed, initialDragVertexStates, dragPreviewVertices, transformIndicatorData, allEdges, findVertexById, findNeighbors: (id) => U.findNeighbors(id, allEdges), colors }, dataToScreen);
    }

    if (facesVisible && allVertices.length > 0) {
        R.drawFaceGlows(ctx, {
            allFaces,
            hoveredFaceId,
            selectedFaceIds,
            colors,
            isDragConfirmed,
            dragPreviewVertices
        }, dataToScreen, findVertexById, U.getFaceId);
        
        ensureFaceCoordinateSystems();
        
        if (selectedFaceIds.length > 0) {
            R.drawFaceCoordinateSystems(ctx, {
                allFaces,
                selectedFaceIds,
                colors: getColors(),
                isDragConfirmed,
                dragPreviewVertices
            }, dataToScreen, findVertexById);
        }
    }

    if (isDrawingMode && currentShiftPressed && frozenReference_Origin_Data) {
        const frozenDisplayContext = {
            frozen_Origin_Data_to_display: frozenReference_Origin_Data,
            displayAngleA_valueRad_for_A_equals_label: frozenReference_A_rad,
            frozen_A_baseRad_to_display: frozenReference_A_baseRad,
            frozen_D_du_to_display: frozenReference_D_du,
            frozen_D_g2g_to_display: frozenReference_D_g2g
        };
        const stateForRefGeo = { showAngles, showDistances, viewTransform, mousePos, colors };
        R.drawReferenceElementsGeometry(ctx, frozenDisplayContext, dataToScreen, screenToData, stateForRefGeo);
        const stateForRefTexts = { showAngles, showDistances, viewTransform, mousePos, frozenReference_D_du, distanceSigFigs, angleDisplayMode, colors };
        R.prepareReferenceElementsTexts(htmlOverlay, frozenDisplayContext, stateForRefTexts, screenToData, dataToScreen, updateHtmlLabel);
    }

    const stateForFeedback = { lastGridState, showDistances, showAngles, distanceSigFigs, angleDisplayMode, angleSigFigs, currentShiftPressed, viewTransform, colors };

    if (isDragConfirmed) {
        if (actionContext && actionContext.dragSnap) {
            const { dragOrigin, snappedData } = actionContext.dragSnap;
            const targetDataPos = { x: snappedData.x, y: snappedData.y };
            const edgeColorIndex = currentDrawingPath ? currentDrawingPath.length - 1 : 0;
            const totalExpectedEdges = currentDrawingPath ? Math.max(currentDrawingPath.length, 2) : 2;
            const nextEdgeColor = getColorForTarget(C.COLOR_TARGET_EDGE, edgeColorIndex, totalExpectedEdges);
            

            let edgeColormapInfo = null;
            const colorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
            if (colorIndex !== -1) {
                const colorItem = allColors[colorIndex];
                if (colorItem && colorItem.type === 'colormap') {
                    edgeColormapInfo = {
                        colormapItem: colorItem,
                        startT: 0,
                        endT: 1
                    };
                }
            }

            R.drawDrawingPreview(ctx, { startVertex: dragOrigin, snappedData, isShiftPressed: true, currentColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextCreationColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextEdgeColor, colors, edgeColormapInfo }, dataToScreen);
            const stateForSnapInfo = { showDistances, showAngles, currentShiftPressed, distanceSigFigs, angleSigFigs, angleDisplayMode, viewTransform, frozenReference_D_du, gridDisplayMode, frozenReference_A_rad, colors };
            R.prepareSnapInfoTexts(ctx, htmlOverlay, dragOrigin, targetDataPos, snappedData, stateForSnapInfo, dataToScreen, getDrawingContext(dragOrigin.id), updateHtmlLabel);
        } else {
            const hybridVertexStates = allVertices.map(p => {
                const draggedVersion = dragPreviewVertices.find(dp => dp.id === p.id);
                return draggedVersion || p;
            });

            if (actionContext && actionContext.targetVertex) {
                R.drawDragFeedback(ctx, htmlOverlay, actionContext.targetVertex.id, hybridVertexStates, stateForFeedback, dataToScreen, (id) => U.findNeighbors(id, allEdges), U.getEdgeId, currentShiftPressed, null, updateHtmlLabel, selectedVertexIds, true, initialDragVertexStates, activeCenterId);
            } else if (actionContext && actionContext.targetEdge) {
                R.drawSelectedEdgeDistances(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showDistances, distanceSigFigs, colors, lastGridState }, findVertexById, U.getEdgeId, dataToScreen, updateHtmlLabel, hybridVertexStates);
            }
        }
    } else if ((showDistances || showAngles) && !isDrawingMode && !isCopyPreviewActive && !isPlacingTransform) {
        if (selectedVertexIds.length > 0 && selectedVertexIds.length <= C.MAX_VERTICES_FOR_ANGLES) {
            selectedVertexIds.forEach(vertexId => {
                R.drawDragFeedback(ctx, htmlOverlay, vertexId, allVertices, { ...stateForFeedback, currentShiftPressed: false }, dataToScreen, (id) => U.findNeighbors(id, allEdges), U.getEdgeId, false, null, updateHtmlLabel, selectedVertexIds, false, [], activeCenterId);
            });
        }
        if (selectedEdgeIds.length > 0 && selectedEdgeIds.length <= C.MAX_EDGES_FOR_LABELS) {
            R.drawSelectedEdgeDistances(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showDistances, distanceSigFigs, colors, lastGridState }, findVertexById, U.getEdgeId, dataToScreen, updateHtmlLabel);
            R.drawSelectedEdgeAngles(ctx, htmlOverlay, selectedEdgeIds, allEdges, { showAngles, angleSigFigs, angleDisplayMode, currentShiftPressed, distanceSigFigs, viewTransform, lastGridState, colors }, findVertexById, U.getEdgeId, dataToScreen, (id) => U.findNeighbors(id, allEdges), updateHtmlLabel);
        }
    }

    if (isDrawingMode && previewLineStartVertexId) {
        const startVertex = findVertexById(previewLineStartVertexId);
        if (startVertex) {
            const currentPreviewDrawingContext = getDrawingContext(startVertex.id);
            const snappedData = getSnappedPosition(startVertex, mousePos, currentShiftPressed);
            
            let nextEdgeColor = getColorForTarget(C.COLOR_TARGET_EDGE);
            const colorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
            if (colorIndex !== -1) {
                const colorItem = allColors[colorIndex];
                if (colorItem && colorItem.type === 'colormap' && currentDrawingPath && currentDrawingPath.length >= 1) {
                    const totalEdges = currentDrawingPath.length;
                    const nextEdgeIndex = currentDrawingPath.length - 1;
                    const startT = totalEdges > 1 ? nextEdgeIndex / (totalEdges - 1) : 0;
                    const endT = totalEdges > 1 ? (nextEdgeIndex + 1) / totalEdges : 1;
                    nextEdgeColor = U.sampleColormap(colorItem, (startT + endT) / 2);
                }
            }
            
            R.drawDrawingPreview(ctx, { startVertex, snappedData, isShiftPressed: currentShiftPressed, currentColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextCreationColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextEdgeColor, colors }, dataToScreen);
        }
    }

    if (isRectangleSelecting && isDragConfirmed) {
        R.drawSelectionRectangle(ctx, rectangleSelectStartPos, mousePos, colors);
    }

    if (isDragConfirmed) {
        R.drawMergePreviews(ctx, { allVertices, dragPreviewVertices, viewTransform, colors, transformIndicatorData, copyCount: parseInt(copyCountInput || '1', 10), initialDragVertexStates }, dataToScreen);
    }

    if (ghostVertexPosition) {
        const screenPos = dataToScreen(ghostVertexPosition);
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, C.VERTEX_RADIUS, 0, 2 * Math.PI);
        ctx.fillStyle = colors.feedbackSnapped;
        ctx.fill();
    }

    ghostVertices.forEach(ghostVertex => {
        const screenPos = dataToScreen(ghostVertex);
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, C.VERTEX_RADIUS, 0, 2 * Math.PI);
        ctx.fillStyle = colors.feedbackSnapped;
        ctx.fill();
    });

    if (transformIndicatorData) {
        R.drawTransformIndicators(ctx, htmlOverlay, { transformIndicatorData, angleSigFigs, distanceSigFigs, colors }, dataToScreen, updateHtmlLabel);
    }

    R.updateMouseCoordinates(htmlOverlay, { coordsDisplayMode, isMouseOverCanvas, currentShiftPressed, ghostVertexPosition, gridDisplayMode, lastGridState, angleDisplayMode, canvas, dpr, mousePos, colors }, screenToData, updateHtmlLabel);

    const stateForUI = {
        dpr, canvasUI, isToolbarExpanded, isColorPaletteExpanded, isTransformPanelExpanded, isDisplayPanelExpanded, isVisibilityPanelExpanded,
        isPlacingTransform, placingTransformType, placingSnapPos, mousePos,
        allColors, activeThemeName, colors, verticesVisible, edgesVisible, facesVisible, coordsDisplayMode, gridDisplayMode, angleDisplayMode, distanceDisplayMode,
        namedColors: colorEditor.namedColors,
        colorAssignments, activeColorTarget
    };
    R.drawCanvasUI(ctx, htmlOverlay, stateForUI, updateHtmlLabel);

    cleanupHtmlLabels();
}

function getBestRigidTranslationSnap(initialDragVertexStates, rawDelta, copyCount) {
    const mergeSnap = getBestTranslationSnap(initialDragVertexStates, rawDelta, copyCount);
    if (mergeSnap.snapped) {
        return mergeSnap;
    }

    const handleVertex = initialDragVertexStates[0];
    const mouseDragPos = { x: handleVertex.x + rawDelta.x, y: handleVertex.y + rawDelta.y };
    const rawDist = Math.hypot(rawDelta.x, rawDelta.y);
    const rawAngle = Math.atan2(rawDelta.y, rawDelta.x);

    let allCandidates = [];
    const gridInterval = (lastGridState.alpha2 > lastGridState.alpha1 && lastGridState.interval2) ? lastGridState.interval2 : lastGridState.interval1;

    if (gridInterval) {
        const distUnit = gridInterval * 0.5;
        const snapDistBefore = Math.floor(rawDist / distUnit) * distUnit;
        const snapDistAfter = snapDistBefore + distUnit;

        const allSnapAngles = C.NINETY_DEG_ANGLE_SNAP_FRACTIONS.flatMap(f => {
            const angle = f * Math.PI / 2;
            return angle === 0 ? [0] : [angle, -angle];
        }).sort((a, b) => a - b);

        let angleBefore = -Infinity;
        let angleAfter = Infinity;

        for (const snapAngle of allSnapAngles) {
            if (snapAngle <= rawAngle) {
                angleBefore = snapAngle;
            }
            if (snapAngle >= rawAngle && angleAfter === Infinity) {
                angleAfter = snapAngle;
            }
        }
        if (angleAfter === Infinity) angleAfter = allSnapAngles[0] + (2 * Math.PI);
        if (angleBefore === -Infinity) angleBefore = allSnapAngles[allSnapAngles.length - 1] - (2 * Math.PI);

        allCandidates.push({ x: snapDistBefore * Math.cos(angleBefore), y: snapDistBefore * Math.sin(angleBefore) });
        allCandidates.push({ x: snapDistBefore * Math.cos(angleAfter), y: snapDistBefore * Math.sin(angleAfter) });
        allCandidates.push({ x: snapDistAfter * Math.cos(angleBefore), y: snapDistAfter * Math.sin(angleBefore) });
        allCandidates.push({ x: snapDistAfter * Math.cos(angleAfter), y: snapDistAfter * Math.sin(angleAfter) });

        const gridVertices = U.getGridSnapCandidates(mouseDragPos, gridDisplayMode, gridInterval, lastAngularGridState, true);
        gridVertices.forEach(p => {
            allCandidates.push({ x: p.x - handleVertex.x, y: p.y - handleVertex.y });
        });
    }

    if (allCandidates.length === 0) {
        return { delta: rawDelta, snapped: false };
    }

    let bestDelta = rawDelta;
    let minSnapDistSq = Infinity;
    allCandidates.forEach(deltaCandidate => {
        const distSq = (deltaCandidate.x - rawDelta.x) ** 2 + (deltaCandidate.y - rawDelta.y) ** 2;
        if (distSq < minSnapDistSq) {
            minSnapDistSq = distSq;
            bestDelta = deltaCandidate;
        }
    });

    const snapStickinessData = C.SNAP_STICKINESS_RADIUS_SCREEN / viewTransform.scale;
    if (Math.sqrt(minSnapDistSq) < snapStickinessData) {
        return { delta: bestDelta, snapped: true, snapType: 'geometric_grid' };
    }

    return { delta: rawDelta, snapped: false };
}

function updateDrawingSequenceColors() {
    if (!currentDrawingPath || currentDrawingPath.length < 2) return;
    
    const colorIndex = colorAssignments[C.COLOR_TARGET_VERTEX];
    if (colorIndex === -1) return;
    
    const colorItem = allColors[colorIndex];
    if (!colorItem || colorItem.type !== 'colormap') return;
    
    const totalVertices = currentDrawingPath.length;
    currentDrawingPath.forEach((vertexId, index) => {
        const vertex = findVertexById(vertexId);
        if (vertex && vertex.type === 'regular') {
            const t = totalVertices > 1 ? index / (totalVertices - 1) : 0.5;
            vertex.color = U.sampleColormap(colorItem, t);
        }
    });
}

function updateDrawingSequenceEdgeColors() {
    if (!currentDrawingPath || currentDrawingPath.length < 2) return;
    
    const colorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
    if (colorIndex === -1) return;
    
    const colorItem = allColors[colorIndex];
    if (!colorItem || colorItem.type !== 'colormap') return;
    
    const totalVertices = currentDrawingPath.length;
    const totalEdges = totalVertices - 1;
    
    for (let i = 0; i < totalEdges; i++) {
        const startVertexId = currentDrawingPath[i];
        const endVertexId = currentDrawingPath[i + 1];
        
        const edge = allEdges.find(e => 
            (e.id1 === startVertexId && e.id2 === endVertexId) ||
            (e.id1 === endVertexId && e.id2 === startVertexId)
        );
        
        if (edge) {
            const startT = i / totalEdges;
            const endT = (i + 1) / totalEdges;
            edge.gradientStart = startT;
            edge.gradientEnd = endT;
            edge.colormapItem = colorItem;
            delete edge.colormapOffset;
            delete edge.color;
        }
    }
}

function initializeColorPalette() {
    allColors = allColors.map(color => {
        if (typeof color === 'string') {
            return { type: 'color', value: color };
        }
        return color;
    });

    if (!allColors.some(item => item.type === 'color' && item.value === currentColor)) {
        allColors.unshift({ type: 'color', value: currentColor });
        if (allColors.length > 8) {
            allColors.pop();
        }
    }

    const currentColorIndex = allColors.findIndex(item =>
        item.type === 'color' && item.value === currentColor
    );
    if (currentColorIndex !== -1) {
        selectedColorIndices = [currentColorIndex];
    }
}

function handleColorPaletteClick(screenPos, shiftKey, ctrlKey) {
    if (!isColorPaletteExpanded) return false;

    // Check for clicks on the target icons first
    for (const icon of canvasUI.colorTargetIcons) {
        if (screenPos.x >= icon.x && screenPos.x <= icon.x + icon.width &&
            screenPos.y >= icon.y && screenPos.y <= icon.y + icon.height) {
            activeColorTarget = icon.target;
            return true;
        }
    }

    const now = Date.now();
    for (const swatch of canvasUI.colorSwatches) {
        if (screenPos.x >= swatch.x && screenPos.x <= swatch.x + swatch.width &&
            screenPos.y >= swatch.y && screenPos.y <= swatch.y + swatch.height) {

            const swatchId = `swatch-${swatch.index}`;
            if (clickData.targetId === swatchId && (now - clickData.timestamp) < C.DOUBLE_CLICK_MS) {
                // Double-click to edit
                isEditingColor = true;
                editingColorIndex = swatch.index;
                const colorToEdit = allColors[swatch.index];
                
                let initialState;
                if (colorToEdit.type === 'color') {
                    const parsedColor = U.parseColor(colorToEdit.value);
                    initialState = {
                        type: 'colormap',
                        points: [{
                            pos: 0.5,
                            alpha: parsedColor.a,
                            color: [parsedColor.r, parsedColor.g, parsedColor.b],
                            order: 1
                        }]
                    };
                } else if (colorToEdit.type === 'colormap') {
                    initialState = {
                        type: 'colormap',
                        points: colorToEdit.vertices.map(v => ({
                            pos: v.pos,
                            alpha: v.alpha !== undefined ? v.alpha : 1.0,
                            color: Array.isArray(v.color) ? [...v.color] : [v.color.r || 0, v.color.g || 0, v.color.b || 0],
                            order: v.order || 1
                        }))
                    };
                }
                
                colorEditor.show(undefined, undefined, initialState);
                clickData.count = 0;
            } else {
                // Single-click to assign color
                colorAssignments[activeColorTarget] = swatch.index;
                applyColorsToSelection();
                buildColorPaletteUI(); // Rebuild to move the icon
                clickData.targetId = swatchId;
                clickData.timestamp = now;
            }
            return true;
        }
    }

    const applyBtn = canvasUI.applyColorsButton;
    if (applyBtn && screenPos.x >= applyBtn.x && screenPos.x <= applyBtn.x + applyBtn.width &&
        screenPos.y >= applyBtn.y && screenPos.y <= applyBtn.y + applyBtn.height) {
        applyColorsToSelection();
        return true;
    }

    const randomBtn = canvasUI.randomColorButton;
    if (randomBtn && screenPos.x >= randomBtn.x && screenPos.x <= randomBtn.x + randomBtn.width &&
        screenPos.y >= randomBtn.y && screenPos.y <= randomBtn.y + randomBtn.height) {
        colorAssignments[activeColorTarget] = -1; // -1 represents random
        applyColorsToSelection();
        buildColorPaletteUI();
        return true;
    }

    const removeBtn = canvasUI.removeColorButton;
    if (removeBtn && screenPos.x >= removeBtn.x && screenPos.x <= removeBtn.x + removeBtn.width &&
        screenPos.y >= removeBtn.y && screenPos.y <= removeBtn.y + removeBtn.height) {
        const colorIndexToRemove = colorAssignments[activeColorTarget];
        if (colorIndexToRemove >= 0) {
             allColors.splice(colorIndexToRemove, 1);
             // Shift down assignments that were after the removed one
             Object.keys(colorAssignments).forEach(target => {
                 if (colorAssignments[target] > colorIndexToRemove) {
                     colorAssignments[target]--;
                 } else if (colorAssignments[target] === colorIndexToRemove) {
                    // Reassign the color for the current target to a safe default
                    colorAssignments[target] = 0;
                 }
             });
             buildColorPaletteUI();
        }
        return true;
    }

    const addBtn = canvasUI.addColorButton;
    if (addBtn && screenPos.x >= addBtn.x && screenPos.x <= addBtn.x + addBtn.width &&
        screenPos.y >= addBtn.y && screenPos.y <= addBtn.y + addBtn.height) {
        isEditingColor = false;
        editingColorIndex = null;
        colorEditor.show();
        return true;
    }

    return false;
}

function performEscapeAction() {
    if (copyCountTimer) clearTimeout(copyCountTimer);
    copyCountInput = '';
    copyCountTimer = null;

    if (isDrawingMode) {
        isDrawingMode = false;
        previewLineStartVertexId = null;
        frozenReference_A_rad = null;
        frozenReference_A_baseRad = null;
        frozenReference_D_du = null;
        frozenReference_D_g2g = null;
        frozenReference_Origin_Data = null;
        drawingSequence = [];
        currentSequenceIndex = 0;
        currentDrawingPath = [];
        return;
    }

    if (isPlacingTransform) {
        isPlacingTransform = false;
        placingTransformType = null;
        placingSnapPos = null;
        return;
    }

    selectedVertexIds = [];
    selectedEdgeIds = [];
    selectedFaceIds = [];
    selectedCenterIds = [];
    activeCenterId = null;
    isActionInProgress = false;
    isDragConfirmed = false;
    isRectangleSelecting = false;
    isEdgeTransformDrag = false;
    isDraggingCenter = false;
    isPanningBackground = false;
    dragPreviewVertices = [];
    initialDragVertexStates = [];
    actionTargetVertex = null;
    currentMouseButton = -1;
    clickData = { targetId: null, type: null, count: 0, timestamp: 0 };
    canvas.style.cursor = 'crosshair';
    transformIndicatorData = null;
    ghostVertices = [];
    ghostVertexPosition = null;
}

function handleRepeat() {
    if (!isDrawingMode || !previewLineStartVertexId || drawingSequence.length === 0) {
        return;
    }

    saveStateForUndo();

    const lastVertex = findVertexById(previewLineStartVertexId);
    if (!lastVertex) {
        performEscapeAction();
        return;
    }

    const precedingSegmentOfLastVertex = getPrecedingSegment(lastVertex.id);
    if (!precedingSegmentOfLastVertex) {
        performEscapeAction();
        return;
    }
    const currentAbsoluteDirection = precedingSegmentOfLastVertex.angleRad;

    if (drawingSequence.length === 1) {
        return;
    }

    const repeatPatternLength = drawingSequence.length - 1;
    const patternStepIndex = ((currentSequenceIndex - 1) % repeatPatternLength) + 1;
    const patternStep = drawingSequence[patternStepIndex];

    const lengthToDraw = patternStep.length;
    let turnToApplyForNextSegment;
    if (patternStepIndex === drawingSequence.length - 1) {
        const firstRepeatSegmentIndex = drawingSequence.length > 2 ? 1 : 0;
        turnToApplyForNextSegment = drawingSequence[firstRepeatSegmentIndex].turn;
    } else {
        turnToApplyForNextSegment = patternStep.turn;
    }

    let colorForNewVertex;
    let colorForCurrentVertex;

    if (patternStepIndex === drawingSequence.length - 1) {
        const establishedColors = [drawingSequence[0].endVertexColor, drawingSequence[1].endVertexColor];
        const currentColorIndex = (currentSequenceIndex - 1) % establishedColors.length;
        colorForCurrentVertex = establishedColors[currentColorIndex];
        const newColorIndex = currentSequenceIndex % establishedColors.length;
        colorForNewVertex = establishedColors[newColorIndex];
        lastVertex.color = colorForCurrentVertex;
    } else {
        colorForNewVertex = patternStep.endVertexColor;
    }

    const newSegmentAbsoluteAngle = U.normalizeAngle(currentAbsoluteDirection + turnToApplyForNextSegment);

    const targetX = lastVertex.x + lengthToDraw * Math.cos(newSegmentAbsoluteAngle);
    const targetY = lastVertex.y + lengthToDraw * Math.sin(newSegmentAbsoluteAngle);

    let newVertex = null;
    let merged = false;
    const mergeRadiusData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;

    for (const p of allVertices) {
        if (p.type === 'regular' && U.distance({ x: targetX, y: targetY }, p) < mergeRadiusData) {
            newVertex = p;
            merged = true;
            break;
        }
    }

    if (!merged) {
        newVertex = { id: U.generateUniqueId(), x: targetX, y: targetY, type: 'regular', color: colorForNewVertex };
        allVertices.push(newVertex);
    }

    const edgeExists = allEdges.some(e =>
            (e.id1 === lastVertex.id && e.id2 === newVertex.id) ||
            (e.id2 === lastVertex.id && e.id1 === newVertex.id)
        );
        if (!edgeExists) {
            allEdges.push({ id1: lastVertex.id, id2: newVertex.id, color: getColorForTarget(C.COLOR_TARGET_EDGE) });
        }

        if (facesVisible) {
            allFaces = U.detectClosedPolygons(allEdges, findVertexById);
            ensureFaceCoordinateSystems();
        }

        currentDrawingPath.push(newVertex.id);
        window.currentDrawingPath = currentDrawingPath;

        // Update both vertex and edge colors in the drawing sequence
        updateDrawingSequenceColors();
        updateDrawingSequenceEdgeColors();

    previewLineStartVertexId = newVertex.id;

    currentSequenceIndex++;
    if (currentSequenceIndex >= drawingSequence.length) {
        currentSequenceIndex = 1;
    }

    frozenReference_D_du = null;
    frozenReference_D_g2g = null;
    frozenReference_A_rad = null;
    frozenReference_A_baseRad = null;
    frozenReference_Origin_Data = null;
}

function gameLoop() {
    redrawAll();
    requestAnimationFrame(gameLoop);
}

function buildAdjacencyMap(edges) {
    const adjMap = new Map();
    edges.forEach(e => {
        if (!adjMap.has(e.id1)) adjMap.set(e.id1, []);
        if (!adjMap.has(e.id2)) adjMap.set(e.id2, []);
        adjMap.get(e.id1).push(e.id2);
        adjMap.get(e.id2).push(e.id1);
    });
    return adjMap;
}

function findAllSimplePaths(startId, endId, adjMap) {
    const allPaths = [];
    const queue = [[startId, [startId]]];

    while (queue.length > 0) {
        const [currentId, path] = queue.shift();

        if (path.length > allVertices.length) continue;

        const neighbors = adjMap.get(currentId) || [];
        for (const neighborId of neighbors) {
            if (neighborId === endId) {
                allPaths.push([...path, neighborId]);
                continue;
            }

            if (!path.includes(neighborId)) {
                const newPath = [...path, neighborId];
                queue.push([neighborId, newPath]);
            }
        }
    }
    return allPaths;
}

function handleCoordinateSystemMouseDown(event) {
    if (selectedFaceIds.length === 0) return false;

    const mousePos = U.getMousePosOnCanvas(event, canvas);

    for (const faceId of selectedFaceIds) {
        const face = allFaces.find(f => f.id === faceId);
        if (!face || !face.localCoordSystem) continue;

        const element = U.findCoordinateSystemElement(mousePos, face, dataToScreen);
        if (element) {
            isDraggingCoordSystem = true;
            draggedCoordSystemElement = element;

            coordSystemSnapTargets = prepareCoordSystemSnapTargets(face);

            if (element.type === 'center') {
                face.localCoordSystem.isCustom = true;
            }

            event.preventDefault();
            return true;
        }
    }

    return false;
}

function prepareCoordSystemSnapTargets(currentFace) {
    const vertices = [];
    const edgeMidvertices = [];
    const faceCenters = [];
    const edgeAngles = [];

    currentFace.vertexIds.forEach(id => {
        const vertex = findVertexById(id);
        if (vertex && vertex.type === 'regular') {
            vertices.push({ x: vertex.x, y: vertex.y });
        }
    });

    for (let i = 0; i < vertices.length; i++) {
        const v1 = vertices[i];
        const v2 = vertices[(i + 1) % vertices.length];
        edgeMidvertices.push({
            x: (v1.x + v2.x) / 2,
            y: (v1.y + v2.y) / 2
        });

        edgeAngles.push(Math.atan2(v2.y - v1.y, v2.x - v1.x));
    }

    allFaces.forEach(face => {
        if (face.id !== currentFace.id && face.localCoordSystem) {
            faceCenters.push(face.localCoordSystem.origin);
        }
    });

    return { vertices, edgeMidvertices, faceCenters, edgeAngles };
}

function handleCoordinateSystemMouseMove(event) {
    if (!isDraggingCoordSystem || !draggedCoordSystemElement) return false;

    const mousePos = U.getMousePosOnCanvas(event, canvas);
    const mouseDataPos = screenToData(mousePos);
    const element = draggedCoordSystemElement;
    const face = element.face;
    const coordSystem = face.localCoordSystem;

    if (element.type === 'center') {
        const snappedPos = U.getCoordinateSystemSnapPosition(
            mouseDataPos,
            coordSystemSnapTargets,
            event.shiftKey
        );

        coordSystem.origin.x = snappedPos.x;
        coordSystem.origin.y = snappedPos.y;
        coordSystem.isCustom = true;

    } else if (element.type === 'x_axis' || element.type === 'y_axis') {
        const vectorFromOrigin = {
            x: mouseDataPos.x - coordSystem.origin.x,
            y: mouseDataPos.y - coordSystem.origin.y
        };
        
        const newScale = Math.hypot(vectorFromOrigin.x, vectorFromOrigin.y);
        let newAngle = Math.atan2(vectorFromOrigin.y, vectorFromOrigin.x);

        // Snap angle
        const snappedAngle = U.getAxisSnapAngle(
            mouseDataPos,
            coordSystem.origin,
            event.shiftKey,
            coordSystemSnapTargets
        );
        newAngle = snappedAngle;

        // Apply rotation based on which axis is dragged
        if (element.type === 'y_axis') {
            coordSystem.angle = newAngle - Math.PI / 2;
        } else { // x_axis
            coordSystem.angle = newAngle;
        }
        
        // Apply scale
        coordSystem.scale = newScale;

        coordSystem.isCustom = true;
    }

    return true;
}

function handleCoordinateSystemMouseUp() {
    if (isDraggingCoordSystem) {
        isDraggingCoordSystem = false;
        draggedCoordSystemElement = null;
        coordSystemSnapTargets = null;
        return true;
    }
    return false;
}

function handleCoordinateSystemKeyDown(event) {
    if (selectedFaceIds.length === 0) return false;

    if (event.key === 'r' && !event.ctrlKey && !event.shiftKey) {
        saveStateForUndo();
        selectedFaceIds.forEach(faceId => {
            const face = allFaces.find(f => f.id === faceId);
            if (face && face.localCoordSystem) {
                face.localCoordSystem.isCustom = false;
                face.localCoordSystem.angle = 0;
                U.updateFaceLocalCoordinateSystems([face], findVertexById);
            }
        });
        event.preventDefault();
        return true;
    }

    return false;
}

function updateFaces(edgesBefore, edgesAfter) {
    if (!facesVisible) {
        allFaces = [];
        return;
    }

    const possibleFacesBefore = U.detectClosedPolygons(edgesBefore, findVertexById);
    const possibleFacesAfter = U.detectClosedPolygons(edgesAfter, findVertexById);

    const idsBefore = new Set(possibleFacesBefore.map(f => U.getFaceId(f)));
    const idsAfter = new Set(possibleFacesAfter.map(f => U.getFaceId(f)));

    // Remove faces that no longer exist
    const destroyedFaceIds = new Set([...idsBefore].filter(id => !idsAfter.has(id)));
    if (destroyedFaceIds.size > 0) {
        allFaces = allFaces.filter(f => !destroyedFaceIds.has(U.getFaceId(f)));
    }

    // Add only newly created faces
    const newFaces = possibleFacesAfter.filter(f => !idsBefore.has(U.getFaceId(f)));
    if (newFaces.length > 0) {
        allFaces.push(...newFaces);
    }

    ensureFaceCoordinateSystems();
}

function handleCoordSystemKeyDown(event) {
    if (selectedFaceIds.length === 0) return false;

    if (event.key === 'r' && !event.ctrlKey && !event.shiftKey) {
        saveStateForUndo();
        selectedFaceIds.forEach(faceId => {
            const face = allFaces.find(f => f.id === faceId);
            if (face && face.localCoordSystem) {
                face.localCoordSystem.isCustom = false;
                face.localCoordSystem.angle = 0;
                U.updateFaceLocalCoordinateSystems([face], findVertexById);
            }
        });
        event.preventDefault();
        return true;
    }

    return false;
}

function handleKeyDown(event) {
    const isCtrlOrCmd = event.ctrlKey || event.metaKey;

    if (handleCoordSystemKeyDown(event)) {
        return;
    }

    if (event.key === 'Shift' && !currentShiftPressed) {
        currentShiftPressed = true;
        const mouseDataPos = screenToData(mousePos);
        if (isPlacingTransform) {
            const potentialSnapPos = getBestSnapPosition(mouseDataPos);
            if (potentialSnapPos) {
                placingSnapPos = dataToScreen(potentialSnapPos);
                ghostVertexPosition = potentialSnapPos;
            }
        } else if (isDrawingMode && previewLineStartVertexId) {
            const startVertex = findVertexById(previewLineStartVertexId);
            if (startVertex) {
                const currentPreviewDrawingContext = getDrawingContext(startVertex.id);
                const snappedData = getSnappedPosition(startVertex, mousePos, currentShiftPressed);

                let nextEdgeColor = getColorForTarget(C.COLOR_TARGET_EDGE);
                let edgeColormapInfo = null;

                const colorIndex = colorAssignments[C.COLOR_TARGET_EDGE];
                if (colorIndex !== -1) {
                    const colorItem = allColors[colorIndex];
                    if (colorItem && colorItem.type === 'colormap' && currentDrawingPath && currentDrawingPath.length >= 1) {
                        const totalEdges = currentDrawingPath.length;
                        const nextEdgeIndex = currentDrawingPath.length - 1;
                        const startT = totalEdges > 1 ? nextEdgeIndex / (totalEdges - 1) : 0;
                        const endT = totalEdges > 1 ? (nextEdgeIndex + 1) / totalEdges : 1;
                        edgeColormapInfo = {
                            colormapItem: colorItem,
                            startT: startT,
                            endT: endT
                        };
                    }
                }

                R.drawDrawingPreview(ctx, { startVertex, snappedData, isShiftPressed: currentShiftPressed, currentColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextCreationColor: getColorForTarget(C.COLOR_TARGET_VERTEX), nextEdgeColor, colors, edgeColormapInfo }, dataToScreen);const stateForSnapInfo = { showDistances, showAngles, currentShiftPressed, distanceSigFigs, angleSigFigs, angleDisplayMode, viewTransform, frozenReference_D_du, gridDisplayMode, frozenReference_A_rad, colors };
                R.prepareSnapInfoTexts(ctx, htmlOverlay, startVertex, snappedData, snappedData, stateForSnapInfo, dataToScreen, currentPreviewDrawingContext, updateHtmlLabel);
            }
        } else if (!isActionInProgress) {
            ghostVertexPosition = getBestSnapPosition(mouseDataPos);
        }
    }

    if (isActionInProgress && currentMouseButton === 0 && (actionContext?.targetVertex || actionContext?.targetEdge) && event.key >= '0' && event.key <= '9') {
        if (event.repeat) {
            return;
        }
        event.preventDefault();

        clearTimeout(copyCountTimer);

        if (copyCountTimer === null || copyCountInput.length >= 2) {
            copyCountInput = event.key;
        } else {
            copyCountInput += event.key;
        }

        copyCountTimer = setTimeout(() => {
            copyCountTimer = null;
        }, 500);
        return;
    }

    if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_REPEAT) {
        event.preventDefault();
        if (isDrawingMode && previewLineStartVertexId) {
            handleRepeat();
        }
        return;
    }

    const allowedDuringAction = ['Shift', 'Control', 'Meta', 'Alt', 'Escape', 'Delete', 'Backspace'];
    if (isActionInProgress && !allowedDuringAction.includes(event.key) && !(isCtrlOrCmd && [C.KEY_COPY, C.KEY_CUT, C.KEY_PASTE, C.KEY_UNDO, C.KEY_REDO, C.KEY_SELECT_ALL, C.KEY_ZOOM_OUT, C.KEY_ZOOM_IN, C.KEY_ZOOM_IN_PLUS].includes(event.key.toLowerCase()))) return;

    if (isMouseOverCanvas && isCtrlOrCmd && (event.key === C.KEY_ZOOM_IN || event.key === C.KEY_ZOOM_IN_PLUS)) {
        event.preventDefault();
        const centerScreen = { x: (canvas.width / dpr) / 2, y: (canvas.height / dpr) / 2 };
        zoomAt(centerScreen, C.KEYBOARD_ZOOM_FACTOR);
        return;
    }
    if (isMouseOverCanvas && isCtrlOrCmd && event.key === C.KEY_ZOOM_OUT) {
        event.preventDefault();
        const centerScreen = { x: (canvas.width / dpr) / 2, y: (canvas.height / dpr) / 2 };
        zoomAt(centerScreen, 1 / C.KEYBOARD_ZOOM_FACTOR);
        return;
    }

    if (event.key === C.KEY_SPACE) {
        event.preventDefault();
        completeGraphOnSelectedVertices();
    } else if (event.key === C.KEY_ESCAPE) {
        performEscapeAction();
    } else if (event.key === C.KEY_DELETE || event.key === C.KEY_BACKSPACE) {
        deleteSelectedItems();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_COPY) {
        event.preventDefault();
        handleCopy();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_CUT) {
        event.preventDefault();
        handleCut();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_PASTE) {
        event.preventDefault();
        handlePaste();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_UNDO && !event.shiftKey) {
        event.preventDefault();
        handleUndo();
    } else if (isCtrlOrCmd && (event.key.toLowerCase() === C.KEY_REDO || (event.shiftKey && event.key.toLowerCase() === C.KEY_UNDO))) {
        event.preventDefault();
        handleRedo();
    } else if (isCtrlOrCmd && event.key.toLowerCase() === C.KEY_SELECT_ALL) {
        event.preventDefault();
        selectedVertexIds = allVertices.filter(p => p.type === 'regular').map(p => p.id);
        selectedEdgeIds = allEdges.map(edge => U.getEdgeId(edge));
        selectedFaceIds = allFaces.map(face => face.id);
        selectedCenterIds = allVertices.filter(p => p.type !== 'regular').map(p => p.id);
        activeCenterId = null;
    }
}

function handleMouseDown(event) {
    const targetElement = event.target;
    if (targetElement && targetElement.closest('.katex')) {
        event.stopPropagation();
        return;
    }

    mousePos = U.getMousePosOnCanvas(event, canvas);
    actionStartPos = { ...mousePos }; 
    
    if (isColorPaletteExpanded && canvasUI.colorTargetIcons) {
        for (let i = canvasUI.colorTargetIcons.length - 1; i >= 0; i--) {
            const icon = canvasUI.colorTargetIcons[i];
            if (mousePos.x >= icon.x && mousePos.x <= icon.x + icon.width &&
                mousePos.y >= icon.y && mousePos.y <= icon.y + icon.height) {
                
                const now = Date.now();
                const targetId = `target-icon-${icon.target}`;

                if (clickData.targetId === targetId && (now - clickData.timestamp) < C.DOUBLE_CLICK_MS) {
                    clickData.count = 0; 
                    if (icon.target === C.COLOR_TARGET_VERTEX) verticesVisible = !verticesVisible;
                    else if (icon.target === C.COLOR_TARGET_EDGE) edgesVisible = !edgesVisible;
                    else if (icon.target === C.COLOR_TARGET_FACE) facesVisible = !facesVisible;
                } else {
                    clickData.targetId = targetId;
                    clickData.timestamp = now;
                    activeColorTarget = icon.target;
                    isDraggingColorTarget = true;
                    draggedColorTargetInfo = {
                        target: icon.target,
                        offsetX: mousePos.x - icon.x,
                        offsetY: mousePos.y - icon.y
                    };
                }
                
                isActionInProgress = true; 
                actionContext = { target: 'ui-icon', targetVertex: null, targetEdge: null, targetFace: null, shiftKey: event.shiftKey, ctrlKey: event.ctrlKey || event.metaKey };
                return; 
            }
        }
    }

    isDraggingCenter = false;

    if (handleCanvasUIClick(mousePos, event.shiftKey, event.ctrlKey || event.metaKey)) {
        return;
    }

    if (handleCoordinateSystemMouseDown(event)) {
        return;
    }

    if (isDrawingMode && event.button === 2) {
        performEscapeAction();
        return;
    }

    if (event.altKey && !isDrawingMode && (findClickedVertex(mousePos) || findClickedEdge(mousePos))) {
        const clickedEdge = findClickedEdge(mousePos);
        saveStateForUndo();
        performEscapeAction();
        isActionInProgress = true;
        currentMouseButton = 0;
        actionContext = { target: null, shiftKey: false, ctrlKey: false };

        const clickedVertex = findClickedVertex(mousePos);
        if (clickedVertex && clickedVertex.type === 'regular') {
            isDrawingMode = true;
            previewLineStartVertexId = clickedVertex.id;
        } else if (clickedEdge) {
            const p1 = findVertexById(clickedEdge.id1);
            const p2 = findVertexById(clickedEdge.id2);
            if (p1 && p2) {
                const closest = U.getClosestPointOnLineSegment(screenToData(actionStartPos), p1, p2);
                insertVertexOnEdgeWithFaces(clickedEdge, closest);
                const newVertex = allVertices[allVertices.length - 1];
                isDrawingMode = true;
                previewLineStartVertexId = newVertex.id;
            }
        }
        return;
    }

    let clickedVertex = findClickedVertex(mousePos);
    let clickedEdge = !clickedVertex ? findClickedEdge(mousePos) : null;
    let clickedFace = !clickedVertex && !clickedEdge ? findClickedFace(mousePos) : null;

    if (!isDrawingMode && !event.shiftKey && !event.ctrlKey) {
        if (clickedVertex && clickedVertex.type === 'regular' && !selectedVertexIds.includes(clickedVertex.id)) {
            applySelectionLogic([clickedVertex.id], [], [], false, false);
        } else if (clickedEdge && !selectedEdgeIds.includes(U.getEdgeId(clickedEdge))) {
            applySelectionLogic([], [U.getEdgeId(clickedEdge)], [], false, false);
        } else if (clickedFace && !selectedFaceIds.includes(U.getFaceId(clickedFace))) {
            applySelectionLogic([], [], [U.getFaceId(clickedFace)], false, false);
        }
    }

    isActionInProgress = true;
    isDragConfirmed = false;
    isPanningBackground = false;
    isRectangleSelecting = false;
    initialDragVertexStates = [];
    dragPreviewVertices = [];
    currentMouseButton = event.button;
    
    // THE FIX IS HERE: This line was missing.
    rectangleSelectStartPos = actionStartPos;

    actionContext = { targetVertex: clickedVertex, targetEdge: clickedEdge, targetFace: clickedFace, target: clickedVertex || clickedEdge || clickedFace || 'canvas', shiftKey: event.shiftKey, ctrlKey: event.ctrlKey || event.metaKey };

    if (clickedVertex && clickedVertex.type !== 'regular') {
        isDraggingCenter = true;
        handleCenterSelection(clickedVertex.id, event.shiftKey, event.ctrlKey || event.metaKey);
    }
}

function handleMouseMove(event) {
    mousePos = U.getMousePosOnCanvas(event, canvas);
    currentShiftPressed = event.shiftKey;

    if (isDraggingColorTarget && draggedColorTargetInfo) {
        // Find all possible drop targets
        const dropTargets = [...canvasUI.colorSwatches, canvasUI.randomColorButton];
        let closestTarget = null;
        let minDistance = Infinity;

        // Find the closest swatch to the current mouse position
        dropTargets.forEach(target => {
            if (!target) return;
            const targetCenter = { x: target.x + target.width / 2 };
            const d = Math.abs(mousePos.x - targetCenter.x);
            if (d < minDistance) {
                minDistance = d;
                closestTarget = target;
            }
        });

        const icon = canvasUI.colorTargetIcons.find(i => i.target === draggedColorTargetInfo.target);
        if (icon && closestTarget) {
            // Snap the icon's position to the center of the closest target during the drag
            const targetCenter = { x: closestTarget.x + closestTarget.width / 2 };
            icon.x = targetCenter.x - icon.width / 2;
        }
        return;
    }

    if (handleCoordinateSystemMouseMove(event)) {
        return;
    }

    hoveredVertexId = null;
    hoveredEdgeId = null;
    hoveredFaceId = null;

    if (!isActionInProgress) {
        const p = findClickedVertex(mousePos);
        const e = findClickedEdge(mousePos);
        const f = findClickedFace(mousePos);

        if (p) {
            hoveredVertexId = p.id;
        } else if (e) {
            hoveredEdgeId = U.getEdgeId(e);
        } else if (f) {
            hoveredFaceId = f.id;
        }
    }

    if (currentShiftPressed && !isActionInProgress) {
        const mouseDataPos = screenToData(mousePos);
        if (isPlacingTransform) {
            const potentialSnapPos = getBestSnapPosition(mouseDataPos);
            if (potentialSnapPos) {
                placingSnapPos = dataToScreen(potentialSnapPos);
                ghostVertexPosition = potentialSnapPos;
            }
        } else if (isDrawingMode && previewLineStartVertexId) {
            const startVertex = findVertexById(previewLineStartVertexId);
            if (startVertex) {
                const snappedData = getSnappedPosition(startVertex, mousePos, currentShiftPressed);
                ghostVertexPosition = { x: snappedData.x, y: snappedData.y };
            }
        } else {
            ghostVertexPosition = getBestSnapPosition(mouseDataPos);
        }
    } else if (!currentShiftPressed && isDrawingMode && previewLineStartVertexId) {
        const startVertex = findVertexById(previewLineStartVertexId);
        if (startVertex) {
            const snappedData = getSnappedPosition(startVertex, mousePos, false);
            if (snappedData.snapped && (snappedData.snapType === 'vertex' || snappedData.snapType === 'edge')) {
                ghostVertexPosition = { x: snappedData.x, y: snappedData.y };
            } else {
                ghostVertexPosition = null;
            }
        } else {
            ghostVertexPosition = null;
        }
    } else if (!currentShiftPressed) {
        ghostVertexPosition = null;
        placingSnapPos = null;
    }

    if (!isActionInProgress) {
        return;
    }

    if (!isDragConfirmed && U.distance(mousePos, actionStartPos) > C.DRAG_THRESHOLD) {
        isDragConfirmed = true;
        isEdgeTransformDrag = false;

        if (currentMouseButton === 2) {
            isRectangleSelecting = true;
            return;
        }

        if (actionContext.target === 'canvas') {
            isPanningBackground = true;
            backgroundPanStartOffset = { x: viewTransform.offsetX, y: viewTransform.offsetY };
            canvas.style.cursor = 'move';
        } else {
            canvas.style.cursor = 'grabbing';
            isDraggingCenter = actionContext.targetVertex && actionContext.targetVertex.type !== 'regular';

            let verticesToDragIds = new Set(selectedVertexIds);

            selectedEdgeIds.forEach(edgeId => {
                const [id1, id2] = edgeId.split(C.EDGE_ID_DELIMITER);
                verticesToDragIds.add(id1);
                verticesToDragIds.add(id2);
            });

            selectedFaceIds.forEach(faceId => {
                const face = allFaces.find(f => U.getFaceId(f) === faceId);
                if (face) {
                    face.vertexIds.forEach(id => verticesToDragIds.add(id));
                }
            });

            let verticesToDrag = Array.from(verticesToDragIds).map(id => findVertexById(id)).filter(p => p && p.type === 'regular');

            if (isDraggingCenter) {
                verticesToDrag = [actionContext.targetVertex];
                if (actionContext.targetVertex.type === C.TRANSFORMATION_TYPE_ROTATION) {
                    const center = actionContext.targetVertex;
                    const startReferenceVertex = screenToData(actionStartPos);
                    const startVector = { x: startReferenceVertex.x - center.x, y: startReferenceVertex.y - center.y };
                    actionContext.initialRotationStartAngle = Math.atan2(startVector.y, startVector.x);
                    currentAccumulatedRotation = 0;
                }
            }

            if (verticesToDrag.length > 0) {
                initialDragVertexStates = JSON.parse(JSON.stringify(verticesToDrag));
                dragPreviewVertices = JSON.parse(JSON.stringify(verticesToDrag));
            }
        }
    }

    if (isDragConfirmed) {
        actionContext.dragSnap = null;
        const isTransformingSelection = activeCenterId && selectedVertexIds.length > 0 && !isEdgeTransformDrag;
        ghostVertexPosition = null;
        ghostVertices = [];

        if (isPanningBackground) {
            const deltaX_css = mousePos.x - actionStartPos.x;
            const deltaY_css = mousePos.y - actionStartPos.y;
            viewTransform.offsetX = backgroundPanStartOffset.x + (deltaX_css * dpr);
            viewTransform.offsetY = backgroundPanStartOffset.y - (deltaY_css * dpr);
        } else if (isDraggingCenter) {
            const mouseData = screenToData(mousePos);
            const startMouseData = screenToData(actionStartPos);
            let finalDelta = { x: mouseData.x - startMouseData.x, y: mouseData.y - startMouseData.y };
            const targetSnapPos = { x: initialDragVertexStates[0].x + finalDelta.x, y: initialDragVertexStates[0].y + finalDelta.y };
            const snapResult = getDragSnapPosition(initialDragVertexStates[0], targetSnapPos);
            if (snapResult.snapped) {
                finalDelta = { x: snapResult.vertex.x - initialDragVertexStates[0].x, y: snapResult.vertex.y - initialDragVertexStates[0].y };
                ghostVertexPosition = snapResult.vertex;
            }
            const newPos = { x: initialDragVertexStates[0].x + finalDelta.x, y: initialDragVertexStates[0].y + finalDelta.y };
            dragPreviewVertices[0].x = newPos.x;
            dragPreviewVertices[0].y = newPos.y;
        } else if (isTransformingSelection || isEdgeTransformDrag) {
            const center = findVertexById(activeCenterId);
            let startReferenceVertex;
            if (isEdgeTransformDrag) {
                startReferenceVertex = screenToData(actionStartPos);
            } else {
                startReferenceVertex = initialDragVertexStates.find(p => actionTargetVertex && p.id === actionTargetVertex.id);
                if (!startReferenceVertex || U.distance(startReferenceVertex, center) < 1e-6) {
                    startReferenceVertex = initialDragVertexStates.find(p => U.distance(p, center) > 1e-6) || startReferenceVertex || initialDragVertexStates[0];
                }
            }
            if (!center || !startReferenceVertex) return;
            const centerType = center.type;
            const mouseData = screenToData(mousePos);
            const rawTransform = calculateTransformFromMouse(center, mouseData, startReferenceVertex, centerType, currentAccumulatedRotation);
            let snapResult = {};
            let finalTransform = {};
            if (centerType === C.TRANSFORMATION_TYPE_ROTATION) {
                snapResult = getBestRotationSnap(center, initialDragVertexStates, startReferenceVertex, rawTransform.rotation);
                finalTransform = { rotation: snapResult.rotation, scale: 1, directionalScale: false };
                currentAccumulatedRotation = snapResult.rotation;
            } else if (centerType === C.TRANSFORMATION_TYPE_SCALE) {
                snapResult = getBestScaleSnap(center, initialDragVertexStates, startReferenceVertex, rawTransform.scale);
                finalTransform = { rotation: 0, scale: snapResult.scale || rawTransform.scale, directionalScale: false };
            } else if (centerType === C.TRANSFORMATION_TYPE_DIRECTIONAL_SCALE) {
                const startVector = { x: startReferenceVertex.x - center.x, y: startReferenceVertex.y - center.y };
                snapResult = getBestDirectionalScaleSnap(center, initialDragVertexStates, startReferenceVertex, rawTransform.scale, startVector);
                finalTransform = { rotation: 0, scale: snapResult.scale || rawTransform.scale, directionalScale: true };
            }
            transformIndicatorData = {
                center,
                startPos: startReferenceVertex,
                currentPos: snapResult.pos || mouseData,
                rotation: finalTransform.rotation,
                scale: finalTransform.scale,
                isSnapping: snapResult.snapped || false,
                transformType: centerType,
                directionalScale: finalTransform.directionalScale,
                snappedScaleValue: snapResult.snappedScaleValue || null,
                gridToGridInfo: snapResult.gridToGridInfo || null
            };
            const startVectorForApply = { x: startReferenceVertex.x - center.x, y: startReferenceVertex.y - center.y };
            dragPreviewVertices = initialDragVertexStates.map(p_initial => {
                const newPos = U.applyTransformToVertex(p_initial, center, finalTransform.rotation, finalTransform.scale, finalTransform.directionalScale, startVectorForApply);
                return { ...p_initial, x: newPos.x, y: newPos.y };
            });
            if (snapResult.snapped && snapResult.snapType === 'merge' && snapResult.mergingVertex && snapResult.mergeTarget) {
                const sourceVertexInitial = initialDragVertexStates.find(p => p.id === snapResult.mergingVertex.id);
                if (sourceVertexInitial) {
                    const snappedVertexPreview = dragPreviewVertices.find(p => p.id === sourceVertexInitial.id);
                    if (snappedVertexPreview) {
                        const correctionVector = { x: snapResult.mergeTarget.x - snappedVertexPreview.x, y: snapResult.mergeTarget.y - snappedVertexPreview.y };
                        dragPreviewVertices.forEach(p => { p.x += correctionVector.x; p.y += correctionVector.y; });
                        if (transformIndicatorData.currentPos) { transformIndicatorData.currentPos.x += correctionVector.x; transformIndicatorData.currentPos.y += correctionVector.y; }
                    }
                }
            }
            ghostVertices = [];
            ghostVertexPosition = null;
            const mergeRadiusData = (C.VERTEX_RADIUS * 2) / viewTransform.scale;
            const staticVerticesForMerge = allVertices.filter(p => p.type === 'regular' && !initialDragVertexStates.some(ip => ip.id === p.id));
            dragPreviewVertices.forEach(previewVertex => {
                if (previewVertex.type === 'regular') {
                    staticVerticesForMerge.forEach(staticVertex => {
                        if (U.distance(previewVertex, staticVertex) < mergeRadiusData) { ghostVertices.push({ x: staticVertex.x, y: staticVertex.y }); }
                    });
                }
            });
            for (let i = 0; i < dragPreviewVertices.length; i++) {
                for (let j = i + 1; j < dragPreviewVertices.length; j++) {
                    const p1 = dragPreviewVertices[i];
                    const p2 = dragPreviewVertices[j];
                    if (p1.type === 'regular' && p2.type === 'regular' && U.distance(p1, p2) < mergeRadiusData) {
                        ghostVertices.push({ x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 });
                    }
                }
            }
        } else if (dragPreviewVertices.length > 0) {
            const mouseData = screenToData(mousePos);
            const startMouseData = screenToData(actionStartPos);
            const rawDelta = { x: mouseData.x - startMouseData.x, y: mouseData.y - startMouseData.y };
            let snapResult = { snapped: false };
            const copyCount = parseInt(copyCountInput || '1', 10);

            const isDeformingDrag = currentShiftPressed &&
                initialDragVertexStates.length === 1 &&
                initialDragVertexStates[0].type === 'regular' &&
                U.findNeighbors(initialDragVertexStates[0].id, allEdges).some(id => !selectedVertexIds.includes(id));

            if (isDeformingDrag) {
                const dragOrigin = initialDragVertexStates[0];
                snapResult = getDeformingSnapPosition(dragOrigin, mouseData, selectedVertexIds);
                const previewVertexToUpdate = dragPreviewVertices.find(dp => dp && dp.id === dragOrigin.id);
                if (previewVertexToUpdate) {
                    previewVertexToUpdate.x = snapResult.pos.x;
                    previewVertexToUpdate.y = snapResult.pos.y;
                }
            } else {
                let finalDelta;
                if (currentShiftPressed) {
                    snapResult = getBestRigidTranslationSnap(initialDragVertexStates, rawDelta, copyCount);
                    finalDelta = snapResult.delta;
                } else {
                    snapResult = getBestTranslationSnap(initialDragVertexStates, rawDelta, copyCount);
                    finalDelta = snapResult.delta;
                }
                initialDragVertexStates.forEach(originalVertexState => {
                    const previewVertexToUpdate = dragPreviewVertices.find(dp => dp && dp.id === originalVertexState.id);
                    if (previewVertexToUpdate) {
                        previewVertexToUpdate.x = originalVertexState.x + finalDelta.x;
                        previewVertexToUpdate.y = originalVertexState.y + finalDelta.y;
                    }
                });
            }

            actionContext.finalSnapResult = snapResult;
            if (snapResult.snapped && snapResult.mergeTarget) {
                ghostVertexPosition = snapResult.mergeTarget;
            }
        }
    }
}

function handleMouseUp(event) {
    if (isDraggingColorTarget) {
        // The snapping is already handled by mousemove, so we just need to find the final target.
        const draggedIcon = canvasUI.colorTargetIcons.find(i => i.target === draggedColorTargetInfo.target);
        if (draggedIcon) {
            const iconCenter = { x: draggedIcon.x + draggedIcon.width / 2 };
            const dropTargets = [...canvasUI.colorSwatches, canvasUI.randomColorButton];
            let closestTarget = null;
            let minDistance = Infinity;

            dropTargets.forEach(target => {
                if (!target) return;
                const targetCenter = { x: target.x + target.width / 2 };
                const d = Math.abs(iconCenter.x - targetCenter.x);
                if (d < minDistance) {
                    minDistance = d;
                    closestTarget = target;
                }
            });

            if (closestTarget) {
                const newIndex = closestTarget.id === 'random-color-button' ? -1 : closestTarget.index;
                // Only update and apply if the assignment has changed
                if (colorAssignments[draggedColorTargetInfo.target] !== newIndex) {
                    colorAssignments[draggedColorTargetInfo.target] = newIndex;
                    applyColorsToSelection();
                }
            }
        }

        // Reset state
        isDraggingColorTarget = false;
        draggedColorTargetInfo = null;
        buildColorPaletteUI(); // Snap icon back to its correct, final position
        isActionInProgress = false;
        return;
    }

    if (handleCoordinateSystemMouseUp()) {
        return;
    }

    if (copyCountTimer) clearTimeout(copyCountTimer);
    const copyCount = parseInt(copyCountInput, 10) || 1;
    copyCountInput = '';
    copyCountTimer = null;

    if (!isActionInProgress) return;

    const { shiftKey, ctrlKey, targetVertex, targetEdge, targetFace } = actionContext;

    if (isDragConfirmed) {
        saveStateForUndo();
        const edgesBefore = JSON.parse(JSON.stringify(allEdges));
        let topologyChanged = false;

        if (isPanningBackground) {
            // No geometry change
        } else if (isRectangleSelecting) {
            const dataP1 = screenToData({ x: Math.min(actionStartPos.x, mousePos.x), y: Math.min(actionStartPos.y, mousePos.y) });
            const dataP2 = screenToData({ x: Math.max(actionStartPos.x, mousePos.x), y: Math.max(actionStartPos.y, mousePos.y) });
            const minX = Math.min(dataP1.x, dataP2.x);
            const maxX = Math.max(dataP1.x, dataP2.x);
            const minY = Math.min(dataP1.y, dataP2.y);
            const maxY = Math.max(dataP1.y, dataP2.y);
            const verticesInRect = allVertices.filter(p => p.type === 'regular' && p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY).map(p => p.id);
            const edgesInRect = allEdges.filter(e => verticesInRect.includes(e.id1) && verticesInRect.includes(e.id2)).map(e => U.getEdgeId(e));
            const allVerticesInRect = new Set(verticesInRect);
            const facesInRect = allFaces.filter(f => f.vertexIds.every(vId => allVerticesInRect.has(vId))).map(f => U.getFaceId(f));
            applySelectionLogic(verticesInRect, edgesInRect, facesInRect, shiftKey, ctrlKey);
        } else if (dragPreviewVertices.length > 0) {
            if (copyCount > 1) {
                topologyChanged = true;
                const verticesToCopy = initialDragVertexStates.filter(p => p.type === 'regular');
                const originalIds = new Set(verticesToCopy.map(p => p.id));
                const internalEdges = allEdges.filter(edge => originalIds.has(edge.id1) && originalIds.has(edge.id2));
                const externalEdges = allEdges.filter(edge => {
                    const isP1Original = originalIds.has(edge.id1);
                    const isP2Original = originalIds.has(edge.id2);
                    return (isP1Original && !isP2Original) || (!isP1Original && isP2Original);
                });
                const allNewVertices = [];
                const allNewEdges = [];

                for (let i = 1; i < copyCount; i++) {
                    const newIdMapForThisCopy = new Map();
                    verticesToCopy.forEach(p => {
                        let newPos;
                        if (transformIndicatorData) {
                            const { center, rotation, scale, directionalScale, startPos } = transformIndicatorData;
                            const startVector = { x: startPos.x - center.x, y: startPos.y - center.y };
                            newPos = U.applyTransformToVertex(p, center, rotation * i, Math.pow(scale, i), directionalScale, startVector);
                        } else {
                            const delta = { x: dragPreviewVertices[0].x - initialDragVertexStates[0].x, y: dragPreviewVertices[0].y - initialDragVertexStates[0].y };
                            newPos = { x: p.x + delta.x * i, y: p.y + delta.y * i };
                        }
                        const newVertex = { ...p, ...newPos, id: U.generateUniqueId(), color: getColorForTarget(C.COLOR_TARGET_VERTEX) };
                        allNewVertices.push(newVertex);
                        newIdMapForThisCopy.set(p.id, newVertex.id);
                    });
                    internalEdges.forEach(edge => {
                        const newId1 = newIdMapForThisCopy.get(edge.id1);
                        const newId2 = newIdMapForThisCopy.get(edge.id2);
                        if (newId1 && newId2) {
                            const newEdge = { id1: newId1, id2: newId2 };
                            applyColormapToEdge(newEdge, allNewEdges.length, allNewEdges.length + internalEdges.length);
                            allNewEdges.push(newEdge);
                        }
                    });
                    externalEdges.forEach(edge => {
                        const originalDraggedId = originalIds.has(edge.id1) ? edge.id1 : edge.id2;
                        const staticId = originalIds.has(edge.id1) ? edge.id2 : edge.id1;
                        const newCopiedId = newIdMapForThisCopy.get(originalDraggedId);
                        if (newCopiedId && staticId) {
                            const newEdge = { id1: newCopiedId, id2: staticId };
                            applyColormapToEdge(newEdge, allNewEdges.length, allNewEdges.length + externalEdges.length);
                            allNewEdges.push(newEdge);
                        }
                    });
                }
                allVertices.push(...allNewVertices);
                allEdges.push(...allNewEdges);
                selectedVertexIds = allNewVertices.map(p => p.id);
                selectedEdgeIds = allNewEdges.map(e => U.getEdgeId(e));
            } else {
                dragPreviewVertices.forEach(dp => {
                    const originalVertex = allVertices.find(p => p.id === dp.id);
                    if (originalVertex) {
                        originalVertex.x = dp.x;
                        originalVertex.y = dp.y;
                    }
                });
            }

            const mergeRadius = C.MERGE_RADIUS_SCREEN / viewTransform.scale;
            const parent = new Map();
            allVertices.forEach(p => parent.set(p.id, p.id));
            const isOriginalDragged = new Set(initialDragVertexStates.map(p => p.id));

            const findRoot = (id) => {
                if (!parent.has(id) || parent.get(id) === id) return id;
                const rootId = findRoot(parent.get(id));
                parent.set(id, rootId);
                return rootId;
            };

            for (let i = 0; i < allVertices.length; i++) {
                for (let j = i + 1; j < allVertices.length; j++) {
                    const p1 = allVertices[i];
                    const p2 = allVertices[j];
                    if (U.distance(p1, p2) < mergeRadius) {
                        const root1 = findRoot(p1.id);
                        const root2 = findRoot(p2.id);
                        if (root1 !== root2) {
                            const p1_is_orig = isOriginalDragged.has(root1);
                            const p2_is_orig = isOriginalDragged.has(root2);
                            if (p1_is_orig && !p2_is_orig) {
                                parent.set(root1, root2);
                            } else {
                                parent.set(root2, root1);
                            }
                        }
                    }
                }
            }

            const verticesToDelete = new Set();
            allVertices.forEach(p => {
                const rootId = findRoot(p.id);
                if (p.id !== rootId) verticesToDelete.add(p.id);
            });

            if (verticesToDelete.size > 0) {
                topologyChanged = true;
                allVertices = allVertices.filter(p => !verticesToDelete.has(p.id));
                allEdges.forEach(edge => {
                    edge.id1 = findRoot(edge.id1);
                    edge.id2 = findRoot(edge.id2);
                });
                allEdges = allEdges.filter((e, index, self) =>
                    e.id1 !== e.id2 &&
                    index === self.findIndex(t => U.getEdgeId(t) === U.getEdgeId(e))
                );
                selectedVertexIds = Array.from(new Set(selectedVertexIds.map(id => findRoot(id)).filter(id => !verticesToDelete.has(id))));
            }
        }

        if (topologyChanged) {
            updateFaces(edgesBefore, allEdges);
        }

    } else { // This is a CLICK action
        if (currentMouseButton === 0) {
            if (actionContext.target === 'ui-icon') {
                // This was a simple click on an icon, already handled by setting activeColorTarget in mouseDown.
            } else {
                const startVertex = findVertexById(previewLineStartVertexId);
                if (isDrawingMode && startVertex) {
                    console.log('Drawing mode - adding new vertex');
                    console.log('Before adding vertex, currentDrawingPath length:', currentDrawingPath.length);
                    
                    saveStateForUndo();
                    const edgesBefore = JSON.parse(JSON.stringify(allEdges));
                    const snappedData = getSnappedPosition(startVertex, mousePos, shiftKey);
                    let newVertex = null;
    
                    if (snappedData.snapType === 'vertex' && snappedData.targetVertex) {
                        newVertex = snappedData.targetVertex;
                        console.log('Snapped to existing vertex:', newVertex.id);
                    } else if (snappedData.snapType === 'edge' && snappedData.targetEdge) {
                        newVertex = insertVertexOnEdgeWithFaces(snappedData.targetEdge, { x: snappedData.x, y: snappedData.y });
                        console.log('Created vertex on edge:', newVertex?.id);
                    } else {
                        // Calculate the correct colormap color for this vertex position in the sequence
                        // Calculate temporary color - will be redistributed by updateDrawingSequenceColors
                        let newVertexColor = getColorForTarget(C.COLOR_TARGET_VERTEX);
                        const colorIndex = colorAssignments[C.COLOR_TARGET_VERTEX];
                        if (colorIndex !== -1) {
                            const colorItem = allColors[colorIndex];
                            if (colorItem && colorItem.type === 'colormap') {
                                newVertexColor = U.sampleColormap(colorItem, 0.5); // Temporary color
                            }
                        }

                        newVertex = { id: U.generateUniqueId(), x: snappedData.x, y: snappedData.y, type: 'regular', color: newVertexColor };
                        allVertices.push(newVertex);
                    }
    
                    if (newVertex) {
                        const edgeExists = allEdges.some(e => (e.id1 === startVertex.id && e.id2 === newVertex.id) || (e.id2 === startVertex.id && e.id1 === newVertex.id));
                        if (!edgeExists) {
                            // Create edge with temporary color - will be redistributed
                            const newEdge = { id1: startVertex.id, id2: newVertex.id };
                            applyColormapToEdge(newEdge);
                            allEdges.push(newEdge);
                            updateFaces(edgesBefore, allEdges);
                        }
                        
                        const completedSegmentProps = getCompletedSegmentProperties(startVertex, newVertex, allEdges);
                        if (completedSegmentProps) {
                            if (drawingSequence.length > 0) {
                                drawingSequence[drawingSequence.length - 1].turn = completedSegmentProps.turnAngleRad;
                            }
                            drawingSequence.push({ 
                                length: completedSegmentProps.length, 
                                turn: 0, 
                                endVertexColor: newVertex.color 
                            });
                            currentSequenceIndex = drawingSequence.length - 1;
                        }
                        
                        currentDrawingPath.push(newVertex.id);
                        window.currentDrawingPath = currentDrawingPath;

                        // Update both vertex and edge colors in the drawing sequence
                        updateDrawingSequenceColors();
                        updateDrawingSequenceEdgeColors();
                        
                        previewLineStartVertexId = newVertex.id;
                    }
                    
                    if (shiftKey && newVertex && snappedData) {
                        const completedSegmentProps = getCompletedSegmentProperties(startVertex, newVertex, allEdges);
                        if (completedSegmentProps) {
                            frozenReference_Origin_Data = completedSegmentProps.startVertex;
                            
                            if (snappedData.gridToGridSquaredSum > 0 && snappedData.gridInterval) {
                                frozenReference_D_du = snappedData.gridInterval * Math.sqrt(snappedData.gridToGridSquaredSum);
                            } else {
                                frozenReference_D_du = completedSegmentProps.length;
                            }
                            
                            frozenReference_D_g2g = snappedData.gridToGridSquaredSum > 0 ? { 
                                g2gSquaredSum: snappedData.gridToGridSquaredSum, 
                                interval: snappedData.gridInterval 
                            } : null;
                            
                            frozenReference_A_rad = completedSegmentProps.turnAngleRad;
                            frozenReference_A_baseRad = completedSegmentProps.precedingSegmentAbsoluteAngleRad;
                        }
                    } else {
                        frozenReference_D_du = null;
                        frozenReference_D_g2g = null;
                        frozenReference_A_rad = null;
                        frozenReference_A_baseRad = null;
                        frozenReference_Origin_Data = null;
                    }
    
                    clickData.count = 0;
                } else if (actionContext.target === 'canvas') {
                    console.log('Canvas click - creating first vertex');
                    saveStateForUndo();
                    const startCoords = ghostVertexPosition ? ghostVertexPosition : screenToData(mousePos);
                    
                    // For the first vertex in a new drawing sequence, always use the first color of the colormap
                    let newVertexColor = getColorForTarget(C.COLOR_TARGET_VERTEX);
                    const colorIndex = colorAssignments[C.COLOR_TARGET_VERTEX];
                    if (colorIndex !== -1) {
                        const colorItem = allColors[colorIndex];
                        if (colorItem && colorItem.type === 'colormap') {
                            newVertexColor = U.sampleColormap(colorItem, 0); // First vertex gets t=0
                            console.log('First vertex colormap color:', newVertexColor);
                        }
                    }

                    const newVertex = { id: U.generateUniqueId(), ...startCoords, type: 'regular', color: newVertexColor };
                    console.log('Created first vertex with color:', newVertex.color);
                    allVertices.push(newVertex);
                    isDrawingMode = true;
                    previewLineStartVertexId = newVertex.id;
                    drawingSequence = [];
                    currentSequenceIndex = 0;
                    currentDrawingPath = [newVertex.id];
                    window.currentDrawingPath = currentDrawingPath;
                    console.log('Initialized currentDrawingPath:', currentDrawingPath);
                } else {
                    if (targetVertex || targetEdge || targetFace) {
                        const targetId = targetFace ? U.getFaceId(targetFace) : (targetEdge ? U.getEdgeId(targetEdge) : targetVertex.id);
                        let targetType;
                        if (targetFace) targetType = 'face';
                        else if (targetVertex && targetVertex.type !== 'regular') targetType = 'center';
                        else if (targetVertex) targetType = 'vertex';
                        else if (targetEdge) targetType = 'edge';
    
                        if (targetId && clickData.targetId === targetId && (Date.now() - clickData.timestamp) < C.DOUBLE_CLICK_MS) {
                            clickData.count++;
                        } else {
                            clickData.count = 1;
                        }
                        clickData.targetId = targetId;
                        clickData.type = targetType;
                        clickData.timestamp = Date.now();
    
                        switch (clickData.count) {
                            case 1:
                                if (clickData.type === 'face') applySelectionLogic([], [], [clickData.targetId], shiftKey, ctrlKey);
                                else if (clickData.type === 'edge') applySelectionLogic([], [clickData.targetId], [], shiftKey, ctrlKey);
                                else if (clickData.type === 'vertex') applySelectionLogic([clickData.targetId], [], [], shiftKey, ctrlKey);
                                else if (clickData.type === 'center') handleCenterSelection(clickData.targetId, shiftKey, ctrlKey);
                                break;
                            case 2:
                                if (clickData.type === 'vertex') {
                                    const neighbors = U.findNeighbors(clickData.targetId, allEdges);
                                    applySelectionLogic([clickData.targetId, ...neighbors], [], [], shiftKey, ctrlKey);
                                } else if (clickData.type === 'edge') {
                                    const edge = allEdges.find(e => U.getEdgeId(e) === clickData.targetId);
                                    if (edge) {
                                        const validNeighborEdges = [...findNeighborEdges(edge.id1), ...findNeighborEdges(edge.id2)];
                                        applySelectionLogic([], Array.from(new Set(validNeighborEdges.map(e => U.getEdgeId(e)))), [], shiftKey, ctrlKey);
                                    }
                                } else if (clickData.type === 'face') {
                                    const face = allFaces.find(f => U.getFaceId(f) === clickData.targetId);
                                    if (face) {
                                        const adjacentFaceIds = [];
                                        const faceEdges = new Set();
                                        for (let i = 0; i < face.vertexIds.length; i++) {
                                            const id1 = face.vertexIds[i];
                                            const id2 = face.vertexIds[(i + 1) % face.vertexIds.length];
                                            faceEdges.add(U.getEdgeId({ id1, id2 }));
                                        }
                                        allFaces.forEach(otherFace => {
                                            if (U.getFaceId(otherFace) === U.getFaceId(face)) return;
                                            for (let i = 0; i < otherFace.vertexIds.length; i++) {
                                                const id1 = otherFace.vertexIds[i];
                                                const id2 = otherFace.vertexIds[(i + 1) % otherFace.vertexIds.length];
                                                if (faceEdges.has(U.getEdgeId({ id1, id2 }))) {
                                                    adjacentFaceIds.push(U.getFaceId(otherFace));
                                                    break;
                                                }
                                            }
                                        });
                                        applySelectionLogic([], [], [U.getFaceId(face), ...adjacentFaceIds], shiftKey, ctrlKey);
                                    }
                                }
                                break;
                            case 3:
                                if (clickData.type === 'vertex' || clickData.type === 'edge' || clickData.type === 'face') {
                                    let startNode;
                                    if (clickData.type === 'vertex') startNode = clickData.targetId;
                                    else if (clickData.type === 'edge') startNode = clickData.targetId.split(C.EDGE_ID_DELIMITER)[0];
                                    else if (clickData.type === 'face') {
                                        const face = allFaces.find(f => U.getFaceId(f) === clickData.targetId);
                                        if (face) startNode = face.vertexIds[0];
                                    }
                                    if (startNode) {
                                        const verticesInSubgraph = new Set(findAllVerticesInSubgraph(startNode));
                                        if (clickData.type === 'vertex') applySelectionLogic(Array.from(verticesInSubgraph), [], [], shiftKey, ctrlKey);
                                        else if (clickData.type === 'edge') {
                                            const edgesInSubgraph = allEdges.filter(e => verticesInSubgraph.has(e.id1) && verticesInSubgraph.has(e.id2)).map(e => U.getEdgeId(e));
                                            applySelectionLogic([], edgesInSubgraph, [], shiftKey, ctrlKey);
                                        } else if (clickData.type === 'face') {
                                            const facesInSubgraph = allFaces.filter(f => f.vertexIds.every(vId => verticesInSubgraph.has(vId))).map(f => U.getFaceId(f));
                                            applySelectionLogic([], [], facesInSubgraph, shiftKey, ctrlKey);
                                        }
                                    }
                                }
                                clickData.count = 0;
                                break;
                        }
    
                        if (selectedFaceIds.length > 0) {
                            activeColorTarget = C.COLOR_TARGET_FACE;
                        } else if (selectedEdgeIds.length > 0) {
                            activeColorTarget = C.COLOR_TARGET_EDGE;
                        } else if (selectedVertexIds.length > 0) {
                            activeColorTarget = C.COLOR_TARGET_VERTEX;
                        }
                    }
                }
            }
        } else if (currentMouseButton === 2) {
            performEscapeAction();
        }
    }

    isActionInProgress = false;
    isDragConfirmed = false;
    isPanningBackground = false;
    isRectangleSelecting = false;
    actionContext = null;
    transformIndicatorData = null;
    canvas.style.cursor = 'crosshair';
    if (!currentShiftPressed) ghostVertexPosition = null;
}

// Event listeners setup
canvas.addEventListener('wheel', (event) => {
    event.preventDefault();
    const mouseScreen = U.getMousePosOnCanvas(event, canvas);
    const scaleFactor = event.deltaY > 0 ? 1 / 1.15 : 1.15;
    zoomAt(mouseScreen, scaleFactor);
}, { passive: false });

canvas.addEventListener('mouseenter', () => {
    isMouseOverCanvas = true;
});

canvas.addEventListener('mouseleave', () => {
    isMouseOverCanvas = false;
    redrawAll();
});

canvas.addEventListener('contextmenu', (event) => event.preventDefault());

canvas.addEventListener('mousemove', handleMouseMove);

canvas.addEventListener("mouseup", handleMouseUp);

canvas.addEventListener('mousedown', handleMouseDown);

window.addEventListener('keyup', (event) => {
    if (event.key === 'Shift') {
        currentShiftPressed = false;
        ghostVertexPosition = null;
        placingSnapPos = null;
        ghostVertices = [];
    }
});

window.addEventListener('keydown', handleKeyDown);

window.addEventListener('resize', resizeCanvas);

window.addEventListener('load', () => {
    initializeApp();
});

=== style.css ===
:root {
    --container-bg-color: #1e1e1e;
    --default-text-color: #e2e8f0; /* A light default text color */
}

html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background-color: var(--container-bg-color);
    /* Set a default text color for the whole page */
    color: var(--default-text-color);
}

.container {
    /* Scope the specific font only to the app's container */
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
}

.canvas-container {
    flex-grow: 1;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    box-sizing: border-box;
}

.canvas-wrapper-relative {
    position: relative;
    width: 100%;
    height: 100%;
}

/* This rule is now specific to the main drawing canvas */
#drawingCanvas {
    display: block;
    background-color: #1a1a1a;
    cursor: crosshair;
}

#html-overlay {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    width: 100%;
    height: 100%;
}


=== utils.js ===
import * as C from './constants.js';

export function formatNumber(value, sigFigs) {
    if (value === 0) return "0";
    const absValue = Math.abs(value);
    const sign = value < 0 ? "-" : "";
    let formattedString;
    if (absValue >= C.SCIENTIFIC_NOTATION_UPPER_BOUND || (absValue !== 0 && absValue < C.SCIENTIFIC_NOTATION_LOWER_BOUND)) {
        const expStr = absValue.toExponential(Math.max(0, sigFigs - 1));
        const parts = expStr.split('e');
        let coefficient = parseFloat(parts[0]).toString();
        let exponent = parseInt(parts[1], 10);
        formattedString = `${coefficient} \\cdot 10^{${exponent}}`;
    } else {
        const integerDigits = absValue < 1 ? 0 : Math.floor(Math.log10(absValue)) + 1;
        let decimalPlacesToDisplay;
        if (absValue === 0) {
            decimalPlacesToDisplay = sigFigs - 1;
        } else if (absValue < 1) {
            let k = 0;
            let temp = absValue;
            while (temp < 1 && k < sigFigs + 5) {
                temp *= 10;
                k++;
            }
            decimalPlacesToDisplay = Math.max(0, (k - 1) + sigFigs);
        } else {
            decimalPlacesToDisplay = Math.max(0, sigFigs - integerDigits);
        }
        decimalPlacesToDisplay = Math.min(decimalPlacesToDisplay, C.MAX_DECIMAL_PLACES_FORMAT);
        let fixedStr = absValue.toFixed(decimalPlacesToDisplay);
        let num = parseFloat(fixedStr);
        if (Math.abs(num) === 0 && value !== 0) {
            return "0";
        }
        formattedString = Math.abs(num).toString();
    }
    return sign + formattedString;
}

export function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b);
}

export function getEdgeId(edge) {
    return edge.id1 < edge.id2 
        ? `${edge.id1}${C.EDGE_ID_DELIMITER}${edge.id2}` 
        : `${edge.id2}${C.EDGE_ID_DELIMITER}${edge.id1}`;
}

export function getFaceId(face) {
    if (face.id) return face.id;
    if (face.vertexIds) {
        return `face_${[...face.vertexIds].sort().join('_')}`;
    }
    return null;
}

export function getGridSnapCandidates(mouseDataPos, gridDisplayMode, gridInterval, angularGridState, getMultipleRect = false) {
    const candidates = [];
    if (gridDisplayMode === 'none' || !gridInterval || gridInterval <= 0) {
        return candidates;
    }

    if (gridDisplayMode === 'polar') {
        const mouseAngleDeg = (Math.atan2(mouseDataPos.y, mouseDataPos.x) * 180 / Math.PI + 360) % 360;
        const mouseRadius = Math.hypot(mouseDataPos.x, mouseDataPos.y);
        const snappedRadius = Math.round(mouseRadius / gridInterval) * gridInterval;

        angularGridState.forEach(level => {
            if (level.alpha > 0.01 && level.angle > 0) {
                const angularInterval = level.angle;
                const snappedAngleDeg = Math.round(mouseAngleDeg / angularInterval) * angularInterval;
                const snappedAngleRad = snappedAngleDeg * Math.PI / 180;
                candidates.push({ x: snappedRadius * Math.cos(snappedAngleRad), y: snappedRadius * Math.sin(snappedAngleRad), isGridPoint: true });
            }
        });
    } else if (gridDisplayMode === 'triangular') {
        const y_step = gridInterval * C.TRIANGULAR_GRID_Y_STEP_FACTOR;
        const i_f = (mouseDataPos.x / gridInterval) - (mouseDataPos.y / (gridInterval * Math.sqrt(3)));
        const j_f = mouseDataPos.y / y_step;

        let i_r = Math.round(i_f);
        let j_r = Math.round(j_f);
        let k_r = Math.round(-i_f - j_f);

        const i_diff = Math.abs(i_r - i_f);
        const j_diff = Math.abs(j_r - j_f);
        const k_diff = Math.abs(k_r - (-i_f - j_f));

        if (i_diff > j_diff && i_diff > k_diff) {
            i_r = -j_r - k_r;
        } else if (j_diff > k_diff) {
            j_r = -i_r - k_r;
        }

        const snappedX = i_r * gridInterval + j_r * gridInterval / 2;
        const snappedY = j_r * y_step;
        candidates.push({ x: snappedX, y: snappedY, isGridPoint: true });
    } else {
        if (getMultipleRect) {
            const gridX = Math.floor(mouseDataPos.x / gridInterval) * gridInterval;
            const gridY = Math.floor(mouseDataPos.y / gridInterval) * gridInterval;
            candidates.push(
                { x: gridX, y: gridY, isGridPoint: true },
                { x: gridX + gridInterval, y: gridY, isGridPoint: true },
                { x: gridX, y: gridY + gridInterval, isGridPoint: true },
                { x: gridX + gridInterval, y: gridY + gridInterval, isGridPoint: true }
            );
        } else {
            candidates.push({ x: Math.round(mouseDataPos.x / gridInterval) * gridInterval, y: Math.round(mouseDataPos.y / gridInterval) * gridInterval, isGridPoint: true });
        }
    }
    return candidates;
}

export function generateUniqueId() {
    return crypto.randomUUID();
}

export function normalizeAngle(angleRad) {
    while (angleRad < 0) angleRad += C.RADIANS_IN_CIRCLE;
    while (angleRad >= C.RADIANS_IN_CIRCLE) angleRad -= C.RADIANS_IN_CIRCLE;
    return angleRad;
}

export function calculateRotationAngle(initialStartAngle, currentMouseAngle, totalAccumulatedRotationFromStart = 0) {
    let rawDeltaAngle = currentMouseAngle - initialStartAngle;
    let numRevolutions = Math.round((totalAccumulatedRotationFromStart - rawDeltaAngle) / (2 * Math.PI));
    let continuousDeltaAngle = rawDeltaAngle + numRevolutions * (2 * Math.PI);
    return continuousDeltaAngle;
}

export function normalizeAngleToPi(angleRad) {
    angleRad = normalizeAngle(angleRad);
    if (angleRad > Math.PI) {
        angleRad -= C.RADIANS_IN_CIRCLE;
    }
    return angleRad;
}

export function normalizeAngleDegrees(angleDeg) {
    while (angleDeg < 0) angleDeg += C.DEGREES_IN_CIRCLE;
    while (angleDeg >= C.DEGREES_IN_CIRCLE) angleDeg -= C.DEGREES_IN_CIRCLE;
    return angleDeg;
}

export function getLineCircleIntersection(line, circle) {
    const { p1, p2 } = line;
    const { center, radius } = circle;
    const d = { x: p2.x - p1.x, y: p2.y - p1.y };
    const f = { x: p1.x - center.x, y: p1.y - center.y };
    const a = d.x * d.x + d.y * d.y;
    const b = 2 * (f.x * d.x + f.y * d.y);
    const c = f.x * f.x + f.y * f.y - radius * radius;
    let discriminant = b * b - 4 * a * c;

    if (discriminant < 0) return [];

    discriminant = Math.sqrt(discriminant);
    const t1 = (-b - discriminant) / (2 * a);
    const t2 = (-b + discriminant) / (2 * a);

    return [
        { x: p1.x + t1 * d.x, y: p1.y + t1 * d.y },
        { x: p1.x + t2 * d.x, y: p1.y + t2 * d.y }
    ];
}

export function getLineLineIntersection(line1, line2) {
    const p1 = line1.p1, p2 = line1.p2, p3 = line2.p1, p4 = line2.p2;
    const den = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
    if (Math.abs(den) < C.GEOMETRY_CALCULATION_EPSILON) return null;
    const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / den;
    const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / den;
    
    if (u >= 0 && u <= 1) {
        return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
    }
    return null;
}

export function simplifySquareRoot(n) {
    if (n < 0 || !Number.isInteger(n)) return [null, null];
    if (n === 0) return [0, 1];
    
    let coefficient = 1;
    let radicand = n;

    for (let i = 2; i * i <= radicand; i++) {
        while (radicand % (i * i) === 0) {
            radicand /= (i * i);
            coefficient *= i;
        }
    }

    return [coefficient, radicand];
}

export function formatSimplifiedRoot(coeff, radicand, symbol = '') {
    const symString = symbol ? `\\${symbol}` : '';

    if (radicand === 1) {
        if (coeff === 1 && symbol) return symString;
        return `${coeff}${symString}`;
    }
    if (coeff === 1) {
        return `\\sqrt{${radicand}}${symString}`;
    }
    return `${coeff}\\sqrt{${radicand}}${symString}`;
}

export function distance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

export function formatFraction(decimal, tolerance = C.FRACTION_FORMAT_TOLERANCE, maxDisplayDenominator = C.FRACTION_FORMAT_MAX_DENOMINATOR) {
    if (Math.abs(decimal) < C.ZERO_TOLERANCE) return "0";
    const originalSign = decimal < 0 ? "-" : "";
    const absDecimal = Math.abs(decimal);

    if (Math.abs(absDecimal - Math.round(absDecimal)) < tolerance) {
        const rounded = Math.round(absDecimal);
        return originalSign + rounded.toString();
    }

    const fractions = [
        [1,2],[1,3],[2,3],[1,4],[3,4],[1,5],[2,5],[3,5],[4,5],[1,6],[5,6],
        [1,8],[3,8],[5,8],[7,8],[1,10],[3,10],[7,10],[9,10],
        [1,12],[5,12],[7,12],[11,12],[1,16],[3,16],[5,16],[7,16],[9,16],[11,16],[13,16],[15,16]
    ];

    for (const [num, den] of fractions) {
        if (den <= maxDisplayDenominator) {
            if (Math.abs(absDecimal - num/den) < tolerance) {
                return originalSign + `${num}/${den}`;
            }
        }
    }

    for (let currentDen = 1; currentDen <= maxDisplayDenominator; currentDen++) {
        const currentNum = Math.round(absDecimal * currentDen);
        if (currentNum === 0 && absDecimal > C.ZERO_TOLERANCE) continue;
        if (Math.abs(absDecimal - currentNum / currentDen) < tolerance / currentDen) {
            const common = gcd(currentNum, currentDen);
            const n = currentNum/common;
            const d = currentDen/common;
            if (d === 1) return originalSign + `${n}`;
            return originalSign + `${n}/${d}`;
        }
    }
    let fixedPrecision = 2;
        if (absDecimal < 0.01) fixedPrecision = 3;
    else if (absDecimal < 0.1)  fixedPrecision = 2;
    else if (absDecimal < 10)   fixedPrecision = 1;
    else                        fixedPrecision = 0;
    
    return originalSign + absDecimal.toFixed(fixedPrecision);
}

export function isVertexInPolygon(vertex, vertices) {
    if (vertices.length < 3) return false;
    
    let inside = false;
    const x = vertex.x;
    const y = vertex.y;
    
    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        const xi = vertices[i].x;
        const yi = vertices[i].y;
        const xj = vertices[j].x;
        const yj = vertices[j].y;
        
        if (((yi > y) !== (yj > y)) && 
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
            inside = !inside;
        }
    }
    
    return inside;
}

export function parseColor(colorString) {
    if (!colorString || typeof colorString !== 'string') {
        return { r: 255, g: 255, b: 255, a: 1.0 };
    }
    
    if (colorString.startsWith('rgba(')) {
        const match = colorString.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        if (match) {
            return {
                r: Math.max(0, Math.min(255, parseInt(match[1]))),
                g: Math.max(0, Math.min(255, parseInt(match[2]))),
                b: Math.max(0, Math.min(255, parseInt(match[3]))),
                a: Math.max(0, Math.min(1, parseFloat(match[4])))
            };
        }
    }
    
    if (colorString.startsWith('rgb(')) {
        const match = colorString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (match) {
            return {
                r: Math.max(0, Math.min(255, parseInt(match[1]))),
                g: Math.max(0, Math.min(255, parseInt(match[2]))),
                b: Math.max(0, Math.min(255, parseInt(match[3]))),
                a: 1.0
            };
        }
    }
    
    if (colorString.startsWith('#')) {
        const hex = colorString.slice(1);
        if (hex.length === 6) {
            return {
                r: parseInt(hex.slice(0, 2), 16),
                g: parseInt(hex.slice(2, 4), 16),
                b: parseInt(hex.slice(4, 6), 16),
                a: 1.0
            };
        }
        if (hex.length === 3) {
            return {
                r: parseInt(hex[0] + hex[0], 16),
                g: parseInt(hex[1] + hex[1], 16),
                b: parseInt(hex[2] + hex[2], 16),
                a: 1.0
            };
        }
    }
    
    return { r: 255, g: 255, b: 255, a: 1.0 };
}

export function findCoordinateSystemElement(screenPos, face, dataToScreen) {
    const coordSystem = face.localCoordSystem;
    if (!coordSystem) return null;

    const centerScreen = dataToScreen(coordSystem.origin);
    const centerSelectRadius = 10; // in screen pixels

    if (distance(screenPos, centerScreen) < centerSelectRadius) {
        return { face, type: 'center' };
    }

    const armEndSelectRadius = 10; // in screen pixels

    const checkArm = (x, y, type) => {
        const armEndGlobal = localToGlobal({ x, y }, coordSystem);
        if (distance(screenPos, dataToScreen(armEndGlobal)) < armEndSelectRadius) {
            return { face, type };
        }
        return null;
    };

    return checkArm(1, 0, 'x_axis') ||
           checkArm(-1, 0, 'x_axis') ||
           checkArm(0, 1, 'y_axis') ||
           checkArm(0, -1, 'y_axis');
}


export function detectClosedPolygons(allEdges, findPointById) {
    const adjacencyMap = new Map();
    const vertices = new Map();

    allEdges.forEach(edge => {
        const p1 = findPointById(edge.id1);
        const p2 = findPointById(edge.id2);
        if (!p1 || !p2 || p1.type !== 'regular' || p2.type !== 'regular') return;

        if (!vertices.has(p1.id)) vertices.set(p1.id, p1);
        if (!vertices.has(p2.id)) vertices.set(p2.id, p2);

        if (!adjacencyMap.has(edge.id1)) adjacencyMap.set(edge.id1, []);
        if (!adjacencyMap.has(edge.id2)) adjacencyMap.set(edge.id2, []);

        adjacencyMap.get(edge.id1).push(edge.id2);
        adjacencyMap.get(edge.id2).push(edge.id1);
    });

    // For each vertex, sort its neighbors by angle (counter-clockwise)
    for (const [vertexId, neighbors] of adjacencyMap.entries()) {
        const centerPoint = vertices.get(vertexId);
        neighbors.sort((a, b) => {
            const pA = vertices.get(a);
            const pB = vertices.get(b);
            const angleA = Math.atan2(pA.y - centerPoint.y, pA.x - centerPoint.x);
            const angleB = Math.atan2(pB.y - centerPoint.y, pB.x - centerPoint.x);
            return angleA - angleB;
        });
    }

    const visitedDarts = new Set(); // A "dart" is a directed edge like "p1->p2"
    const faces = [];

    function shoelaceArea(vertexPoints) {
        let area = 0;
        const n = vertexPoints.length;
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            area += vertexPoints[i].x * vertexPoints[j].y - vertexPoints[j].x * vertexPoints[i].y;
        }
        return area / 2;
    }

    for (const startNodeId of adjacencyMap.keys()) {
        const neighbors = adjacencyMap.get(startNodeId);
        for (const endNodeId of neighbors) {
            const dart = `${startNodeId}->${endNodeId}`;
            if (visitedDarts.has(dart)) continue;

            const currentPath = [];
            let prev = startNodeId;
            let curr = endNodeId;

            while (true) {
                visitedDarts.add(`${prev}->${curr}`);
                currentPath.push(prev);

                const currNeighbors = adjacencyMap.get(curr);
                if (!currNeighbors) break;
                
                const prevIndex = currNeighbors.indexOf(prev);
                if (prevIndex === -1) break;

                // To trace a face boundary, take the left turn (CCW successor) for standard inner face traversal
                const nextIndex = (prevIndex + 1) % currNeighbors.length;
                const nextNode = currNeighbors[nextIndex];

                prev = curr;
                curr = nextNode;
                
                if (prev === startNodeId && curr === endNodeId) {
                    const vertexPoints = currentPath.map(id => vertices.get(id));
                    // Positive area for CCW polygons, identifying inner faces
                    if (shoelaceArea(vertexPoints) > 0) {
                        faces.push({ vertexIds: currentPath });
                    }
                    break;
                }

                // Stop if we hit an edge that's already part of another face's boundary
                if (visitedDarts.has(`${prev}->${curr}`)) {
                    break;
                }
            }
        }
    }
    return faces;
}

export function normalize(v) {
    const mag = Math.hypot(v.x, v.y);
    if (mag === 0) return { x: 0, y: 0 };
    return { x: v.x / mag, y: v.y / mag };
}

export function getClosestPointOnLineSegment(p, a, b) {
    const abx = b.x - a.x;
    const aby = b.y - a.y;
    const acx = p.x - a.x;
    const acy = p.y - a.y;
    const lenSqAB = abx * abx + aby * aby;

    if (lenSqAB === 0) {
        return { x: a.x, y: a.y, distance: distance(p, a), onSegmentStrict: true, t: 0 };
    }
    let t = (acx * abx + acy * aby) / lenSqAB;
    const onSegmentStrict = t > C.ON_SEGMENT_STRICT_T_MIN && t < C.ON_SEGMENT_STRICT_T_MAX;
    const clampedT = Math.max(0, Math.min(1, t));
    const closestX = a.x + clampedT * abx;
    const closestY = a.y + clampedT * aby;
    const dist = distance(p, { x: closestX, y: closestY });
    return { x: closestX, y: closestY, distance: dist, onSegmentStrict: onSegmentStrict, t: clampedT };
}

export function getMousePosOnCanvas(event, canvasElement) {
    const rect = canvasElement.getBoundingClientRect();
    return { x: event.clientX - rect.left, y: event.clientY - rect.top };
}

function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0;
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}

export function invertGrayscaleValue(value) {
    if (Array.isArray(value)) {
        const [h, s, l] = rgbToHsl(value[0], value[1], value[2]);
        const invertedL = 1 - l;
        const [newR, newG, newB] = hslToRgb(h, s, invertedL);
        return [newR, newG, newB];
    }
    
    if (typeof value === 'string') {
        if (value.startsWith('rgba(')) {
            const match = value.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
            if (match) {
                const [, r, g, b, a] = match;
                const rVal = parseInt(r), gVal = parseInt(g), bVal = parseInt(b);
                const [h, s, l] = rgbToHsl(rVal, gVal, bVal);
                const invertedL = 1 - l;
                const [newR, newG, newB] = hslToRgb(h, s, invertedL);
                return `rgba(${newR}, ${newG}, ${newB}, ${a})`;
            }
        }
        
        if (value.startsWith('#')) {
            if (value.length === 7) {
                const r = parseInt(value.slice(1, 3), 16);
                const g = parseInt(value.slice(3, 5), 16);
                const b = parseInt(value.slice(5, 7), 16);
                const [h, s, l] = rgbToHsl(r, g, b);
                const invertedL = 1 - l;
                const [newR, newG, newB] = hslToRgb(h, s, invertedL);
                return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
            }
        }
        
        if (value === 'white') return 'black';
        if (value === 'black') return 'white';
    }
    
    return value;
}

export function shoelaceArea(vertices) {
    let area = 0.0;
    const n = vertices.length;
    for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        area += vertices[i].x * vertices[j].y;
        area -= vertices[j].x * vertices[i].y;
    }
    return area / 2.0;
}

export function clamp(v, minv, maxv) {
    return Math.max(minv, Math.min(maxv, v));
}

export function computeAngle(prev, curr, next) {
    const u = { x: prev.x - curr.x, y: prev.y - curr.y };
    const v = { x: next.x - curr.x, y: next.y - curr.y };
    const dot = u.x * v.x + u.y * v.y;
    const mag_u = Math.hypot(u.x, u.y);
    const mag_v = Math.hypot(v.x, v.y);
    if (mag_u === 0 || mag_v === 0) return Math.PI;
    const cos_theta = dot / (mag_u * mag_v);
    return Math.acos(clamp(cos_theta, -1, 1));
}

export function isSelfIntersecting(vertices) {
    const n = vertices.length;
    for (let i = 0; i < n; i++) {
        const p1 = vertices[i];
        const p2 = vertices[(i + 1) % n];
        for (let j = i + 2; j < n; j++) {
            const q1 = vertices[j];
            const q2 = vertices[(j + 1) % n];
            if ((j + 1) % n === i || j === (i + 1) % n) continue;
            if (linesIntersect(p1, p2, q1, q2)) return true;
        }
    }
    return false;
}

function linesIntersect(a, b, c, d) {
    function ccw(A, B, C) {
        return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
    }
    return ccw(a, c, d) !== ccw(b, c, d) && ccw(a, b, c) !== ccw(a, b, d);
}

export function triangulatePolygon(vertices) {
    let n = vertices.length;
    if (n < 3) return [];
    
    let area = shoelaceArea(vertices);
    let windingSign = area > 0 ? 1 : (area < 0 ? -1 : 1);
    
    const triangles = [];
    const indices = Array.from({length: n}, (_, i) => i);
    
    function isEar(i, verts, indices, windingSign) {
        const prevIdx = (i - 1 + indices.length) % indices.length;
        const currIdx = i;
        const nextIdx = (i + 1) % indices.length;
        
        const prev = verts[indices[prevIdx]];
        const curr = verts[indices[currIdx]];
        const next = verts[indices[nextIdx]];
        
        const dx1 = curr.x - prev.x;
        const dy1 = curr.y - prev.y;
        const dx2 = next.x - curr.x;
        const dy2 = next.y - curr.y;
        const cross = dx1 * dy2 - dy1 * dx2;
        if (cross * windingSign <= 0) return false;
        
        const tri = [prev, curr, next];
        for (let j = 0; j < indices.length; j++) {
            const idx = indices[j];
            if (idx === indices[prevIdx] || idx === indices[currIdx] || idx === indices[nextIdx]) continue;
            if (vertexInTriangle(verts[idx], tri)) return false;
        }
        return true;
    }
    
    function vertexInTriangle(pt, tri) {
        const [p1, p2, p3] = tri;
        const denom = (p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y);
        if (Math.abs(denom) < 1e-10) return false;
        
        const a = ((p2.y - p3.y) * (pt.x - p3.x) + (p3.x - p2.x) * (pt.y - p3.y)) / denom;
        const b = ((p3.y - p1.y) * (pt.x - p3.x) + (p1.x - p3.x) * (pt.y - p3.y)) / denom;
        const c = 1 - a - b;
        
        return a >= 0 && a <= 1 && b >= 0 && b <= 1 && c >= 0 && c <= 1;
    }
    
    while (indices.length > 3) {
        const ears = [];
        for (let i = 0; i < indices.length; i++) {
            if (isEar(i, vertices, indices, windingSign)) {
                const prevIdx = (i - 1 + indices.length) % indices.length;
                const currIdx = i;
                const nextIdx = (i + 1) % indices.length;
                const angle = computeAngle(vertices[indices[prevIdx]], vertices[indices[currIdx]], vertices[indices[nextIdx]]);
                ears.push({ index: i, angle });
            }
        }
        
        if (ears.length === 0) break;
        
        ears.sort((a, b) => a.angle - b.angle);
        
        const earToClip = ears[0];
        const i = earToClip.index;
        
        const prev = indices[(i - 1 + indices.length) % indices.length];
        const curr = indices[i];
        const next = indices[(i + 1) % indices.length];
        
        triangles.push([prev, curr, next]);
        indices.splice(i, 1);
    }
    
    if (indices.length === 3) {
        triangles.push([indices[0], indices[1], indices[2]]);
    }
    
    return triangles;
}

export function getCurrentTheme(activeThemeName, baseTheme) {
    if (activeThemeName === 'dark') {
        return baseTheme;
    } else {
        const lightTheme = {};
        for (const [key, value] of Object.entries(baseTheme)) {
            if (key === 'frozenReference' || key === 'feedbackSnapped' || key === 'geometryInfoTextSnapped') {
                lightTheme[key] = 'rgba(217, 119, 6, 0.95)';
            } else {
                lightTheme[key] = invertGrayscaleValue(value);
            }
        }
        return lightTheme;
    }
}

export function hslToRgb(h, s, l) {
    let r, g, b;

    if (s === 0) {
        r = g = b = l;
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (6 * (2 / 3 - t));
            return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

export function formatSnapFactor(factor, symbol) {
    const fractionStr = formatFraction(factor, 0.001);
    const newSymbol = symbol === 'A' ? '\\theta' : (symbol === 'D' ? '\\delta' : symbol);
    
    if (fractionStr === "0") return `0${newSymbol}`;
    if (fractionStr === "1") return newSymbol;
    if (fractionStr === "-1") return `-${newSymbol}`;

    if (fractionStr.endsWith("/1")) {
        return `${fractionStr.slice(0, -2)}${newSymbol}`;
    }

    if (fractionStr.includes('/')) {
        let sign = '';
        let workStr = fractionStr;
        if (workStr.startsWith('-')) {
            sign = '-';
            workStr = workStr.substring(1);
        }

        const parts = workStr.split('/');
        const num = parts[0];
        const den = parts[1];
        
        if (num === "1") return `${sign}\\frac{1}{${den}}${newSymbol}`;
        return `${sign}\\frac{${num}}{${den}}${newSymbol}`;
    }
    return `${fractionStr}${newSymbol}`;
}

export function applyTransformToVertex(vertex, center, rotation, scale, directionalScale, startVector) {
    const pointVector = { x: vertex.x - center.x, y: vertex.y - center.y };

    if (directionalScale) {
        const startDist = Math.hypot(startVector.x, startVector.y);
        if (startDist > C.GEOMETRY_CALCULATION_EPSILON) {
            const startNormalized = { x: startVector.x / startDist, y: startVector.y / startDist };

            const parallelComponent = (pointVector.x * startNormalized.x + pointVector.y * startNormalized.y);
            const perpVector = {
                x: pointVector.x - parallelComponent * startNormalized.x,
                y: pointVector.y - parallelComponent * startNormalized.y
            };

            const scaledParallelComponent = parallelComponent * scale;

            const newVector = {
                x: scaledParallelComponent * startNormalized.x + perpVector.x,
                y: scaledParallelComponent * startNormalized.y + perpVector.y
            };

            return { x: center.x + newVector.x, y: center.y + newVector.y };
        }
        return { x: vertex.x, y: vertex.y };
    } else {
        let transformedVector = { ...pointVector };

        transformedVector.x *= scale;
        transformedVector.y *= scale;

        const x = transformedVector.x;
        const y = transformedVector.y;
        transformedVector.x = x * Math.cos(rotation) - y * Math.sin(rotation);
        transformedVector.y = x * Math.sin(rotation) + y * Math.cos(rotation);

        return { x: center.x + transformedVector.x, y: center.y + transformedVector.y };
    }
}

export function calculateIncenter(vertices) {
    if (vertices.length < 3) return null;

    if (vertices.length === 3) {
        const [a, b, c] = vertices;
        const sideA = distance(b, c);
        const sideB = distance(a, c);
        const sideC = distance(a, b);
        const perimeter = sideA + sideB + sideC;
        if (perimeter < C.GEOMETRY_CALCULATION_EPSILON) return null;
        const incenterX = (sideA * a.x + sideB * b.x + sideC * c.x) / perimeter;
        const incenterY = (sideA * a.y + sideB * b.y + sideC * c.y) / perimeter;
        const area = Math.abs((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y)) / 2;
        const inradius = (2 * area) / perimeter;
        return {
            center: { x: incenterX, y: incenterY },
            radius: inradius
        };
    }

    return findLargestInscribedCircle(vertices);
}

export function findLargestInscribedCircle(vertices) {
    if (vertices.length < 3) return null;

    let centroid = {
        x: vertices.reduce((sum, v) => sum + v.x, 0) / vertices.length,
        y: vertices.reduce((sum, v) => sum + v.y, 0) / vertices.length
    };

    if (!isVertexInPolygon(centroid, vertices)) {
        centroid.x = (vertices[0].x + vertices[1].x + vertices[2].x) / 3;
        centroid.y = (vertices[0].y + vertices[1].y + vertices[2].y) / 3;
    }

    let bestCenter = centroid;
    let bestRadius = distanceToPolygonEdges(centroid, vertices);

    for (let iter = 0; iter < C.INSCRIBED_CIRCLE_ITERATIONS; iter++) {
        let improved = false;
        const stepSize = bestRadius * C.INSCRIBED_CIRCLE_STEP_FACTOR;

        const directions = [
            { x: stepSize, y: 0 }, { x: -stepSize, y: 0 },
            { x: 0, y: stepSize }, { x: 0, y: -stepSize },
            { x: stepSize * Math.SQRT1_2, y: stepSize * Math.SQRT1_2 },
            { x: -stepSize * Math.SQRT1_2, y: stepSize * Math.SQRT1_2 },
            { x: stepSize * Math.SQRT1_2, y: -stepSize * Math.SQRT1_2 },
            { x: -stepSize * Math.SQRT1_2, y: -stepSize * Math.SQRT1_2 }
        ];

        for (const dir of directions) {
            const testPoint = {
                x: bestCenter.x + dir.x,
                y: bestCenter.y + dir.y
            };

            if (isVertexInPolygon(testPoint, vertices)) {
                const testRadius = distanceToPolygonEdges(testPoint, vertices);
                if (testRadius > bestRadius) {
                    bestCenter = testPoint;
                    bestRadius = testRadius;
                    improved = true;
                }
            }
        }

        if (!improved) break;
    }

    return {
        center: bestCenter,
        radius: Math.max(bestRadius, C.GEOMETRY_CALCULATION_EPSILON)
    };
}

export function distanceToPolygonEdges(point, vertices) {
    let minDistance = Infinity;
    for (let i = 0; i < vertices.length; i++) {
        const v1 = vertices[i];
        const v2 = vertices[(i + 1) % vertices.length];
        const edgeDistance = distancePointToLineSegment(point, v1, v2);
        minDistance = Math.min(minDistance, edgeDistance);
    }
    return minDistance;
}

export function distancePointToLineSegment(point, lineStart, lineEnd) {
    return getClosestPointOnLineSegment(point, lineStart, lineEnd).distance;
}


export function updateFaceLocalCoordinateSystems(allFaces, findPointById) {
    allFaces.forEach(face => {
        if (!face.localCoordSystem) {
            face.localCoordSystem = createFaceLocalCoordinateSystem(face, findPointById);
        } else if (!face.localCoordSystem.isCustom) {
            // Recalculate if not manually positioned
            const newSystem = createFaceLocalCoordinateSystem(face, findPointById);
            if (newSystem) {
                face.localCoordSystem.origin = newSystem.origin;
                face.localCoordSystem.scale = newSystem.scale;
            }
        }
    });
}

export function convertColorToColormapFormat(colormapData) {
    // Handle colormap selector format (uses 'points' instead of 'vertices')
    if (colormapData && colormapData.points) {
        const processedVertices = colormapData.points.map(p => ({
            pos: p.pos,
            color: Array.isArray(p.color) ? p.color : [p.color.r || 0, p.color.g || 0, p.color.b || 0],
            alpha: p.alpha !== undefined ? p.alpha : 1.0
        }));
        
        if (processedVertices.length === 1) {
            const singlePoint = processedVertices[0];
            const colorValue = (singlePoint.alpha !== undefined && singlePoint.alpha < 1)
                ? `rgba(${singlePoint.color.join(',')},${singlePoint.alpha})`
                : `rgb(${singlePoint.color.join(',')})`;
            return { type: 'color', value: colorValue };
        }
        
        return {
            type: 'colormap',
            vertices: processedVertices
        };
    }
    
    if (colormapData && colormapData.vertices && colormapData.vertices.length === 1) {
        const singlePoint = colormapData.vertices[0];
        const colorValue = (singlePoint.alpha !== undefined && singlePoint.alpha < 1)
            ? `rgba(${singlePoint.color.join(',')},${singlePoint.alpha})`
            : `rgb(${singlePoint.color.join(',')})`;
        return { type: 'color', value: colorValue };
    } else if (colormapData && colormapData.vertices) {
        const processedVertices = colormapData.vertices.map(p => ({
            ...p,
            alpha: p.alpha !== undefined ? p.alpha : 1.0
        }));
        return {
            type: 'colormap',
            vertices: processedVertices
        };
    }
    return colormapData;
}

export function sampleColormap(colormapItem, t) {
    if (!colormapItem || colormapItem.type !== 'colormap' || !colormapItem.vertices) {
        return '#ffffff';
    }

    const vertices = colormapItem.vertices;
    if (vertices.length === 0) return '#ffffff';
    if (vertices.length === 1) {
        const p = vertices[0];
        const alpha = p.alpha !== undefined ? p.alpha : 1.0;
        return `rgba(${p.color.join(',')},${alpha})`;
    }

    // Clamp t to [0, 1]
    t = Math.max(0, Math.min(1, t));

    // Find the two vertices to interpolate between
    let leftPoint = vertices[0];
    let rightPoint = vertices[vertices.length - 1];

    for (let i = 0; i < vertices.length - 1; i++) {
        if (t >= vertices[i].pos && t <= vertices[i + 1].pos) {
            leftPoint = vertices[i];
            rightPoint = vertices[i + 1];
            break;
        }
    }

    // Interpolate between the two vertices
    const range = rightPoint.pos - leftPoint.pos;
    const localT = range > 0 ? (t - leftPoint.pos) / range : 0;

    const r = Math.round(leftPoint.color[0] + (rightPoint.color[0] - leftPoint.color[0]) * localT);
    const g = Math.round(leftPoint.color[1] + (rightPoint.color[1] - leftPoint.color[1]) * localT);
    const b = Math.round(leftPoint.color[2] + (rightPoint.color[2] - leftPoint.color[2]) * localT);

    const leftAlpha = leftPoint.alpha !== undefined ? leftPoint.alpha : 1.0;
    const rightAlpha = rightPoint.alpha !== undefined ? rightPoint.alpha : 1.0;
    const alpha = leftAlpha + (rightAlpha - leftAlpha) * localT;

    return `rgba(${r},${g},${b},${alpha})`;
}

export function createFaceLocalCoordinateSystem(face, findPointById) {
    const vertices = face.vertexIds
        .map(id => findPointById(id))
        .filter(p => p && p.type === 'regular');
    
    if (vertices.length < 3) return null;
    
    const incircle = calculateIncenter(vertices);
    if (!incircle) return null;
    
    return {
        origin: { ...incircle.center },
        angle: 0,
        scale: incircle.radius / 4,
        isCustom: false,
        showCoordSystem: false
    };
}

export function globalToLocal(globalPoint, coordSystem) {
    if (!coordSystem) return globalPoint;
    const translated = {
        x: globalPoint.x - coordSystem.origin.x,
        y: globalPoint.y - coordSystem.origin.y
    };
    const cos = Math.cos(-coordSystem.angle);
    const sin = Math.sin(-coordSystem.angle);
    const rotated = {
        x: translated.x * cos - translated.y * sin,
        y: translated.x * sin + translated.y * cos
    };
    if (coordSystem.scale === 0) return { x: 0, y: 0 };
    return {
        x: rotated.x / coordSystem.scale,
        y: rotated.y / coordSystem.scale
    };
}

export function findNeighbors(vertexId, allEdges) {
    const neighbors = new Set();
    allEdges.forEach(edge => {
        if (edge.id1 === vertexId) {
            neighbors.add(edge.id2);
        } else if (edge.id2 === vertexId) {
            neighbors.add(edge.id1);
        }
    });
    return Array.from(neighbors);
}

export function localToGlobal(localPoint, coordSystem) {
    if (!coordSystem) return localPoint;

    const scaled = {
        x: localPoint.x * coordSystem.scale,
        y: localPoint.y * coordSystem.scale
    };

    const cos = Math.cos(coordSystem.angle);
    const sin = Math.sin(coordSystem.angle);
    const rotated = {
        x: scaled.x * cos - scaled.y * sin,
        y: scaled.x * sin + scaled.y * cos
    };
    return {
        x: rotated.x + coordSystem.origin.x,
        y: rotated.y + coordSystem.origin.y
    };
}



=== LLM Instructions ===
Now please just read the project and the rules for writing code and just wait for instructions.

Here are the rules:
1. DONT write comments, placeholders or docstrings if not explicitely told.
2. Write functions with the correct initial indentation so that if the function is indented so is your code that you write.
3. Use regular spaces: " " and do not use " " for space.
4. For changes that require multiple replacements please tell me what to replace with what instead of rewriting large portions of text. You can use vscode valid regexp for instance.
5. For small functions less than 50 lines of code pleae rewrite the full function. For larger functions please only write complete control statements if/while/case.
6. Never omit/change working logic if not explicitely statet that it should be removed/change
7. DONT use the CANVAS TOOL where code is written in artifacts.
8. Write one functions that are new seperately ot functions that needs updated.
9. Make sure to write what has been change where to place/what to replace for each code snippet.
